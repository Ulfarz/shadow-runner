var PE = Object.defineProperty; var ME = (i, o, h) => o in i ? PE(i, o, { enumerable: !0, configurable: !0, writable: !0, value: h }) : i[o] = h; var rt = (i, o, h) => ME(i, typeof o != "symbol" ? o + "" : o, h); (function () { const o = document.createElement("link").relList; if (o && o.supports && o.supports("modulepreload")) return; for (const w of document.querySelectorAll('link[rel="modulepreload"]')) y(w); new MutationObserver(w => { for (const P of w) if (P.type === "childList") for (const b of P.addedNodes) b.tagName === "LINK" && b.rel === "modulepreload" && y(b) }).observe(document, { childList: !0, subtree: !0 }); function h(w) { const P = {}; return w.integrity && (P.integrity = w.integrity), w.referrerPolicy && (P.referrerPolicy = w.referrerPolicy), w.crossOrigin === "use-credentials" ? P.credentials = "include" : w.crossOrigin === "anonymous" ? P.credentials = "omit" : P.credentials = "same-origin", P } function y(w) { if (w.ep) return; w.ep = !0; const P = h(w); fetch(w.href, P) } })(); var IE = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {}; function Pw(i) { return i && i.__esModule && Object.prototype.hasOwnProperty.call(i, "default") ? i.default : i } var Mw = { exports: {} }, vm = {}, Iw = { exports: {} }, $t = {};/**
 * @license React
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var Dd = Symbol.for("react.element"), CE = Symbol.for("react.portal"), AE = Symbol.for("react.fragment"), kE = Symbol.for("react.strict_mode"), DE = Symbol.for("react.profiler"), zE = Symbol.for("react.provider"), RE = Symbol.for("react.context"), LE = Symbol.for("react.forward_ref"), FE = Symbol.for("react.suspense"), BE = Symbol.for("react.memo"), OE = Symbol.for("react.lazy"), Kx = Symbol.iterator; function NE(i) { return i === null || typeof i != "object" ? null : (i = Kx && i[Kx] || i["@@iterator"], typeof i == "function" ? i : null) } var Cw = { isMounted: function () { return !1 }, enqueueForceUpdate: function () { }, enqueueReplaceState: function () { }, enqueueSetState: function () { } }, Aw = Object.assign, kw = {}; function Tc(i, o, h) { this.props = i, this.context = o, this.refs = kw, this.updater = h || Cw } Tc.prototype.isReactComponent = {}; Tc.prototype.setState = function (i, o) { if (typeof i != "object" && typeof i != "function" && i != null) throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables."); this.updater.enqueueSetState(this, i, o, "setState") }; Tc.prototype.forceUpdate = function (i) { this.updater.enqueueForceUpdate(this, i, "forceUpdate") }; function Dw() { } Dw.prototype = Tc.prototype; function Uy(i, o, h) { this.props = i, this.context = o, this.refs = kw, this.updater = h || Cw } var Gy = Uy.prototype = new Dw; Gy.constructor = Uy; Aw(Gy, Tc.prototype); Gy.isPureReactComponent = !0; var Qx = Array.isArray, zw = Object.prototype.hasOwnProperty, $y = { current: null }, Rw = { key: !0, ref: !0, __self: !0, __source: !0 }; function Lw(i, o, h) { var y, w = {}, P = null, b = null; if (o != null) for (y in o.ref !== void 0 && (b = o.ref), o.key !== void 0 && (P = "" + o.key), o) zw.call(o, y) && !Rw.hasOwnProperty(y) && (w[y] = o[y]); var c = arguments.length - 2; if (c === 1) w.children = h; else if (1 < c) { for (var B = Array(c), $ = 0; $ < c; $++)B[$] = arguments[$ + 2]; w.children = B } if (i && i.defaultProps) for (y in c = i.defaultProps, c) w[y] === void 0 && (w[y] = c[y]); return { $$typeof: Dd, type: i, key: P, ref: b, props: w, _owner: $y.current } } function jE(i, o) { return { $$typeof: Dd, type: i.type, key: o, ref: i.ref, props: i.props, _owner: i._owner } } function qy(i) { return typeof i == "object" && i !== null && i.$$typeof === Dd } function VE(i) { var o = { "=": "=0", ":": "=2" }; return "$" + i.replace(/[=:]/g, function (h) { return o[h] }) } var Jx = /\/+/g; function o_(i, o) { return typeof i == "object" && i !== null && i.key != null ? VE("" + i.key) : o.toString(36) } function Df(i, o, h, y, w) { var P = typeof i; (P === "undefined" || P === "boolean") && (i = null); var b = !1; if (i === null) b = !0; else switch (P) { case "string": case "number": b = !0; break; case "object": switch (i.$$typeof) { case Dd: case CE: b = !0 } }if (b) return b = i, w = w(b), i = y === "" ? "." + o_(b, 0) : y, Qx(w) ? (h = "", i != null && (h = i.replace(Jx, "$&/") + "/"), Df(w, o, h, "", function ($) { return $ })) : w != null && (qy(w) && (w = jE(w, h + (!w.key || b && b.key === w.key ? "" : ("" + w.key).replace(Jx, "$&/") + "/") + i)), o.push(w)), 1; if (b = 0, y = y === "" ? "." : y + ":", Qx(i)) for (var c = 0; c < i.length; c++) { P = i[c]; var B = y + o_(P, c); b += Df(P, o, h, B, w) } else if (B = NE(i), typeof B == "function") for (i = B.call(i), c = 0; !(P = i.next()).done;)P = P.value, B = y + o_(P, c++), b += Df(P, o, h, B, w); else if (P === "object") throw o = String(i), Error("Objects are not valid as a React child (found: " + (o === "[object Object]" ? "object with keys {" + Object.keys(i).join(", ") + "}" : o) + "). If you meant to render a collection of children, use an array instead."); return b } function pf(i, o, h) { if (i == null) return i; var y = [], w = 0; return Df(i, y, "", "", function (P) { return o.call(h, P, w++) }), y } function UE(i) { if (i._status === -1) { var o = i._result; o = o(), o.then(function (h) { (i._status === 0 || i._status === -1) && (i._status = 1, i._result = h) }, function (h) { (i._status === 0 || i._status === -1) && (i._status = 2, i._result = h) }), i._status === -1 && (i._status = 0, i._result = o) } if (i._status === 1) return i._result.default; throw i._result } var ii = { current: null }, zf = { transition: null }, GE = { ReactCurrentDispatcher: ii, ReactCurrentBatchConfig: zf, ReactCurrentOwner: $y }; function Fw() { throw Error("act(...) is not supported in production builds of React.") } $t.Children = { map: pf, forEach: function (i, o, h) { pf(i, function () { o.apply(this, arguments) }, h) }, count: function (i) { var o = 0; return pf(i, function () { o++ }), o }, toArray: function (i) { return pf(i, function (o) { return o }) || [] }, only: function (i) { if (!qy(i)) throw Error("React.Children.only expected to receive a single React element child."); return i } }; $t.Component = Tc; $t.Fragment = AE; $t.Profiler = DE; $t.PureComponent = Uy; $t.StrictMode = kE; $t.Suspense = FE; $t.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = GE; $t.act = Fw; $t.cloneElement = function (i, o, h) { if (i == null) throw Error("React.cloneElement(...): The argument must be a React element, but you passed " + i + "."); var y = Aw({}, i.props), w = i.key, P = i.ref, b = i._owner; if (o != null) { if (o.ref !== void 0 && (P = o.ref, b = $y.current), o.key !== void 0 && (w = "" + o.key), i.type && i.type.defaultProps) var c = i.type.defaultProps; for (B in o) zw.call(o, B) && !Rw.hasOwnProperty(B) && (y[B] = o[B] === void 0 && c !== void 0 ? c[B] : o[B]) } var B = arguments.length - 2; if (B === 1) y.children = h; else if (1 < B) { c = Array(B); for (var $ = 0; $ < B; $++)c[$] = arguments[$ + 2]; y.children = c } return { $$typeof: Dd, type: i.type, key: w, ref: P, props: y, _owner: b } }; $t.createContext = function (i) { return i = { $$typeof: RE, _currentValue: i, _currentValue2: i, _threadCount: 0, Provider: null, Consumer: null, _defaultValue: null, _globalName: null }, i.Provider = { $$typeof: zE, _context: i }, i.Consumer = i }; $t.createElement = Lw; $t.createFactory = function (i) { var o = Lw.bind(null, i); return o.type = i, o }; $t.createRef = function () { return { current: null } }; $t.forwardRef = function (i) { return { $$typeof: LE, render: i } }; $t.isValidElement = qy; $t.lazy = function (i) { return { $$typeof: OE, _payload: { _status: -1, _result: i }, _init: UE } }; $t.memo = function (i, o) { return { $$typeof: BE, type: i, compare: o === void 0 ? null : o } }; $t.startTransition = function (i) { var o = zf.transition; zf.transition = {}; try { i() } finally { zf.transition = o } }; $t.unstable_act = Fw; $t.useCallback = function (i, o) { return ii.current.useCallback(i, o) }; $t.useContext = function (i) { return ii.current.useContext(i) }; $t.useDebugValue = function () { }; $t.useDeferredValue = function (i) { return ii.current.useDeferredValue(i) }; $t.useEffect = function (i, o) { return ii.current.useEffect(i, o) }; $t.useId = function () { return ii.current.useId() }; $t.useImperativeHandle = function (i, o, h) { return ii.current.useImperativeHandle(i, o, h) }; $t.useInsertionEffect = function (i, o) { return ii.current.useInsertionEffect(i, o) }; $t.useLayoutEffect = function (i, o) { return ii.current.useLayoutEffect(i, o) }; $t.useMemo = function (i, o) { return ii.current.useMemo(i, o) }; $t.useReducer = function (i, o, h) { return ii.current.useReducer(i, o, h) }; $t.useRef = function (i) { return ii.current.useRef(i) }; $t.useState = function (i) { return ii.current.useState(i) }; $t.useSyncExternalStore = function (i, o, h) { return ii.current.useSyncExternalStore(i, o, h) }; $t.useTransition = function () { return ii.current.useTransition() }; $t.version = "18.3.1"; Iw.exports = $t; var gr = Iw.exports; const Kh = Pw(gr);/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var $E = gr, qE = Symbol.for("react.element"), ZE = Symbol.for("react.fragment"), WE = Object.prototype.hasOwnProperty, HE = $E.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, XE = { key: !0, ref: !0, __self: !0, __source: !0 }; function Bw(i, o, h) { var y, w = {}, P = null, b = null; h !== void 0 && (P = "" + h), o.key !== void 0 && (P = "" + o.key), o.ref !== void 0 && (b = o.ref); for (y in o) WE.call(o, y) && !XE.hasOwnProperty(y) && (w[y] = o[y]); if (i && i.defaultProps) for (y in o = i.defaultProps, o) w[y] === void 0 && (w[y] = o[y]); return { $$typeof: qE, type: i, key: P, ref: b, props: w, _owner: HE.current } } vm.Fragment = ZE; vm.jsx = Bw; vm.jsxs = Bw; Mw.exports = vm; var _t = Mw.exports, O_ = {}, Ow = { exports: {} }, Bi = {}, Nw = { exports: {} }, jw = {};/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */(function (i) { function o(de, Se) { var et = de.length; de.push(Se); e: for (; 0 < et;) { var lt = et - 1 >>> 1, Tt = de[lt]; if (0 < w(Tt, Se)) de[lt] = Se, de[et] = Tt, et = lt; else break e } } function h(de) { return de.length === 0 ? null : de[0] } function y(de) { if (de.length === 0) return null; var Se = de[0], et = de.pop(); if (et !== Se) { de[0] = et; e: for (var lt = 0, Tt = de.length, Zt = Tt >>> 1; lt < Zt;) { var Ut = 2 * (lt + 1) - 1, St = de[Ut], Ct = Ut + 1, Yt = de[Ct]; if (0 > w(St, et)) Ct < Tt && 0 > w(Yt, St) ? (de[lt] = Yt, de[Ct] = et, lt = Ct) : (de[lt] = St, de[Ut] = et, lt = Ut); else if (Ct < Tt && 0 > w(Yt, et)) de[lt] = Yt, de[Ct] = et, lt = Ct; else break e } } return Se } function w(de, Se) { var et = de.sortIndex - Se.sortIndex; return et !== 0 ? et : de.id - Se.id } if (typeof performance == "object" && typeof performance.now == "function") { var P = performance; i.unstable_now = function () { return P.now() } } else { var b = Date, c = b.now(); i.unstable_now = function () { return b.now() - c } } var B = [], $ = [], me = 1, ge = null, we = 3, Ge = !1, Ye = !1, $e = !1, ye = typeof setTimeout == "function" ? setTimeout : null, be = typeof clearTimeout == "function" ? clearTimeout : null, K = typeof setImmediate < "u" ? setImmediate : null; typeof navigator < "u" && navigator.scheduling !== void 0 && navigator.scheduling.isInputPending !== void 0 && navigator.scheduling.isInputPending.bind(navigator.scheduling); function ve(de) { for (var Se = h($); Se !== null;) { if (Se.callback === null) y($); else if (Se.startTime <= de) y($), Se.sortIndex = Se.expirationTime, o(B, Se); else break; Se = h($) } } function Ke(de) { if ($e = !1, ve(de), !Ye) if (h(B) !== null) Ye = !0, Me(ft); else { var Se = h($); Se !== null && Le(Ke, Se.startTime - de) } } function ft(de, Se) { Ye = !1, $e && ($e = !1, be(Z), Z = -1), Ge = !0; var et = we; try { for (ve(Se), ge = h(B); ge !== null && (!(ge.expirationTime > Se) || de && !Ce());) { var lt = ge.callback; if (typeof lt == "function") { ge.callback = null, we = ge.priorityLevel; var Tt = lt(ge.expirationTime <= Se); Se = i.unstable_now(), typeof Tt == "function" ? ge.callback = Tt : ge === h(B) && y(B), ve(Se) } else y(B); ge = h(B) } if (ge !== null) var Zt = !0; else { var Ut = h($); Ut !== null && Le(Ke, Ut.startTime - Se), Zt = !1 } return Zt } finally { ge = null, we = et, Ge = !1 } } var mt = !1, ct = null, Z = -1, re = 5, ie = -1; function Ce() { return !(i.unstable_now() - ie < re) } function xe() { if (ct !== null) { var de = i.unstable_now(); ie = de; var Se = !0; try { Se = ct(!0, de) } finally { Se ? Te() : (mt = !1, ct = null) } } else mt = !1 } var Te; if (typeof K == "function") Te = function () { K(xe) }; else if (typeof MessageChannel < "u") { var Ne = new MessageChannel, _e = Ne.port2; Ne.port1.onmessage = xe, Te = function () { _e.postMessage(null) } } else Te = function () { ye(xe, 0) }; function Me(de) { ct = de, mt || (mt = !0, Te()) } function Le(de, Se) { Z = ye(function () { de(i.unstable_now()) }, Se) } i.unstable_IdlePriority = 5, i.unstable_ImmediatePriority = 1, i.unstable_LowPriority = 4, i.unstable_NormalPriority = 3, i.unstable_Profiling = null, i.unstable_UserBlockingPriority = 2, i.unstable_cancelCallback = function (de) { de.callback = null }, i.unstable_continueExecution = function () { Ye || Ge || (Ye = !0, Me(ft)) }, i.unstable_forceFrameRate = function (de) { 0 > de || 125 < de ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : re = 0 < de ? Math.floor(1e3 / de) : 5 }, i.unstable_getCurrentPriorityLevel = function () { return we }, i.unstable_getFirstCallbackNode = function () { return h(B) }, i.unstable_next = function (de) { switch (we) { case 1: case 2: case 3: var Se = 3; break; default: Se = we }var et = we; we = Se; try { return de() } finally { we = et } }, i.unstable_pauseExecution = function () { }, i.unstable_requestPaint = function () { }, i.unstable_runWithPriority = function (de, Se) { switch (de) { case 1: case 2: case 3: case 4: case 5: break; default: de = 3 }var et = we; we = de; try { return Se() } finally { we = et } }, i.unstable_scheduleCallback = function (de, Se, et) { var lt = i.unstable_now(); switch (typeof et == "object" && et !== null ? (et = et.delay, et = typeof et == "number" && 0 < et ? lt + et : lt) : et = lt, de) { case 1: var Tt = -1; break; case 2: Tt = 250; break; case 5: Tt = 1073741823; break; case 4: Tt = 1e4; break; default: Tt = 5e3 }return Tt = et + Tt, de = { id: me++, callback: Se, priorityLevel: de, startTime: et, expirationTime: Tt, sortIndex: -1 }, et > lt ? (de.sortIndex = et, o($, de), h(B) === null && de === h($) && ($e ? (be(Z), Z = -1) : $e = !0, Le(Ke, et - lt))) : (de.sortIndex = Tt, o(B, de), Ye || Ge || (Ye = !0, Me(ft))), de }, i.unstable_shouldYield = Ce, i.unstable_wrapCallback = function (de) { var Se = we; return function () { var et = we; we = Se; try { return de.apply(this, arguments) } finally { we = et } } } })(jw); Nw.exports = jw; var YE = Nw.exports;/**
 * @license React
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var KE = gr, Fi = YE; function st(i) { for (var o = "https://reactjs.org/docs/error-decoder.html?invariant=" + i, h = 1; h < arguments.length; h++)o += "&args[]=" + encodeURIComponent(arguments[h]); return "Minified React error #" + i + "; visit " + o + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings." } var Vw = new Set, fd = {}; function Nl(i, o) { fc(i, o), fc(i + "Capture", o) } function fc(i, o) { for (fd[i] = o, i = 0; i < o.length; i++)Vw.add(o[i]) } var xo = !(typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u"), N_ = Object.prototype.hasOwnProperty, QE = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/, e1 = {}, t1 = {}; function JE(i) { return N_.call(t1, i) ? !0 : N_.call(e1, i) ? !1 : QE.test(i) ? t1[i] = !0 : (e1[i] = !0, !1) } function eP(i, o, h, y) { if (h !== null && h.type === 0) return !1; switch (typeof o) { case "function": case "symbol": return !0; case "boolean": return y ? !1 : h !== null ? !h.acceptsBooleans : (i = i.toLowerCase().slice(0, 5), i !== "data-" && i !== "aria-"); default: return !1 } } function tP(i, o, h, y) { if (o === null || typeof o > "u" || eP(i, o, h, y)) return !0; if (y) return !1; if (h !== null) switch (h.type) { case 3: return !o; case 4: return o === !1; case 5: return isNaN(o); case 6: return isNaN(o) || 1 > o }return !1 } function si(i, o, h, y, w, P, b) { this.acceptsBooleans = o === 2 || o === 3 || o === 4, this.attributeName = y, this.attributeNamespace = w, this.mustUseProperty = h, this.propertyName = i, this.type = o, this.sanitizeURL = P, this.removeEmptyString = b } var Nn = {}; "children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function (i) { Nn[i] = new si(i, 0, !1, i, null, !1, !1) });[["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function (i) { var o = i[0]; Nn[o] = new si(o, 1, !1, i[1], null, !1, !1) });["contentEditable", "draggable", "spellCheck", "value"].forEach(function (i) { Nn[i] = new si(i, 2, !1, i.toLowerCase(), null, !1, !1) });["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function (i) { Nn[i] = new si(i, 2, !1, i, null, !1, !1) }); "allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function (i) { Nn[i] = new si(i, 3, !1, i.toLowerCase(), null, !1, !1) });["checked", "multiple", "muted", "selected"].forEach(function (i) { Nn[i] = new si(i, 3, !0, i, null, !1, !1) });["capture", "download"].forEach(function (i) { Nn[i] = new si(i, 4, !1, i, null, !1, !1) });["cols", "rows", "size", "span"].forEach(function (i) { Nn[i] = new si(i, 6, !1, i, null, !1, !1) });["rowSpan", "start"].forEach(function (i) { Nn[i] = new si(i, 5, !1, i.toLowerCase(), null, !1, !1) }); var Zy = /[\-:]([a-z])/g; function Wy(i) { return i[1].toUpperCase() } "accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function (i) { var o = i.replace(Zy, Wy); Nn[o] = new si(o, 1, !1, i, null, !1, !1) }); "xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function (i) { var o = i.replace(Zy, Wy); Nn[o] = new si(o, 1, !1, i, "http://www.w3.org/1999/xlink", !1, !1) });["xml:base", "xml:lang", "xml:space"].forEach(function (i) { var o = i.replace(Zy, Wy); Nn[o] = new si(o, 1, !1, i, "http://www.w3.org/XML/1998/namespace", !1, !1) });["tabIndex", "crossOrigin"].forEach(function (i) { Nn[i] = new si(i, 1, !1, i.toLowerCase(), null, !1, !1) }); Nn.xlinkHref = new si("xlinkHref", 1, !1, "xlink:href", "http://www.w3.org/1999/xlink", !0, !1);["src", "href", "action", "formAction"].forEach(function (i) { Nn[i] = new si(i, 1, !1, i.toLowerCase(), null, !0, !0) }); function Hy(i, o, h, y) { var w = Nn.hasOwnProperty(o) ? Nn[o] : null; (w !== null ? w.type !== 0 : y || !(2 < o.length) || o[0] !== "o" && o[0] !== "O" || o[1] !== "n" && o[1] !== "N") && (tP(o, h, w, y) && (h = null), y || w === null ? JE(o) && (h === null ? i.removeAttribute(o) : i.setAttribute(o, "" + h)) : w.mustUseProperty ? i[w.propertyName] = h === null ? w.type === 3 ? !1 : "" : h : (o = w.attributeName, y = w.attributeNamespace, h === null ? i.removeAttribute(o) : (w = w.type, h = w === 3 || w === 4 && h === !0 ? "" : "" + h, y ? i.setAttributeNS(y, o, h) : i.setAttribute(o, h)))) } var Eo = KE.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, ff = Symbol.for("react.element"), Yu = Symbol.for("react.portal"), Ku = Symbol.for("react.fragment"), Xy = Symbol.for("react.strict_mode"), j_ = Symbol.for("react.profiler"), Uw = Symbol.for("react.provider"), Gw = Symbol.for("react.context"), Yy = Symbol.for("react.forward_ref"), V_ = Symbol.for("react.suspense"), U_ = Symbol.for("react.suspense_list"), Ky = Symbol.for("react.memo"), ua = Symbol.for("react.lazy"), $w = Symbol.for("react.offscreen"), r1 = Symbol.iterator; function Vh(i) { return i === null || typeof i != "object" ? null : (i = r1 && i[r1] || i["@@iterator"], typeof i == "function" ? i : null) } var Zr = Object.assign, a_; function Qh(i) {
    if (a_ === void 0) try { throw Error() } catch (h) { var o = h.stack.trim().match(/\n( *(at )?)/); a_ = o && o[1] || "" } return `
`+ a_ + i
} var l_ = !1; function u_(i, o) {
    if (!i || l_) return ""; l_ = !0; var h = Error.prepareStackTrace; Error.prepareStackTrace = void 0; try { if (o) if (o = function () { throw Error() }, Object.defineProperty(o.prototype, "props", { set: function () { throw Error() } }), typeof Reflect == "object" && Reflect.construct) { try { Reflect.construct(o, []) } catch ($) { var y = $ } Reflect.construct(i, [], o) } else { try { o.call() } catch ($) { y = $ } i.call(o.prototype) } else { try { throw Error() } catch ($) { y = $ } i() } } catch ($) {
        if ($ && y && typeof $.stack == "string") {
            for (var w = $.stack.split(`
`), P = y.stack.split(`
`), b = w.length - 1, c = P.length - 1; 1 <= b && 0 <= c && w[b] !== P[c];)c--; for (; 1 <= b && 0 <= c; b--, c--)if (w[b] !== P[c]) {
                if (b !== 1 || c !== 1) do if (b--, c--, 0 > c || w[b] !== P[c]) {
                    var B = `
`+ w[b].replace(" at new ", " at "); return i.displayName && B.includes("<anonymous>") && (B = B.replace("<anonymous>", i.displayName)), B
                } while (1 <= b && 0 <= c); break
            }
        }
    } finally { l_ = !1, Error.prepareStackTrace = h } return (i = i ? i.displayName || i.name : "") ? Qh(i) : ""
} function rP(i) { switch (i.tag) { case 5: return Qh(i.type); case 16: return Qh("Lazy"); case 13: return Qh("Suspense"); case 19: return Qh("SuspenseList"); case 0: case 2: case 15: return i = u_(i.type, !1), i; case 11: return i = u_(i.type.render, !1), i; case 1: return i = u_(i.type, !0), i; default: return "" } } function G_(i) { if (i == null) return null; if (typeof i == "function") return i.displayName || i.name || null; if (typeof i == "string") return i; switch (i) { case Ku: return "Fragment"; case Yu: return "Portal"; case j_: return "Profiler"; case Xy: return "StrictMode"; case V_: return "Suspense"; case U_: return "SuspenseList" }if (typeof i == "object") switch (i.$$typeof) { case Gw: return (i.displayName || "Context") + ".Consumer"; case Uw: return (i._context.displayName || "Context") + ".Provider"; case Yy: var o = i.render; return i = i.displayName, i || (i = o.displayName || o.name || "", i = i !== "" ? "ForwardRef(" + i + ")" : "ForwardRef"), i; case Ky: return o = i.displayName || null, o !== null ? o : G_(i.type) || "Memo"; case ua: o = i._payload, i = i._init; try { return G_(i(o)) } catch { } }return null } function nP(i) { var o = i.type; switch (i.tag) { case 24: return "Cache"; case 9: return (o.displayName || "Context") + ".Consumer"; case 10: return (o._context.displayName || "Context") + ".Provider"; case 18: return "DehydratedFragment"; case 11: return i = o.render, i = i.displayName || i.name || "", o.displayName || (i !== "" ? "ForwardRef(" + i + ")" : "ForwardRef"); case 7: return "Fragment"; case 5: return o; case 4: return "Portal"; case 3: return "Root"; case 6: return "Text"; case 16: return G_(o); case 8: return o === Xy ? "StrictMode" : "Mode"; case 22: return "Offscreen"; case 12: return "Profiler"; case 21: return "Scope"; case 13: return "Suspense"; case 19: return "SuspenseList"; case 25: return "TracingMarker"; case 1: case 0: case 17: case 2: case 14: case 15: if (typeof o == "function") return o.displayName || o.name || null; if (typeof o == "string") return o }return null } function Ta(i) { switch (typeof i) { case "boolean": case "number": case "string": case "undefined": return i; case "object": return i; default: return "" } } function qw(i) { var o = i.type; return (i = i.nodeName) && i.toLowerCase() === "input" && (o === "checkbox" || o === "radio") } function iP(i) { var o = qw(i) ? "checked" : "value", h = Object.getOwnPropertyDescriptor(i.constructor.prototype, o), y = "" + i[o]; if (!i.hasOwnProperty(o) && typeof h < "u" && typeof h.get == "function" && typeof h.set == "function") { var w = h.get, P = h.set; return Object.defineProperty(i, o, { configurable: !0, get: function () { return w.call(this) }, set: function (b) { y = "" + b, P.call(this, b) } }), Object.defineProperty(i, o, { enumerable: h.enumerable }), { getValue: function () { return y }, setValue: function (b) { y = "" + b }, stopTracking: function () { i._valueTracker = null, delete i[o] } } } } function mf(i) { i._valueTracker || (i._valueTracker = iP(i)) } function Zw(i) { if (!i) return !1; var o = i._valueTracker; if (!o) return !0; var h = o.getValue(), y = ""; return i && (y = qw(i) ? i.checked ? "true" : "false" : i.value), i = y, i !== h ? (o.setValue(i), !0) : !1 } function Zf(i) { if (i = i || (typeof document < "u" ? document : void 0), typeof i > "u") return null; try { return i.activeElement || i.body } catch { return i.body } } function $_(i, o) { var h = o.checked; return Zr({}, o, { defaultChecked: void 0, defaultValue: void 0, value: void 0, checked: h ?? i._wrapperState.initialChecked }) } function n1(i, o) { var h = o.defaultValue == null ? "" : o.defaultValue, y = o.checked != null ? o.checked : o.defaultChecked; h = Ta(o.value != null ? o.value : h), i._wrapperState = { initialChecked: y, initialValue: h, controlled: o.type === "checkbox" || o.type === "radio" ? o.checked != null : o.value != null } } function Ww(i, o) { o = o.checked, o != null && Hy(i, "checked", o, !1) } function q_(i, o) { Ww(i, o); var h = Ta(o.value), y = o.type; if (h != null) y === "number" ? (h === 0 && i.value === "" || i.value != h) && (i.value = "" + h) : i.value !== "" + h && (i.value = "" + h); else if (y === "submit" || y === "reset") { i.removeAttribute("value"); return } o.hasOwnProperty("value") ? Z_(i, o.type, h) : o.hasOwnProperty("defaultValue") && Z_(i, o.type, Ta(o.defaultValue)), o.checked == null && o.defaultChecked != null && (i.defaultChecked = !!o.defaultChecked) } function i1(i, o, h) { if (o.hasOwnProperty("value") || o.hasOwnProperty("defaultValue")) { var y = o.type; if (!(y !== "submit" && y !== "reset" || o.value !== void 0 && o.value !== null)) return; o = "" + i._wrapperState.initialValue, h || o === i.value || (i.value = o), i.defaultValue = o } h = i.name, h !== "" && (i.name = ""), i.defaultChecked = !!i._wrapperState.initialChecked, h !== "" && (i.name = h) } function Z_(i, o, h) { (o !== "number" || Zf(i.ownerDocument) !== i) && (h == null ? i.defaultValue = "" + i._wrapperState.initialValue : i.defaultValue !== "" + h && (i.defaultValue = "" + h)) } var Jh = Array.isArray; function lc(i, o, h, y) { if (i = i.options, o) { o = {}; for (var w = 0; w < h.length; w++)o["$" + h[w]] = !0; for (h = 0; h < i.length; h++)w = o.hasOwnProperty("$" + i[h].value), i[h].selected !== w && (i[h].selected = w), w && y && (i[h].defaultSelected = !0) } else { for (h = "" + Ta(h), o = null, w = 0; w < i.length; w++) { if (i[w].value === h) { i[w].selected = !0, y && (i[w].defaultSelected = !0); return } o !== null || i[w].disabled || (o = i[w]) } o !== null && (o.selected = !0) } } function W_(i, o) { if (o.dangerouslySetInnerHTML != null) throw Error(st(91)); return Zr({}, o, { value: void 0, defaultValue: void 0, children: "" + i._wrapperState.initialValue }) } function s1(i, o) { var h = o.value; if (h == null) { if (h = o.children, o = o.defaultValue, h != null) { if (o != null) throw Error(st(92)); if (Jh(h)) { if (1 < h.length) throw Error(st(93)); h = h[0] } o = h } o == null && (o = ""), h = o } i._wrapperState = { initialValue: Ta(h) } } function Hw(i, o) { var h = Ta(o.value), y = Ta(o.defaultValue); h != null && (h = "" + h, h !== i.value && (i.value = h), o.defaultValue == null && i.defaultValue !== h && (i.defaultValue = h)), y != null && (i.defaultValue = "" + y) } function o1(i) { var o = i.textContent; o === i._wrapperState.initialValue && o !== "" && o !== null && (i.value = o) } function Xw(i) { switch (i) { case "svg": return "http://www.w3.org/2000/svg"; case "math": return "http://www.w3.org/1998/Math/MathML"; default: return "http://www.w3.org/1999/xhtml" } } function H_(i, o) { return i == null || i === "http://www.w3.org/1999/xhtml" ? Xw(o) : i === "http://www.w3.org/2000/svg" && o === "foreignObject" ? "http://www.w3.org/1999/xhtml" : i } var gf, Yw = function (i) { return typeof MSApp < "u" && MSApp.execUnsafeLocalFunction ? function (o, h, y, w) { MSApp.execUnsafeLocalFunction(function () { return i(o, h, y, w) }) } : i }(function (i, o) { if (i.namespaceURI !== "http://www.w3.org/2000/svg" || "innerHTML" in i) i.innerHTML = o; else { for (gf = gf || document.createElement("div"), gf.innerHTML = "<svg>" + o.valueOf().toString() + "</svg>", o = gf.firstChild; i.firstChild;)i.removeChild(i.firstChild); for (; o.firstChild;)i.appendChild(o.firstChild) } }); function md(i, o) { if (o) { var h = i.firstChild; if (h && h === i.lastChild && h.nodeType === 3) { h.nodeValue = o; return } } i.textContent = o } var sd = { animationIterationCount: !0, aspectRatio: !0, borderImageOutset: !0, borderImageSlice: !0, borderImageWidth: !0, boxFlex: !0, boxFlexGroup: !0, boxOrdinalGroup: !0, columnCount: !0, columns: !0, flex: !0, flexGrow: !0, flexPositive: !0, flexShrink: !0, flexNegative: !0, flexOrder: !0, gridArea: !0, gridRow: !0, gridRowEnd: !0, gridRowSpan: !0, gridRowStart: !0, gridColumn: !0, gridColumnEnd: !0, gridColumnSpan: !0, gridColumnStart: !0, fontWeight: !0, lineClamp: !0, lineHeight: !0, opacity: !0, order: !0, orphans: !0, tabSize: !0, widows: !0, zIndex: !0, zoom: !0, fillOpacity: !0, floodOpacity: !0, stopOpacity: !0, strokeDasharray: !0, strokeDashoffset: !0, strokeMiterlimit: !0, strokeOpacity: !0, strokeWidth: !0 }, sP = ["Webkit", "ms", "Moz", "O"]; Object.keys(sd).forEach(function (i) { sP.forEach(function (o) { o = o + i.charAt(0).toUpperCase() + i.substring(1), sd[o] = sd[i] }) }); function Kw(i, o, h) { return o == null || typeof o == "boolean" || o === "" ? "" : h || typeof o != "number" || o === 0 || sd.hasOwnProperty(i) && sd[i] ? ("" + o).trim() : o + "px" } function Qw(i, o) { i = i.style; for (var h in o) if (o.hasOwnProperty(h)) { var y = h.indexOf("--") === 0, w = Kw(h, o[h], y); h === "float" && (h = "cssFloat"), y ? i.setProperty(h, w) : i[h] = w } } var oP = Zr({ menuitem: !0 }, { area: !0, base: !0, br: !0, col: !0, embed: !0, hr: !0, img: !0, input: !0, keygen: !0, link: !0, meta: !0, param: !0, source: !0, track: !0, wbr: !0 }); function X_(i, o) { if (o) { if (oP[i] && (o.children != null || o.dangerouslySetInnerHTML != null)) throw Error(st(137, i)); if (o.dangerouslySetInnerHTML != null) { if (o.children != null) throw Error(st(60)); if (typeof o.dangerouslySetInnerHTML != "object" || !("__html" in o.dangerouslySetInnerHTML)) throw Error(st(61)) } if (o.style != null && typeof o.style != "object") throw Error(st(62)) } } function Y_(i, o) { if (i.indexOf("-") === -1) return typeof o.is == "string"; switch (i) { case "annotation-xml": case "color-profile": case "font-face": case "font-face-src": case "font-face-uri": case "font-face-format": case "font-face-name": case "missing-glyph": return !1; default: return !0 } } var K_ = null; function Qy(i) { return i = i.target || i.srcElement || window, i.correspondingUseElement && (i = i.correspondingUseElement), i.nodeType === 3 ? i.parentNode : i } var Q_ = null, uc = null, cc = null; function a1(i) { if (i = Ld(i)) { if (typeof Q_ != "function") throw Error(st(280)); var o = i.stateNode; o && (o = Sm(o), Q_(i.stateNode, i.type, o)) } } function Jw(i) { uc ? cc ? cc.push(i) : cc = [i] : uc = i } function eb() { if (uc) { var i = uc, o = cc; if (cc = uc = null, a1(i), o) for (i = 0; i < o.length; i++)a1(o[i]) } } function tb(i, o) { return i(o) } function rb() { } var c_ = !1; function nb(i, o, h) { if (c_) return i(o, h); c_ = !0; try { return tb(i, o, h) } finally { c_ = !1, (uc !== null || cc !== null) && (rb(), eb()) } } function gd(i, o) { var h = i.stateNode; if (h === null) return null; var y = Sm(h); if (y === null) return null; h = y[o]; e: switch (o) { case "onClick": case "onClickCapture": case "onDoubleClick": case "onDoubleClickCapture": case "onMouseDown": case "onMouseDownCapture": case "onMouseMove": case "onMouseMoveCapture": case "onMouseUp": case "onMouseUpCapture": case "onMouseEnter": (y = !y.disabled) || (i = i.type, y = !(i === "button" || i === "input" || i === "select" || i === "textarea")), i = !y; break e; default: i = !1 }if (i) return null; if (h && typeof h != "function") throw Error(st(231, o, typeof h)); return h } var J_ = !1; if (xo) try { var Uh = {}; Object.defineProperty(Uh, "passive", { get: function () { J_ = !0 } }), window.addEventListener("test", Uh, Uh), window.removeEventListener("test", Uh, Uh) } catch { J_ = !1 } function aP(i, o, h, y, w, P, b, c, B) { var $ = Array.prototype.slice.call(arguments, 3); try { o.apply(h, $) } catch (me) { this.onError(me) } } var od = !1, Wf = null, Hf = !1, ey = null, lP = { onError: function (i) { od = !0, Wf = i } }; function uP(i, o, h, y, w, P, b, c, B) { od = !1, Wf = null, aP.apply(lP, arguments) } function cP(i, o, h, y, w, P, b, c, B) { if (uP.apply(this, arguments), od) { if (od) { var $ = Wf; od = !1, Wf = null } else throw Error(st(198)); Hf || (Hf = !0, ey = $) } } function jl(i) { var o = i, h = i; if (i.alternate) for (; o.return;)o = o.return; else { i = o; do o = i, o.flags & 4098 && (h = o.return), i = o.return; while (i) } return o.tag === 3 ? h : null } function ib(i) { if (i.tag === 13) { var o = i.memoizedState; if (o === null && (i = i.alternate, i !== null && (o = i.memoizedState)), o !== null) return o.dehydrated } return null } function l1(i) { if (jl(i) !== i) throw Error(st(188)) } function hP(i) { var o = i.alternate; if (!o) { if (o = jl(i), o === null) throw Error(st(188)); return o !== i ? null : i } for (var h = i, y = o; ;) { var w = h.return; if (w === null) break; var P = w.alternate; if (P === null) { if (y = w.return, y !== null) { h = y; continue } break } if (w.child === P.child) { for (P = w.child; P;) { if (P === h) return l1(w), i; if (P === y) return l1(w), o; P = P.sibling } throw Error(st(188)) } if (h.return !== y.return) h = w, y = P; else { for (var b = !1, c = w.child; c;) { if (c === h) { b = !0, h = w, y = P; break } if (c === y) { b = !0, y = w, h = P; break } c = c.sibling } if (!b) { for (c = P.child; c;) { if (c === h) { b = !0, h = P, y = w; break } if (c === y) { b = !0, y = P, h = w; break } c = c.sibling } if (!b) throw Error(st(189)) } } if (h.alternate !== y) throw Error(st(190)) } if (h.tag !== 3) throw Error(st(188)); return h.stateNode.current === h ? i : o } function sb(i) { return i = hP(i), i !== null ? ob(i) : null } function ob(i) { if (i.tag === 5 || i.tag === 6) return i; for (i = i.child; i !== null;) { var o = ob(i); if (o !== null) return o; i = i.sibling } return null } var ab = Fi.unstable_scheduleCallback, u1 = Fi.unstable_cancelCallback, dP = Fi.unstable_shouldYield, pP = Fi.unstable_requestPaint, tn = Fi.unstable_now, fP = Fi.unstable_getCurrentPriorityLevel, Jy = Fi.unstable_ImmediatePriority, lb = Fi.unstable_UserBlockingPriority, Xf = Fi.unstable_NormalPriority, mP = Fi.unstable_LowPriority, ub = Fi.unstable_IdlePriority, xm = null, Ns = null; function gP(i) { if (Ns && typeof Ns.onCommitFiberRoot == "function") try { Ns.onCommitFiberRoot(xm, i, void 0, (i.current.flags & 128) === 128) } catch { } } var ms = Math.clz32 ? Math.clz32 : vP, _P = Math.log, yP = Math.LN2; function vP(i) { return i >>>= 0, i === 0 ? 32 : 31 - (_P(i) / yP | 0) | 0 } var _f = 64, yf = 4194304; function ed(i) { switch (i & -i) { case 1: return 1; case 2: return 2; case 4: return 4; case 8: return 8; case 16: return 16; case 32: return 32; case 64: case 128: case 256: case 512: case 1024: case 2048: case 4096: case 8192: case 16384: case 32768: case 65536: case 131072: case 262144: case 524288: case 1048576: case 2097152: return i & 4194240; case 4194304: case 8388608: case 16777216: case 33554432: case 67108864: return i & 130023424; case 134217728: return 134217728; case 268435456: return 268435456; case 536870912: return 536870912; case 1073741824: return 1073741824; default: return i } } function Yf(i, o) { var h = i.pendingLanes; if (h === 0) return 0; var y = 0, w = i.suspendedLanes, P = i.pingedLanes, b = h & 268435455; if (b !== 0) { var c = b & ~w; c !== 0 ? y = ed(c) : (P &= b, P !== 0 && (y = ed(P))) } else b = h & ~w, b !== 0 ? y = ed(b) : P !== 0 && (y = ed(P)); if (y === 0) return 0; if (o !== 0 && o !== y && !(o & w) && (w = y & -y, P = o & -o, w >= P || w === 16 && (P & 4194240) !== 0)) return o; if (y & 4 && (y |= h & 16), o = i.entangledLanes, o !== 0) for (i = i.entanglements, o &= y; 0 < o;)h = 31 - ms(o), w = 1 << h, y |= i[h], o &= ~w; return y } function xP(i, o) { switch (i) { case 1: case 2: case 4: return o + 250; case 8: case 16: case 32: case 64: case 128: case 256: case 512: case 1024: case 2048: case 4096: case 8192: case 16384: case 32768: case 65536: case 131072: case 262144: case 524288: case 1048576: case 2097152: return o + 5e3; case 4194304: case 8388608: case 16777216: case 33554432: case 67108864: return -1; case 134217728: case 268435456: case 536870912: case 1073741824: return -1; default: return -1 } } function wP(i, o) { for (var h = i.suspendedLanes, y = i.pingedLanes, w = i.expirationTimes, P = i.pendingLanes; 0 < P;) { var b = 31 - ms(P), c = 1 << b, B = w[b]; B === -1 ? (!(c & h) || c & y) && (w[b] = xP(c, o)) : B <= o && (i.expiredLanes |= c), P &= ~c } } function ty(i) { return i = i.pendingLanes & -1073741825, i !== 0 ? i : i & 1073741824 ? 1073741824 : 0 } function cb() { var i = _f; return _f <<= 1, !(_f & 4194240) && (_f = 64), i } function h_(i) { for (var o = [], h = 0; 31 > h; h++)o.push(i); return o } function zd(i, o, h) { i.pendingLanes |= o, o !== 536870912 && (i.suspendedLanes = 0, i.pingedLanes = 0), i = i.eventTimes, o = 31 - ms(o), i[o] = h } function bP(i, o) { var h = i.pendingLanes & ~o; i.pendingLanes = o, i.suspendedLanes = 0, i.pingedLanes = 0, i.expiredLanes &= o, i.mutableReadLanes &= o, i.entangledLanes &= o, o = i.entanglements; var y = i.eventTimes; for (i = i.expirationTimes; 0 < h;) { var w = 31 - ms(h), P = 1 << w; o[w] = 0, y[w] = -1, i[w] = -1, h &= ~P } } function e0(i, o) { var h = i.entangledLanes |= o; for (i = i.entanglements; h;) { var y = 31 - ms(h), w = 1 << y; w & o | i[y] & o && (i[y] |= o), h &= ~w } } var dr = 0; function hb(i) { return i &= -i, 1 < i ? 4 < i ? i & 268435455 ? 16 : 536870912 : 4 : 1 } var db, t0, pb, fb, mb, ry = !1, vf = [], ma = null, ga = null, _a = null, _d = new Map, yd = new Map, ha = [], TP = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" "); function c1(i, o) { switch (i) { case "focusin": case "focusout": ma = null; break; case "dragenter": case "dragleave": ga = null; break; case "mouseover": case "mouseout": _a = null; break; case "pointerover": case "pointerout": _d.delete(o.pointerId); break; case "gotpointercapture": case "lostpointercapture": yd.delete(o.pointerId) } } function Gh(i, o, h, y, w, P) { return i === null || i.nativeEvent !== P ? (i = { blockedOn: o, domEventName: h, eventSystemFlags: y, nativeEvent: P, targetContainers: [w] }, o !== null && (o = Ld(o), o !== null && t0(o)), i) : (i.eventSystemFlags |= y, o = i.targetContainers, w !== null && o.indexOf(w) === -1 && o.push(w), i) } function SP(i, o, h, y, w) { switch (o) { case "focusin": return ma = Gh(ma, i, o, h, y, w), !0; case "dragenter": return ga = Gh(ga, i, o, h, y, w), !0; case "mouseover": return _a = Gh(_a, i, o, h, y, w), !0; case "pointerover": var P = w.pointerId; return _d.set(P, Gh(_d.get(P) || null, i, o, h, y, w)), !0; case "gotpointercapture": return P = w.pointerId, yd.set(P, Gh(yd.get(P) || null, i, o, h, y, w)), !0 }return !1 } function gb(i) { var o = Ml(i.target); if (o !== null) { var h = jl(o); if (h !== null) { if (o = h.tag, o === 13) { if (o = ib(h), o !== null) { i.blockedOn = o, mb(i.priority, function () { pb(h) }); return } } else if (o === 3 && h.stateNode.current.memoizedState.isDehydrated) { i.blockedOn = h.tag === 3 ? h.stateNode.containerInfo : null; return } } } i.blockedOn = null } function Rf(i) { if (i.blockedOn !== null) return !1; for (var o = i.targetContainers; 0 < o.length;) { var h = ny(i.domEventName, i.eventSystemFlags, o[0], i.nativeEvent); if (h === null) { h = i.nativeEvent; var y = new h.constructor(h.type, h); K_ = y, h.target.dispatchEvent(y), K_ = null } else return o = Ld(h), o !== null && t0(o), i.blockedOn = h, !1; o.shift() } return !0 } function h1(i, o, h) { Rf(i) && h.delete(o) } function EP() { ry = !1, ma !== null && Rf(ma) && (ma = null), ga !== null && Rf(ga) && (ga = null), _a !== null && Rf(_a) && (_a = null), _d.forEach(h1), yd.forEach(h1) } function $h(i, o) { i.blockedOn === o && (i.blockedOn = null, ry || (ry = !0, Fi.unstable_scheduleCallback(Fi.unstable_NormalPriority, EP))) } function vd(i) { function o(w) { return $h(w, i) } if (0 < vf.length) { $h(vf[0], i); for (var h = 1; h < vf.length; h++) { var y = vf[h]; y.blockedOn === i && (y.blockedOn = null) } } for (ma !== null && $h(ma, i), ga !== null && $h(ga, i), _a !== null && $h(_a, i), _d.forEach(o), yd.forEach(o), h = 0; h < ha.length; h++)y = ha[h], y.blockedOn === i && (y.blockedOn = null); for (; 0 < ha.length && (h = ha[0], h.blockedOn === null);)gb(h), h.blockedOn === null && ha.shift() } var hc = Eo.ReactCurrentBatchConfig, Kf = !0; function PP(i, o, h, y) { var w = dr, P = hc.transition; hc.transition = null; try { dr = 1, r0(i, o, h, y) } finally { dr = w, hc.transition = P } } function MP(i, o, h, y) { var w = dr, P = hc.transition; hc.transition = null; try { dr = 4, r0(i, o, h, y) } finally { dr = w, hc.transition = P } } function r0(i, o, h, y) { if (Kf) { var w = ny(i, o, h, y); if (w === null) w_(i, o, y, Qf, h), c1(i, y); else if (SP(w, i, o, h, y)) y.stopPropagation(); else if (c1(i, y), o & 4 && -1 < TP.indexOf(i)) { for (; w !== null;) { var P = Ld(w); if (P !== null && db(P), P = ny(i, o, h, y), P === null && w_(i, o, y, Qf, h), P === w) break; w = P } w !== null && y.stopPropagation() } else w_(i, o, y, null, h) } } var Qf = null; function ny(i, o, h, y) { if (Qf = null, i = Qy(y), i = Ml(i), i !== null) if (o = jl(i), o === null) i = null; else if (h = o.tag, h === 13) { if (i = ib(o), i !== null) return i; i = null } else if (h === 3) { if (o.stateNode.current.memoizedState.isDehydrated) return o.tag === 3 ? o.stateNode.containerInfo : null; i = null } else o !== i && (i = null); return Qf = i, null } function _b(i) { switch (i) { case "cancel": case "click": case "close": case "contextmenu": case "copy": case "cut": case "auxclick": case "dblclick": case "dragend": case "dragstart": case "drop": case "focusin": case "focusout": case "input": case "invalid": case "keydown": case "keypress": case "keyup": case "mousedown": case "mouseup": case "paste": case "pause": case "play": case "pointercancel": case "pointerdown": case "pointerup": case "ratechange": case "reset": case "resize": case "seeked": case "submit": case "touchcancel": case "touchend": case "touchstart": case "volumechange": case "change": case "selectionchange": case "textInput": case "compositionstart": case "compositionend": case "compositionupdate": case "beforeblur": case "afterblur": case "beforeinput": case "blur": case "fullscreenchange": case "focus": case "hashchange": case "popstate": case "select": case "selectstart": return 1; case "drag": case "dragenter": case "dragexit": case "dragleave": case "dragover": case "mousemove": case "mouseout": case "mouseover": case "pointermove": case "pointerout": case "pointerover": case "scroll": case "toggle": case "touchmove": case "wheel": case "mouseenter": case "mouseleave": case "pointerenter": case "pointerleave": return 4; case "message": switch (fP()) { case Jy: return 1; case lb: return 4; case Xf: case mP: return 16; case ub: return 536870912; default: return 16 }default: return 16 } } var pa = null, n0 = null, Lf = null; function yb() { if (Lf) return Lf; var i, o = n0, h = o.length, y, w = "value" in pa ? pa.value : pa.textContent, P = w.length; for (i = 0; i < h && o[i] === w[i]; i++); var b = h - i; for (y = 1; y <= b && o[h - y] === w[P - y]; y++); return Lf = w.slice(i, 1 < y ? 1 - y : void 0) } function Ff(i) { var o = i.keyCode; return "charCode" in i ? (i = i.charCode, i === 0 && o === 13 && (i = 13)) : i = o, i === 10 && (i = 13), 32 <= i || i === 13 ? i : 0 } function xf() { return !0 } function d1() { return !1 } function Oi(i) { function o(h, y, w, P, b) { this._reactName = h, this._targetInst = w, this.type = y, this.nativeEvent = P, this.target = b, this.currentTarget = null; for (var c in i) i.hasOwnProperty(c) && (h = i[c], this[c] = h ? h(P) : P[c]); return this.isDefaultPrevented = (P.defaultPrevented != null ? P.defaultPrevented : P.returnValue === !1) ? xf : d1, this.isPropagationStopped = d1, this } return Zr(o.prototype, { preventDefault: function () { this.defaultPrevented = !0; var h = this.nativeEvent; h && (h.preventDefault ? h.preventDefault() : typeof h.returnValue != "unknown" && (h.returnValue = !1), this.isDefaultPrevented = xf) }, stopPropagation: function () { var h = this.nativeEvent; h && (h.stopPropagation ? h.stopPropagation() : typeof h.cancelBubble != "unknown" && (h.cancelBubble = !0), this.isPropagationStopped = xf) }, persist: function () { }, isPersistent: xf }), o } var Sc = { eventPhase: 0, bubbles: 0, cancelable: 0, timeStamp: function (i) { return i.timeStamp || Date.now() }, defaultPrevented: 0, isTrusted: 0 }, i0 = Oi(Sc), Rd = Zr({}, Sc, { view: 0, detail: 0 }), IP = Oi(Rd), d_, p_, qh, wm = Zr({}, Rd, { screenX: 0, screenY: 0, clientX: 0, clientY: 0, pageX: 0, pageY: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, getModifierState: s0, button: 0, buttons: 0, relatedTarget: function (i) { return i.relatedTarget === void 0 ? i.fromElement === i.srcElement ? i.toElement : i.fromElement : i.relatedTarget }, movementX: function (i) { return "movementX" in i ? i.movementX : (i !== qh && (qh && i.type === "mousemove" ? (d_ = i.screenX - qh.screenX, p_ = i.screenY - qh.screenY) : p_ = d_ = 0, qh = i), d_) }, movementY: function (i) { return "movementY" in i ? i.movementY : p_ } }), p1 = Oi(wm), CP = Zr({}, wm, { dataTransfer: 0 }), AP = Oi(CP), kP = Zr({}, Rd, { relatedTarget: 0 }), f_ = Oi(kP), DP = Zr({}, Sc, { animationName: 0, elapsedTime: 0, pseudoElement: 0 }), zP = Oi(DP), RP = Zr({}, Sc, { clipboardData: function (i) { return "clipboardData" in i ? i.clipboardData : window.clipboardData } }), LP = Oi(RP), FP = Zr({}, Sc, { data: 0 }), f1 = Oi(FP), BP = { Esc: "Escape", Spacebar: " ", Left: "ArrowLeft", Up: "ArrowUp", Right: "ArrowRight", Down: "ArrowDown", Del: "Delete", Win: "OS", Menu: "ContextMenu", Apps: "ContextMenu", Scroll: "ScrollLock", MozPrintableKey: "Unidentified" }, OP = { 8: "Backspace", 9: "Tab", 12: "Clear", 13: "Enter", 16: "Shift", 17: "Control", 18: "Alt", 19: "Pause", 20: "CapsLock", 27: "Escape", 32: " ", 33: "PageUp", 34: "PageDown", 35: "End", 36: "Home", 37: "ArrowLeft", 38: "ArrowUp", 39: "ArrowRight", 40: "ArrowDown", 45: "Insert", 46: "Delete", 112: "F1", 113: "F2", 114: "F3", 115: "F4", 116: "F5", 117: "F6", 118: "F7", 119: "F8", 120: "F9", 121: "F10", 122: "F11", 123: "F12", 144: "NumLock", 145: "ScrollLock", 224: "Meta" }, NP = { Alt: "altKey", Control: "ctrlKey", Meta: "metaKey", Shift: "shiftKey" }; function jP(i) { var o = this.nativeEvent; return o.getModifierState ? o.getModifierState(i) : (i = NP[i]) ? !!o[i] : !1 } function s0() { return jP } var VP = Zr({}, Rd, { key: function (i) { if (i.key) { var o = BP[i.key] || i.key; if (o !== "Unidentified") return o } return i.type === "keypress" ? (i = Ff(i), i === 13 ? "Enter" : String.fromCharCode(i)) : i.type === "keydown" || i.type === "keyup" ? OP[i.keyCode] || "Unidentified" : "" }, code: 0, location: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, repeat: 0, locale: 0, getModifierState: s0, charCode: function (i) { return i.type === "keypress" ? Ff(i) : 0 }, keyCode: function (i) { return i.type === "keydown" || i.type === "keyup" ? i.keyCode : 0 }, which: function (i) { return i.type === "keypress" ? Ff(i) : i.type === "keydown" || i.type === "keyup" ? i.keyCode : 0 } }), UP = Oi(VP), GP = Zr({}, wm, { pointerId: 0, width: 0, height: 0, pressure: 0, tangentialPressure: 0, tiltX: 0, tiltY: 0, twist: 0, pointerType: 0, isPrimary: 0 }), m1 = Oi(GP), $P = Zr({}, Rd, { touches: 0, targetTouches: 0, changedTouches: 0, altKey: 0, metaKey: 0, ctrlKey: 0, shiftKey: 0, getModifierState: s0 }), qP = Oi($P), ZP = Zr({}, Sc, { propertyName: 0, elapsedTime: 0, pseudoElement: 0 }), WP = Oi(ZP), HP = Zr({}, wm, { deltaX: function (i) { return "deltaX" in i ? i.deltaX : "wheelDeltaX" in i ? -i.wheelDeltaX : 0 }, deltaY: function (i) { return "deltaY" in i ? i.deltaY : "wheelDeltaY" in i ? -i.wheelDeltaY : "wheelDelta" in i ? -i.wheelDelta : 0 }, deltaZ: 0, deltaMode: 0 }), XP = Oi(HP), YP = [9, 13, 27, 32], o0 = xo && "CompositionEvent" in window, ad = null; xo && "documentMode" in document && (ad = document.documentMode); var KP = xo && "TextEvent" in window && !ad, vb = xo && (!o0 || ad && 8 < ad && 11 >= ad), g1 = " ", _1 = !1; function xb(i, o) { switch (i) { case "keyup": return YP.indexOf(o.keyCode) !== -1; case "keydown": return o.keyCode !== 229; case "keypress": case "mousedown": case "focusout": return !0; default: return !1 } } function wb(i) { return i = i.detail, typeof i == "object" && "data" in i ? i.data : null } var Qu = !1; function QP(i, o) { switch (i) { case "compositionend": return wb(o); case "keypress": return o.which !== 32 ? null : (_1 = !0, g1); case "textInput": return i = o.data, i === g1 && _1 ? null : i; default: return null } } function JP(i, o) { if (Qu) return i === "compositionend" || !o0 && xb(i, o) ? (i = yb(), Lf = n0 = pa = null, Qu = !1, i) : null; switch (i) { case "paste": return null; case "keypress": if (!(o.ctrlKey || o.altKey || o.metaKey) || o.ctrlKey && o.altKey) { if (o.char && 1 < o.char.length) return o.char; if (o.which) return String.fromCharCode(o.which) } return null; case "compositionend": return vb && o.locale !== "ko" ? null : o.data; default: return null } } var eM = { color: !0, date: !0, datetime: !0, "datetime-local": !0, email: !0, month: !0, number: !0, password: !0, range: !0, search: !0, tel: !0, text: !0, time: !0, url: !0, week: !0 }; function y1(i) { var o = i && i.nodeName && i.nodeName.toLowerCase(); return o === "input" ? !!eM[i.type] : o === "textarea" } function bb(i, o, h, y) { Jw(y), o = Jf(o, "onChange"), 0 < o.length && (h = new i0("onChange", "change", null, h, y), i.push({ event: h, listeners: o })) } var ld = null, xd = null; function tM(i) { zb(i, 0) } function bm(i) { var o = tc(i); if (Zw(o)) return i } function rM(i, o) { if (i === "change") return o } var Tb = !1; if (xo) { var m_; if (xo) { var g_ = "oninput" in document; if (!g_) { var v1 = document.createElement("div"); v1.setAttribute("oninput", "return;"), g_ = typeof v1.oninput == "function" } m_ = g_ } else m_ = !1; Tb = m_ && (!document.documentMode || 9 < document.documentMode) } function x1() { ld && (ld.detachEvent("onpropertychange", Sb), xd = ld = null) } function Sb(i) { if (i.propertyName === "value" && bm(xd)) { var o = []; bb(o, xd, i, Qy(i)), nb(tM, o) } } function nM(i, o, h) { i === "focusin" ? (x1(), ld = o, xd = h, ld.attachEvent("onpropertychange", Sb)) : i === "focusout" && x1() } function iM(i) { if (i === "selectionchange" || i === "keyup" || i === "keydown") return bm(xd) } function sM(i, o) { if (i === "click") return bm(o) } function oM(i, o) { if (i === "input" || i === "change") return bm(o) } function aM(i, o) { return i === o && (i !== 0 || 1 / i === 1 / o) || i !== i && o !== o } var _s = typeof Object.is == "function" ? Object.is : aM; function wd(i, o) { if (_s(i, o)) return !0; if (typeof i != "object" || i === null || typeof o != "object" || o === null) return !1; var h = Object.keys(i), y = Object.keys(o); if (h.length !== y.length) return !1; for (y = 0; y < h.length; y++) { var w = h[y]; if (!N_.call(o, w) || !_s(i[w], o[w])) return !1 } return !0 } function w1(i) { for (; i && i.firstChild;)i = i.firstChild; return i } function b1(i, o) { var h = w1(i); i = 0; for (var y; h;) { if (h.nodeType === 3) { if (y = i + h.textContent.length, i <= o && y >= o) return { node: h, offset: o - i }; i = y } e: { for (; h;) { if (h.nextSibling) { h = h.nextSibling; break e } h = h.parentNode } h = void 0 } h = w1(h) } } function Eb(i, o) { return i && o ? i === o ? !0 : i && i.nodeType === 3 ? !1 : o && o.nodeType === 3 ? Eb(i, o.parentNode) : "contains" in i ? i.contains(o) : i.compareDocumentPosition ? !!(i.compareDocumentPosition(o) & 16) : !1 : !1 } function Pb() { for (var i = window, o = Zf(); o instanceof i.HTMLIFrameElement;) { try { var h = typeof o.contentWindow.location.href == "string" } catch { h = !1 } if (h) i = o.contentWindow; else break; o = Zf(i.document) } return o } function a0(i) { var o = i && i.nodeName && i.nodeName.toLowerCase(); return o && (o === "input" && (i.type === "text" || i.type === "search" || i.type === "tel" || i.type === "url" || i.type === "password") || o === "textarea" || i.contentEditable === "true") } function lM(i) { var o = Pb(), h = i.focusedElem, y = i.selectionRange; if (o !== h && h && h.ownerDocument && Eb(h.ownerDocument.documentElement, h)) { if (y !== null && a0(h)) { if (o = y.start, i = y.end, i === void 0 && (i = o), "selectionStart" in h) h.selectionStart = o, h.selectionEnd = Math.min(i, h.value.length); else if (i = (o = h.ownerDocument || document) && o.defaultView || window, i.getSelection) { i = i.getSelection(); var w = h.textContent.length, P = Math.min(y.start, w); y = y.end === void 0 ? P : Math.min(y.end, w), !i.extend && P > y && (w = y, y = P, P = w), w = b1(h, P); var b = b1(h, y); w && b && (i.rangeCount !== 1 || i.anchorNode !== w.node || i.anchorOffset !== w.offset || i.focusNode !== b.node || i.focusOffset !== b.offset) && (o = o.createRange(), o.setStart(w.node, w.offset), i.removeAllRanges(), P > y ? (i.addRange(o), i.extend(b.node, b.offset)) : (o.setEnd(b.node, b.offset), i.addRange(o))) } } for (o = [], i = h; i = i.parentNode;)i.nodeType === 1 && o.push({ element: i, left: i.scrollLeft, top: i.scrollTop }); for (typeof h.focus == "function" && h.focus(), h = 0; h < o.length; h++)i = o[h], i.element.scrollLeft = i.left, i.element.scrollTop = i.top } } var uM = xo && "documentMode" in document && 11 >= document.documentMode, Ju = null, iy = null, ud = null, sy = !1; function T1(i, o, h) { var y = h.window === h ? h.document : h.nodeType === 9 ? h : h.ownerDocument; sy || Ju == null || Ju !== Zf(y) || (y = Ju, "selectionStart" in y && a0(y) ? y = { start: y.selectionStart, end: y.selectionEnd } : (y = (y.ownerDocument && y.ownerDocument.defaultView || window).getSelection(), y = { anchorNode: y.anchorNode, anchorOffset: y.anchorOffset, focusNode: y.focusNode, focusOffset: y.focusOffset }), ud && wd(ud, y) || (ud = y, y = Jf(iy, "onSelect"), 0 < y.length && (o = new i0("onSelect", "select", null, o, h), i.push({ event: o, listeners: y }), o.target = Ju))) } function wf(i, o) { var h = {}; return h[i.toLowerCase()] = o.toLowerCase(), h["Webkit" + i] = "webkit" + o, h["Moz" + i] = "moz" + o, h } var ec = { animationend: wf("Animation", "AnimationEnd"), animationiteration: wf("Animation", "AnimationIteration"), animationstart: wf("Animation", "AnimationStart"), transitionend: wf("Transition", "TransitionEnd") }, __ = {}, Mb = {}; xo && (Mb = document.createElement("div").style, "AnimationEvent" in window || (delete ec.animationend.animation, delete ec.animationiteration.animation, delete ec.animationstart.animation), "TransitionEvent" in window || delete ec.transitionend.transition); function Tm(i) { if (__[i]) return __[i]; if (!ec[i]) return i; var o = ec[i], h; for (h in o) if (o.hasOwnProperty(h) && h in Mb) return __[i] = o[h]; return i } var Ib = Tm("animationend"), Cb = Tm("animationiteration"), Ab = Tm("animationstart"), kb = Tm("transitionend"), Db = new Map, S1 = "abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" "); function Ea(i, o) { Db.set(i, o), Nl(o, [i]) } for (var y_ = 0; y_ < S1.length; y_++) { var v_ = S1[y_], cM = v_.toLowerCase(), hM = v_[0].toUpperCase() + v_.slice(1); Ea(cM, "on" + hM) } Ea(Ib, "onAnimationEnd"); Ea(Cb, "onAnimationIteration"); Ea(Ab, "onAnimationStart"); Ea("dblclick", "onDoubleClick"); Ea("focusin", "onFocus"); Ea("focusout", "onBlur"); Ea(kb, "onTransitionEnd"); fc("onMouseEnter", ["mouseout", "mouseover"]); fc("onMouseLeave", ["mouseout", "mouseover"]); fc("onPointerEnter", ["pointerout", "pointerover"]); fc("onPointerLeave", ["pointerout", "pointerover"]); Nl("onChange", "change click focusin focusout input keydown keyup selectionchange".split(" ")); Nl("onSelect", "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" ")); Nl("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]); Nl("onCompositionEnd", "compositionend focusout keydown keypress keyup mousedown".split(" ")); Nl("onCompositionStart", "compositionstart focusout keydown keypress keyup mousedown".split(" ")); Nl("onCompositionUpdate", "compositionupdate focusout keydown keypress keyup mousedown".split(" ")); var td = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "), dM = new Set("cancel close invalid load scroll toggle".split(" ").concat(td)); function E1(i, o, h) { var y = i.type || "unknown-event"; i.currentTarget = h, cP(y, o, void 0, i), i.currentTarget = null } function zb(i, o) { o = (o & 4) !== 0; for (var h = 0; h < i.length; h++) { var y = i[h], w = y.event; y = y.listeners; e: { var P = void 0; if (o) for (var b = y.length - 1; 0 <= b; b--) { var c = y[b], B = c.instance, $ = c.currentTarget; if (c = c.listener, B !== P && w.isPropagationStopped()) break e; E1(w, c, $), P = B } else for (b = 0; b < y.length; b++) { if (c = y[b], B = c.instance, $ = c.currentTarget, c = c.listener, B !== P && w.isPropagationStopped()) break e; E1(w, c, $), P = B } } } if (Hf) throw i = ey, Hf = !1, ey = null, i } function zr(i, o) { var h = o[cy]; h === void 0 && (h = o[cy] = new Set); var y = i + "__bubble"; h.has(y) || (Rb(o, i, 2, !1), h.add(y)) } function x_(i, o, h) { var y = 0; o && (y |= 4), Rb(h, i, y, o) } var bf = "_reactListening" + Math.random().toString(36).slice(2); function bd(i) { if (!i[bf]) { i[bf] = !0, Vw.forEach(function (h) { h !== "selectionchange" && (dM.has(h) || x_(h, !1, i), x_(h, !0, i)) }); var o = i.nodeType === 9 ? i : i.ownerDocument; o === null || o[bf] || (o[bf] = !0, x_("selectionchange", !1, o)) } } function Rb(i, o, h, y) { switch (_b(o)) { case 1: var w = PP; break; case 4: w = MP; break; default: w = r0 }h = w.bind(null, o, h, i), w = void 0, !J_ || o !== "touchstart" && o !== "touchmove" && o !== "wheel" || (w = !0), y ? w !== void 0 ? i.addEventListener(o, h, { capture: !0, passive: w }) : i.addEventListener(o, h, !0) : w !== void 0 ? i.addEventListener(o, h, { passive: w }) : i.addEventListener(o, h, !1) } function w_(i, o, h, y, w) { var P = y; if (!(o & 1) && !(o & 2) && y !== null) e: for (; ;) { if (y === null) return; var b = y.tag; if (b === 3 || b === 4) { var c = y.stateNode.containerInfo; if (c === w || c.nodeType === 8 && c.parentNode === w) break; if (b === 4) for (b = y.return; b !== null;) { var B = b.tag; if ((B === 3 || B === 4) && (B = b.stateNode.containerInfo, B === w || B.nodeType === 8 && B.parentNode === w)) return; b = b.return } for (; c !== null;) { if (b = Ml(c), b === null) return; if (B = b.tag, B === 5 || B === 6) { y = P = b; continue e } c = c.parentNode } } y = y.return } nb(function () { var $ = P, me = Qy(h), ge = []; e: { var we = Db.get(i); if (we !== void 0) { var Ge = i0, Ye = i; switch (i) { case "keypress": if (Ff(h) === 0) break e; case "keydown": case "keyup": Ge = UP; break; case "focusin": Ye = "focus", Ge = f_; break; case "focusout": Ye = "blur", Ge = f_; break; case "beforeblur": case "afterblur": Ge = f_; break; case "click": if (h.button === 2) break e; case "auxclick": case "dblclick": case "mousedown": case "mousemove": case "mouseup": case "mouseout": case "mouseover": case "contextmenu": Ge = p1; break; case "drag": case "dragend": case "dragenter": case "dragexit": case "dragleave": case "dragover": case "dragstart": case "drop": Ge = AP; break; case "touchcancel": case "touchend": case "touchmove": case "touchstart": Ge = qP; break; case Ib: case Cb: case Ab: Ge = zP; break; case kb: Ge = WP; break; case "scroll": Ge = IP; break; case "wheel": Ge = XP; break; case "copy": case "cut": case "paste": Ge = LP; break; case "gotpointercapture": case "lostpointercapture": case "pointercancel": case "pointerdown": case "pointermove": case "pointerout": case "pointerover": case "pointerup": Ge = m1 }var $e = (o & 4) !== 0, ye = !$e && i === "scroll", be = $e ? we !== null ? we + "Capture" : null : we; $e = []; for (var K = $, ve; K !== null;) { ve = K; var Ke = ve.stateNode; if (ve.tag === 5 && Ke !== null && (ve = Ke, be !== null && (Ke = gd(K, be), Ke != null && $e.push(Td(K, Ke, ve)))), ye) break; K = K.return } 0 < $e.length && (we = new Ge(we, Ye, null, h, me), ge.push({ event: we, listeners: $e })) } } if (!(o & 7)) { e: { if (we = i === "mouseover" || i === "pointerover", Ge = i === "mouseout" || i === "pointerout", we && h !== K_ && (Ye = h.relatedTarget || h.fromElement) && (Ml(Ye) || Ye[wo])) break e; if ((Ge || we) && (we = me.window === me ? me : (we = me.ownerDocument) ? we.defaultView || we.parentWindow : window, Ge ? (Ye = h.relatedTarget || h.toElement, Ge = $, Ye = Ye ? Ml(Ye) : null, Ye !== null && (ye = jl(Ye), Ye !== ye || Ye.tag !== 5 && Ye.tag !== 6) && (Ye = null)) : (Ge = null, Ye = $), Ge !== Ye)) { if ($e = p1, Ke = "onMouseLeave", be = "onMouseEnter", K = "mouse", (i === "pointerout" || i === "pointerover") && ($e = m1, Ke = "onPointerLeave", be = "onPointerEnter", K = "pointer"), ye = Ge == null ? we : tc(Ge), ve = Ye == null ? we : tc(Ye), we = new $e(Ke, K + "leave", Ge, h, me), we.target = ye, we.relatedTarget = ve, Ke = null, Ml(me) === $ && ($e = new $e(be, K + "enter", Ye, h, me), $e.target = ve, $e.relatedTarget = ye, Ke = $e), ye = Ke, Ge && Ye) t: { for ($e = Ge, be = Ye, K = 0, ve = $e; ve; ve = Xu(ve))K++; for (ve = 0, Ke = be; Ke; Ke = Xu(Ke))ve++; for (; 0 < K - ve;)$e = Xu($e), K--; for (; 0 < ve - K;)be = Xu(be), ve--; for (; K--;) { if ($e === be || be !== null && $e === be.alternate) break t; $e = Xu($e), be = Xu(be) } $e = null } else $e = null; Ge !== null && P1(ge, we, Ge, $e, !1), Ye !== null && ye !== null && P1(ge, ye, Ye, $e, !0) } } e: { if (we = $ ? tc($) : window, Ge = we.nodeName && we.nodeName.toLowerCase(), Ge === "select" || Ge === "input" && we.type === "file") var ft = rM; else if (y1(we)) if (Tb) ft = oM; else { ft = iM; var mt = nM } else (Ge = we.nodeName) && Ge.toLowerCase() === "input" && (we.type === "checkbox" || we.type === "radio") && (ft = sM); if (ft && (ft = ft(i, $))) { bb(ge, ft, h, me); break e } mt && mt(i, we, $), i === "focusout" && (mt = we._wrapperState) && mt.controlled && we.type === "number" && Z_(we, "number", we.value) } switch (mt = $ ? tc($) : window, i) { case "focusin": (y1(mt) || mt.contentEditable === "true") && (Ju = mt, iy = $, ud = null); break; case "focusout": ud = iy = Ju = null; break; case "mousedown": sy = !0; break; case "contextmenu": case "mouseup": case "dragend": sy = !1, T1(ge, h, me); break; case "selectionchange": if (uM) break; case "keydown": case "keyup": T1(ge, h, me) }var ct; if (o0) e: { switch (i) { case "compositionstart": var Z = "onCompositionStart"; break e; case "compositionend": Z = "onCompositionEnd"; break e; case "compositionupdate": Z = "onCompositionUpdate"; break e }Z = void 0 } else Qu ? xb(i, h) && (Z = "onCompositionEnd") : i === "keydown" && h.keyCode === 229 && (Z = "onCompositionStart"); Z && (vb && h.locale !== "ko" && (Qu || Z !== "onCompositionStart" ? Z === "onCompositionEnd" && Qu && (ct = yb()) : (pa = me, n0 = "value" in pa ? pa.value : pa.textContent, Qu = !0)), mt = Jf($, Z), 0 < mt.length && (Z = new f1(Z, i, null, h, me), ge.push({ event: Z, listeners: mt }), ct ? Z.data = ct : (ct = wb(h), ct !== null && (Z.data = ct)))), (ct = KP ? QP(i, h) : JP(i, h)) && ($ = Jf($, "onBeforeInput"), 0 < $.length && (me = new f1("onBeforeInput", "beforeinput", null, h, me), ge.push({ event: me, listeners: $ }), me.data = ct)) } zb(ge, o) }) } function Td(i, o, h) { return { instance: i, listener: o, currentTarget: h } } function Jf(i, o) { for (var h = o + "Capture", y = []; i !== null;) { var w = i, P = w.stateNode; w.tag === 5 && P !== null && (w = P, P = gd(i, h), P != null && y.unshift(Td(i, P, w)), P = gd(i, o), P != null && y.push(Td(i, P, w))), i = i.return } return y } function Xu(i) { if (i === null) return null; do i = i.return; while (i && i.tag !== 5); return i || null } function P1(i, o, h, y, w) { for (var P = o._reactName, b = []; h !== null && h !== y;) { var c = h, B = c.alternate, $ = c.stateNode; if (B !== null && B === y) break; c.tag === 5 && $ !== null && (c = $, w ? (B = gd(h, P), B != null && b.unshift(Td(h, B, c))) : w || (B = gd(h, P), B != null && b.push(Td(h, B, c)))), h = h.return } b.length !== 0 && i.push({ event: o, listeners: b }) } var pM = /\r\n?/g, fM = /\u0000|\uFFFD/g; function M1(i) {
    return (typeof i == "string" ? i : "" + i).replace(pM, `
`).replace(fM, "")
} function Tf(i, o, h) { if (o = M1(o), M1(i) !== o && h) throw Error(st(425)) } function em() { } var oy = null, ay = null; function ly(i, o) { return i === "textarea" || i === "noscript" || typeof o.children == "string" || typeof o.children == "number" || typeof o.dangerouslySetInnerHTML == "object" && o.dangerouslySetInnerHTML !== null && o.dangerouslySetInnerHTML.__html != null } var uy = typeof setTimeout == "function" ? setTimeout : void 0, mM = typeof clearTimeout == "function" ? clearTimeout : void 0, I1 = typeof Promise == "function" ? Promise : void 0, gM = typeof queueMicrotask == "function" ? queueMicrotask : typeof I1 < "u" ? function (i) { return I1.resolve(null).then(i).catch(_M) } : uy; function _M(i) { setTimeout(function () { throw i }) } function b_(i, o) { var h = o, y = 0; do { var w = h.nextSibling; if (i.removeChild(h), w && w.nodeType === 8) if (h = w.data, h === "/$") { if (y === 0) { i.removeChild(w), vd(o); return } y-- } else h !== "$" && h !== "$?" && h !== "$!" || y++; h = w } while (h); vd(o) } function ya(i) { for (; i != null; i = i.nextSibling) { var o = i.nodeType; if (o === 1 || o === 3) break; if (o === 8) { if (o = i.data, o === "$" || o === "$!" || o === "$?") break; if (o === "/$") return null } } return i } function C1(i) { i = i.previousSibling; for (var o = 0; i;) { if (i.nodeType === 8) { var h = i.data; if (h === "$" || h === "$!" || h === "$?") { if (o === 0) return i; o-- } else h === "/$" && o++ } i = i.previousSibling } return null } var Ec = Math.random().toString(36).slice(2), Bs = "__reactFiber$" + Ec, Sd = "__reactProps$" + Ec, wo = "__reactContainer$" + Ec, cy = "__reactEvents$" + Ec, yM = "__reactListeners$" + Ec, vM = "__reactHandles$" + Ec; function Ml(i) { var o = i[Bs]; if (o) return o; for (var h = i.parentNode; h;) { if (o = h[wo] || h[Bs]) { if (h = o.alternate, o.child !== null || h !== null && h.child !== null) for (i = C1(i); i !== null;) { if (h = i[Bs]) return h; i = C1(i) } return o } i = h, h = i.parentNode } return null } function Ld(i) { return i = i[Bs] || i[wo], !i || i.tag !== 5 && i.tag !== 6 && i.tag !== 13 && i.tag !== 3 ? null : i } function tc(i) { if (i.tag === 5 || i.tag === 6) return i.stateNode; throw Error(st(33)) } function Sm(i) { return i[Sd] || null } var hy = [], rc = -1; function Pa(i) { return { current: i } } function Rr(i) { 0 > rc || (i.current = hy[rc], hy[rc] = null, rc--) } function Er(i, o) { rc++, hy[rc] = i.current, i.current = o } var Sa = {}, Xn = Pa(Sa), gi = Pa(!1), Rl = Sa; function mc(i, o) { var h = i.type.contextTypes; if (!h) return Sa; var y = i.stateNode; if (y && y.__reactInternalMemoizedUnmaskedChildContext === o) return y.__reactInternalMemoizedMaskedChildContext; var w = {}, P; for (P in h) w[P] = o[P]; return y && (i = i.stateNode, i.__reactInternalMemoizedUnmaskedChildContext = o, i.__reactInternalMemoizedMaskedChildContext = w), w } function _i(i) { return i = i.childContextTypes, i != null } function tm() { Rr(gi), Rr(Xn) } function A1(i, o, h) { if (Xn.current !== Sa) throw Error(st(168)); Er(Xn, o), Er(gi, h) } function Lb(i, o, h) { var y = i.stateNode; if (o = o.childContextTypes, typeof y.getChildContext != "function") return h; y = y.getChildContext(); for (var w in y) if (!(w in o)) throw Error(st(108, nP(i) || "Unknown", w)); return Zr({}, h, y) } function rm(i) { return i = (i = i.stateNode) && i.__reactInternalMemoizedMergedChildContext || Sa, Rl = Xn.current, Er(Xn, i), Er(gi, gi.current), !0 } function k1(i, o, h) { var y = i.stateNode; if (!y) throw Error(st(169)); h ? (i = Lb(i, o, Rl), y.__reactInternalMemoizedMergedChildContext = i, Rr(gi), Rr(Xn), Er(Xn, i)) : Rr(gi), Er(gi, h) } var go = null, Em = !1, T_ = !1; function Fb(i) { go === null ? go = [i] : go.push(i) } function xM(i) { Em = !0, Fb(i) } function Ma() { if (!T_ && go !== null) { T_ = !0; var i = 0, o = dr; try { var h = go; for (dr = 1; i < h.length; i++) { var y = h[i]; do y = y(!0); while (y !== null) } go = null, Em = !1 } catch (w) { throw go !== null && (go = go.slice(i + 1)), ab(Jy, Ma), w } finally { dr = o, T_ = !1 } } return null } var nc = [], ic = 0, nm = null, im = 0, Hi = [], Xi = 0, Ll = null, _o = 1, yo = ""; function El(i, o) { nc[ic++] = im, nc[ic++] = nm, nm = i, im = o } function Bb(i, o, h) { Hi[Xi++] = _o, Hi[Xi++] = yo, Hi[Xi++] = Ll, Ll = i; var y = _o; i = yo; var w = 32 - ms(y) - 1; y &= ~(1 << w), h += 1; var P = 32 - ms(o) + w; if (30 < P) { var b = w - w % 5; P = (y & (1 << b) - 1).toString(32), y >>= b, w -= b, _o = 1 << 32 - ms(o) + w | h << w | y, yo = P + i } else _o = 1 << P | h << w | y, yo = i } function l0(i) { i.return !== null && (El(i, 1), Bb(i, 1, 0)) } function u0(i) { for (; i === nm;)nm = nc[--ic], nc[ic] = null, im = nc[--ic], nc[ic] = null; for (; i === Ll;)Ll = Hi[--Xi], Hi[Xi] = null, yo = Hi[--Xi], Hi[Xi] = null, _o = Hi[--Xi], Hi[Xi] = null } var Li = null, Ri = null, jr = !1, ps = null; function Ob(i, o) { var h = Yi(5, null, null, 0); h.elementType = "DELETED", h.stateNode = o, h.return = i, o = i.deletions, o === null ? (i.deletions = [h], i.flags |= 16) : o.push(h) } function D1(i, o) { switch (i.tag) { case 5: var h = i.type; return o = o.nodeType !== 1 || h.toLowerCase() !== o.nodeName.toLowerCase() ? null : o, o !== null ? (i.stateNode = o, Li = i, Ri = ya(o.firstChild), !0) : !1; case 6: return o = i.pendingProps === "" || o.nodeType !== 3 ? null : o, o !== null ? (i.stateNode = o, Li = i, Ri = null, !0) : !1; case 13: return o = o.nodeType !== 8 ? null : o, o !== null ? (h = Ll !== null ? { id: _o, overflow: yo } : null, i.memoizedState = { dehydrated: o, treeContext: h, retryLane: 1073741824 }, h = Yi(18, null, null, 0), h.stateNode = o, h.return = i, i.child = h, Li = i, Ri = null, !0) : !1; default: return !1 } } function dy(i) { return (i.mode & 1) !== 0 && (i.flags & 128) === 0 } function py(i) { if (jr) { var o = Ri; if (o) { var h = o; if (!D1(i, o)) { if (dy(i)) throw Error(st(418)); o = ya(h.nextSibling); var y = Li; o && D1(i, o) ? Ob(y, h) : (i.flags = i.flags & -4097 | 2, jr = !1, Li = i) } } else { if (dy(i)) throw Error(st(418)); i.flags = i.flags & -4097 | 2, jr = !1, Li = i } } } function z1(i) { for (i = i.return; i !== null && i.tag !== 5 && i.tag !== 3 && i.tag !== 13;)i = i.return; Li = i } function Sf(i) { if (i !== Li) return !1; if (!jr) return z1(i), jr = !0, !1; var o; if ((o = i.tag !== 3) && !(o = i.tag !== 5) && (o = i.type, o = o !== "head" && o !== "body" && !ly(i.type, i.memoizedProps)), o && (o = Ri)) { if (dy(i)) throw Nb(), Error(st(418)); for (; o;)Ob(i, o), o = ya(o.nextSibling) } if (z1(i), i.tag === 13) { if (i = i.memoizedState, i = i !== null ? i.dehydrated : null, !i) throw Error(st(317)); e: { for (i = i.nextSibling, o = 0; i;) { if (i.nodeType === 8) { var h = i.data; if (h === "/$") { if (o === 0) { Ri = ya(i.nextSibling); break e } o-- } else h !== "$" && h !== "$!" && h !== "$?" || o++ } i = i.nextSibling } Ri = null } } else Ri = Li ? ya(i.stateNode.nextSibling) : null; return !0 } function Nb() { for (var i = Ri; i;)i = ya(i.nextSibling) } function gc() { Ri = Li = null, jr = !1 } function c0(i) { ps === null ? ps = [i] : ps.push(i) } var wM = Eo.ReactCurrentBatchConfig; function Zh(i, o, h) { if (i = h.ref, i !== null && typeof i != "function" && typeof i != "object") { if (h._owner) { if (h = h._owner, h) { if (h.tag !== 1) throw Error(st(309)); var y = h.stateNode } if (!y) throw Error(st(147, i)); var w = y, P = "" + i; return o !== null && o.ref !== null && typeof o.ref == "function" && o.ref._stringRef === P ? o.ref : (o = function (b) { var c = w.refs; b === null ? delete c[P] : c[P] = b }, o._stringRef = P, o) } if (typeof i != "string") throw Error(st(284)); if (!h._owner) throw Error(st(290, i)) } return i } function Ef(i, o) { throw i = Object.prototype.toString.call(o), Error(st(31, i === "[object Object]" ? "object with keys {" + Object.keys(o).join(", ") + "}" : i)) } function R1(i) { var o = i._init; return o(i._payload) } function jb(i) { function o(be, K) { if (i) { var ve = be.deletions; ve === null ? (be.deletions = [K], be.flags |= 16) : ve.push(K) } } function h(be, K) { if (!i) return null; for (; K !== null;)o(be, K), K = K.sibling; return null } function y(be, K) { for (be = new Map; K !== null;)K.key !== null ? be.set(K.key, K) : be.set(K.index, K), K = K.sibling; return be } function w(be, K) { return be = ba(be, K), be.index = 0, be.sibling = null, be } function P(be, K, ve) { return be.index = ve, i ? (ve = be.alternate, ve !== null ? (ve = ve.index, ve < K ? (be.flags |= 2, K) : ve) : (be.flags |= 2, K)) : (be.flags |= 1048576, K) } function b(be) { return i && be.alternate === null && (be.flags |= 2), be } function c(be, K, ve, Ke) { return K === null || K.tag !== 6 ? (K = A_(ve, be.mode, Ke), K.return = be, K) : (K = w(K, ve), K.return = be, K) } function B(be, K, ve, Ke) { var ft = ve.type; return ft === Ku ? me(be, K, ve.props.children, Ke, ve.key) : K !== null && (K.elementType === ft || typeof ft == "object" && ft !== null && ft.$$typeof === ua && R1(ft) === K.type) ? (Ke = w(K, ve.props), Ke.ref = Zh(be, K, ve), Ke.return = be, Ke) : (Ke = Gf(ve.type, ve.key, ve.props, null, be.mode, Ke), Ke.ref = Zh(be, K, ve), Ke.return = be, Ke) } function $(be, K, ve, Ke) { return K === null || K.tag !== 4 || K.stateNode.containerInfo !== ve.containerInfo || K.stateNode.implementation !== ve.implementation ? (K = k_(ve, be.mode, Ke), K.return = be, K) : (K = w(K, ve.children || []), K.return = be, K) } function me(be, K, ve, Ke, ft) { return K === null || K.tag !== 7 ? (K = Dl(ve, be.mode, Ke, ft), K.return = be, K) : (K = w(K, ve), K.return = be, K) } function ge(be, K, ve) { if (typeof K == "string" && K !== "" || typeof K == "number") return K = A_("" + K, be.mode, ve), K.return = be, K; if (typeof K == "object" && K !== null) { switch (K.$$typeof) { case ff: return ve = Gf(K.type, K.key, K.props, null, be.mode, ve), ve.ref = Zh(be, null, K), ve.return = be, ve; case Yu: return K = k_(K, be.mode, ve), K.return = be, K; case ua: var Ke = K._init; return ge(be, Ke(K._payload), ve) }if (Jh(K) || Vh(K)) return K = Dl(K, be.mode, ve, null), K.return = be, K; Ef(be, K) } return null } function we(be, K, ve, Ke) { var ft = K !== null ? K.key : null; if (typeof ve == "string" && ve !== "" || typeof ve == "number") return ft !== null ? null : c(be, K, "" + ve, Ke); if (typeof ve == "object" && ve !== null) { switch (ve.$$typeof) { case ff: return ve.key === ft ? B(be, K, ve, Ke) : null; case Yu: return ve.key === ft ? $(be, K, ve, Ke) : null; case ua: return ft = ve._init, we(be, K, ft(ve._payload), Ke) }if (Jh(ve) || Vh(ve)) return ft !== null ? null : me(be, K, ve, Ke, null); Ef(be, ve) } return null } function Ge(be, K, ve, Ke, ft) { if (typeof Ke == "string" && Ke !== "" || typeof Ke == "number") return be = be.get(ve) || null, c(K, be, "" + Ke, ft); if (typeof Ke == "object" && Ke !== null) { switch (Ke.$$typeof) { case ff: return be = be.get(Ke.key === null ? ve : Ke.key) || null, B(K, be, Ke, ft); case Yu: return be = be.get(Ke.key === null ? ve : Ke.key) || null, $(K, be, Ke, ft); case ua: var mt = Ke._init; return Ge(be, K, ve, mt(Ke._payload), ft) }if (Jh(Ke) || Vh(Ke)) return be = be.get(ve) || null, me(K, be, Ke, ft, null); Ef(K, Ke) } return null } function Ye(be, K, ve, Ke) { for (var ft = null, mt = null, ct = K, Z = K = 0, re = null; ct !== null && Z < ve.length; Z++) { ct.index > Z ? (re = ct, ct = null) : re = ct.sibling; var ie = we(be, ct, ve[Z], Ke); if (ie === null) { ct === null && (ct = re); break } i && ct && ie.alternate === null && o(be, ct), K = P(ie, K, Z), mt === null ? ft = ie : mt.sibling = ie, mt = ie, ct = re } if (Z === ve.length) return h(be, ct), jr && El(be, Z), ft; if (ct === null) { for (; Z < ve.length; Z++)ct = ge(be, ve[Z], Ke), ct !== null && (K = P(ct, K, Z), mt === null ? ft = ct : mt.sibling = ct, mt = ct); return jr && El(be, Z), ft } for (ct = y(be, ct); Z < ve.length; Z++)re = Ge(ct, be, Z, ve[Z], Ke), re !== null && (i && re.alternate !== null && ct.delete(re.key === null ? Z : re.key), K = P(re, K, Z), mt === null ? ft = re : mt.sibling = re, mt = re); return i && ct.forEach(function (Ce) { return o(be, Ce) }), jr && El(be, Z), ft } function $e(be, K, ve, Ke) { var ft = Vh(ve); if (typeof ft != "function") throw Error(st(150)); if (ve = ft.call(ve), ve == null) throw Error(st(151)); for (var mt = ft = null, ct = K, Z = K = 0, re = null, ie = ve.next(); ct !== null && !ie.done; Z++, ie = ve.next()) { ct.index > Z ? (re = ct, ct = null) : re = ct.sibling; var Ce = we(be, ct, ie.value, Ke); if (Ce === null) { ct === null && (ct = re); break } i && ct && Ce.alternate === null && o(be, ct), K = P(Ce, K, Z), mt === null ? ft = Ce : mt.sibling = Ce, mt = Ce, ct = re } if (ie.done) return h(be, ct), jr && El(be, Z), ft; if (ct === null) { for (; !ie.done; Z++, ie = ve.next())ie = ge(be, ie.value, Ke), ie !== null && (K = P(ie, K, Z), mt === null ? ft = ie : mt.sibling = ie, mt = ie); return jr && El(be, Z), ft } for (ct = y(be, ct); !ie.done; Z++, ie = ve.next())ie = Ge(ct, be, Z, ie.value, Ke), ie !== null && (i && ie.alternate !== null && ct.delete(ie.key === null ? Z : ie.key), K = P(ie, K, Z), mt === null ? ft = ie : mt.sibling = ie, mt = ie); return i && ct.forEach(function (xe) { return o(be, xe) }), jr && El(be, Z), ft } function ye(be, K, ve, Ke) { if (typeof ve == "object" && ve !== null && ve.type === Ku && ve.key === null && (ve = ve.props.children), typeof ve == "object" && ve !== null) { switch (ve.$$typeof) { case ff: e: { for (var ft = ve.key, mt = K; mt !== null;) { if (mt.key === ft) { if (ft = ve.type, ft === Ku) { if (mt.tag === 7) { h(be, mt.sibling), K = w(mt, ve.props.children), K.return = be, be = K; break e } } else if (mt.elementType === ft || typeof ft == "object" && ft !== null && ft.$$typeof === ua && R1(ft) === mt.type) { h(be, mt.sibling), K = w(mt, ve.props), K.ref = Zh(be, mt, ve), K.return = be, be = K; break e } h(be, mt); break } else o(be, mt); mt = mt.sibling } ve.type === Ku ? (K = Dl(ve.props.children, be.mode, Ke, ve.key), K.return = be, be = K) : (Ke = Gf(ve.type, ve.key, ve.props, null, be.mode, Ke), Ke.ref = Zh(be, K, ve), Ke.return = be, be = Ke) } return b(be); case Yu: e: { for (mt = ve.key; K !== null;) { if (K.key === mt) if (K.tag === 4 && K.stateNode.containerInfo === ve.containerInfo && K.stateNode.implementation === ve.implementation) { h(be, K.sibling), K = w(K, ve.children || []), K.return = be, be = K; break e } else { h(be, K); break } else o(be, K); K = K.sibling } K = k_(ve, be.mode, Ke), K.return = be, be = K } return b(be); case ua: return mt = ve._init, ye(be, K, mt(ve._payload), Ke) }if (Jh(ve)) return Ye(be, K, ve, Ke); if (Vh(ve)) return $e(be, K, ve, Ke); Ef(be, ve) } return typeof ve == "string" && ve !== "" || typeof ve == "number" ? (ve = "" + ve, K !== null && K.tag === 6 ? (h(be, K.sibling), K = w(K, ve), K.return = be, be = K) : (h(be, K), K = A_(ve, be.mode, Ke), K.return = be, be = K), b(be)) : h(be, K) } return ye } var _c = jb(!0), Vb = jb(!1), sm = Pa(null), om = null, sc = null, h0 = null; function d0() { h0 = sc = om = null } function p0(i) { var o = sm.current; Rr(sm), i._currentValue = o } function fy(i, o, h) { for (; i !== null;) { var y = i.alternate; if ((i.childLanes & o) !== o ? (i.childLanes |= o, y !== null && (y.childLanes |= o)) : y !== null && (y.childLanes & o) !== o && (y.childLanes |= o), i === h) break; i = i.return } } function dc(i, o) { om = i, h0 = sc = null, i = i.dependencies, i !== null && i.firstContext !== null && (i.lanes & o && (mi = !0), i.firstContext = null) } function Qi(i) { var o = i._currentValue; if (h0 !== i) if (i = { context: i, memoizedValue: o, next: null }, sc === null) { if (om === null) throw Error(st(308)); sc = i, om.dependencies = { lanes: 0, firstContext: i } } else sc = sc.next = i; return o } var Il = null; function f0(i) { Il === null ? Il = [i] : Il.push(i) } function Ub(i, o, h, y) { var w = o.interleaved; return w === null ? (h.next = h, f0(o)) : (h.next = w.next, w.next = h), o.interleaved = h, bo(i, y) } function bo(i, o) { i.lanes |= o; var h = i.alternate; for (h !== null && (h.lanes |= o), h = i, i = i.return; i !== null;)i.childLanes |= o, h = i.alternate, h !== null && (h.childLanes |= o), h = i, i = i.return; return h.tag === 3 ? h.stateNode : null } var ca = !1; function m0(i) { i.updateQueue = { baseState: i.memoizedState, firstBaseUpdate: null, lastBaseUpdate: null, shared: { pending: null, interleaved: null, lanes: 0 }, effects: null } } function Gb(i, o) { i = i.updateQueue, o.updateQueue === i && (o.updateQueue = { baseState: i.baseState, firstBaseUpdate: i.firstBaseUpdate, lastBaseUpdate: i.lastBaseUpdate, shared: i.shared, effects: i.effects }) } function vo(i, o) { return { eventTime: i, lane: o, tag: 0, payload: null, callback: null, next: null } } function va(i, o, h) { var y = i.updateQueue; if (y === null) return null; if (y = y.shared, Qt & 2) { var w = y.pending; return w === null ? o.next = o : (o.next = w.next, w.next = o), y.pending = o, bo(i, h) } return w = y.interleaved, w === null ? (o.next = o, f0(y)) : (o.next = w.next, w.next = o), y.interleaved = o, bo(i, h) } function Bf(i, o, h) { if (o = o.updateQueue, o !== null && (o = o.shared, (h & 4194240) !== 0)) { var y = o.lanes; y &= i.pendingLanes, h |= y, o.lanes = h, e0(i, h) } } function L1(i, o) { var h = i.updateQueue, y = i.alternate; if (y !== null && (y = y.updateQueue, h === y)) { var w = null, P = null; if (h = h.firstBaseUpdate, h !== null) { do { var b = { eventTime: h.eventTime, lane: h.lane, tag: h.tag, payload: h.payload, callback: h.callback, next: null }; P === null ? w = P = b : P = P.next = b, h = h.next } while (h !== null); P === null ? w = P = o : P = P.next = o } else w = P = o; h = { baseState: y.baseState, firstBaseUpdate: w, lastBaseUpdate: P, shared: y.shared, effects: y.effects }, i.updateQueue = h; return } i = h.lastBaseUpdate, i === null ? h.firstBaseUpdate = o : i.next = o, h.lastBaseUpdate = o } function am(i, o, h, y) { var w = i.updateQueue; ca = !1; var P = w.firstBaseUpdate, b = w.lastBaseUpdate, c = w.shared.pending; if (c !== null) { w.shared.pending = null; var B = c, $ = B.next; B.next = null, b === null ? P = $ : b.next = $, b = B; var me = i.alternate; me !== null && (me = me.updateQueue, c = me.lastBaseUpdate, c !== b && (c === null ? me.firstBaseUpdate = $ : c.next = $, me.lastBaseUpdate = B)) } if (P !== null) { var ge = w.baseState; b = 0, me = $ = B = null, c = P; do { var we = c.lane, Ge = c.eventTime; if ((y & we) === we) { me !== null && (me = me.next = { eventTime: Ge, lane: 0, tag: c.tag, payload: c.payload, callback: c.callback, next: null }); e: { var Ye = i, $e = c; switch (we = o, Ge = h, $e.tag) { case 1: if (Ye = $e.payload, typeof Ye == "function") { ge = Ye.call(Ge, ge, we); break e } ge = Ye; break e; case 3: Ye.flags = Ye.flags & -65537 | 128; case 0: if (Ye = $e.payload, we = typeof Ye == "function" ? Ye.call(Ge, ge, we) : Ye, we == null) break e; ge = Zr({}, ge, we); break e; case 2: ca = !0 } } c.callback !== null && c.lane !== 0 && (i.flags |= 64, we = w.effects, we === null ? w.effects = [c] : we.push(c)) } else Ge = { eventTime: Ge, lane: we, tag: c.tag, payload: c.payload, callback: c.callback, next: null }, me === null ? ($ = me = Ge, B = ge) : me = me.next = Ge, b |= we; if (c = c.next, c === null) { if (c = w.shared.pending, c === null) break; we = c, c = we.next, we.next = null, w.lastBaseUpdate = we, w.shared.pending = null } } while (!0); if (me === null && (B = ge), w.baseState = B, w.firstBaseUpdate = $, w.lastBaseUpdate = me, o = w.shared.interleaved, o !== null) { w = o; do b |= w.lane, w = w.next; while (w !== o) } else P === null && (w.shared.lanes = 0); Bl |= b, i.lanes = b, i.memoizedState = ge } } function F1(i, o, h) { if (i = o.effects, o.effects = null, i !== null) for (o = 0; o < i.length; o++) { var y = i[o], w = y.callback; if (w !== null) { if (y.callback = null, y = h, typeof w != "function") throw Error(st(191, w)); w.call(y) } } } var Fd = {}, js = Pa(Fd), Ed = Pa(Fd), Pd = Pa(Fd); function Cl(i) { if (i === Fd) throw Error(st(174)); return i } function g0(i, o) { switch (Er(Pd, o), Er(Ed, i), Er(js, Fd), i = o.nodeType, i) { case 9: case 11: o = (o = o.documentElement) ? o.namespaceURI : H_(null, ""); break; default: i = i === 8 ? o.parentNode : o, o = i.namespaceURI || null, i = i.tagName, o = H_(o, i) }Rr(js), Er(js, o) } function yc() { Rr(js), Rr(Ed), Rr(Pd) } function $b(i) { Cl(Pd.current); var o = Cl(js.current), h = H_(o, i.type); o !== h && (Er(Ed, i), Er(js, h)) } function _0(i) { Ed.current === i && (Rr(js), Rr(Ed)) } var $r = Pa(0); function lm(i) { for (var o = i; o !== null;) { if (o.tag === 13) { var h = o.memoizedState; if (h !== null && (h = h.dehydrated, h === null || h.data === "$?" || h.data === "$!")) return o } else if (o.tag === 19 && o.memoizedProps.revealOrder !== void 0) { if (o.flags & 128) return o } else if (o.child !== null) { o.child.return = o, o = o.child; continue } if (o === i) break; for (; o.sibling === null;) { if (o.return === null || o.return === i) return null; o = o.return } o.sibling.return = o.return, o = o.sibling } return null } var S_ = []; function y0() { for (var i = 0; i < S_.length; i++)S_[i]._workInProgressVersionPrimary = null; S_.length = 0 } var Of = Eo.ReactCurrentDispatcher, E_ = Eo.ReactCurrentBatchConfig, Fl = 0, qr = null, _n = null, Pn = null, um = !1, cd = !1, Md = 0, bM = 0; function Zn() { throw Error(st(321)) } function v0(i, o) { if (o === null) return !1; for (var h = 0; h < o.length && h < i.length; h++)if (!_s(i[h], o[h])) return !1; return !0 } function x0(i, o, h, y, w, P) { if (Fl = P, qr = o, o.memoizedState = null, o.updateQueue = null, o.lanes = 0, Of.current = i === null || i.memoizedState === null ? PM : MM, i = h(y, w), cd) { P = 0; do { if (cd = !1, Md = 0, 25 <= P) throw Error(st(301)); P += 1, Pn = _n = null, o.updateQueue = null, Of.current = IM, i = h(y, w) } while (cd) } if (Of.current = cm, o = _n !== null && _n.next !== null, Fl = 0, Pn = _n = qr = null, um = !1, o) throw Error(st(300)); return i } function w0() { var i = Md !== 0; return Md = 0, i } function Ls() { var i = { memoizedState: null, baseState: null, baseQueue: null, queue: null, next: null }; return Pn === null ? qr.memoizedState = Pn = i : Pn = Pn.next = i, Pn } function Ji() { if (_n === null) { var i = qr.alternate; i = i !== null ? i.memoizedState : null } else i = _n.next; var o = Pn === null ? qr.memoizedState : Pn.next; if (o !== null) Pn = o, _n = i; else { if (i === null) throw Error(st(310)); _n = i, i = { memoizedState: _n.memoizedState, baseState: _n.baseState, baseQueue: _n.baseQueue, queue: _n.queue, next: null }, Pn === null ? qr.memoizedState = Pn = i : Pn = Pn.next = i } return Pn } function Id(i, o) { return typeof o == "function" ? o(i) : o } function P_(i) { var o = Ji(), h = o.queue; if (h === null) throw Error(st(311)); h.lastRenderedReducer = i; var y = _n, w = y.baseQueue, P = h.pending; if (P !== null) { if (w !== null) { var b = w.next; w.next = P.next, P.next = b } y.baseQueue = w = P, h.pending = null } if (w !== null) { P = w.next, y = y.baseState; var c = b = null, B = null, $ = P; do { var me = $.lane; if ((Fl & me) === me) B !== null && (B = B.next = { lane: 0, action: $.action, hasEagerState: $.hasEagerState, eagerState: $.eagerState, next: null }), y = $.hasEagerState ? $.eagerState : i(y, $.action); else { var ge = { lane: me, action: $.action, hasEagerState: $.hasEagerState, eagerState: $.eagerState, next: null }; B === null ? (c = B = ge, b = y) : B = B.next = ge, qr.lanes |= me, Bl |= me } $ = $.next } while ($ !== null && $ !== P); B === null ? b = y : B.next = c, _s(y, o.memoizedState) || (mi = !0), o.memoizedState = y, o.baseState = b, o.baseQueue = B, h.lastRenderedState = y } if (i = h.interleaved, i !== null) { w = i; do P = w.lane, qr.lanes |= P, Bl |= P, w = w.next; while (w !== i) } else w === null && (h.lanes = 0); return [o.memoizedState, h.dispatch] } function M_(i) { var o = Ji(), h = o.queue; if (h === null) throw Error(st(311)); h.lastRenderedReducer = i; var y = h.dispatch, w = h.pending, P = o.memoizedState; if (w !== null) { h.pending = null; var b = w = w.next; do P = i(P, b.action), b = b.next; while (b !== w); _s(P, o.memoizedState) || (mi = !0), o.memoizedState = P, o.baseQueue === null && (o.baseState = P), h.lastRenderedState = P } return [P, y] } function qb() { } function Zb(i, o) { var h = qr, y = Ji(), w = o(), P = !_s(y.memoizedState, w); if (P && (y.memoizedState = w, mi = !0), y = y.queue, b0(Xb.bind(null, h, y, i), [i]), y.getSnapshot !== o || P || Pn !== null && Pn.memoizedState.tag & 1) { if (h.flags |= 2048, Cd(9, Hb.bind(null, h, y, w, o), void 0, null), Mn === null) throw Error(st(349)); Fl & 30 || Wb(h, o, w) } return w } function Wb(i, o, h) { i.flags |= 16384, i = { getSnapshot: o, value: h }, o = qr.updateQueue, o === null ? (o = { lastEffect: null, stores: null }, qr.updateQueue = o, o.stores = [i]) : (h = o.stores, h === null ? o.stores = [i] : h.push(i)) } function Hb(i, o, h, y) { o.value = h, o.getSnapshot = y, Yb(o) && Kb(i) } function Xb(i, o, h) { return h(function () { Yb(o) && Kb(i) }) } function Yb(i) { var o = i.getSnapshot; i = i.value; try { var h = o(); return !_s(i, h) } catch { return !0 } } function Kb(i) { var o = bo(i, 1); o !== null && gs(o, i, 1, -1) } function B1(i) { var o = Ls(); return typeof i == "function" && (i = i()), o.memoizedState = o.baseState = i, i = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: Id, lastRenderedState: i }, o.queue = i, i = i.dispatch = EM.bind(null, qr, i), [o.memoizedState, i] } function Cd(i, o, h, y) { return i = { tag: i, create: o, destroy: h, deps: y, next: null }, o = qr.updateQueue, o === null ? (o = { lastEffect: null, stores: null }, qr.updateQueue = o, o.lastEffect = i.next = i) : (h = o.lastEffect, h === null ? o.lastEffect = i.next = i : (y = h.next, h.next = i, i.next = y, o.lastEffect = i)), i } function Qb() { return Ji().memoizedState } function Nf(i, o, h, y) { var w = Ls(); qr.flags |= i, w.memoizedState = Cd(1 | o, h, void 0, y === void 0 ? null : y) } function Pm(i, o, h, y) { var w = Ji(); y = y === void 0 ? null : y; var P = void 0; if (_n !== null) { var b = _n.memoizedState; if (P = b.destroy, y !== null && v0(y, b.deps)) { w.memoizedState = Cd(o, h, P, y); return } } qr.flags |= i, w.memoizedState = Cd(1 | o, h, P, y) } function O1(i, o) { return Nf(8390656, 8, i, o) } function b0(i, o) { return Pm(2048, 8, i, o) } function Jb(i, o) { return Pm(4, 2, i, o) } function e2(i, o) { return Pm(4, 4, i, o) } function t2(i, o) { if (typeof o == "function") return i = i(), o(i), function () { o(null) }; if (o != null) return i = i(), o.current = i, function () { o.current = null } } function r2(i, o, h) { return h = h != null ? h.concat([i]) : null, Pm(4, 4, t2.bind(null, o, i), h) } function T0() { } function n2(i, o) { var h = Ji(); o = o === void 0 ? null : o; var y = h.memoizedState; return y !== null && o !== null && v0(o, y[1]) ? y[0] : (h.memoizedState = [i, o], i) } function i2(i, o) { var h = Ji(); o = o === void 0 ? null : o; var y = h.memoizedState; return y !== null && o !== null && v0(o, y[1]) ? y[0] : (i = i(), h.memoizedState = [i, o], i) } function s2(i, o, h) { return Fl & 21 ? (_s(h, o) || (h = cb(), qr.lanes |= h, Bl |= h, i.baseState = !0), o) : (i.baseState && (i.baseState = !1, mi = !0), i.memoizedState = h) } function TM(i, o) { var h = dr; dr = h !== 0 && 4 > h ? h : 4, i(!0); var y = E_.transition; E_.transition = {}; try { i(!1), o() } finally { dr = h, E_.transition = y } } function o2() { return Ji().memoizedState } function SM(i, o, h) { var y = wa(i); if (h = { lane: y, action: h, hasEagerState: !1, eagerState: null, next: null }, a2(i)) l2(o, h); else if (h = Ub(i, o, h, y), h !== null) { var w = ni(); gs(h, i, y, w), u2(h, o, y) } } function EM(i, o, h) { var y = wa(i), w = { lane: y, action: h, hasEagerState: !1, eagerState: null, next: null }; if (a2(i)) l2(o, w); else { var P = i.alternate; if (i.lanes === 0 && (P === null || P.lanes === 0) && (P = o.lastRenderedReducer, P !== null)) try { var b = o.lastRenderedState, c = P(b, h); if (w.hasEagerState = !0, w.eagerState = c, _s(c, b)) { var B = o.interleaved; B === null ? (w.next = w, f0(o)) : (w.next = B.next, B.next = w), o.interleaved = w; return } } catch { } finally { } h = Ub(i, o, w, y), h !== null && (w = ni(), gs(h, i, y, w), u2(h, o, y)) } } function a2(i) { var o = i.alternate; return i === qr || o !== null && o === qr } function l2(i, o) { cd = um = !0; var h = i.pending; h === null ? o.next = o : (o.next = h.next, h.next = o), i.pending = o } function u2(i, o, h) { if (h & 4194240) { var y = o.lanes; y &= i.pendingLanes, h |= y, o.lanes = h, e0(i, h) } } var cm = { readContext: Qi, useCallback: Zn, useContext: Zn, useEffect: Zn, useImperativeHandle: Zn, useInsertionEffect: Zn, useLayoutEffect: Zn, useMemo: Zn, useReducer: Zn, useRef: Zn, useState: Zn, useDebugValue: Zn, useDeferredValue: Zn, useTransition: Zn, useMutableSource: Zn, useSyncExternalStore: Zn, useId: Zn, unstable_isNewReconciler: !1 }, PM = { readContext: Qi, useCallback: function (i, o) { return Ls().memoizedState = [i, o === void 0 ? null : o], i }, useContext: Qi, useEffect: O1, useImperativeHandle: function (i, o, h) { return h = h != null ? h.concat([i]) : null, Nf(4194308, 4, t2.bind(null, o, i), h) }, useLayoutEffect: function (i, o) { return Nf(4194308, 4, i, o) }, useInsertionEffect: function (i, o) { return Nf(4, 2, i, o) }, useMemo: function (i, o) { var h = Ls(); return o = o === void 0 ? null : o, i = i(), h.memoizedState = [i, o], i }, useReducer: function (i, o, h) { var y = Ls(); return o = h !== void 0 ? h(o) : o, y.memoizedState = y.baseState = o, i = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: i, lastRenderedState: o }, y.queue = i, i = i.dispatch = SM.bind(null, qr, i), [y.memoizedState, i] }, useRef: function (i) { var o = Ls(); return i = { current: i }, o.memoizedState = i }, useState: B1, useDebugValue: T0, useDeferredValue: function (i) { return Ls().memoizedState = i }, useTransition: function () { var i = B1(!1), o = i[0]; return i = TM.bind(null, i[1]), Ls().memoizedState = i, [o, i] }, useMutableSource: function () { }, useSyncExternalStore: function (i, o, h) { var y = qr, w = Ls(); if (jr) { if (h === void 0) throw Error(st(407)); h = h() } else { if (h = o(), Mn === null) throw Error(st(349)); Fl & 30 || Wb(y, o, h) } w.memoizedState = h; var P = { value: h, getSnapshot: o }; return w.queue = P, O1(Xb.bind(null, y, P, i), [i]), y.flags |= 2048, Cd(9, Hb.bind(null, y, P, h, o), void 0, null), h }, useId: function () { var i = Ls(), o = Mn.identifierPrefix; if (jr) { var h = yo, y = _o; h = (y & ~(1 << 32 - ms(y) - 1)).toString(32) + h, o = ":" + o + "R" + h, h = Md++, 0 < h && (o += "H" + h.toString(32)), o += ":" } else h = bM++, o = ":" + o + "r" + h.toString(32) + ":"; return i.memoizedState = o }, unstable_isNewReconciler: !1 }, MM = { readContext: Qi, useCallback: n2, useContext: Qi, useEffect: b0, useImperativeHandle: r2, useInsertionEffect: Jb, useLayoutEffect: e2, useMemo: i2, useReducer: P_, useRef: Qb, useState: function () { return P_(Id) }, useDebugValue: T0, useDeferredValue: function (i) { var o = Ji(); return s2(o, _n.memoizedState, i) }, useTransition: function () { var i = P_(Id)[0], o = Ji().memoizedState; return [i, o] }, useMutableSource: qb, useSyncExternalStore: Zb, useId: o2, unstable_isNewReconciler: !1 }, IM = { readContext: Qi, useCallback: n2, useContext: Qi, useEffect: b0, useImperativeHandle: r2, useInsertionEffect: Jb, useLayoutEffect: e2, useMemo: i2, useReducer: M_, useRef: Qb, useState: function () { return M_(Id) }, useDebugValue: T0, useDeferredValue: function (i) { var o = Ji(); return _n === null ? o.memoizedState = i : s2(o, _n.memoizedState, i) }, useTransition: function () { var i = M_(Id)[0], o = Ji().memoizedState; return [i, o] }, useMutableSource: qb, useSyncExternalStore: Zb, useId: o2, unstable_isNewReconciler: !1 }; function hs(i, o) { if (i && i.defaultProps) { o = Zr({}, o), i = i.defaultProps; for (var h in i) o[h] === void 0 && (o[h] = i[h]); return o } return o } function my(i, o, h, y) { o = i.memoizedState, h = h(y, o), h = h == null ? o : Zr({}, o, h), i.memoizedState = h, i.lanes === 0 && (i.updateQueue.baseState = h) } var Mm = { isMounted: function (i) { return (i = i._reactInternals) ? jl(i) === i : !1 }, enqueueSetState: function (i, o, h) { i = i._reactInternals; var y = ni(), w = wa(i), P = vo(y, w); P.payload = o, h != null && (P.callback = h), o = va(i, P, w), o !== null && (gs(o, i, w, y), Bf(o, i, w)) }, enqueueReplaceState: function (i, o, h) { i = i._reactInternals; var y = ni(), w = wa(i), P = vo(y, w); P.tag = 1, P.payload = o, h != null && (P.callback = h), o = va(i, P, w), o !== null && (gs(o, i, w, y), Bf(o, i, w)) }, enqueueForceUpdate: function (i, o) { i = i._reactInternals; var h = ni(), y = wa(i), w = vo(h, y); w.tag = 2, o != null && (w.callback = o), o = va(i, w, y), o !== null && (gs(o, i, y, h), Bf(o, i, y)) } }; function N1(i, o, h, y, w, P, b) { return i = i.stateNode, typeof i.shouldComponentUpdate == "function" ? i.shouldComponentUpdate(y, P, b) : o.prototype && o.prototype.isPureReactComponent ? !wd(h, y) || !wd(w, P) : !0 } function c2(i, o, h) { var y = !1, w = Sa, P = o.contextType; return typeof P == "object" && P !== null ? P = Qi(P) : (w = _i(o) ? Rl : Xn.current, y = o.contextTypes, P = (y = y != null) ? mc(i, w) : Sa), o = new o(h, P), i.memoizedState = o.state !== null && o.state !== void 0 ? o.state : null, o.updater = Mm, i.stateNode = o, o._reactInternals = i, y && (i = i.stateNode, i.__reactInternalMemoizedUnmaskedChildContext = w, i.__reactInternalMemoizedMaskedChildContext = P), o } function j1(i, o, h, y) { i = o.state, typeof o.componentWillReceiveProps == "function" && o.componentWillReceiveProps(h, y), typeof o.UNSAFE_componentWillReceiveProps == "function" && o.UNSAFE_componentWillReceiveProps(h, y), o.state !== i && Mm.enqueueReplaceState(o, o.state, null) } function gy(i, o, h, y) { var w = i.stateNode; w.props = h, w.state = i.memoizedState, w.refs = {}, m0(i); var P = o.contextType; typeof P == "object" && P !== null ? w.context = Qi(P) : (P = _i(o) ? Rl : Xn.current, w.context = mc(i, P)), w.state = i.memoizedState, P = o.getDerivedStateFromProps, typeof P == "function" && (my(i, o, P, h), w.state = i.memoizedState), typeof o.getDerivedStateFromProps == "function" || typeof w.getSnapshotBeforeUpdate == "function" || typeof w.UNSAFE_componentWillMount != "function" && typeof w.componentWillMount != "function" || (o = w.state, typeof w.componentWillMount == "function" && w.componentWillMount(), typeof w.UNSAFE_componentWillMount == "function" && w.UNSAFE_componentWillMount(), o !== w.state && Mm.enqueueReplaceState(w, w.state, null), am(i, h, w, y), w.state = i.memoizedState), typeof w.componentDidMount == "function" && (i.flags |= 4194308) } function vc(i, o) {
    try { var h = "", y = o; do h += rP(y), y = y.return; while (y); var w = h } catch (P) {
        w = `
Error generating stack: `+ P.message + `
`+ P.stack
    } return { value: i, source: o, stack: w, digest: null }
} function I_(i, o, h) { return { value: i, source: null, stack: h ?? null, digest: o ?? null } } function _y(i, o) { try { console.error(o.value) } catch (h) { setTimeout(function () { throw h }) } } var CM = typeof WeakMap == "function" ? WeakMap : Map; function h2(i, o, h) { h = vo(-1, h), h.tag = 3, h.payload = { element: null }; var y = o.value; return h.callback = function () { dm || (dm = !0, My = y), _y(i, o) }, h } function d2(i, o, h) { h = vo(-1, h), h.tag = 3; var y = i.type.getDerivedStateFromError; if (typeof y == "function") { var w = o.value; h.payload = function () { return y(w) }, h.callback = function () { _y(i, o) } } var P = i.stateNode; return P !== null && typeof P.componentDidCatch == "function" && (h.callback = function () { _y(i, o), typeof y != "function" && (xa === null ? xa = new Set([this]) : xa.add(this)); var b = o.stack; this.componentDidCatch(o.value, { componentStack: b !== null ? b : "" }) }), h } function V1(i, o, h) { var y = i.pingCache; if (y === null) { y = i.pingCache = new CM; var w = new Set; y.set(o, w) } else w = y.get(o), w === void 0 && (w = new Set, y.set(o, w)); w.has(h) || (w.add(h), i = GM.bind(null, i, o, h), o.then(i, i)) } function U1(i) { do { var o; if ((o = i.tag === 13) && (o = i.memoizedState, o = o !== null ? o.dehydrated !== null : !0), o) return i; i = i.return } while (i !== null); return null } function G1(i, o, h, y, w) { return i.mode & 1 ? (i.flags |= 65536, i.lanes = w, i) : (i === o ? i.flags |= 65536 : (i.flags |= 128, h.flags |= 131072, h.flags &= -52805, h.tag === 1 && (h.alternate === null ? h.tag = 17 : (o = vo(-1, 1), o.tag = 2, va(h, o, 1))), h.lanes |= 1), i) } var AM = Eo.ReactCurrentOwner, mi = !1; function ri(i, o, h, y) { o.child = i === null ? Vb(o, null, h, y) : _c(o, i.child, h, y) } function $1(i, o, h, y, w) { h = h.render; var P = o.ref; return dc(o, w), y = x0(i, o, h, y, P, w), h = w0(), i !== null && !mi ? (o.updateQueue = i.updateQueue, o.flags &= -2053, i.lanes &= ~w, To(i, o, w)) : (jr && h && l0(o), o.flags |= 1, ri(i, o, y, w), o.child) } function q1(i, o, h, y, w) { if (i === null) { var P = h.type; return typeof P == "function" && !k0(P) && P.defaultProps === void 0 && h.compare === null && h.defaultProps === void 0 ? (o.tag = 15, o.type = P, p2(i, o, P, y, w)) : (i = Gf(h.type, null, y, o, o.mode, w), i.ref = o.ref, i.return = o, o.child = i) } if (P = i.child, !(i.lanes & w)) { var b = P.memoizedProps; if (h = h.compare, h = h !== null ? h : wd, h(b, y) && i.ref === o.ref) return To(i, o, w) } return o.flags |= 1, i = ba(P, y), i.ref = o.ref, i.return = o, o.child = i } function p2(i, o, h, y, w) { if (i !== null) { var P = i.memoizedProps; if (wd(P, y) && i.ref === o.ref) if (mi = !1, o.pendingProps = y = P, (i.lanes & w) !== 0) i.flags & 131072 && (mi = !0); else return o.lanes = i.lanes, To(i, o, w) } return yy(i, o, h, y, w) } function f2(i, o, h) { var y = o.pendingProps, w = y.children, P = i !== null ? i.memoizedState : null; if (y.mode === "hidden") if (!(o.mode & 1)) o.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }, Er(ac, zi), zi |= h; else { if (!(h & 1073741824)) return i = P !== null ? P.baseLanes | h : h, o.lanes = o.childLanes = 1073741824, o.memoizedState = { baseLanes: i, cachePool: null, transitions: null }, o.updateQueue = null, Er(ac, zi), zi |= i, null; o.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }, y = P !== null ? P.baseLanes : h, Er(ac, zi), zi |= y } else P !== null ? (y = P.baseLanes | h, o.memoizedState = null) : y = h, Er(ac, zi), zi |= y; return ri(i, o, w, h), o.child } function m2(i, o) { var h = o.ref; (i === null && h !== null || i !== null && i.ref !== h) && (o.flags |= 512, o.flags |= 2097152) } function yy(i, o, h, y, w) { var P = _i(h) ? Rl : Xn.current; return P = mc(o, P), dc(o, w), h = x0(i, o, h, y, P, w), y = w0(), i !== null && !mi ? (o.updateQueue = i.updateQueue, o.flags &= -2053, i.lanes &= ~w, To(i, o, w)) : (jr && y && l0(o), o.flags |= 1, ri(i, o, h, w), o.child) } function Z1(i, o, h, y, w) { if (_i(h)) { var P = !0; rm(o) } else P = !1; if (dc(o, w), o.stateNode === null) jf(i, o), c2(o, h, y), gy(o, h, y, w), y = !0; else if (i === null) { var b = o.stateNode, c = o.memoizedProps; b.props = c; var B = b.context, $ = h.contextType; typeof $ == "object" && $ !== null ? $ = Qi($) : ($ = _i(h) ? Rl : Xn.current, $ = mc(o, $)); var me = h.getDerivedStateFromProps, ge = typeof me == "function" || typeof b.getSnapshotBeforeUpdate == "function"; ge || typeof b.UNSAFE_componentWillReceiveProps != "function" && typeof b.componentWillReceiveProps != "function" || (c !== y || B !== $) && j1(o, b, y, $), ca = !1; var we = o.memoizedState; b.state = we, am(o, y, b, w), B = o.memoizedState, c !== y || we !== B || gi.current || ca ? (typeof me == "function" && (my(o, h, me, y), B = o.memoizedState), (c = ca || N1(o, h, c, y, we, B, $)) ? (ge || typeof b.UNSAFE_componentWillMount != "function" && typeof b.componentWillMount != "function" || (typeof b.componentWillMount == "function" && b.componentWillMount(), typeof b.UNSAFE_componentWillMount == "function" && b.UNSAFE_componentWillMount()), typeof b.componentDidMount == "function" && (o.flags |= 4194308)) : (typeof b.componentDidMount == "function" && (o.flags |= 4194308), o.memoizedProps = y, o.memoizedState = B), b.props = y, b.state = B, b.context = $, y = c) : (typeof b.componentDidMount == "function" && (o.flags |= 4194308), y = !1) } else { b = o.stateNode, Gb(i, o), c = o.memoizedProps, $ = o.type === o.elementType ? c : hs(o.type, c), b.props = $, ge = o.pendingProps, we = b.context, B = h.contextType, typeof B == "object" && B !== null ? B = Qi(B) : (B = _i(h) ? Rl : Xn.current, B = mc(o, B)); var Ge = h.getDerivedStateFromProps; (me = typeof Ge == "function" || typeof b.getSnapshotBeforeUpdate == "function") || typeof b.UNSAFE_componentWillReceiveProps != "function" && typeof b.componentWillReceiveProps != "function" || (c !== ge || we !== B) && j1(o, b, y, B), ca = !1, we = o.memoizedState, b.state = we, am(o, y, b, w); var Ye = o.memoizedState; c !== ge || we !== Ye || gi.current || ca ? (typeof Ge == "function" && (my(o, h, Ge, y), Ye = o.memoizedState), ($ = ca || N1(o, h, $, y, we, Ye, B) || !1) ? (me || typeof b.UNSAFE_componentWillUpdate != "function" && typeof b.componentWillUpdate != "function" || (typeof b.componentWillUpdate == "function" && b.componentWillUpdate(y, Ye, B), typeof b.UNSAFE_componentWillUpdate == "function" && b.UNSAFE_componentWillUpdate(y, Ye, B)), typeof b.componentDidUpdate == "function" && (o.flags |= 4), typeof b.getSnapshotBeforeUpdate == "function" && (o.flags |= 1024)) : (typeof b.componentDidUpdate != "function" || c === i.memoizedProps && we === i.memoizedState || (o.flags |= 4), typeof b.getSnapshotBeforeUpdate != "function" || c === i.memoizedProps && we === i.memoizedState || (o.flags |= 1024), o.memoizedProps = y, o.memoizedState = Ye), b.props = y, b.state = Ye, b.context = B, y = $) : (typeof b.componentDidUpdate != "function" || c === i.memoizedProps && we === i.memoizedState || (o.flags |= 4), typeof b.getSnapshotBeforeUpdate != "function" || c === i.memoizedProps && we === i.memoizedState || (o.flags |= 1024), y = !1) } return vy(i, o, h, y, P, w) } function vy(i, o, h, y, w, P) { m2(i, o); var b = (o.flags & 128) !== 0; if (!y && !b) return w && k1(o, h, !1), To(i, o, P); y = o.stateNode, AM.current = o; var c = b && typeof h.getDerivedStateFromError != "function" ? null : y.render(); return o.flags |= 1, i !== null && b ? (o.child = _c(o, i.child, null, P), o.child = _c(o, null, c, P)) : ri(i, o, c, P), o.memoizedState = y.state, w && k1(o, h, !0), o.child } function g2(i) { var o = i.stateNode; o.pendingContext ? A1(i, o.pendingContext, o.pendingContext !== o.context) : o.context && A1(i, o.context, !1), g0(i, o.containerInfo) } function W1(i, o, h, y, w) { return gc(), c0(w), o.flags |= 256, ri(i, o, h, y), o.child } var xy = { dehydrated: null, treeContext: null, retryLane: 0 }; function wy(i) { return { baseLanes: i, cachePool: null, transitions: null } } function _2(i, o, h) { var y = o.pendingProps, w = $r.current, P = !1, b = (o.flags & 128) !== 0, c; if ((c = b) || (c = i !== null && i.memoizedState === null ? !1 : (w & 2) !== 0), c ? (P = !0, o.flags &= -129) : (i === null || i.memoizedState !== null) && (w |= 1), Er($r, w & 1), i === null) return py(o), i = o.memoizedState, i !== null && (i = i.dehydrated, i !== null) ? (o.mode & 1 ? i.data === "$!" ? o.lanes = 8 : o.lanes = 1073741824 : o.lanes = 1, null) : (b = y.children, i = y.fallback, P ? (y = o.mode, P = o.child, b = { mode: "hidden", children: b }, !(y & 1) && P !== null ? (P.childLanes = 0, P.pendingProps = b) : P = Am(b, y, 0, null), i = Dl(i, y, h, null), P.return = o, i.return = o, P.sibling = i, o.child = P, o.child.memoizedState = wy(h), o.memoizedState = xy, i) : S0(o, b)); if (w = i.memoizedState, w !== null && (c = w.dehydrated, c !== null)) return kM(i, o, b, y, c, w, h); if (P) { P = y.fallback, b = o.mode, w = i.child, c = w.sibling; var B = { mode: "hidden", children: y.children }; return !(b & 1) && o.child !== w ? (y = o.child, y.childLanes = 0, y.pendingProps = B, o.deletions = null) : (y = ba(w, B), y.subtreeFlags = w.subtreeFlags & 14680064), c !== null ? P = ba(c, P) : (P = Dl(P, b, h, null), P.flags |= 2), P.return = o, y.return = o, y.sibling = P, o.child = y, y = P, P = o.child, b = i.child.memoizedState, b = b === null ? wy(h) : { baseLanes: b.baseLanes | h, cachePool: null, transitions: b.transitions }, P.memoizedState = b, P.childLanes = i.childLanes & ~h, o.memoizedState = xy, y } return P = i.child, i = P.sibling, y = ba(P, { mode: "visible", children: y.children }), !(o.mode & 1) && (y.lanes = h), y.return = o, y.sibling = null, i !== null && (h = o.deletions, h === null ? (o.deletions = [i], o.flags |= 16) : h.push(i)), o.child = y, o.memoizedState = null, y } function S0(i, o) { return o = Am({ mode: "visible", children: o }, i.mode, 0, null), o.return = i, i.child = o } function Pf(i, o, h, y) { return y !== null && c0(y), _c(o, i.child, null, h), i = S0(o, o.pendingProps.children), i.flags |= 2, o.memoizedState = null, i } function kM(i, o, h, y, w, P, b) { if (h) return o.flags & 256 ? (o.flags &= -257, y = I_(Error(st(422))), Pf(i, o, b, y)) : o.memoizedState !== null ? (o.child = i.child, o.flags |= 128, null) : (P = y.fallback, w = o.mode, y = Am({ mode: "visible", children: y.children }, w, 0, null), P = Dl(P, w, b, null), P.flags |= 2, y.return = o, P.return = o, y.sibling = P, o.child = y, o.mode & 1 && _c(o, i.child, null, b), o.child.memoizedState = wy(b), o.memoizedState = xy, P); if (!(o.mode & 1)) return Pf(i, o, b, null); if (w.data === "$!") { if (y = w.nextSibling && w.nextSibling.dataset, y) var c = y.dgst; return y = c, P = Error(st(419)), y = I_(P, y, void 0), Pf(i, o, b, y) } if (c = (b & i.childLanes) !== 0, mi || c) { if (y = Mn, y !== null) { switch (b & -b) { case 4: w = 2; break; case 16: w = 8; break; case 64: case 128: case 256: case 512: case 1024: case 2048: case 4096: case 8192: case 16384: case 32768: case 65536: case 131072: case 262144: case 524288: case 1048576: case 2097152: case 4194304: case 8388608: case 16777216: case 33554432: case 67108864: w = 32; break; case 536870912: w = 268435456; break; default: w = 0 }w = w & (y.suspendedLanes | b) ? 0 : w, w !== 0 && w !== P.retryLane && (P.retryLane = w, bo(i, w), gs(y, i, w, -1)) } return A0(), y = I_(Error(st(421))), Pf(i, o, b, y) } return w.data === "$?" ? (o.flags |= 128, o.child = i.child, o = $M.bind(null, i), w._reactRetry = o, null) : (i = P.treeContext, Ri = ya(w.nextSibling), Li = o, jr = !0, ps = null, i !== null && (Hi[Xi++] = _o, Hi[Xi++] = yo, Hi[Xi++] = Ll, _o = i.id, yo = i.overflow, Ll = o), o = S0(o, y.children), o.flags |= 4096, o) } function H1(i, o, h) { i.lanes |= o; var y = i.alternate; y !== null && (y.lanes |= o), fy(i.return, o, h) } function C_(i, o, h, y, w) { var P = i.memoizedState; P === null ? i.memoizedState = { isBackwards: o, rendering: null, renderingStartTime: 0, last: y, tail: h, tailMode: w } : (P.isBackwards = o, P.rendering = null, P.renderingStartTime = 0, P.last = y, P.tail = h, P.tailMode = w) } function y2(i, o, h) { var y = o.pendingProps, w = y.revealOrder, P = y.tail; if (ri(i, o, y.children, h), y = $r.current, y & 2) y = y & 1 | 2, o.flags |= 128; else { if (i !== null && i.flags & 128) e: for (i = o.child; i !== null;) { if (i.tag === 13) i.memoizedState !== null && H1(i, h, o); else if (i.tag === 19) H1(i, h, o); else if (i.child !== null) { i.child.return = i, i = i.child; continue } if (i === o) break e; for (; i.sibling === null;) { if (i.return === null || i.return === o) break e; i = i.return } i.sibling.return = i.return, i = i.sibling } y &= 1 } if (Er($r, y), !(o.mode & 1)) o.memoizedState = null; else switch (w) { case "forwards": for (h = o.child, w = null; h !== null;)i = h.alternate, i !== null && lm(i) === null && (w = h), h = h.sibling; h = w, h === null ? (w = o.child, o.child = null) : (w = h.sibling, h.sibling = null), C_(o, !1, w, h, P); break; case "backwards": for (h = null, w = o.child, o.child = null; w !== null;) { if (i = w.alternate, i !== null && lm(i) === null) { o.child = w; break } i = w.sibling, w.sibling = h, h = w, w = i } C_(o, !0, h, null, P); break; case "together": C_(o, !1, null, null, void 0); break; default: o.memoizedState = null }return o.child } function jf(i, o) { !(o.mode & 1) && i !== null && (i.alternate = null, o.alternate = null, o.flags |= 2) } function To(i, o, h) { if (i !== null && (o.dependencies = i.dependencies), Bl |= o.lanes, !(h & o.childLanes)) return null; if (i !== null && o.child !== i.child) throw Error(st(153)); if (o.child !== null) { for (i = o.child, h = ba(i, i.pendingProps), o.child = h, h.return = o; i.sibling !== null;)i = i.sibling, h = h.sibling = ba(i, i.pendingProps), h.return = o; h.sibling = null } return o.child } function DM(i, o, h) { switch (o.tag) { case 3: g2(o), gc(); break; case 5: $b(o); break; case 1: _i(o.type) && rm(o); break; case 4: g0(o, o.stateNode.containerInfo); break; case 10: var y = o.type._context, w = o.memoizedProps.value; Er(sm, y._currentValue), y._currentValue = w; break; case 13: if (y = o.memoizedState, y !== null) return y.dehydrated !== null ? (Er($r, $r.current & 1), o.flags |= 128, null) : h & o.child.childLanes ? _2(i, o, h) : (Er($r, $r.current & 1), i = To(i, o, h), i !== null ? i.sibling : null); Er($r, $r.current & 1); break; case 19: if (y = (h & o.childLanes) !== 0, i.flags & 128) { if (y) return y2(i, o, h); o.flags |= 128 } if (w = o.memoizedState, w !== null && (w.rendering = null, w.tail = null, w.lastEffect = null), Er($r, $r.current), y) break; return null; case 22: case 23: return o.lanes = 0, f2(i, o, h) }return To(i, o, h) } var v2, by, x2, w2; v2 = function (i, o) { for (var h = o.child; h !== null;) { if (h.tag === 5 || h.tag === 6) i.appendChild(h.stateNode); else if (h.tag !== 4 && h.child !== null) { h.child.return = h, h = h.child; continue } if (h === o) break; for (; h.sibling === null;) { if (h.return === null || h.return === o) return; h = h.return } h.sibling.return = h.return, h = h.sibling } }; by = function () { }; x2 = function (i, o, h, y) { var w = i.memoizedProps; if (w !== y) { i = o.stateNode, Cl(js.current); var P = null; switch (h) { case "input": w = $_(i, w), y = $_(i, y), P = []; break; case "select": w = Zr({}, w, { value: void 0 }), y = Zr({}, y, { value: void 0 }), P = []; break; case "textarea": w = W_(i, w), y = W_(i, y), P = []; break; default: typeof w.onClick != "function" && typeof y.onClick == "function" && (i.onclick = em) }X_(h, y); var b; h = null; for ($ in w) if (!y.hasOwnProperty($) && w.hasOwnProperty($) && w[$] != null) if ($ === "style") { var c = w[$]; for (b in c) c.hasOwnProperty(b) && (h || (h = {}), h[b] = "") } else $ !== "dangerouslySetInnerHTML" && $ !== "children" && $ !== "suppressContentEditableWarning" && $ !== "suppressHydrationWarning" && $ !== "autoFocus" && (fd.hasOwnProperty($) ? P || (P = []) : (P = P || []).push($, null)); for ($ in y) { var B = y[$]; if (c = w != null ? w[$] : void 0, y.hasOwnProperty($) && B !== c && (B != null || c != null)) if ($ === "style") if (c) { for (b in c) !c.hasOwnProperty(b) || B && B.hasOwnProperty(b) || (h || (h = {}), h[b] = ""); for (b in B) B.hasOwnProperty(b) && c[b] !== B[b] && (h || (h = {}), h[b] = B[b]) } else h || (P || (P = []), P.push($, h)), h = B; else $ === "dangerouslySetInnerHTML" ? (B = B ? B.__html : void 0, c = c ? c.__html : void 0, B != null && c !== B && (P = P || []).push($, B)) : $ === "children" ? typeof B != "string" && typeof B != "number" || (P = P || []).push($, "" + B) : $ !== "suppressContentEditableWarning" && $ !== "suppressHydrationWarning" && (fd.hasOwnProperty($) ? (B != null && $ === "onScroll" && zr("scroll", i), P || c === B || (P = [])) : (P = P || []).push($, B)) } h && (P = P || []).push("style", h); var $ = P; (o.updateQueue = $) && (o.flags |= 4) } }; w2 = function (i, o, h, y) { h !== y && (o.flags |= 4) }; function Wh(i, o) { if (!jr) switch (i.tailMode) { case "hidden": o = i.tail; for (var h = null; o !== null;)o.alternate !== null && (h = o), o = o.sibling; h === null ? i.tail = null : h.sibling = null; break; case "collapsed": h = i.tail; for (var y = null; h !== null;)h.alternate !== null && (y = h), h = h.sibling; y === null ? o || i.tail === null ? i.tail = null : i.tail.sibling = null : y.sibling = null } } function Wn(i) { var o = i.alternate !== null && i.alternate.child === i.child, h = 0, y = 0; if (o) for (var w = i.child; w !== null;)h |= w.lanes | w.childLanes, y |= w.subtreeFlags & 14680064, y |= w.flags & 14680064, w.return = i, w = w.sibling; else for (w = i.child; w !== null;)h |= w.lanes | w.childLanes, y |= w.subtreeFlags, y |= w.flags, w.return = i, w = w.sibling; return i.subtreeFlags |= y, i.childLanes = h, o } function zM(i, o, h) { var y = o.pendingProps; switch (u0(o), o.tag) { case 2: case 16: case 15: case 0: case 11: case 7: case 8: case 12: case 9: case 14: return Wn(o), null; case 1: return _i(o.type) && tm(), Wn(o), null; case 3: return y = o.stateNode, yc(), Rr(gi), Rr(Xn), y0(), y.pendingContext && (y.context = y.pendingContext, y.pendingContext = null), (i === null || i.child === null) && (Sf(o) ? o.flags |= 4 : i === null || i.memoizedState.isDehydrated && !(o.flags & 256) || (o.flags |= 1024, ps !== null && (Ay(ps), ps = null))), by(i, o), Wn(o), null; case 5: _0(o); var w = Cl(Pd.current); if (h = o.type, i !== null && o.stateNode != null) x2(i, o, h, y, w), i.ref !== o.ref && (o.flags |= 512, o.flags |= 2097152); else { if (!y) { if (o.stateNode === null) throw Error(st(166)); return Wn(o), null } if (i = Cl(js.current), Sf(o)) { y = o.stateNode, h = o.type; var P = o.memoizedProps; switch (y[Bs] = o, y[Sd] = P, i = (o.mode & 1) !== 0, h) { case "dialog": zr("cancel", y), zr("close", y); break; case "iframe": case "object": case "embed": zr("load", y); break; case "video": case "audio": for (w = 0; w < td.length; w++)zr(td[w], y); break; case "source": zr("error", y); break; case "img": case "image": case "link": zr("error", y), zr("load", y); break; case "details": zr("toggle", y); break; case "input": n1(y, P), zr("invalid", y); break; case "select": y._wrapperState = { wasMultiple: !!P.multiple }, zr("invalid", y); break; case "textarea": s1(y, P), zr("invalid", y) }X_(h, P), w = null; for (var b in P) if (P.hasOwnProperty(b)) { var c = P[b]; b === "children" ? typeof c == "string" ? y.textContent !== c && (P.suppressHydrationWarning !== !0 && Tf(y.textContent, c, i), w = ["children", c]) : typeof c == "number" && y.textContent !== "" + c && (P.suppressHydrationWarning !== !0 && Tf(y.textContent, c, i), w = ["children", "" + c]) : fd.hasOwnProperty(b) && c != null && b === "onScroll" && zr("scroll", y) } switch (h) { case "input": mf(y), i1(y, P, !0); break; case "textarea": mf(y), o1(y); break; case "select": case "option": break; default: typeof P.onClick == "function" && (y.onclick = em) }y = w, o.updateQueue = y, y !== null && (o.flags |= 4) } else { b = w.nodeType === 9 ? w : w.ownerDocument, i === "http://www.w3.org/1999/xhtml" && (i = Xw(h)), i === "http://www.w3.org/1999/xhtml" ? h === "script" ? (i = b.createElement("div"), i.innerHTML = "<script><\/script>", i = i.removeChild(i.firstChild)) : typeof y.is == "string" ? i = b.createElement(h, { is: y.is }) : (i = b.createElement(h), h === "select" && (b = i, y.multiple ? b.multiple = !0 : y.size && (b.size = y.size))) : i = b.createElementNS(i, h), i[Bs] = o, i[Sd] = y, v2(i, o, !1, !1), o.stateNode = i; e: { switch (b = Y_(h, y), h) { case "dialog": zr("cancel", i), zr("close", i), w = y; break; case "iframe": case "object": case "embed": zr("load", i), w = y; break; case "video": case "audio": for (w = 0; w < td.length; w++)zr(td[w], i); w = y; break; case "source": zr("error", i), w = y; break; case "img": case "image": case "link": zr("error", i), zr("load", i), w = y; break; case "details": zr("toggle", i), w = y; break; case "input": n1(i, y), w = $_(i, y), zr("invalid", i); break; case "option": w = y; break; case "select": i._wrapperState = { wasMultiple: !!y.multiple }, w = Zr({}, y, { value: void 0 }), zr("invalid", i); break; case "textarea": s1(i, y), w = W_(i, y), zr("invalid", i); break; default: w = y }X_(h, w), c = w; for (P in c) if (c.hasOwnProperty(P)) { var B = c[P]; P === "style" ? Qw(i, B) : P === "dangerouslySetInnerHTML" ? (B = B ? B.__html : void 0, B != null && Yw(i, B)) : P === "children" ? typeof B == "string" ? (h !== "textarea" || B !== "") && md(i, B) : typeof B == "number" && md(i, "" + B) : P !== "suppressContentEditableWarning" && P !== "suppressHydrationWarning" && P !== "autoFocus" && (fd.hasOwnProperty(P) ? B != null && P === "onScroll" && zr("scroll", i) : B != null && Hy(i, P, B, b)) } switch (h) { case "input": mf(i), i1(i, y, !1); break; case "textarea": mf(i), o1(i); break; case "option": y.value != null && i.setAttribute("value", "" + Ta(y.value)); break; case "select": i.multiple = !!y.multiple, P = y.value, P != null ? lc(i, !!y.multiple, P, !1) : y.defaultValue != null && lc(i, !!y.multiple, y.defaultValue, !0); break; default: typeof w.onClick == "function" && (i.onclick = em) }switch (h) { case "button": case "input": case "select": case "textarea": y = !!y.autoFocus; break e; case "img": y = !0; break e; default: y = !1 } } y && (o.flags |= 4) } o.ref !== null && (o.flags |= 512, o.flags |= 2097152) } return Wn(o), null; case 6: if (i && o.stateNode != null) w2(i, o, i.memoizedProps, y); else { if (typeof y != "string" && o.stateNode === null) throw Error(st(166)); if (h = Cl(Pd.current), Cl(js.current), Sf(o)) { if (y = o.stateNode, h = o.memoizedProps, y[Bs] = o, (P = y.nodeValue !== h) && (i = Li, i !== null)) switch (i.tag) { case 3: Tf(y.nodeValue, h, (i.mode & 1) !== 0); break; case 5: i.memoizedProps.suppressHydrationWarning !== !0 && Tf(y.nodeValue, h, (i.mode & 1) !== 0) }P && (o.flags |= 4) } else y = (h.nodeType === 9 ? h : h.ownerDocument).createTextNode(y), y[Bs] = o, o.stateNode = y } return Wn(o), null; case 13: if (Rr($r), y = o.memoizedState, i === null || i.memoizedState !== null && i.memoizedState.dehydrated !== null) { if (jr && Ri !== null && o.mode & 1 && !(o.flags & 128)) Nb(), gc(), o.flags |= 98560, P = !1; else if (P = Sf(o), y !== null && y.dehydrated !== null) { if (i === null) { if (!P) throw Error(st(318)); if (P = o.memoizedState, P = P !== null ? P.dehydrated : null, !P) throw Error(st(317)); P[Bs] = o } else gc(), !(o.flags & 128) && (o.memoizedState = null), o.flags |= 4; Wn(o), P = !1 } else ps !== null && (Ay(ps), ps = null), P = !0; if (!P) return o.flags & 65536 ? o : null } return o.flags & 128 ? (o.lanes = h, o) : (y = y !== null, y !== (i !== null && i.memoizedState !== null) && y && (o.child.flags |= 8192, o.mode & 1 && (i === null || $r.current & 1 ? yn === 0 && (yn = 3) : A0())), o.updateQueue !== null && (o.flags |= 4), Wn(o), null); case 4: return yc(), by(i, o), i === null && bd(o.stateNode.containerInfo), Wn(o), null; case 10: return p0(o.type._context), Wn(o), null; case 17: return _i(o.type) && tm(), Wn(o), null; case 19: if (Rr($r), P = o.memoizedState, P === null) return Wn(o), null; if (y = (o.flags & 128) !== 0, b = P.rendering, b === null) if (y) Wh(P, !1); else { if (yn !== 0 || i !== null && i.flags & 128) for (i = o.child; i !== null;) { if (b = lm(i), b !== null) { for (o.flags |= 128, Wh(P, !1), y = b.updateQueue, y !== null && (o.updateQueue = y, o.flags |= 4), o.subtreeFlags = 0, y = h, h = o.child; h !== null;)P = h, i = y, P.flags &= 14680066, b = P.alternate, b === null ? (P.childLanes = 0, P.lanes = i, P.child = null, P.subtreeFlags = 0, P.memoizedProps = null, P.memoizedState = null, P.updateQueue = null, P.dependencies = null, P.stateNode = null) : (P.childLanes = b.childLanes, P.lanes = b.lanes, P.child = b.child, P.subtreeFlags = 0, P.deletions = null, P.memoizedProps = b.memoizedProps, P.memoizedState = b.memoizedState, P.updateQueue = b.updateQueue, P.type = b.type, i = b.dependencies, P.dependencies = i === null ? null : { lanes: i.lanes, firstContext: i.firstContext }), h = h.sibling; return Er($r, $r.current & 1 | 2), o.child } i = i.sibling } P.tail !== null && tn() > xc && (o.flags |= 128, y = !0, Wh(P, !1), o.lanes = 4194304) } else { if (!y) if (i = lm(b), i !== null) { if (o.flags |= 128, y = !0, h = i.updateQueue, h !== null && (o.updateQueue = h, o.flags |= 4), Wh(P, !0), P.tail === null && P.tailMode === "hidden" && !b.alternate && !jr) return Wn(o), null } else 2 * tn() - P.renderingStartTime > xc && h !== 1073741824 && (o.flags |= 128, y = !0, Wh(P, !1), o.lanes = 4194304); P.isBackwards ? (b.sibling = o.child, o.child = b) : (h = P.last, h !== null ? h.sibling = b : o.child = b, P.last = b) } return P.tail !== null ? (o = P.tail, P.rendering = o, P.tail = o.sibling, P.renderingStartTime = tn(), o.sibling = null, h = $r.current, Er($r, y ? h & 1 | 2 : h & 1), o) : (Wn(o), null); case 22: case 23: return C0(), y = o.memoizedState !== null, i !== null && i.memoizedState !== null !== y && (o.flags |= 8192), y && o.mode & 1 ? zi & 1073741824 && (Wn(o), o.subtreeFlags & 6 && (o.flags |= 8192)) : Wn(o), null; case 24: return null; case 25: return null }throw Error(st(156, o.tag)) } function RM(i, o) { switch (u0(o), o.tag) { case 1: return _i(o.type) && tm(), i = o.flags, i & 65536 ? (o.flags = i & -65537 | 128, o) : null; case 3: return yc(), Rr(gi), Rr(Xn), y0(), i = o.flags, i & 65536 && !(i & 128) ? (o.flags = i & -65537 | 128, o) : null; case 5: return _0(o), null; case 13: if (Rr($r), i = o.memoizedState, i !== null && i.dehydrated !== null) { if (o.alternate === null) throw Error(st(340)); gc() } return i = o.flags, i & 65536 ? (o.flags = i & -65537 | 128, o) : null; case 19: return Rr($r), null; case 4: return yc(), null; case 10: return p0(o.type._context), null; case 22: case 23: return C0(), null; case 24: return null; default: return null } } var Mf = !1, Hn = !1, LM = typeof WeakSet == "function" ? WeakSet : Set, wt = null; function oc(i, o) { var h = i.ref; if (h !== null) if (typeof h == "function") try { h(null) } catch (y) { Qr(i, o, y) } else h.current = null } function Ty(i, o, h) { try { h() } catch (y) { Qr(i, o, y) } } var X1 = !1; function FM(i, o) { if (oy = Kf, i = Pb(), a0(i)) { if ("selectionStart" in i) var h = { start: i.selectionStart, end: i.selectionEnd }; else e: { h = (h = i.ownerDocument) && h.defaultView || window; var y = h.getSelection && h.getSelection(); if (y && y.rangeCount !== 0) { h = y.anchorNode; var w = y.anchorOffset, P = y.focusNode; y = y.focusOffset; try { h.nodeType, P.nodeType } catch { h = null; break e } var b = 0, c = -1, B = -1, $ = 0, me = 0, ge = i, we = null; t: for (; ;) { for (var Ge; ge !== h || w !== 0 && ge.nodeType !== 3 || (c = b + w), ge !== P || y !== 0 && ge.nodeType !== 3 || (B = b + y), ge.nodeType === 3 && (b += ge.nodeValue.length), (Ge = ge.firstChild) !== null;)we = ge, ge = Ge; for (; ;) { if (ge === i) break t; if (we === h && ++$ === w && (c = b), we === P && ++me === y && (B = b), (Ge = ge.nextSibling) !== null) break; ge = we, we = ge.parentNode } ge = Ge } h = c === -1 || B === -1 ? null : { start: c, end: B } } else h = null } h = h || { start: 0, end: 0 } } else h = null; for (ay = { focusedElem: i, selectionRange: h }, Kf = !1, wt = o; wt !== null;)if (o = wt, i = o.child, (o.subtreeFlags & 1028) !== 0 && i !== null) i.return = o, wt = i; else for (; wt !== null;) { o = wt; try { var Ye = o.alternate; if (o.flags & 1024) switch (o.tag) { case 0: case 11: case 15: break; case 1: if (Ye !== null) { var $e = Ye.memoizedProps, ye = Ye.memoizedState, be = o.stateNode, K = be.getSnapshotBeforeUpdate(o.elementType === o.type ? $e : hs(o.type, $e), ye); be.__reactInternalSnapshotBeforeUpdate = K } break; case 3: var ve = o.stateNode.containerInfo; ve.nodeType === 1 ? ve.textContent = "" : ve.nodeType === 9 && ve.documentElement && ve.removeChild(ve.documentElement); break; case 5: case 6: case 4: case 17: break; default: throw Error(st(163)) } } catch (Ke) { Qr(o, o.return, Ke) } if (i = o.sibling, i !== null) { i.return = o.return, wt = i; break } wt = o.return } return Ye = X1, X1 = !1, Ye } function hd(i, o, h) { var y = o.updateQueue; if (y = y !== null ? y.lastEffect : null, y !== null) { var w = y = y.next; do { if ((w.tag & i) === i) { var P = w.destroy; w.destroy = void 0, P !== void 0 && Ty(o, h, P) } w = w.next } while (w !== y) } } function Im(i, o) { if (o = o.updateQueue, o = o !== null ? o.lastEffect : null, o !== null) { var h = o = o.next; do { if ((h.tag & i) === i) { var y = h.create; h.destroy = y() } h = h.next } while (h !== o) } } function Sy(i) { var o = i.ref; if (o !== null) { var h = i.stateNode; switch (i.tag) { case 5: i = h; break; default: i = h }typeof o == "function" ? o(i) : o.current = i } } function b2(i) { var o = i.alternate; o !== null && (i.alternate = null, b2(o)), i.child = null, i.deletions = null, i.sibling = null, i.tag === 5 && (o = i.stateNode, o !== null && (delete o[Bs], delete o[Sd], delete o[cy], delete o[yM], delete o[vM])), i.stateNode = null, i.return = null, i.dependencies = null, i.memoizedProps = null, i.memoizedState = null, i.pendingProps = null, i.stateNode = null, i.updateQueue = null } function T2(i) { return i.tag === 5 || i.tag === 3 || i.tag === 4 } function Y1(i) { e: for (; ;) { for (; i.sibling === null;) { if (i.return === null || T2(i.return)) return null; i = i.return } for (i.sibling.return = i.return, i = i.sibling; i.tag !== 5 && i.tag !== 6 && i.tag !== 18;) { if (i.flags & 2 || i.child === null || i.tag === 4) continue e; i.child.return = i, i = i.child } if (!(i.flags & 2)) return i.stateNode } } function Ey(i, o, h) { var y = i.tag; if (y === 5 || y === 6) i = i.stateNode, o ? h.nodeType === 8 ? h.parentNode.insertBefore(i, o) : h.insertBefore(i, o) : (h.nodeType === 8 ? (o = h.parentNode, o.insertBefore(i, h)) : (o = h, o.appendChild(i)), h = h._reactRootContainer, h != null || o.onclick !== null || (o.onclick = em)); else if (y !== 4 && (i = i.child, i !== null)) for (Ey(i, o, h), i = i.sibling; i !== null;)Ey(i, o, h), i = i.sibling } function Py(i, o, h) { var y = i.tag; if (y === 5 || y === 6) i = i.stateNode, o ? h.insertBefore(i, o) : h.appendChild(i); else if (y !== 4 && (i = i.child, i !== null)) for (Py(i, o, h), i = i.sibling; i !== null;)Py(i, o, h), i = i.sibling } var Bn = null, ds = !1; function aa(i, o, h) { for (h = h.child; h !== null;)S2(i, o, h), h = h.sibling } function S2(i, o, h) { if (Ns && typeof Ns.onCommitFiberUnmount == "function") try { Ns.onCommitFiberUnmount(xm, h) } catch { } switch (h.tag) { case 5: Hn || oc(h, o); case 6: var y = Bn, w = ds; Bn = null, aa(i, o, h), Bn = y, ds = w, Bn !== null && (ds ? (i = Bn, h = h.stateNode, i.nodeType === 8 ? i.parentNode.removeChild(h) : i.removeChild(h)) : Bn.removeChild(h.stateNode)); break; case 18: Bn !== null && (ds ? (i = Bn, h = h.stateNode, i.nodeType === 8 ? b_(i.parentNode, h) : i.nodeType === 1 && b_(i, h), vd(i)) : b_(Bn, h.stateNode)); break; case 4: y = Bn, w = ds, Bn = h.stateNode.containerInfo, ds = !0, aa(i, o, h), Bn = y, ds = w; break; case 0: case 11: case 14: case 15: if (!Hn && (y = h.updateQueue, y !== null && (y = y.lastEffect, y !== null))) { w = y = y.next; do { var P = w, b = P.destroy; P = P.tag, b !== void 0 && (P & 2 || P & 4) && Ty(h, o, b), w = w.next } while (w !== y) } aa(i, o, h); break; case 1: if (!Hn && (oc(h, o), y = h.stateNode, typeof y.componentWillUnmount == "function")) try { y.props = h.memoizedProps, y.state = h.memoizedState, y.componentWillUnmount() } catch (c) { Qr(h, o, c) } aa(i, o, h); break; case 21: aa(i, o, h); break; case 22: h.mode & 1 ? (Hn = (y = Hn) || h.memoizedState !== null, aa(i, o, h), Hn = y) : aa(i, o, h); break; default: aa(i, o, h) } } function K1(i) { var o = i.updateQueue; if (o !== null) { i.updateQueue = null; var h = i.stateNode; h === null && (h = i.stateNode = new LM), o.forEach(function (y) { var w = qM.bind(null, i, y); h.has(y) || (h.add(y), y.then(w, w)) }) } } function us(i, o) { var h = o.deletions; if (h !== null) for (var y = 0; y < h.length; y++) { var w = h[y]; try { var P = i, b = o, c = b; e: for (; c !== null;) { switch (c.tag) { case 5: Bn = c.stateNode, ds = !1; break e; case 3: Bn = c.stateNode.containerInfo, ds = !0; break e; case 4: Bn = c.stateNode.containerInfo, ds = !0; break e }c = c.return } if (Bn === null) throw Error(st(160)); S2(P, b, w), Bn = null, ds = !1; var B = w.alternate; B !== null && (B.return = null), w.return = null } catch ($) { Qr(w, o, $) } } if (o.subtreeFlags & 12854) for (o = o.child; o !== null;)E2(o, i), o = o.sibling } function E2(i, o) { var h = i.alternate, y = i.flags; switch (i.tag) { case 0: case 11: case 14: case 15: if (us(o, i), Rs(i), y & 4) { try { hd(3, i, i.return), Im(3, i) } catch ($e) { Qr(i, i.return, $e) } try { hd(5, i, i.return) } catch ($e) { Qr(i, i.return, $e) } } break; case 1: us(o, i), Rs(i), y & 512 && h !== null && oc(h, h.return); break; case 5: if (us(o, i), Rs(i), y & 512 && h !== null && oc(h, h.return), i.flags & 32) { var w = i.stateNode; try { md(w, "") } catch ($e) { Qr(i, i.return, $e) } } if (y & 4 && (w = i.stateNode, w != null)) { var P = i.memoizedProps, b = h !== null ? h.memoizedProps : P, c = i.type, B = i.updateQueue; if (i.updateQueue = null, B !== null) try { c === "input" && P.type === "radio" && P.name != null && Ww(w, P), Y_(c, b); var $ = Y_(c, P); for (b = 0; b < B.length; b += 2) { var me = B[b], ge = B[b + 1]; me === "style" ? Qw(w, ge) : me === "dangerouslySetInnerHTML" ? Yw(w, ge) : me === "children" ? md(w, ge) : Hy(w, me, ge, $) } switch (c) { case "input": q_(w, P); break; case "textarea": Hw(w, P); break; case "select": var we = w._wrapperState.wasMultiple; w._wrapperState.wasMultiple = !!P.multiple; var Ge = P.value; Ge != null ? lc(w, !!P.multiple, Ge, !1) : we !== !!P.multiple && (P.defaultValue != null ? lc(w, !!P.multiple, P.defaultValue, !0) : lc(w, !!P.multiple, P.multiple ? [] : "", !1)) }w[Sd] = P } catch ($e) { Qr(i, i.return, $e) } } break; case 6: if (us(o, i), Rs(i), y & 4) { if (i.stateNode === null) throw Error(st(162)); w = i.stateNode, P = i.memoizedProps; try { w.nodeValue = P } catch ($e) { Qr(i, i.return, $e) } } break; case 3: if (us(o, i), Rs(i), y & 4 && h !== null && h.memoizedState.isDehydrated) try { vd(o.containerInfo) } catch ($e) { Qr(i, i.return, $e) } break; case 4: us(o, i), Rs(i); break; case 13: us(o, i), Rs(i), w = i.child, w.flags & 8192 && (P = w.memoizedState !== null, w.stateNode.isHidden = P, !P || w.alternate !== null && w.alternate.memoizedState !== null || (M0 = tn())), y & 4 && K1(i); break; case 22: if (me = h !== null && h.memoizedState !== null, i.mode & 1 ? (Hn = ($ = Hn) || me, us(o, i), Hn = $) : us(o, i), Rs(i), y & 8192) { if ($ = i.memoizedState !== null, (i.stateNode.isHidden = $) && !me && i.mode & 1) for (wt = i, me = i.child; me !== null;) { for (ge = wt = me; wt !== null;) { switch (we = wt, Ge = we.child, we.tag) { case 0: case 11: case 14: case 15: hd(4, we, we.return); break; case 1: oc(we, we.return); var Ye = we.stateNode; if (typeof Ye.componentWillUnmount == "function") { y = we, h = we.return; try { o = y, Ye.props = o.memoizedProps, Ye.state = o.memoizedState, Ye.componentWillUnmount() } catch ($e) { Qr(y, h, $e) } } break; case 5: oc(we, we.return); break; case 22: if (we.memoizedState !== null) { J1(ge); continue } }Ge !== null ? (Ge.return = we, wt = Ge) : J1(ge) } me = me.sibling } e: for (me = null, ge = i; ;) { if (ge.tag === 5) { if (me === null) { me = ge; try { w = ge.stateNode, $ ? (P = w.style, typeof P.setProperty == "function" ? P.setProperty("display", "none", "important") : P.display = "none") : (c = ge.stateNode, B = ge.memoizedProps.style, b = B != null && B.hasOwnProperty("display") ? B.display : null, c.style.display = Kw("display", b)) } catch ($e) { Qr(i, i.return, $e) } } } else if (ge.tag === 6) { if (me === null) try { ge.stateNode.nodeValue = $ ? "" : ge.memoizedProps } catch ($e) { Qr(i, i.return, $e) } } else if ((ge.tag !== 22 && ge.tag !== 23 || ge.memoizedState === null || ge === i) && ge.child !== null) { ge.child.return = ge, ge = ge.child; continue } if (ge === i) break e; for (; ge.sibling === null;) { if (ge.return === null || ge.return === i) break e; me === ge && (me = null), ge = ge.return } me === ge && (me = null), ge.sibling.return = ge.return, ge = ge.sibling } } break; case 19: us(o, i), Rs(i), y & 4 && K1(i); break; case 21: break; default: us(o, i), Rs(i) } } function Rs(i) { var o = i.flags; if (o & 2) { try { e: { for (var h = i.return; h !== null;) { if (T2(h)) { var y = h; break e } h = h.return } throw Error(st(160)) } switch (y.tag) { case 5: var w = y.stateNode; y.flags & 32 && (md(w, ""), y.flags &= -33); var P = Y1(i); Py(i, P, w); break; case 3: case 4: var b = y.stateNode.containerInfo, c = Y1(i); Ey(i, c, b); break; default: throw Error(st(161)) } } catch (B) { Qr(i, i.return, B) } i.flags &= -3 } o & 4096 && (i.flags &= -4097) } function BM(i, o, h) { wt = i, P2(i) } function P2(i, o, h) { for (var y = (i.mode & 1) !== 0; wt !== null;) { var w = wt, P = w.child; if (w.tag === 22 && y) { var b = w.memoizedState !== null || Mf; if (!b) { var c = w.alternate, B = c !== null && c.memoizedState !== null || Hn; c = Mf; var $ = Hn; if (Mf = b, (Hn = B) && !$) for (wt = w; wt !== null;)b = wt, B = b.child, b.tag === 22 && b.memoizedState !== null ? ew(w) : B !== null ? (B.return = b, wt = B) : ew(w); for (; P !== null;)wt = P, P2(P), P = P.sibling; wt = w, Mf = c, Hn = $ } Q1(i) } else w.subtreeFlags & 8772 && P !== null ? (P.return = w, wt = P) : Q1(i) } } function Q1(i) { for (; wt !== null;) { var o = wt; if (o.flags & 8772) { var h = o.alternate; try { if (o.flags & 8772) switch (o.tag) { case 0: case 11: case 15: Hn || Im(5, o); break; case 1: var y = o.stateNode; if (o.flags & 4 && !Hn) if (h === null) y.componentDidMount(); else { var w = o.elementType === o.type ? h.memoizedProps : hs(o.type, h.memoizedProps); y.componentDidUpdate(w, h.memoizedState, y.__reactInternalSnapshotBeforeUpdate) } var P = o.updateQueue; P !== null && F1(o, P, y); break; case 3: var b = o.updateQueue; if (b !== null) { if (h = null, o.child !== null) switch (o.child.tag) { case 5: h = o.child.stateNode; break; case 1: h = o.child.stateNode }F1(o, b, h) } break; case 5: var c = o.stateNode; if (h === null && o.flags & 4) { h = c; var B = o.memoizedProps; switch (o.type) { case "button": case "input": case "select": case "textarea": B.autoFocus && h.focus(); break; case "img": B.src && (h.src = B.src) } } break; case 6: break; case 4: break; case 12: break; case 13: if (o.memoizedState === null) { var $ = o.alternate; if ($ !== null) { var me = $.memoizedState; if (me !== null) { var ge = me.dehydrated; ge !== null && vd(ge) } } } break; case 19: case 17: case 21: case 22: case 23: case 25: break; default: throw Error(st(163)) }Hn || o.flags & 512 && Sy(o) } catch (we) { Qr(o, o.return, we) } } if (o === i) { wt = null; break } if (h = o.sibling, h !== null) { h.return = o.return, wt = h; break } wt = o.return } } function J1(i) { for (; wt !== null;) { var o = wt; if (o === i) { wt = null; break } var h = o.sibling; if (h !== null) { h.return = o.return, wt = h; break } wt = o.return } } function ew(i) { for (; wt !== null;) { var o = wt; try { switch (o.tag) { case 0: case 11: case 15: var h = o.return; try { Im(4, o) } catch (B) { Qr(o, h, B) } break; case 1: var y = o.stateNode; if (typeof y.componentDidMount == "function") { var w = o.return; try { y.componentDidMount() } catch (B) { Qr(o, w, B) } } var P = o.return; try { Sy(o) } catch (B) { Qr(o, P, B) } break; case 5: var b = o.return; try { Sy(o) } catch (B) { Qr(o, b, B) } } } catch (B) { Qr(o, o.return, B) } if (o === i) { wt = null; break } var c = o.sibling; if (c !== null) { c.return = o.return, wt = c; break } wt = o.return } } var OM = Math.ceil, hm = Eo.ReactCurrentDispatcher, E0 = Eo.ReactCurrentOwner, Ki = Eo.ReactCurrentBatchConfig, Qt = 0, Mn = null, hn = null, On = 0, zi = 0, ac = Pa(0), yn = 0, Ad = null, Bl = 0, Cm = 0, P0 = 0, dd = null, fi = null, M0 = 0, xc = 1 / 0, mo = null, dm = !1, My = null, xa = null, If = !1, fa = null, pm = 0, pd = 0, Iy = null, Vf = -1, Uf = 0; function ni() { return Qt & 6 ? tn() : Vf !== -1 ? Vf : Vf = tn() } function wa(i) { return i.mode & 1 ? Qt & 2 && On !== 0 ? On & -On : wM.transition !== null ? (Uf === 0 && (Uf = cb()), Uf) : (i = dr, i !== 0 || (i = window.event, i = i === void 0 ? 16 : _b(i.type)), i) : 1 } function gs(i, o, h, y) { if (50 < pd) throw pd = 0, Iy = null, Error(st(185)); zd(i, h, y), (!(Qt & 2) || i !== Mn) && (i === Mn && (!(Qt & 2) && (Cm |= h), yn === 4 && da(i, On)), yi(i, y), h === 1 && Qt === 0 && !(o.mode & 1) && (xc = tn() + 500, Em && Ma())) } function yi(i, o) { var h = i.callbackNode; wP(i, o); var y = Yf(i, i === Mn ? On : 0); if (y === 0) h !== null && u1(h), i.callbackNode = null, i.callbackPriority = 0; else if (o = y & -y, i.callbackPriority !== o) { if (h != null && u1(h), o === 1) i.tag === 0 ? xM(tw.bind(null, i)) : Fb(tw.bind(null, i)), gM(function () { !(Qt & 6) && Ma() }), h = null; else { switch (hb(y)) { case 1: h = Jy; break; case 4: h = lb; break; case 16: h = Xf; break; case 536870912: h = ub; break; default: h = Xf }h = R2(h, M2.bind(null, i)) } i.callbackPriority = o, i.callbackNode = h } } function M2(i, o) { if (Vf = -1, Uf = 0, Qt & 6) throw Error(st(327)); var h = i.callbackNode; if (pc() && i.callbackNode !== h) return null; var y = Yf(i, i === Mn ? On : 0); if (y === 0) return null; if (y & 30 || y & i.expiredLanes || o) o = fm(i, y); else { o = y; var w = Qt; Qt |= 2; var P = C2(); (Mn !== i || On !== o) && (mo = null, xc = tn() + 500, kl(i, o)); do try { VM(); break } catch (c) { I2(i, c) } while (!0); d0(), hm.current = P, Qt = w, hn !== null ? o = 0 : (Mn = null, On = 0, o = yn) } if (o !== 0) { if (o === 2 && (w = ty(i), w !== 0 && (y = w, o = Cy(i, w))), o === 1) throw h = Ad, kl(i, 0), da(i, y), yi(i, tn()), h; if (o === 6) da(i, y); else { if (w = i.current.alternate, !(y & 30) && !NM(w) && (o = fm(i, y), o === 2 && (P = ty(i), P !== 0 && (y = P, o = Cy(i, P))), o === 1)) throw h = Ad, kl(i, 0), da(i, y), yi(i, tn()), h; switch (i.finishedWork = w, i.finishedLanes = y, o) { case 0: case 1: throw Error(st(345)); case 2: Pl(i, fi, mo); break; case 3: if (da(i, y), (y & 130023424) === y && (o = M0 + 500 - tn(), 10 < o)) { if (Yf(i, 0) !== 0) break; if (w = i.suspendedLanes, (w & y) !== y) { ni(), i.pingedLanes |= i.suspendedLanes & w; break } i.timeoutHandle = uy(Pl.bind(null, i, fi, mo), o); break } Pl(i, fi, mo); break; case 4: if (da(i, y), (y & 4194240) === y) break; for (o = i.eventTimes, w = -1; 0 < y;) { var b = 31 - ms(y); P = 1 << b, b = o[b], b > w && (w = b), y &= ~P } if (y = w, y = tn() - y, y = (120 > y ? 120 : 480 > y ? 480 : 1080 > y ? 1080 : 1920 > y ? 1920 : 3e3 > y ? 3e3 : 4320 > y ? 4320 : 1960 * OM(y / 1960)) - y, 10 < y) { i.timeoutHandle = uy(Pl.bind(null, i, fi, mo), y); break } Pl(i, fi, mo); break; case 5: Pl(i, fi, mo); break; default: throw Error(st(329)) } } } return yi(i, tn()), i.callbackNode === h ? M2.bind(null, i) : null } function Cy(i, o) { var h = dd; return i.current.memoizedState.isDehydrated && (kl(i, o).flags |= 256), i = fm(i, o), i !== 2 && (o = fi, fi = h, o !== null && Ay(o)), i } function Ay(i) { fi === null ? fi = i : fi.push.apply(fi, i) } function NM(i) { for (var o = i; ;) { if (o.flags & 16384) { var h = o.updateQueue; if (h !== null && (h = h.stores, h !== null)) for (var y = 0; y < h.length; y++) { var w = h[y], P = w.getSnapshot; w = w.value; try { if (!_s(P(), w)) return !1 } catch { return !1 } } } if (h = o.child, o.subtreeFlags & 16384 && h !== null) h.return = o, o = h; else { if (o === i) break; for (; o.sibling === null;) { if (o.return === null || o.return === i) return !0; o = o.return } o.sibling.return = o.return, o = o.sibling } } return !0 } function da(i, o) { for (o &= ~P0, o &= ~Cm, i.suspendedLanes |= o, i.pingedLanes &= ~o, i = i.expirationTimes; 0 < o;) { var h = 31 - ms(o), y = 1 << h; i[h] = -1, o &= ~y } } function tw(i) { if (Qt & 6) throw Error(st(327)); pc(); var o = Yf(i, 0); if (!(o & 1)) return yi(i, tn()), null; var h = fm(i, o); if (i.tag !== 0 && h === 2) { var y = ty(i); y !== 0 && (o = y, h = Cy(i, y)) } if (h === 1) throw h = Ad, kl(i, 0), da(i, o), yi(i, tn()), h; if (h === 6) throw Error(st(345)); return i.finishedWork = i.current.alternate, i.finishedLanes = o, Pl(i, fi, mo), yi(i, tn()), null } function I0(i, o) { var h = Qt; Qt |= 1; try { return i(o) } finally { Qt = h, Qt === 0 && (xc = tn() + 500, Em && Ma()) } } function Ol(i) { fa !== null && fa.tag === 0 && !(Qt & 6) && pc(); var o = Qt; Qt |= 1; var h = Ki.transition, y = dr; try { if (Ki.transition = null, dr = 1, i) return i() } finally { dr = y, Ki.transition = h, Qt = o, !(Qt & 6) && Ma() } } function C0() { zi = ac.current, Rr(ac) } function kl(i, o) { i.finishedWork = null, i.finishedLanes = 0; var h = i.timeoutHandle; if (h !== -1 && (i.timeoutHandle = -1, mM(h)), hn !== null) for (h = hn.return; h !== null;) { var y = h; switch (u0(y), y.tag) { case 1: y = y.type.childContextTypes, y != null && tm(); break; case 3: yc(), Rr(gi), Rr(Xn), y0(); break; case 5: _0(y); break; case 4: yc(); break; case 13: Rr($r); break; case 19: Rr($r); break; case 10: p0(y.type._context); break; case 22: case 23: C0() }h = h.return } if (Mn = i, hn = i = ba(i.current, null), On = zi = o, yn = 0, Ad = null, P0 = Cm = Bl = 0, fi = dd = null, Il !== null) { for (o = 0; o < Il.length; o++)if (h = Il[o], y = h.interleaved, y !== null) { h.interleaved = null; var w = y.next, P = h.pending; if (P !== null) { var b = P.next; P.next = w, y.next = b } h.pending = y } Il = null } return i } function I2(i, o) { do { var h = hn; try { if (d0(), Of.current = cm, um) { for (var y = qr.memoizedState; y !== null;) { var w = y.queue; w !== null && (w.pending = null), y = y.next } um = !1 } if (Fl = 0, Pn = _n = qr = null, cd = !1, Md = 0, E0.current = null, h === null || h.return === null) { yn = 1, Ad = o, hn = null; break } e: { var P = i, b = h.return, c = h, B = o; if (o = On, c.flags |= 32768, B !== null && typeof B == "object" && typeof B.then == "function") { var $ = B, me = c, ge = me.tag; if (!(me.mode & 1) && (ge === 0 || ge === 11 || ge === 15)) { var we = me.alternate; we ? (me.updateQueue = we.updateQueue, me.memoizedState = we.memoizedState, me.lanes = we.lanes) : (me.updateQueue = null, me.memoizedState = null) } var Ge = U1(b); if (Ge !== null) { Ge.flags &= -257, G1(Ge, b, c, P, o), Ge.mode & 1 && V1(P, $, o), o = Ge, B = $; var Ye = o.updateQueue; if (Ye === null) { var $e = new Set; $e.add(B), o.updateQueue = $e } else Ye.add(B); break e } else { if (!(o & 1)) { V1(P, $, o), A0(); break e } B = Error(st(426)) } } else if (jr && c.mode & 1) { var ye = U1(b); if (ye !== null) { !(ye.flags & 65536) && (ye.flags |= 256), G1(ye, b, c, P, o), c0(vc(B, c)); break e } } P = B = vc(B, c), yn !== 4 && (yn = 2), dd === null ? dd = [P] : dd.push(P), P = b; do { switch (P.tag) { case 3: P.flags |= 65536, o &= -o, P.lanes |= o; var be = h2(P, B, o); L1(P, be); break e; case 1: c = B; var K = P.type, ve = P.stateNode; if (!(P.flags & 128) && (typeof K.getDerivedStateFromError == "function" || ve !== null && typeof ve.componentDidCatch == "function" && (xa === null || !xa.has(ve)))) { P.flags |= 65536, o &= -o, P.lanes |= o; var Ke = d2(P, c, o); L1(P, Ke); break e } }P = P.return } while (P !== null) } k2(h) } catch (ft) { o = ft, hn === h && h !== null && (hn = h = h.return); continue } break } while (!0) } function C2() { var i = hm.current; return hm.current = cm, i === null ? cm : i } function A0() { (yn === 0 || yn === 3 || yn === 2) && (yn = 4), Mn === null || !(Bl & 268435455) && !(Cm & 268435455) || da(Mn, On) } function fm(i, o) { var h = Qt; Qt |= 2; var y = C2(); (Mn !== i || On !== o) && (mo = null, kl(i, o)); do try { jM(); break } catch (w) { I2(i, w) } while (!0); if (d0(), Qt = h, hm.current = y, hn !== null) throw Error(st(261)); return Mn = null, On = 0, yn } function jM() { for (; hn !== null;)A2(hn) } function VM() { for (; hn !== null && !dP();)A2(hn) } function A2(i) { var o = z2(i.alternate, i, zi); i.memoizedProps = i.pendingProps, o === null ? k2(i) : hn = o, E0.current = null } function k2(i) { var o = i; do { var h = o.alternate; if (i = o.return, o.flags & 32768) { if (h = RM(h, o), h !== null) { h.flags &= 32767, hn = h; return } if (i !== null) i.flags |= 32768, i.subtreeFlags = 0, i.deletions = null; else { yn = 6, hn = null; return } } else if (h = zM(h, o, zi), h !== null) { hn = h; return } if (o = o.sibling, o !== null) { hn = o; return } hn = o = i } while (o !== null); yn === 0 && (yn = 5) } function Pl(i, o, h) { var y = dr, w = Ki.transition; try { Ki.transition = null, dr = 1, UM(i, o, h, y) } finally { Ki.transition = w, dr = y } return null } function UM(i, o, h, y) { do pc(); while (fa !== null); if (Qt & 6) throw Error(st(327)); h = i.finishedWork; var w = i.finishedLanes; if (h === null) return null; if (i.finishedWork = null, i.finishedLanes = 0, h === i.current) throw Error(st(177)); i.callbackNode = null, i.callbackPriority = 0; var P = h.lanes | h.childLanes; if (bP(i, P), i === Mn && (hn = Mn = null, On = 0), !(h.subtreeFlags & 2064) && !(h.flags & 2064) || If || (If = !0, R2(Xf, function () { return pc(), null })), P = (h.flags & 15990) !== 0, h.subtreeFlags & 15990 || P) { P = Ki.transition, Ki.transition = null; var b = dr; dr = 1; var c = Qt; Qt |= 4, E0.current = null, FM(i, h), E2(h, i), lM(ay), Kf = !!oy, ay = oy = null, i.current = h, BM(h), pP(), Qt = c, dr = b, Ki.transition = P } else i.current = h; if (If && (If = !1, fa = i, pm = w), P = i.pendingLanes, P === 0 && (xa = null), gP(h.stateNode), yi(i, tn()), o !== null) for (y = i.onRecoverableError, h = 0; h < o.length; h++)w = o[h], y(w.value, { componentStack: w.stack, digest: w.digest }); if (dm) throw dm = !1, i = My, My = null, i; return pm & 1 && i.tag !== 0 && pc(), P = i.pendingLanes, P & 1 ? i === Iy ? pd++ : (pd = 0, Iy = i) : pd = 0, Ma(), null } function pc() { if (fa !== null) { var i = hb(pm), o = Ki.transition, h = dr; try { if (Ki.transition = null, dr = 16 > i ? 16 : i, fa === null) var y = !1; else { if (i = fa, fa = null, pm = 0, Qt & 6) throw Error(st(331)); var w = Qt; for (Qt |= 4, wt = i.current; wt !== null;) { var P = wt, b = P.child; if (wt.flags & 16) { var c = P.deletions; if (c !== null) { for (var B = 0; B < c.length; B++) { var $ = c[B]; for (wt = $; wt !== null;) { var me = wt; switch (me.tag) { case 0: case 11: case 15: hd(8, me, P) }var ge = me.child; if (ge !== null) ge.return = me, wt = ge; else for (; wt !== null;) { me = wt; var we = me.sibling, Ge = me.return; if (b2(me), me === $) { wt = null; break } if (we !== null) { we.return = Ge, wt = we; break } wt = Ge } } } var Ye = P.alternate; if (Ye !== null) { var $e = Ye.child; if ($e !== null) { Ye.child = null; do { var ye = $e.sibling; $e.sibling = null, $e = ye } while ($e !== null) } } wt = P } } if (P.subtreeFlags & 2064 && b !== null) b.return = P, wt = b; else e: for (; wt !== null;) { if (P = wt, P.flags & 2048) switch (P.tag) { case 0: case 11: case 15: hd(9, P, P.return) }var be = P.sibling; if (be !== null) { be.return = P.return, wt = be; break e } wt = P.return } } var K = i.current; for (wt = K; wt !== null;) { b = wt; var ve = b.child; if (b.subtreeFlags & 2064 && ve !== null) ve.return = b, wt = ve; else e: for (b = K; wt !== null;) { if (c = wt, c.flags & 2048) try { switch (c.tag) { case 0: case 11: case 15: Im(9, c) } } catch (ft) { Qr(c, c.return, ft) } if (c === b) { wt = null; break e } var Ke = c.sibling; if (Ke !== null) { Ke.return = c.return, wt = Ke; break e } wt = c.return } } if (Qt = w, Ma(), Ns && typeof Ns.onPostCommitFiberRoot == "function") try { Ns.onPostCommitFiberRoot(xm, i) } catch { } y = !0 } return y } finally { dr = h, Ki.transition = o } } return !1 } function rw(i, o, h) { o = vc(h, o), o = h2(i, o, 1), i = va(i, o, 1), o = ni(), i !== null && (zd(i, 1, o), yi(i, o)) } function Qr(i, o, h) { if (i.tag === 3) rw(i, i, h); else for (; o !== null;) { if (o.tag === 3) { rw(o, i, h); break } else if (o.tag === 1) { var y = o.stateNode; if (typeof o.type.getDerivedStateFromError == "function" || typeof y.componentDidCatch == "function" && (xa === null || !xa.has(y))) { i = vc(h, i), i = d2(o, i, 1), o = va(o, i, 1), i = ni(), o !== null && (zd(o, 1, i), yi(o, i)); break } } o = o.return } } function GM(i, o, h) { var y = i.pingCache; y !== null && y.delete(o), o = ni(), i.pingedLanes |= i.suspendedLanes & h, Mn === i && (On & h) === h && (yn === 4 || yn === 3 && (On & 130023424) === On && 500 > tn() - M0 ? kl(i, 0) : P0 |= h), yi(i, o) } function D2(i, o) { o === 0 && (i.mode & 1 ? (o = yf, yf <<= 1, !(yf & 130023424) && (yf = 4194304)) : o = 1); var h = ni(); i = bo(i, o), i !== null && (zd(i, o, h), yi(i, h)) } function $M(i) { var o = i.memoizedState, h = 0; o !== null && (h = o.retryLane), D2(i, h) } function qM(i, o) { var h = 0; switch (i.tag) { case 13: var y = i.stateNode, w = i.memoizedState; w !== null && (h = w.retryLane); break; case 19: y = i.stateNode; break; default: throw Error(st(314)) }y !== null && y.delete(o), D2(i, h) } var z2; z2 = function (i, o, h) { if (i !== null) if (i.memoizedProps !== o.pendingProps || gi.current) mi = !0; else { if (!(i.lanes & h) && !(o.flags & 128)) return mi = !1, DM(i, o, h); mi = !!(i.flags & 131072) } else mi = !1, jr && o.flags & 1048576 && Bb(o, im, o.index); switch (o.lanes = 0, o.tag) { case 2: var y = o.type; jf(i, o), i = o.pendingProps; var w = mc(o, Xn.current); dc(o, h), w = x0(null, o, y, i, w, h); var P = w0(); return o.flags |= 1, typeof w == "object" && w !== null && typeof w.render == "function" && w.$$typeof === void 0 ? (o.tag = 1, o.memoizedState = null, o.updateQueue = null, _i(y) ? (P = !0, rm(o)) : P = !1, o.memoizedState = w.state !== null && w.state !== void 0 ? w.state : null, m0(o), w.updater = Mm, o.stateNode = w, w._reactInternals = o, gy(o, y, i, h), o = vy(null, o, y, !0, P, h)) : (o.tag = 0, jr && P && l0(o), ri(null, o, w, h), o = o.child), o; case 16: y = o.elementType; e: { switch (jf(i, o), i = o.pendingProps, w = y._init, y = w(y._payload), o.type = y, w = o.tag = WM(y), i = hs(y, i), w) { case 0: o = yy(null, o, y, i, h); break e; case 1: o = Z1(null, o, y, i, h); break e; case 11: o = $1(null, o, y, i, h); break e; case 14: o = q1(null, o, y, hs(y.type, i), h); break e }throw Error(st(306, y, "")) } return o; case 0: return y = o.type, w = o.pendingProps, w = o.elementType === y ? w : hs(y, w), yy(i, o, y, w, h); case 1: return y = o.type, w = o.pendingProps, w = o.elementType === y ? w : hs(y, w), Z1(i, o, y, w, h); case 3: e: { if (g2(o), i === null) throw Error(st(387)); y = o.pendingProps, P = o.memoizedState, w = P.element, Gb(i, o), am(o, y, null, h); var b = o.memoizedState; if (y = b.element, P.isDehydrated) if (P = { element: y, isDehydrated: !1, cache: b.cache, pendingSuspenseBoundaries: b.pendingSuspenseBoundaries, transitions: b.transitions }, o.updateQueue.baseState = P, o.memoizedState = P, o.flags & 256) { w = vc(Error(st(423)), o), o = W1(i, o, y, h, w); break e } else if (y !== w) { w = vc(Error(st(424)), o), o = W1(i, o, y, h, w); break e } else for (Ri = ya(o.stateNode.containerInfo.firstChild), Li = o, jr = !0, ps = null, h = Vb(o, null, y, h), o.child = h; h;)h.flags = h.flags & -3 | 4096, h = h.sibling; else { if (gc(), y === w) { o = To(i, o, h); break e } ri(i, o, y, h) } o = o.child } return o; case 5: return $b(o), i === null && py(o), y = o.type, w = o.pendingProps, P = i !== null ? i.memoizedProps : null, b = w.children, ly(y, w) ? b = null : P !== null && ly(y, P) && (o.flags |= 32), m2(i, o), ri(i, o, b, h), o.child; case 6: return i === null && py(o), null; case 13: return _2(i, o, h); case 4: return g0(o, o.stateNode.containerInfo), y = o.pendingProps, i === null ? o.child = _c(o, null, y, h) : ri(i, o, y, h), o.child; case 11: return y = o.type, w = o.pendingProps, w = o.elementType === y ? w : hs(y, w), $1(i, o, y, w, h); case 7: return ri(i, o, o.pendingProps, h), o.child; case 8: return ri(i, o, o.pendingProps.children, h), o.child; case 12: return ri(i, o, o.pendingProps.children, h), o.child; case 10: e: { if (y = o.type._context, w = o.pendingProps, P = o.memoizedProps, b = w.value, Er(sm, y._currentValue), y._currentValue = b, P !== null) if (_s(P.value, b)) { if (P.children === w.children && !gi.current) { o = To(i, o, h); break e } } else for (P = o.child, P !== null && (P.return = o); P !== null;) { var c = P.dependencies; if (c !== null) { b = P.child; for (var B = c.firstContext; B !== null;) { if (B.context === y) { if (P.tag === 1) { B = vo(-1, h & -h), B.tag = 2; var $ = P.updateQueue; if ($ !== null) { $ = $.shared; var me = $.pending; me === null ? B.next = B : (B.next = me.next, me.next = B), $.pending = B } } P.lanes |= h, B = P.alternate, B !== null && (B.lanes |= h), fy(P.return, h, o), c.lanes |= h; break } B = B.next } } else if (P.tag === 10) b = P.type === o.type ? null : P.child; else if (P.tag === 18) { if (b = P.return, b === null) throw Error(st(341)); b.lanes |= h, c = b.alternate, c !== null && (c.lanes |= h), fy(b, h, o), b = P.sibling } else b = P.child; if (b !== null) b.return = P; else for (b = P; b !== null;) { if (b === o) { b = null; break } if (P = b.sibling, P !== null) { P.return = b.return, b = P; break } b = b.return } P = b } ri(i, o, w.children, h), o = o.child } return o; case 9: return w = o.type, y = o.pendingProps.children, dc(o, h), w = Qi(w), y = y(w), o.flags |= 1, ri(i, o, y, h), o.child; case 14: return y = o.type, w = hs(y, o.pendingProps), w = hs(y.type, w), q1(i, o, y, w, h); case 15: return p2(i, o, o.type, o.pendingProps, h); case 17: return y = o.type, w = o.pendingProps, w = o.elementType === y ? w : hs(y, w), jf(i, o), o.tag = 1, _i(y) ? (i = !0, rm(o)) : i = !1, dc(o, h), c2(o, y, w), gy(o, y, w, h), vy(null, o, y, !0, i, h); case 19: return y2(i, o, h); case 22: return f2(i, o, h) }throw Error(st(156, o.tag)) }; function R2(i, o) { return ab(i, o) } function ZM(i, o, h, y) { this.tag = i, this.key = h, this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null, this.index = 0, this.ref = null, this.pendingProps = o, this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null, this.mode = y, this.subtreeFlags = this.flags = 0, this.deletions = null, this.childLanes = this.lanes = 0, this.alternate = null } function Yi(i, o, h, y) { return new ZM(i, o, h, y) } function k0(i) { return i = i.prototype, !(!i || !i.isReactComponent) } function WM(i) { if (typeof i == "function") return k0(i) ? 1 : 0; if (i != null) { if (i = i.$$typeof, i === Yy) return 11; if (i === Ky) return 14 } return 2 } function ba(i, o) { var h = i.alternate; return h === null ? (h = Yi(i.tag, o, i.key, i.mode), h.elementType = i.elementType, h.type = i.type, h.stateNode = i.stateNode, h.alternate = i, i.alternate = h) : (h.pendingProps = o, h.type = i.type, h.flags = 0, h.subtreeFlags = 0, h.deletions = null), h.flags = i.flags & 14680064, h.childLanes = i.childLanes, h.lanes = i.lanes, h.child = i.child, h.memoizedProps = i.memoizedProps, h.memoizedState = i.memoizedState, h.updateQueue = i.updateQueue, o = i.dependencies, h.dependencies = o === null ? null : { lanes: o.lanes, firstContext: o.firstContext }, h.sibling = i.sibling, h.index = i.index, h.ref = i.ref, h } function Gf(i, o, h, y, w, P) { var b = 2; if (y = i, typeof i == "function") k0(i) && (b = 1); else if (typeof i == "string") b = 5; else e: switch (i) { case Ku: return Dl(h.children, w, P, o); case Xy: b = 8, w |= 8; break; case j_: return i = Yi(12, h, o, w | 2), i.elementType = j_, i.lanes = P, i; case V_: return i = Yi(13, h, o, w), i.elementType = V_, i.lanes = P, i; case U_: return i = Yi(19, h, o, w), i.elementType = U_, i.lanes = P, i; case $w: return Am(h, w, P, o); default: if (typeof i == "object" && i !== null) switch (i.$$typeof) { case Uw: b = 10; break e; case Gw: b = 9; break e; case Yy: b = 11; break e; case Ky: b = 14; break e; case ua: b = 16, y = null; break e }throw Error(st(130, i == null ? i : typeof i, "")) }return o = Yi(b, h, o, w), o.elementType = i, o.type = y, o.lanes = P, o } function Dl(i, o, h, y) { return i = Yi(7, i, y, o), i.lanes = h, i } function Am(i, o, h, y) { return i = Yi(22, i, y, o), i.elementType = $w, i.lanes = h, i.stateNode = { isHidden: !1 }, i } function A_(i, o, h) { return i = Yi(6, i, null, o), i.lanes = h, i } function k_(i, o, h) { return o = Yi(4, i.children !== null ? i.children : [], i.key, o), o.lanes = h, o.stateNode = { containerInfo: i.containerInfo, pendingChildren: null, implementation: i.implementation }, o } function HM(i, o, h, y, w) { this.tag = o, this.containerInfo = i, this.finishedWork = this.pingCache = this.current = this.pendingChildren = null, this.timeoutHandle = -1, this.callbackNode = this.pendingContext = this.context = null, this.callbackPriority = 0, this.eventTimes = h_(0), this.expirationTimes = h_(-1), this.entangledLanes = this.finishedLanes = this.mutableReadLanes = this.expiredLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0, this.entanglements = h_(0), this.identifierPrefix = y, this.onRecoverableError = w, this.mutableSourceEagerHydrationData = null } function D0(i, o, h, y, w, P, b, c, B) { return i = new HM(i, o, h, c, B), o === 1 ? (o = 1, P === !0 && (o |= 8)) : o = 0, P = Yi(3, null, null, o), i.current = P, P.stateNode = i, P.memoizedState = { element: y, isDehydrated: h, cache: null, transitions: null, pendingSuspenseBoundaries: null }, m0(P), i } function XM(i, o, h) { var y = 3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null; return { $$typeof: Yu, key: y == null ? null : "" + y, children: i, containerInfo: o, implementation: h } } function L2(i) { if (!i) return Sa; i = i._reactInternals; e: { if (jl(i) !== i || i.tag !== 1) throw Error(st(170)); var o = i; do { switch (o.tag) { case 3: o = o.stateNode.context; break e; case 1: if (_i(o.type)) { o = o.stateNode.__reactInternalMemoizedMergedChildContext; break e } }o = o.return } while (o !== null); throw Error(st(171)) } if (i.tag === 1) { var h = i.type; if (_i(h)) return Lb(i, h, o) } return o } function F2(i, o, h, y, w, P, b, c, B) { return i = D0(h, y, !0, i, w, P, b, c, B), i.context = L2(null), h = i.current, y = ni(), w = wa(h), P = vo(y, w), P.callback = o ?? null, va(h, P, w), i.current.lanes = w, zd(i, w, y), yi(i, y), i } function km(i, o, h, y) { var w = o.current, P = ni(), b = wa(w); return h = L2(h), o.context === null ? o.context = h : o.pendingContext = h, o = vo(P, b), o.payload = { element: i }, y = y === void 0 ? null : y, y !== null && (o.callback = y), i = va(w, o, b), i !== null && (gs(i, w, b, P), Bf(i, w, b)), b } function mm(i) { if (i = i.current, !i.child) return null; switch (i.child.tag) { case 5: return i.child.stateNode; default: return i.child.stateNode } } function nw(i, o) { if (i = i.memoizedState, i !== null && i.dehydrated !== null) { var h = i.retryLane; i.retryLane = h !== 0 && h < o ? h : o } } function z0(i, o) { nw(i, o), (i = i.alternate) && nw(i, o) } function YM() { return null } var B2 = typeof reportError == "function" ? reportError : function (i) { console.error(i) }; function R0(i) { this._internalRoot = i } Dm.prototype.render = R0.prototype.render = function (i) { var o = this._internalRoot; if (o === null) throw Error(st(409)); km(i, o, null, null) }; Dm.prototype.unmount = R0.prototype.unmount = function () { var i = this._internalRoot; if (i !== null) { this._internalRoot = null; var o = i.containerInfo; Ol(function () { km(null, i, null, null) }), o[wo] = null } }; function Dm(i) { this._internalRoot = i } Dm.prototype.unstable_scheduleHydration = function (i) { if (i) { var o = fb(); i = { blockedOn: null, target: i, priority: o }; for (var h = 0; h < ha.length && o !== 0 && o < ha[h].priority; h++); ha.splice(h, 0, i), h === 0 && gb(i) } }; function L0(i) { return !(!i || i.nodeType !== 1 && i.nodeType !== 9 && i.nodeType !== 11) } function zm(i) { return !(!i || i.nodeType !== 1 && i.nodeType !== 9 && i.nodeType !== 11 && (i.nodeType !== 8 || i.nodeValue !== " react-mount-point-unstable ")) } function iw() { } function KM(i, o, h, y, w) { if (w) { if (typeof y == "function") { var P = y; y = function () { var $ = mm(b); P.call($) } } var b = F2(o, y, i, 0, null, !1, !1, "", iw); return i._reactRootContainer = b, i[wo] = b.current, bd(i.nodeType === 8 ? i.parentNode : i), Ol(), b } for (; w = i.lastChild;)i.removeChild(w); if (typeof y == "function") { var c = y; y = function () { var $ = mm(B); c.call($) } } var B = D0(i, 0, !1, null, null, !1, !1, "", iw); return i._reactRootContainer = B, i[wo] = B.current, bd(i.nodeType === 8 ? i.parentNode : i), Ol(function () { km(o, B, h, y) }), B } function Rm(i, o, h, y, w) { var P = h._reactRootContainer; if (P) { var b = P; if (typeof w == "function") { var c = w; w = function () { var B = mm(b); c.call(B) } } km(o, b, i, w) } else b = KM(h, o, i, w, y); return mm(b) } db = function (i) { switch (i.tag) { case 3: var o = i.stateNode; if (o.current.memoizedState.isDehydrated) { var h = ed(o.pendingLanes); h !== 0 && (e0(o, h | 1), yi(o, tn()), !(Qt & 6) && (xc = tn() + 500, Ma())) } break; case 13: Ol(function () { var y = bo(i, 1); if (y !== null) { var w = ni(); gs(y, i, 1, w) } }), z0(i, 1) } }; t0 = function (i) { if (i.tag === 13) { var o = bo(i, 134217728); if (o !== null) { var h = ni(); gs(o, i, 134217728, h) } z0(i, 134217728) } }; pb = function (i) { if (i.tag === 13) { var o = wa(i), h = bo(i, o); if (h !== null) { var y = ni(); gs(h, i, o, y) } z0(i, o) } }; fb = function () { return dr }; mb = function (i, o) { var h = dr; try { return dr = i, o() } finally { dr = h } }; Q_ = function (i, o, h) { switch (o) { case "input": if (q_(i, h), o = h.name, h.type === "radio" && o != null) { for (h = i; h.parentNode;)h = h.parentNode; for (h = h.querySelectorAll("input[name=" + JSON.stringify("" + o) + '][type="radio"]'), o = 0; o < h.length; o++) { var y = h[o]; if (y !== i && y.form === i.form) { var w = Sm(y); if (!w) throw Error(st(90)); Zw(y), q_(y, w) } } } break; case "textarea": Hw(i, h); break; case "select": o = h.value, o != null && lc(i, !!h.multiple, o, !1) } }; tb = I0; rb = Ol; var QM = { usingClientEntryPoint: !1, Events: [Ld, tc, Sm, Jw, eb, I0] }, Hh = { findFiberByHostInstance: Ml, bundleType: 0, version: "18.3.1", rendererPackageName: "react-dom" }, JM = { bundleType: Hh.bundleType, version: Hh.version, rendererPackageName: Hh.rendererPackageName, rendererConfig: Hh.rendererConfig, overrideHookState: null, overrideHookStateDeletePath: null, overrideHookStateRenamePath: null, overrideProps: null, overridePropsDeletePath: null, overridePropsRenamePath: null, setErrorHandler: null, setSuspenseHandler: null, scheduleUpdate: null, currentDispatcherRef: Eo.ReactCurrentDispatcher, findHostInstanceByFiber: function (i) { return i = sb(i), i === null ? null : i.stateNode }, findFiberByHostInstance: Hh.findFiberByHostInstance || YM, findHostInstancesForRefresh: null, scheduleRefresh: null, scheduleRoot: null, setRefreshHandler: null, getCurrentFiber: null, reconcilerVersion: "18.3.1-next-f1338f8080-20240426" }; if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u") { var Cf = __REACT_DEVTOOLS_GLOBAL_HOOK__; if (!Cf.isDisabled && Cf.supportsFiber) try { xm = Cf.inject(JM), Ns = Cf } catch { } } Bi.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = QM; Bi.createPortal = function (i, o) { var h = 2 < arguments.length && arguments[2] !== void 0 ? arguments[2] : null; if (!L0(o)) throw Error(st(200)); return XM(i, o, null, h) }; Bi.createRoot = function (i, o) { if (!L0(i)) throw Error(st(299)); var h = !1, y = "", w = B2; return o != null && (o.unstable_strictMode === !0 && (h = !0), o.identifierPrefix !== void 0 && (y = o.identifierPrefix), o.onRecoverableError !== void 0 && (w = o.onRecoverableError)), o = D0(i, 1, !1, null, null, h, !1, y, w), i[wo] = o.current, bd(i.nodeType === 8 ? i.parentNode : i), new R0(o) }; Bi.findDOMNode = function (i) { if (i == null) return null; if (i.nodeType === 1) return i; var o = i._reactInternals; if (o === void 0) throw typeof i.render == "function" ? Error(st(188)) : (i = Object.keys(i).join(","), Error(st(268, i))); return i = sb(o), i = i === null ? null : i.stateNode, i }; Bi.flushSync = function (i) { return Ol(i) }; Bi.hydrate = function (i, o, h) { if (!zm(o)) throw Error(st(200)); return Rm(null, i, o, !0, h) }; Bi.hydrateRoot = function (i, o, h) { if (!L0(i)) throw Error(st(405)); var y = h != null && h.hydratedSources || null, w = !1, P = "", b = B2; if (h != null && (h.unstable_strictMode === !0 && (w = !0), h.identifierPrefix !== void 0 && (P = h.identifierPrefix), h.onRecoverableError !== void 0 && (b = h.onRecoverableError)), o = F2(o, null, i, 1, h ?? null, w, !1, P, b), i[wo] = o.current, bd(i), y) for (i = 0; i < y.length; i++)h = y[i], w = h._getVersion, w = w(h._source), o.mutableSourceEagerHydrationData == null ? o.mutableSourceEagerHydrationData = [h, w] : o.mutableSourceEagerHydrationData.push(h, w); return new Dm(o) }; Bi.render = function (i, o, h) { if (!zm(o)) throw Error(st(200)); return Rm(null, i, o, !1, h) }; Bi.unmountComponentAtNode = function (i) { if (!zm(i)) throw Error(st(40)); return i._reactRootContainer ? (Ol(function () { Rm(null, null, i, !1, function () { i._reactRootContainer = null, i[wo] = null }) }), !0) : !1 }; Bi.unstable_batchedUpdates = I0; Bi.unstable_renderSubtreeIntoContainer = function (i, o, h, y) { if (!zm(h)) throw Error(st(200)); if (i == null || i._reactInternals === void 0) throw Error(st(38)); return Rm(i, o, h, !1, y) }; Bi.version = "18.3.1-next-f1338f8080-20240426"; function O2() { if (!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE != "function")) try { __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(O2) } catch (i) { console.error(i) } } O2(), Ow.exports = Bi; var eI = Ow.exports, sw = eI; O_.createRoot = sw.createRoot, O_.hydrateRoot = sw.hydrateRoot; var N2 = { exports: {} };/**
 * MapLibre GL JS
 * @license 3-Clause BSD. Full text of license: https://github.com/maplibre/maplibre-gl-js/blob/v5.15.0/LICENSE.txt
 */(function (i, o) {
    (function (h, y) { i.exports = y() })(IE, function () {
        var h = {}, y = {}; function w(b, c, B) { if (y[b] = B, b === "index") { var $ = "var sharedModule = {}; (" + y.shared + ")(sharedModule); (" + y.worker + ")(sharedModule);", me = {}; return y.shared(me), y.index(h, me), typeof window < "u" && h.setWorkerUrl(window.URL.createObjectURL(new Blob([$], { type: "text/javascript" }))), h } } w("shared", ["exports"], function (b) {
            function c(n, e, r, a) { return new (r || (r = Promise))(function (u, p) { function f(S) { try { x(a.next(S)) } catch (M) { p(M) } } function _(S) { try { x(a.throw(S)) } catch (M) { p(M) } } function x(S) { var M; S.done ? u(S.value) : (M = S.value, M instanceof r ? M : new r(function (C) { C(M) })).then(f, _) } x((a = a.apply(n, e || [])).next()) }) } function B(n, e) { this.x = n, this.y = e } function $(n) { return n && n.__esModule && Object.prototype.hasOwnProperty.call(n, "default") ? n.default : n } var me, ge; typeof SuppressedError == "function" && SuppressedError, B.prototype = { clone() { return new B(this.x, this.y) }, add(n) { return this.clone()._add(n) }, sub(n) { return this.clone()._sub(n) }, multByPoint(n) { return this.clone()._multByPoint(n) }, divByPoint(n) { return this.clone()._divByPoint(n) }, mult(n) { return this.clone()._mult(n) }, div(n) { return this.clone()._div(n) }, rotate(n) { return this.clone()._rotate(n) }, rotateAround(n, e) { return this.clone()._rotateAround(n, e) }, matMult(n) { return this.clone()._matMult(n) }, unit() { return this.clone()._unit() }, perp() { return this.clone()._perp() }, round() { return this.clone()._round() }, mag() { return Math.sqrt(this.x * this.x + this.y * this.y) }, equals(n) { return this.x === n.x && this.y === n.y }, dist(n) { return Math.sqrt(this.distSqr(n)) }, distSqr(n) { const e = n.x - this.x, r = n.y - this.y; return e * e + r * r }, angle() { return Math.atan2(this.y, this.x) }, angleTo(n) { return Math.atan2(this.y - n.y, this.x - n.x) }, angleWith(n) { return this.angleWithSep(n.x, n.y) }, angleWithSep(n, e) { return Math.atan2(this.x * e - this.y * n, this.x * n + this.y * e) }, _matMult(n) { const e = n[2] * this.x + n[3] * this.y; return this.x = n[0] * this.x + n[1] * this.y, this.y = e, this }, _add(n) { return this.x += n.x, this.y += n.y, this }, _sub(n) { return this.x -= n.x, this.y -= n.y, this }, _mult(n) { return this.x *= n, this.y *= n, this }, _div(n) { return this.x /= n, this.y /= n, this }, _multByPoint(n) { return this.x *= n.x, this.y *= n.y, this }, _divByPoint(n) { return this.x /= n.x, this.y /= n.y, this }, _unit() { return this._div(this.mag()), this }, _perp() { const n = this.y; return this.y = this.x, this.x = -n, this }, _rotate(n) { const e = Math.cos(n), r = Math.sin(n), a = r * this.x + e * this.y; return this.x = e * this.x - r * this.y, this.y = a, this }, _rotateAround(n, e) { const r = Math.cos(n), a = Math.sin(n), u = e.y + a * (this.x - e.x) + r * (this.y - e.y); return this.x = e.x + r * (this.x - e.x) - a * (this.y - e.y), this.y = u, this }, _round() { return this.x = Math.round(this.x), this.y = Math.round(this.y), this }, constructor: B }, B.convert = function (n) { if (n instanceof B) return n; if (Array.isArray(n)) return new B(+n[0], +n[1]); if (n.x !== void 0 && n.y !== void 0) return new B(+n.x, +n.y); throw new Error("Expected [x, y] or {x, y} point format") }; var we = function () { if (ge) return me; function n(e, r, a, u) { this.cx = 3 * e, this.bx = 3 * (a - e) - this.cx, this.ax = 1 - this.cx - this.bx, this.cy = 3 * r, this.by = 3 * (u - r) - this.cy, this.ay = 1 - this.cy - this.by, this.p1x = e, this.p1y = r, this.p2x = a, this.p2y = u } return ge = 1, me = n, n.prototype = { sampleCurveX: function (e) { return ((this.ax * e + this.bx) * e + this.cx) * e }, sampleCurveY: function (e) { return ((this.ay * e + this.by) * e + this.cy) * e }, sampleCurveDerivativeX: function (e) { return (3 * this.ax * e + 2 * this.bx) * e + this.cx }, solveCurveX: function (e, r) { if (r === void 0 && (r = 1e-6), e < 0) return 0; if (e > 1) return 1; for (var a = e, u = 0; u < 8; u++) { var p = this.sampleCurveX(a) - e; if (Math.abs(p) < r) return a; var f = this.sampleCurveDerivativeX(a); if (Math.abs(f) < 1e-6) break; a -= p / f } var _ = 0, x = 1; for (a = e, u = 0; u < 20 && (p = this.sampleCurveX(a), !(Math.abs(p - e) < r)); u++)e > p ? _ = a : x = a, a = .5 * (x - _) + _; return a }, solve: function (e, r) { return this.sampleCurveY(this.solveCurveX(e, r)) } }, me }(), Ge = $(we); let Ye, $e; function ye() { return Ye == null && (Ye = typeof OffscreenCanvas < "u" && new OffscreenCanvas(1, 1).getContext("2d") && typeof createImageBitmap == "function"), Ye } function be() { if ($e == null && ($e = !1, ye())) { const e = new OffscreenCanvas(5, 5).getContext("2d", { willReadFrequently: !0 }); if (e) { for (let a = 0; a < 5 * 5; a++) { const u = 4 * a; e.fillStyle = `rgb(${u},${u + 1},${u + 2})`, e.fillRect(a % 5, Math.floor(a / 5), 1, 1) } const r = e.getImageData(0, 0, 5, 5).data; for (let a = 0; a < 5 * 5 * 4; a++)if (a % 4 != 3 && r[a] !== a) { $e = !0; break } } } return $e || !1 } var K = 1e-6, ve = typeof Float32Array < "u" ? Float32Array : Array; function Ke() { var n = new ve(9); return ve != Float32Array && (n[1] = 0, n[2] = 0, n[3] = 0, n[5] = 0, n[6] = 0, n[7] = 0), n[0] = 1, n[4] = 1, n[8] = 1, n } function ft(n) { return n[0] = 1, n[1] = 0, n[2] = 0, n[3] = 0, n[4] = 0, n[5] = 1, n[6] = 0, n[7] = 0, n[8] = 0, n[9] = 0, n[10] = 1, n[11] = 0, n[12] = 0, n[13] = 0, n[14] = 0, n[15] = 1, n } function mt() { var n = new ve(3); return ve != Float32Array && (n[0] = 0, n[1] = 0, n[2] = 0), n } function ct(n) { var e = n[0], r = n[1], a = n[2]; return Math.sqrt(e * e + r * r + a * a) } function Z(n, e, r) { var a = new ve(3); return a[0] = n, a[1] = e, a[2] = r, a } function re(n, e, r) { return n[0] = e[0] + r[0], n[1] = e[1] + r[1], n[2] = e[2] + r[2], n } function ie(n, e, r) { return n[0] = e[0] * r, n[1] = e[1] * r, n[2] = e[2] * r, n } function Ce(n, e, r) { var a = e[0], u = e[1], p = e[2], f = r[0], _ = r[1], x = r[2]; return n[0] = u * x - p * _, n[1] = p * f - a * x, n[2] = a * _ - u * f, n } var xe, Te = ct; function Ne(n, e, r) { var a = e[0], u = e[1], p = e[2], f = e[3]; return n[0] = r[0] * a + r[4] * u + r[8] * p + r[12] * f, n[1] = r[1] * a + r[5] * u + r[9] * p + r[13] * f, n[2] = r[2] * a + r[6] * u + r[10] * p + r[14] * f, n[3] = r[3] * a + r[7] * u + r[11] * p + r[15] * f, n } function _e() { var n = new ve(4); return ve != Float32Array && (n[0] = 0, n[1] = 0, n[2] = 0), n[3] = 1, n } function Me(n, e, r, a) { var u = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : "zyx", p = Math.PI / 360; e *= p, a *= p, r *= p; var f = Math.sin(e), _ = Math.cos(e), x = Math.sin(r), S = Math.cos(r), M = Math.sin(a), C = Math.cos(a); switch (u) { case "xyz": n[0] = f * S * C + _ * x * M, n[1] = _ * x * C - f * S * M, n[2] = _ * S * M + f * x * C, n[3] = _ * S * C - f * x * M; break; case "xzy": n[0] = f * S * C - _ * x * M, n[1] = _ * x * C - f * S * M, n[2] = _ * S * M + f * x * C, n[3] = _ * S * C + f * x * M; break; case "yxz": n[0] = f * S * C + _ * x * M, n[1] = _ * x * C - f * S * M, n[2] = _ * S * M - f * x * C, n[3] = _ * S * C + f * x * M; break; case "yzx": n[0] = f * S * C + _ * x * M, n[1] = _ * x * C + f * S * M, n[2] = _ * S * M - f * x * C, n[3] = _ * S * C - f * x * M; break; case "zxy": n[0] = f * S * C - _ * x * M, n[1] = _ * x * C + f * S * M, n[2] = _ * S * M + f * x * C, n[3] = _ * S * C - f * x * M; break; case "zyx": n[0] = f * S * C - _ * x * M, n[1] = _ * x * C + f * S * M, n[2] = _ * S * M - f * x * C, n[3] = _ * S * C + f * x * M; break; default: throw new Error("Unknown angle order " + u) }return n } function Le() { var n = new ve(2); return ve != Float32Array && (n[0] = 0, n[1] = 0), n } function de(n, e) { var r = new ve(2); return r[0] = n, r[1] = e, r } mt(), xe = new ve(4), ve != Float32Array && (xe[0] = 0, xe[1] = 0, xe[2] = 0, xe[3] = 0), mt(), Z(1, 0, 0), Z(0, 1, 0), _e(), _e(), Ke(), Le(); const Se = 8192; function et(n, e, r) { return e * (Se / (n.tileSize * Math.pow(2, r - n.tileID.overscaledZ))) } function lt(n, e) { return (n % e + e) % e } function Tt(n, e, r) { return n * (1 - r) + e * r } function Zt(n) { if (n <= 0) return 0; if (n >= 1) return 1; const e = n * n, r = e * n; return 4 * (n < .5 ? r : 3 * (n - e) + r - .75) } function Ut(n, e, r, a) { const u = new Ge(n, e, r, a); return p => u.solve(p) } const St = Ut(.25, .1, .25, 1); function Ct(n, e, r) { return Math.min(r, Math.max(e, n)) } function Yt(n, e, r) { const a = r - e, u = ((n - e) % a + a) % a + e; return u === e ? r : u } function Wr(n, ...e) { for (const r of e) for (const a in r) n[a] = r[a]; return n } let vi = 1; function In(n, e, r) { const a = {}; for (const u in n) a[u] = e.call(this, n[u], u, n); return a } function vn(n, e, r) { const a = {}; for (const u in n) e.call(this, n[u], u, n) && (a[u] = n[u]); return a } function dn(n) { return Array.isArray(n) ? n.map(dn) : typeof n == "object" && n ? In(n, dn) : n } const rn = {}; function qt(n) { rn[n] || (typeof console < "u" && console.warn(n), rn[n] = !0) } function Gt(n, e, r) { return (r.y - n.y) * (e.x - n.x) > (e.y - n.y) * (r.x - n.x) } function Ni(n) { return typeof WorkerGlobalScope < "u" && n !== void 0 && n instanceof WorkerGlobalScope } let Pr = null; function ys(n) { return typeof ImageBitmap < "u" && n instanceof ImageBitmap } const Us = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAC0lEQVQYV2NgAAIAAAUAAarVyFEAAAAASUVORK5CYII="; function Po(n, e, r, a, u) { return c(this, void 0, void 0, function* () { if (typeof VideoFrame > "u") throw new Error("VideoFrame not supported"); const p = new VideoFrame(n, { timestamp: 0 }); try { const f = p == null ? void 0 : p.format; if (!f || !f.startsWith("BGR") && !f.startsWith("RGB")) throw new Error(`Unrecognized format ${f}`); const _ = f.startsWith("BGR"), x = new Uint8ClampedArray(a * u * 4); if (yield p.copyTo(x, function (S, M, C, k, D) { const L = 4 * Math.max(-M, 0), F = (Math.max(0, C) - C) * k * 4 + L, N = 4 * k, G = Math.max(0, M), ee = Math.max(0, C); return { rect: { x: G, y: ee, width: Math.min(S.width, M + k) - G, height: Math.min(S.height, C + D) - ee }, layout: [{ offset: F, stride: N }] } }(n, e, r, a, u)), _) for (let S = 0; S < x.length; S += 4) { const M = x[S]; x[S] = x[S + 2], x[S + 2] = M } return x } finally { p.close() } }) } let vs, xi; function Mo(n, e, r, a) { return n.addEventListener(e, r, a), { unsubscribe: () => { n.removeEventListener(e, r, a) } } } function Io(n) { return n * Math.PI / 180 } function jn(n) { return n / Math.PI * 180 } const Pe = { touchstart: !0, touchmove: !0, touchmoveWindow: !0, touchend: !0, touchcancel: !0 }, V = { dblclick: !0, click: !0, mouseover: !0, mouseout: !0, mousedown: !0, mousemove: !0, mousemoveWindow: !0, mouseup: !0, mouseupWindow: !0, contextmenu: !0, wheel: !0 }, j = "AbortError"; class W extends Error { constructor(e = j) { super(e instanceof Error ? e.message : e), this.name = j, e instanceof Error && e.stack && (this.stack = e.stack) } } function ue(n) { return n.name === j } const he = { MAX_PARALLEL_IMAGE_REQUESTS: 16, MAX_PARALLEL_IMAGE_REQUESTS_PER_FRAME: 8, MAX_TILE_CACHE_ZOOM_LEVELS: 5, REGISTERED_PROTOCOLS: {}, WORKER_URL: "" }; function Ae(n) { return he.REGISTERED_PROTOCOLS[n.substring(0, n.indexOf("://"))] } const Ee = "global-dispatcher"; class pe extends Error { constructor(e, r, a, u) { super(`AJAXError: ${r} (${e}): ${a}`), this.status = e, this.statusText = r, this.url = a, this.body = u } } const Be = () => Ni(self) ? self.worker && self.worker.referrer : (window.location.protocol === "blob:" ? window.parent : window).location.href, Xe = function (n, e) { if (/:\/\//.test(n.url) && !/^https?:|^file:/.test(n.url)) { const a = Ae(n.url); if (a) return a(n, e); if (Ni(self) && self.worker && self.worker.actor) return self.worker.actor.sendAsync({ type: "GR", data: n, targetMapId: Ee }, e) } if (!(/^file:/.test(r = n.url) || /^file:/.test(Be()) && !/^\w+:/.test(r))) { if (fetch && Request && AbortController && Object.prototype.hasOwnProperty.call(Request.prototype, "signal")) return function (a, u) { return c(this, void 0, void 0, function* () { const p = new Request(a.url, { method: a.method || "GET", body: a.body, credentials: a.credentials, headers: a.headers, cache: a.cache, referrer: Be(), signal: u.signal }); let f, _; a.type !== "json" || p.headers.has("Accept") || p.headers.set("Accept", "application/json"); try { f = yield fetch(p) } catch (S) { throw ue(S) ? S : new pe(0, S.message, a.url, new Blob) } if (!f.ok) { const S = yield f.blob(); throw new pe(f.status, f.statusText, a.url, S) } _ = a.type === "arrayBuffer" || a.type === "image" ? f.arrayBuffer() : a.type === "json" ? f.json() : f.text(); const x = yield _; return u.signal.throwIfAborted(), { data: x, cacheControl: f.headers.get("Cache-Control"), expires: f.headers.get("Expires") } }) }(n, e); if (Ni(self) && self.worker && self.worker.actor) return self.worker.actor.sendAsync({ type: "GR", data: n, mustQueue: !0, targetMapId: Ee }, e) } var r; return function (a, u) { return new Promise((p, f) => { var _; const x = new XMLHttpRequest; x.open(a.method || "GET", a.url, !0), a.type !== "arrayBuffer" && a.type !== "image" || (x.responseType = "arraybuffer"); for (const S in a.headers) x.setRequestHeader(S, a.headers[S]); a.type === "json" && (x.responseType = "text", !((_ = a.headers) === null || _ === void 0) && _.Accept || x.setRequestHeader("Accept", "application/json")), x.withCredentials = a.credentials === "include", x.onerror = () => { f(new Error(x.statusText)) }, x.onload = () => { if (!u.signal.aborted) if ((x.status >= 200 && x.status < 300 || x.status === 0) && x.response !== null) { let S = x.response; if (a.type === "json") try { S = JSON.parse(x.response) } catch (M) { return void f(M) } p({ data: S, cacheControl: x.getResponseHeader("Cache-Control"), expires: x.getResponseHeader("Expires") }) } else { const S = new Blob([x.response], { type: x.getResponseHeader("Content-Type") }); f(new pe(x.status, x.statusText, a.url, S)) } }, u.signal.addEventListener("abort", () => { x.abort(), f(new W(u.signal.reason)) }), x.send(a.body) }) }(n, e) }; function qe(n) { if (!n || n.indexOf("://") <= 0 || n.indexOf("data:image/") === 0 || n.indexOf("blob:") === 0) return !0; const e = new URL(n), r = window.location; return e.protocol === r.protocol && e.host === r.host } function ht(n, e, r) { r[n] && r[n].indexOf(e) !== -1 || (r[n] = r[n] || [], r[n].push(e)) } function yt(n, e, r) { if (r && r[n]) { const a = r[n].indexOf(e); a !== -1 && r[n].splice(a, 1) } } class Pt { constructor(e, r = {}) { Wr(this, r), this.type = e } } class tr extends Pt { constructor(e, r = {}) { super("error", Wr({ error: e }, r)) } } class Wt { on(e, r) { return this._listeners = this._listeners || {}, ht(e, r, this._listeners), { unsubscribe: () => { this.off(e, r) } } } off(e, r) { return yt(e, r, this._listeners), yt(e, r, this._oneTimeListeners), this } once(e, r) { return r ? (this._oneTimeListeners = this._oneTimeListeners || {}, ht(e, r, this._oneTimeListeners), this) : new Promise(a => this.once(e, a)) } fire(e, r) { typeof e == "string" && (e = new Pt(e, r || {})); const a = e.type; if (this.listens(a)) { e.target = this; const u = this._listeners && this._listeners[a] ? this._listeners[a].slice() : []; for (const _ of u) _.call(this, e); const p = this._oneTimeListeners && this._oneTimeListeners[a] ? this._oneTimeListeners[a].slice() : []; for (const _ of p) yt(a, _, this._oneTimeListeners), _.call(this, e); const f = this._eventedParent; f && (Wr(e, typeof this._eventedParentData == "function" ? this._eventedParentData() : this._eventedParentData), f.fire(e)) } else e instanceof tr && console.error(e.error); return this } listens(e) { return this._listeners && this._listeners[e] && this._listeners[e].length > 0 || this._oneTimeListeners && this._oneTimeListeners[e] && this._oneTimeListeners[e].length > 0 || this._eventedParent && this._eventedParent.listens(e) } setEventedParent(e, r) { return this._eventedParent = e, this._eventedParentData = r, this } } var De = { $version: 8, $root: { version: { required: !0, type: "enum", values: [8] }, name: { type: "string" }, metadata: { type: "*" }, center: { type: "array", value: "number", length: 2 }, centerAltitude: { type: "number" }, zoom: { type: "number" }, bearing: { type: "number", default: 0, period: 360, units: "degrees" }, pitch: { type: "number", default: 0, units: "degrees" }, roll: { type: "number", default: 0, units: "degrees" }, state: { type: "state", default: {} }, light: { type: "light" }, sky: { type: "sky" }, projection: { type: "projection" }, terrain: { type: "terrain" }, sources: { required: !0, type: "sources" }, sprite: { type: "sprite" }, glyphs: { type: "string" }, "font-faces": { type: "fontFaces" }, transition: { type: "transition" }, layers: { required: !0, type: "array", value: "layer" } }, sources: { "*": { type: "source" } }, source: ["source_vector", "source_raster", "source_raster_dem", "source_geojson", "source_video", "source_image"], source_vector: { type: { required: !0, type: "enum", values: { vector: {} } }, url: { type: "string" }, tiles: { type: "array", value: "string" }, bounds: { type: "array", value: "number", length: 4, default: [-180, -85.051129, 180, 85.051129] }, scheme: { type: "enum", values: { xyz: {}, tms: {} }, default: "xyz" }, minzoom: { type: "number", default: 0 }, maxzoom: { type: "number", default: 22 }, attribution: { type: "string" }, promoteId: { type: "promoteId" }, volatile: { type: "boolean", default: !1 }, encoding: { type: "enum", values: { mvt: {}, mlt: {} }, default: "mvt" }, "*": { type: "*" } }, source_raster: { type: { required: !0, type: "enum", values: { raster: {} } }, url: { type: "string" }, tiles: { type: "array", value: "string" }, bounds: { type: "array", value: "number", length: 4, default: [-180, -85.051129, 180, 85.051129] }, minzoom: { type: "number", default: 0 }, maxzoom: { type: "number", default: 22 }, tileSize: { type: "number", default: 512, units: "pixels" }, scheme: { type: "enum", values: { xyz: {}, tms: {} }, default: "xyz" }, attribution: { type: "string" }, volatile: { type: "boolean", default: !1 }, "*": { type: "*" } }, source_raster_dem: { type: { required: !0, type: "enum", values: { "raster-dem": {} } }, url: { type: "string" }, tiles: { type: "array", value: "string" }, bounds: { type: "array", value: "number", length: 4, default: [-180, -85.051129, 180, 85.051129] }, minzoom: { type: "number", default: 0 }, maxzoom: { type: "number", default: 22 }, tileSize: { type: "number", default: 512, units: "pixels" }, attribution: { type: "string" }, encoding: { type: "enum", values: { terrarium: {}, mapbox: {}, custom: {} }, default: "mapbox" }, redFactor: { type: "number", default: 1 }, blueFactor: { type: "number", default: 1 }, greenFactor: { type: "number", default: 1 }, baseShift: { type: "number", default: 0 }, volatile: { type: "boolean", default: !1 }, "*": { type: "*" } }, source_geojson: { type: { required: !0, type: "enum", values: { geojson: {} } }, data: { required: !0, type: "*" }, maxzoom: { type: "number", default: 18 }, attribution: { type: "string" }, buffer: { type: "number", default: 128, maximum: 512, minimum: 0 }, filter: { type: "filter" }, tolerance: { type: "number", default: .375 }, cluster: { type: "boolean", default: !1 }, clusterRadius: { type: "number", default: 50, minimum: 0 }, clusterMaxZoom: { type: "number" }, clusterMinPoints: { type: "number" }, clusterProperties: { type: "*" }, lineMetrics: { type: "boolean", default: !1 }, generateId: { type: "boolean", default: !1 }, promoteId: { type: "promoteId" } }, source_video: { type: { required: !0, type: "enum", values: { video: {} } }, urls: { required: !0, type: "array", value: "string" }, coordinates: { required: !0, type: "array", length: 4, value: { type: "array", length: 2, value: "number" } } }, source_image: { type: { required: !0, type: "enum", values: { image: {} } }, url: { required: !0, type: "string" }, coordinates: { required: !0, type: "array", length: 4, value: { type: "array", length: 2, value: "number" } } }, layer: { id: { type: "string", required: !0 }, type: { type: "enum", values: { fill: {}, line: {}, symbol: {}, circle: {}, heatmap: {}, "fill-extrusion": {}, raster: {}, hillshade: {}, "color-relief": {}, background: {} }, required: !0 }, metadata: { type: "*" }, source: { type: "string" }, "source-layer": { type: "string" }, minzoom: { type: "number", minimum: 0, maximum: 24 }, maxzoom: { type: "number", minimum: 0, maximum: 24 }, filter: { type: "filter" }, layout: { type: "layout" }, paint: { type: "paint" } }, layout: ["layout_fill", "layout_line", "layout_circle", "layout_heatmap", "layout_fill-extrusion", "layout_symbol", "layout_raster", "layout_hillshade", "layout_color-relief", "layout_background"], layout_background: { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", expression: { interpolated: !1, parameters: ["global-state"] }, "property-type": "data-constant" } }, layout_fill: { "fill-sort-key": { type: "number", expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", expression: { interpolated: !1, parameters: ["global-state"] }, "property-type": "data-constant" } }, layout_circle: { "circle-sort-key": { type: "number", expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", expression: { interpolated: !1, parameters: ["global-state"] }, "property-type": "data-constant" } }, layout_heatmap: { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", expression: { interpolated: !1, parameters: ["global-state"] }, "property-type": "data-constant" } }, "layout_fill-extrusion": { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", expression: { interpolated: !1, parameters: ["global-state"] }, "property-type": "data-constant" } }, layout_line: { "line-cap": { type: "enum", values: { butt: {}, round: {}, square: {} }, default: "butt", expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "line-join": { type: "enum", values: { bevel: {}, round: {}, miter: {} }, default: "miter", expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "line-miter-limit": { type: "number", default: 2, requires: [{ "line-join": "miter" }], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "line-round-limit": { type: "number", default: 1.05, requires: [{ "line-join": "round" }], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "line-sort-key": { type: "number", expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", expression: { interpolated: !1, parameters: ["global-state"] }, "property-type": "data-constant" } }, layout_symbol: { "symbol-placement": { type: "enum", values: { point: {}, line: {}, "line-center": {} }, default: "point", expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "symbol-spacing": { type: "number", default: 250, minimum: 1, units: "pixels", requires: [{ "symbol-placement": "line" }], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "symbol-avoid-edges": { type: "boolean", default: !1, expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "symbol-sort-key": { type: "number", expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "symbol-z-order": { type: "enum", values: { auto: {}, "viewport-y": {}, source: {} }, default: "auto", expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-allow-overlap": { type: "boolean", default: !1, requires: ["icon-image", { "!": "icon-overlap" }], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-overlap": { type: "enum", values: { never: {}, always: {}, cooperative: {} }, requires: ["icon-image"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-ignore-placement": { type: "boolean", default: !1, requires: ["icon-image"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-optional": { type: "boolean", default: !1, requires: ["icon-image", "text-field"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-rotation-alignment": { type: "enum", values: { map: {}, viewport: {}, auto: {} }, default: "auto", requires: ["icon-image"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-size": { type: "number", default: 1, minimum: 0, units: "factor of the original icon size", requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-text-fit": { type: "enum", values: { none: {}, width: {}, height: {}, both: {} }, default: "none", requires: ["icon-image", "text-field"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-text-fit-padding": { type: "array", value: "number", length: 4, default: [0, 0, 0, 0], units: "pixels", requires: ["icon-image", "text-field", { "icon-text-fit": ["both", "width", "height"] }], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-image": { type: "resolvedImage", tokens: !0, expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-rotate": { type: "number", default: 0, period: 360, units: "degrees", requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-padding": { type: "padding", default: [2], units: "pixels", requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-keep-upright": { type: "boolean", default: !1, requires: ["icon-image", { "icon-rotation-alignment": "map" }, { "symbol-placement": ["line", "line-center"] }], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-offset": { type: "array", value: "number", length: 2, default: [0, 0], requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-anchor": { type: "enum", values: { center: {}, left: {}, right: {}, top: {}, bottom: {}, "top-left": {}, "top-right": {}, "bottom-left": {}, "bottom-right": {} }, default: "center", requires: ["icon-image"], expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-pitch-alignment": { type: "enum", values: { map: {}, viewport: {}, auto: {} }, default: "auto", requires: ["icon-image"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-pitch-alignment": { type: "enum", values: { map: {}, viewport: {}, auto: {} }, default: "auto", requires: ["text-field"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-rotation-alignment": { type: "enum", values: { map: {}, viewport: {}, "viewport-glyph": {}, auto: {} }, default: "auto", requires: ["text-field"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-field": { type: "formatted", default: "", tokens: !0, expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-font": { type: "array", value: "string", default: ["Open Sans Regular", "Arial Unicode MS Regular"], requires: ["text-field"], expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-size": { type: "number", default: 16, minimum: 0, units: "pixels", requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-max-width": { type: "number", default: 10, minimum: 0, units: "ems", requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-line-height": { type: "number", default: 1.2, units: "ems", requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-letter-spacing": { type: "number", default: 0, units: "ems", requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-justify": { type: "enum", values: { auto: {}, left: {}, center: {}, right: {} }, default: "center", requires: ["text-field"], expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-radial-offset": { type: "number", units: "ems", default: 0, requires: ["text-field"], "property-type": "data-driven", expression: { interpolated: !0, parameters: ["zoom", "feature"] } }, "text-variable-anchor": { type: "array", value: "enum", values: { center: {}, left: {}, right: {}, top: {}, bottom: {}, "top-left": {}, "top-right": {}, "bottom-left": {}, "bottom-right": {} }, requires: ["text-field", { "symbol-placement": ["point"] }], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-variable-anchor-offset": { type: "variableAnchorOffsetCollection", requires: ["text-field", { "symbol-placement": ["point"] }], expression: { interpolated: !0, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-anchor": { type: "enum", values: { center: {}, left: {}, right: {}, top: {}, bottom: {}, "top-left": {}, "top-right": {}, "bottom-left": {}, "bottom-right": {} }, default: "center", requires: ["text-field", { "!": "text-variable-anchor" }], expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-max-angle": { type: "number", default: 45, units: "degrees", requires: ["text-field", { "symbol-placement": ["line", "line-center"] }], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-writing-mode": { type: "array", value: "enum", values: { horizontal: {}, vertical: {} }, requires: ["text-field", { "symbol-placement": ["point"] }], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-rotate": { type: "number", default: 0, period: 360, units: "degrees", requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-padding": { type: "number", default: 2, minimum: 0, units: "pixels", requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-keep-upright": { type: "boolean", default: !0, requires: ["text-field", { "text-rotation-alignment": "map" }, { "symbol-placement": ["line", "line-center"] }], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-transform": { type: "enum", values: { none: {}, uppercase: {}, lowercase: {} }, default: "none", requires: ["text-field"], expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-offset": { type: "array", value: "number", units: "ems", length: 2, default: [0, 0], requires: ["text-field", { "!": "text-radial-offset" }], expression: { interpolated: !0, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-allow-overlap": { type: "boolean", default: !1, requires: ["text-field", { "!": "text-overlap" }], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-overlap": { type: "enum", values: { never: {}, always: {}, cooperative: {} }, requires: ["text-field"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-ignore-placement": { type: "boolean", default: !1, requires: ["text-field"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-optional": { type: "boolean", default: !1, requires: ["text-field", "icon-image"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", expression: { interpolated: !1, parameters: ["global-state"] }, "property-type": "data-constant" } }, layout_raster: { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", expression: { interpolated: !1, parameters: ["global-state"] }, "property-type": "data-constant" } }, layout_hillshade: { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", expression: { interpolated: !1, parameters: ["global-state"] }, "property-type": "data-constant" } }, "layout_color-relief": { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", expression: { interpolated: !1, parameters: ["global-state"] }, "property-type": "data-constant" } }, filter: { type: "boolean", expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, filter_operator: { type: "enum", values: { "==": {}, "!=": {}, ">": {}, ">=": {}, "<": {}, "<=": {}, in: {}, "!in": {}, all: {}, any: {}, none: {}, has: {}, "!has": {} } }, geometry_type: { type: "enum", values: { Point: {}, LineString: {}, Polygon: {} } }, function: { expression: { type: "expression" }, stops: { type: "array", value: "function_stop" }, base: { type: "number", default: 1, minimum: 0 }, property: { type: "string", default: "$zoom" }, type: { type: "enum", values: { identity: {}, exponential: {}, interval: {}, categorical: {} }, default: "exponential" }, colorSpace: { type: "enum", values: { rgb: {}, lab: {}, hcl: {} }, default: "rgb" }, default: { type: "*", required: !1 } }, function_stop: { type: "array", minimum: 0, maximum: 24, value: ["number", "color"], length: 2 }, expression: { type: "array", value: "expression_name", minimum: 1 }, light: { anchor: { type: "enum", default: "viewport", values: { map: {}, viewport: {} }, "property-type": "data-constant", transition: !1, expression: { interpolated: !1, parameters: ["zoom"] } }, position: { type: "array", default: [1.15, 210, 30], length: 3, value: "number", "property-type": "data-constant", transition: !0, expression: { interpolated: !0, parameters: ["zoom"] } }, color: { type: "color", "property-type": "data-constant", default: "#ffffff", expression: { interpolated: !0, parameters: ["zoom"] }, transition: !0 }, intensity: { type: "number", "property-type": "data-constant", default: .5, minimum: 0, maximum: 1, expression: { interpolated: !0, parameters: ["zoom"] }, transition: !0 } }, sky: { "sky-color": { type: "color", "property-type": "data-constant", default: "#88C6FC", expression: { interpolated: !0, parameters: ["zoom"] }, transition: !0 }, "horizon-color": { type: "color", "property-type": "data-constant", default: "#ffffff", expression: { interpolated: !0, parameters: ["zoom"] }, transition: !0 }, "fog-color": { type: "color", "property-type": "data-constant", default: "#ffffff", expression: { interpolated: !0, parameters: ["zoom"] }, transition: !0 }, "fog-ground-blend": { type: "number", "property-type": "data-constant", default: .5, minimum: 0, maximum: 1, expression: { interpolated: !0, parameters: ["zoom"] }, transition: !0 }, "horizon-fog-blend": { type: "number", "property-type": "data-constant", default: .8, minimum: 0, maximum: 1, expression: { interpolated: !0, parameters: ["zoom"] }, transition: !0 }, "sky-horizon-blend": { type: "number", "property-type": "data-constant", default: .8, minimum: 0, maximum: 1, expression: { interpolated: !0, parameters: ["zoom"] }, transition: !0 }, "atmosphere-blend": { type: "number", "property-type": "data-constant", default: .8, minimum: 0, maximum: 1, expression: { interpolated: !0, parameters: ["zoom"] }, transition: !0 } }, terrain: { source: { type: "string", required: !0 }, exaggeration: { type: "number", minimum: 0, default: 1 } }, projection: { type: { type: "projectionDefinition", default: "mercator", "property-type": "data-constant", transition: !1, expression: { interpolated: !0, parameters: ["zoom"] } } }, paint: ["paint_fill", "paint_line", "paint_circle", "paint_heatmap", "paint_fill-extrusion", "paint_symbol", "paint_raster", "paint_hillshade", "paint_color-relief", "paint_background"], paint_fill: { "fill-antialias": { type: "boolean", default: !0, expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-color": { type: "color", default: "#000000", transition: !0, requires: [{ "!": "fill-pattern" }], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-outline-color": { type: "color", transition: !0, requires: [{ "!": "fill-pattern" }, { "fill-antialias": !0 }], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["fill-translate"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-pattern": { type: "resolvedImage", transition: !0, expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "cross-faded-data-driven" } }, "paint_fill-extrusion": { "fill-extrusion-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-extrusion-color": { type: "color", default: "#000000", transition: !0, requires: [{ "!": "fill-extrusion-pattern" }], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-extrusion-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-extrusion-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["fill-extrusion-translate"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-extrusion-pattern": { type: "resolvedImage", transition: !0, expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "cross-faded-data-driven" }, "fill-extrusion-height": { type: "number", default: 0, minimum: 0, units: "meters", transition: !0, expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-extrusion-base": { type: "number", default: 0, minimum: 0, units: "meters", transition: !0, requires: ["fill-extrusion-height"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-extrusion-vertical-gradient": { type: "boolean", default: !0, transition: !1, expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" } }, paint_line: { "line-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-color": { type: "color", default: "#000000", transition: !0, requires: [{ "!": "line-pattern" }], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "line-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["line-translate"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "line-width": { type: "number", default: 1, minimum: 0, transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-gap-width": { type: "number", default: 0, minimum: 0, transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-offset": { type: "number", default: 0, transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-blur": { type: "number", default: 0, minimum: 0, transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-dasharray": { type: "array", value: "number", minimum: 0, transition: !0, units: "line widths", requires: [{ "!": "line-pattern" }], expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "cross-faded-data-driven" }, "line-pattern": { type: "resolvedImage", transition: !0, expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "cross-faded-data-driven" }, "line-gradient": { type: "color", transition: !1, requires: [{ "!": "line-dasharray" }, { "!": "line-pattern" }, { source: "geojson", has: { lineMetrics: !0 } }], expression: { interpolated: !0, parameters: ["line-progress"] }, "property-type": "color-ramp" } }, paint_circle: { "circle-radius": { type: "number", default: 5, minimum: 0, transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-color": { type: "color", default: "#000000", transition: !0, expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-blur": { type: "number", default: 0, transition: !0, expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "circle-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["circle-translate"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "circle-pitch-scale": { type: "enum", values: { map: {}, viewport: {} }, default: "map", expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "circle-pitch-alignment": { type: "enum", values: { map: {}, viewport: {} }, default: "viewport", expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "circle-stroke-width": { type: "number", default: 0, minimum: 0, transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-stroke-color": { type: "color", default: "#000000", transition: !0, expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-stroke-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" } }, paint_heatmap: { "heatmap-radius": { type: "number", default: 30, minimum: 1, transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "heatmap-weight": { type: "number", default: 1, minimum: 0, transition: !1, expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "heatmap-intensity": { type: "number", default: 1, minimum: 0, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "heatmap-color": { type: "color", default: ["interpolate", ["linear"], ["heatmap-density"], 0, "rgba(0, 0, 255, 0)", .1, "royalblue", .3, "cyan", .5, "lime", .7, "yellow", 1, "red"], transition: !1, expression: { interpolated: !0, parameters: ["heatmap-density"] }, "property-type": "color-ramp" }, "heatmap-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" } }, paint_symbol: { "icon-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "icon-color": { type: "color", default: "#000000", transition: !0, requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "icon-halo-color": { type: "color", default: "rgba(0, 0, 0, 0)", transition: !0, requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "icon-halo-width": { type: "number", default: 0, minimum: 0, transition: !0, units: "pixels", requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "icon-halo-blur": { type: "number", default: 0, minimum: 0, transition: !0, units: "pixels", requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "icon-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: !0, units: "pixels", requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["icon-image", "icon-translate"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "text-color": { type: "color", default: "#000000", transition: !0, overridable: !0, requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "text-halo-color": { type: "color", default: "rgba(0, 0, 0, 0)", transition: !0, requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "text-halo-width": { type: "number", default: 0, minimum: 0, transition: !0, units: "pixels", requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "text-halo-blur": { type: "number", default: 0, minimum: 0, transition: !0, units: "pixels", requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "text-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: !0, units: "pixels", requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["text-field", "text-translate"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" } }, paint_raster: { "raster-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-hue-rotate": { type: "number", default: 0, period: 360, transition: !0, units: "degrees", expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-brightness-min": { type: "number", default: 0, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-brightness-max": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-saturation": { type: "number", default: 0, minimum: -1, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-contrast": { type: "number", default: 0, minimum: -1, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-resampling": { type: "enum", values: { linear: {}, nearest: {} }, default: "linear", expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-fade-duration": { type: "number", default: 300, minimum: 0, transition: !1, units: "milliseconds", expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" } }, paint_hillshade: { "hillshade-illumination-direction": { type: "numberArray", default: 335, minimum: 0, maximum: 359, transition: !1, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-illumination-altitude": { type: "numberArray", default: 45, minimum: 0, maximum: 90, transition: !1, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-illumination-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "viewport", expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-exaggeration": { type: "number", default: .5, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-shadow-color": { type: "colorArray", default: "#000000", transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-highlight-color": { type: "colorArray", default: "#FFFFFF", transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-accent-color": { type: "color", default: "#000000", transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-method": { type: "enum", values: { standard: {}, basic: {}, combined: {}, igor: {}, multidirectional: {} }, default: "standard", expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" } }, "paint_color-relief": { "color-relief-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "color-relief-color": { type: "color", transition: !1, expression: { interpolated: !0, parameters: ["elevation"] }, "property-type": "color-ramp" } }, paint_background: { "background-color": { type: "color", default: "#000000", transition: !0, requires: [{ "!": "background-pattern" }], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "background-pattern": { type: "resolvedImage", transition: !0, expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "cross-faded" }, "background-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" } }, transition: { duration: { type: "number", default: 300, minimum: 0, units: "milliseconds" }, delay: { type: "number", default: 0, minimum: 0, units: "milliseconds" } }, "property-type": { "data-driven": { type: "property-type" }, "cross-faded": { type: "property-type" }, "cross-faded-data-driven": { type: "property-type" }, "color-ramp": { type: "property-type" }, "data-constant": { type: "property-type" }, constant: { type: "property-type" } }, promoteId: { "*": { type: "string" } }, interpolation: { type: "array", value: "interpolation_name", minimum: 1 }, interpolation_name: { type: "enum", values: { linear: { syntax: { overloads: [{ parameters: [], "output-type": "interpolation" }], parameters: [] } }, exponential: { syntax: { overloads: [{ parameters: ["base"], "output-type": "interpolation" }], parameters: [{ name: "base", type: "number literal" }] } }, "cubic-bezier": { syntax: { overloads: [{ parameters: ["x1", "y1", "x2", "y2"], "output-type": "interpolation" }], parameters: [{ name: "x1", type: "number literal" }, { name: "y1", type: "number literal" }, { name: "x2", type: "number literal" }, { name: "y2", type: "number literal" }] } } } } }; const nr = ["type", "source", "source-layer", "minzoom", "maxzoom", "filter", "layout"]; function pn(n, e) { const r = {}; for (const a in n) a !== "ref" && (r[a] = n[a]); return nr.forEach(a => { a in e && (r[a] = e[a]) }), r } function Mt(n, e) { if (Array.isArray(n)) { if (!Array.isArray(e) || n.length !== e.length) return !1; for (let r = 0; r < n.length; r++)if (!Mt(n[r], e[r])) return !1; return !0 } if (typeof n == "object" && n !== null && e !== null) { if (typeof e != "object" || Object.keys(n).length !== Object.keys(e).length) return !1; for (const r in n) if (!Mt(n[r], e[r])) return !1; return !0 } return n === e } function Jt(n, e) { n.push(e) } function fn(n, e, r) { Jt(r, { command: "addSource", args: [n, e[n]] }) } function pr(n, e, r) { Jt(e, { command: "removeSource", args: [n] }), r[n] = !0 } function Mr(n, e, r, a) { pr(n, r, a), fn(n, e, r) } function ir(n, e, r) { let a; for (a in n[r]) if (Object.prototype.hasOwnProperty.call(n[r], a) && a !== "data" && !Mt(n[r][a], e[r][a])) return !1; for (a in e[r]) if (Object.prototype.hasOwnProperty.call(e[r], a) && a !== "data" && !Mt(n[r][a], e[r][a])) return !1; return !0 } function Hr(n, e, r, a, u, p) { n = n || {}, e = e || {}; for (const f in n) Object.prototype.hasOwnProperty.call(n, f) && (Mt(n[f], e[f]) || r.push({ command: p, args: [a, f, e[f], u] })); for (const f in e) Object.prototype.hasOwnProperty.call(e, f) && !Object.prototype.hasOwnProperty.call(n, f) && (Mt(n[f], e[f]) || r.push({ command: p, args: [a, f, e[f], u] })) } function Ia(n) { return n.id } function Ca(n, e) { return n[e.id] = e, n } class Qe { constructor(e, r, a, u) { this.message = (e ? `${e}: ` : "") + a, u && (this.identifier = u), r != null && r.__line__ && (this.line = r.__line__) } } function Cn(n, ...e) { for (const r of e) for (const a in r) n[a] = r[a]; return n } class An extends Error { constructor(e, r) { super(r), this.message = r, this.key = e } } class Ul { constructor(e, r = []) { this.parent = e, this.bindings = {}; for (const [a, u] of r) this.bindings[a] = u } concat(e) { return new Ul(this, e) } get(e) { if (this.bindings[e]) return this.bindings[e]; if (this.parent) return this.parent.get(e); throw new Error(`${e} not found in scope.`) } has(e) { return !!this.bindings[e] || !!this.parent && this.parent.has(e) } } const oi = { kind: "null" }, at = { kind: "number" }, Dt = { kind: "string" }, zt = { kind: "boolean" }, Yn = { kind: "color" }, Gl = { kind: "projectionDefinition" }, es = { kind: "object" }, At = { kind: "value" }, Aa = { kind: "collator" }, ka = { kind: "formatted" }, $l = { kind: "padding" }, Co = { kind: "colorArray" }, Da = { kind: "numberArray" }, Ao = { kind: "resolvedImage" }, za = { kind: "variableAnchorOffsetCollection" }; function kn(n, e) { return { kind: "array", itemType: n, N: e } } function er(n) { if (n.kind === "array") { const e = er(n.itemType); return typeof n.N == "number" ? `array<${e}, ${n.N}>` : n.itemType.kind === "value" ? "array" : `array<${e}>` } return n.kind } const ql = [oi, at, Dt, zt, Yn, Gl, ka, es, kn(At), $l, Da, Co, Ao, za]; function ko(n, e) { if (e.kind === "error") return null; if (n.kind === "array") { if (e.kind === "array" && (e.N === 0 && e.itemType.kind === "value" || !ko(n.itemType, e.itemType)) && (typeof n.N != "number" || n.N === e.N)) return null } else { if (n.kind === e.kind) return null; if (n.kind === "value") { for (const r of ql) if (!ko(r, e)) return null } } return `Expected ${er(n)} but found ${er(e)} instead.` } function Ra(n, e) { return e.some(r => r.kind === n.kind) } function Gs(n, e) { return e.some(r => r === "null" ? n === null : r === "array" ? Array.isArray(n) : r === "object" ? n && !Array.isArray(n) && typeof n == "object" : r === typeof n) } function wi(n, e) { return n.kind === "array" && e.kind === "array" ? n.itemType.kind === e.itemType.kind && typeof n.N == "number" : n.kind === e.kind } const Bd = .96422, $s = .82521, Zl = 4 / 29, Ir = 6 / 29, Od = 3 * Ir * Ir, Nd = Ir * Ir * Ir, La = Math.PI / 180, jd = 180 / Math.PI; function Vd(n) { return (n %= 360) < 0 && (n += 360), n } function Ud([n, e, r, a]) { let u, p; const f = Pc((.2225045 * (n = Wl(n)) + .7168786 * (e = Wl(e)) + .0606169 * (r = Wl(r))) / 1); n === e && e === r ? u = p = f : (u = Pc((.4360747 * n + .3850649 * e + .1430804 * r) / Bd), p = Pc((.0139322 * n + .0971045 * e + .7141733 * r) / $s)); const _ = 116 * f - 16; return [_ < 0 ? 0 : _, 500 * (u - f), 200 * (f - p), a] } function Wl(n) { return n <= .04045 ? n / 12.92 : Math.pow((n + .055) / 1.055, 2.4) } function Pc(n) { return n > Nd ? Math.pow(n, 1 / 3) : n / Od + Zl } function Mc([n, e, r, a]) { let u = (n + 16) / 116, p = isNaN(e) ? u : u + e / 500, f = isNaN(r) ? u : u - r / 200; return u = 1 * Cc(u), p = Bd * Cc(p), f = $s * Cc(f), [Ic(3.1338561 * p - 1.6168667 * u - .4906146 * f), Ic(-.9787684 * p + 1.9161415 * u + .033454 * f), Ic(.0719453 * p - .2289914 * u + 1.4052427 * f), a] } function Ic(n) { return (n = n <= .00304 ? 12.92 * n : 1.055 * Math.pow(n, 1 / 2.4) - .055) < 0 ? 0 : n > 1 ? 1 : n } function Cc(n) { return n > Ir ? n * n * n : Od * (n - Zl) } const Fm = Object.hasOwn || function (n, e) { return Object.prototype.hasOwnProperty.call(n, e) }; function Fa(n, e) { return Fm(n, e) ? n[e] : void 0 } function Hl(n) { return parseInt(n.padEnd(2, n), 16) / 255 } function Gd(n, e) { return Do(e ? n / 100 : n, 0, 1) } function Do(n, e, r) { return Math.min(Math.max(e, n), r) } function Ac(n) { return !n.some(Number.isNaN) } const Ba = { aliceblue: [240, 248, 255], antiquewhite: [250, 235, 215], aqua: [0, 255, 255], aquamarine: [127, 255, 212], azure: [240, 255, 255], beige: [245, 245, 220], bisque: [255, 228, 196], black: [0, 0, 0], blanchedalmond: [255, 235, 205], blue: [0, 0, 255], blueviolet: [138, 43, 226], brown: [165, 42, 42], burlywood: [222, 184, 135], cadetblue: [95, 158, 160], chartreuse: [127, 255, 0], chocolate: [210, 105, 30], coral: [255, 127, 80], cornflowerblue: [100, 149, 237], cornsilk: [255, 248, 220], crimson: [220, 20, 60], cyan: [0, 255, 255], darkblue: [0, 0, 139], darkcyan: [0, 139, 139], darkgoldenrod: [184, 134, 11], darkgray: [169, 169, 169], darkgreen: [0, 100, 0], darkgrey: [169, 169, 169], darkkhaki: [189, 183, 107], darkmagenta: [139, 0, 139], darkolivegreen: [85, 107, 47], darkorange: [255, 140, 0], darkorchid: [153, 50, 204], darkred: [139, 0, 0], darksalmon: [233, 150, 122], darkseagreen: [143, 188, 143], darkslateblue: [72, 61, 139], darkslategray: [47, 79, 79], darkslategrey: [47, 79, 79], darkturquoise: [0, 206, 209], darkviolet: [148, 0, 211], deeppink: [255, 20, 147], deepskyblue: [0, 191, 255], dimgray: [105, 105, 105], dimgrey: [105, 105, 105], dodgerblue: [30, 144, 255], firebrick: [178, 34, 34], floralwhite: [255, 250, 240], forestgreen: [34, 139, 34], fuchsia: [255, 0, 255], gainsboro: [220, 220, 220], ghostwhite: [248, 248, 255], gold: [255, 215, 0], goldenrod: [218, 165, 32], gray: [128, 128, 128], green: [0, 128, 0], greenyellow: [173, 255, 47], grey: [128, 128, 128], honeydew: [240, 255, 240], hotpink: [255, 105, 180], indianred: [205, 92, 92], indigo: [75, 0, 130], ivory: [255, 255, 240], khaki: [240, 230, 140], lavender: [230, 230, 250], lavenderblush: [255, 240, 245], lawngreen: [124, 252, 0], lemonchiffon: [255, 250, 205], lightblue: [173, 216, 230], lightcoral: [240, 128, 128], lightcyan: [224, 255, 255], lightgoldenrodyellow: [250, 250, 210], lightgray: [211, 211, 211], lightgreen: [144, 238, 144], lightgrey: [211, 211, 211], lightpink: [255, 182, 193], lightsalmon: [255, 160, 122], lightseagreen: [32, 178, 170], lightskyblue: [135, 206, 250], lightslategray: [119, 136, 153], lightslategrey: [119, 136, 153], lightsteelblue: [176, 196, 222], lightyellow: [255, 255, 224], lime: [0, 255, 0], limegreen: [50, 205, 50], linen: [250, 240, 230], magenta: [255, 0, 255], maroon: [128, 0, 0], mediumaquamarine: [102, 205, 170], mediumblue: [0, 0, 205], mediumorchid: [186, 85, 211], mediumpurple: [147, 112, 219], mediumseagreen: [60, 179, 113], mediumslateblue: [123, 104, 238], mediumspringgreen: [0, 250, 154], mediumturquoise: [72, 209, 204], mediumvioletred: [199, 21, 133], midnightblue: [25, 25, 112], mintcream: [245, 255, 250], mistyrose: [255, 228, 225], moccasin: [255, 228, 181], navajowhite: [255, 222, 173], navy: [0, 0, 128], oldlace: [253, 245, 230], olive: [128, 128, 0], olivedrab: [107, 142, 35], orange: [255, 165, 0], orangered: [255, 69, 0], orchid: [218, 112, 214], palegoldenrod: [238, 232, 170], palegreen: [152, 251, 152], paleturquoise: [175, 238, 238], palevioletred: [219, 112, 147], papayawhip: [255, 239, 213], peachpuff: [255, 218, 185], peru: [205, 133, 63], pink: [255, 192, 203], plum: [221, 160, 221], powderblue: [176, 224, 230], purple: [128, 0, 128], rebeccapurple: [102, 51, 153], red: [255, 0, 0], rosybrown: [188, 143, 143], royalblue: [65, 105, 225], saddlebrown: [139, 69, 19], salmon: [250, 128, 114], sandybrown: [244, 164, 96], seagreen: [46, 139, 87], seashell: [255, 245, 238], sienna: [160, 82, 45], silver: [192, 192, 192], skyblue: [135, 206, 235], slateblue: [106, 90, 205], slategray: [112, 128, 144], slategrey: [112, 128, 144], snow: [255, 250, 250], springgreen: [0, 255, 127], steelblue: [70, 130, 180], tan: [210, 180, 140], teal: [0, 128, 128], thistle: [216, 191, 216], tomato: [255, 99, 71], turquoise: [64, 224, 208], violet: [238, 130, 238], wheat: [245, 222, 179], white: [255, 255, 255], whitesmoke: [245, 245, 245], yellow: [255, 255, 0], yellowgreen: [154, 205, 50] }; function xs(n, e, r) { return n + r * (e - n) } function zo(n, e, r) { return n.map((a, u) => xs(a, e[u], r)) } class Rt { constructor(e, r, a, u = 1, p = !0) { this.r = e, this.g = r, this.b = a, this.a = u, p || (this.r *= u, this.g *= u, this.b *= u, u || this.overwriteGetter("rgb", [e, r, a, u])) } static parse(e) { if (e instanceof Rt) return e; if (typeof e != "string") return; const r = function (a) { if ((a = a.toLowerCase().trim()) === "transparent") return [0, 0, 0, 0]; const u = Fa(Ba, a); if (u) { const [f, _, x] = u; return [f / 255, _ / 255, x / 255, 1] } if (a.startsWith("#") && /^#(?:[0-9a-f]{3,4}|[0-9a-f]{6}|[0-9a-f]{8})$/.test(a)) { const f = a.length < 6 ? 1 : 2; let _ = 1; return [Hl(a.slice(_, _ += f)), Hl(a.slice(_, _ += f)), Hl(a.slice(_, _ += f)), Hl(a.slice(_, _ + f) || "ff")] } if (a.startsWith("rgb")) { const f = a.match(/^rgba?\(\s*([\de.+-]+)(%)?(?:\s+|\s*(,)\s*)([\de.+-]+)(%)?(?:\s+|\s*(,)\s*)([\de.+-]+)(%)?(?:\s*([,\/])\s*([\de.+-]+)(%)?)?\s*\)$/); if (f) { const [_, x, S, M, C, k, D, L, F, N, G, ee] = f, q = [M || " ", D || " ", N].join(""); if (q === "  " || q === "  /" || q === ",," || q === ",,,") { const H = [S, k, F].join(""), ne = H === "%%%" ? 100 : H === "" ? 255 : 0; if (ne) { const ae = [Do(+x / ne, 0, 1), Do(+C / ne, 0, 1), Do(+L / ne, 0, 1), G ? Gd(+G, ee) : 1]; if (Ac(ae)) return ae } } return } } const p = a.match(/^hsla?\(\s*([\de.+-]+)(?:deg)?(?:\s+|\s*(,)\s*)([\de.+-]+)%(?:\s+|\s*(,)\s*)([\de.+-]+)%(?:\s*([,\/])\s*([\de.+-]+)(%)?)?\s*\)$/); if (p) { const [f, _, x, S, M, C, k, D, L] = p, F = [x || " ", M || " ", k].join(""); if (F === "  " || F === "  /" || F === ",," || F === ",,,") { const N = [+_, Do(+S, 0, 100), Do(+C, 0, 100), D ? Gd(+D, L) : 1]; if (Ac(N)) return function ([G, ee, q, H]) { function ne(ae) { const Ie = (ae + G / 30) % 12, Ue = ee * Math.min(q, 1 - q); return q - Ue * Math.max(-1, Math.min(Ie - 3, 9 - Ie, 1)) } return G = Vd(G), ee /= 100, q /= 100, [ne(0), ne(8), ne(4), H] }(N) } } }(e); return r ? new Rt(...r, !1) : void 0 } get rgb() { const { r: e, g: r, b: a, a: u } = this, p = u || 1 / 0; return this.overwriteGetter("rgb", [e / p, r / p, a / p, u]) } get hcl() { return this.overwriteGetter("hcl", function (e) { const [r, a, u, p] = Ud(e), f = Math.sqrt(a * a + u * u); return [Math.round(1e4 * f) ? Vd(Math.atan2(u, a) * jd) : NaN, f, r, p] }(this.rgb)) } get lab() { return this.overwriteGetter("lab", Ud(this.rgb)) } overwriteGetter(e, r) { return Object.defineProperty(this, e, { value: r }), r } toString() { const [e, r, a, u] = this.rgb; return `rgba(${[e, r, a].map(p => Math.round(255 * p)).join(",")},${u})` } static interpolate(e, r, a, u = "rgb") { switch (u) { case "rgb": { const [p, f, _, x] = zo(e.rgb, r.rgb, a); return new Rt(p, f, _, x, !1) } case "hcl": { const [p, f, _, x] = e.hcl, [S, M, C, k] = r.hcl; let D, L; if (isNaN(p) || isNaN(S)) isNaN(p) ? isNaN(S) ? D = NaN : (D = S, _ !== 1 && _ !== 0 || (L = M)) : (D = p, C !== 1 && C !== 0 || (L = f)); else { let q = S - p; S > p && q > 180 ? q -= 360 : S < p && p - S > 180 && (q += 360), D = p + a * q } const [F, N, G, ee] = function ([q, H, ne, ae]) { return q = isNaN(q) ? 0 : q * La, Mc([ne, Math.cos(q) * H, Math.sin(q) * H, ae]) }([D, L ?? xs(f, M, a), xs(_, C, a), xs(x, k, a)]); return new Rt(F, N, G, ee, !1) } case "lab": { const [p, f, _, x] = Mc(zo(e.lab, r.lab, a)); return new Rt(p, f, _, x, !1) } } } } Rt.black = new Rt(0, 0, 0, 1), Rt.white = new Rt(1, 1, 1, 1), Rt.transparent = new Rt(0, 0, 0, 0), Rt.red = new Rt(1, 0, 0, 1); class kc { constructor(e, r, a) { this.sensitivity = e ? r ? "variant" : "case" : r ? "accent" : "base", this.locale = a, this.collator = new Intl.Collator(this.locale ? this.locale : [], { sensitivity: this.sensitivity, usage: "search" }) } compare(e, r) { return this.collator.compare(e, r) } resolvedLocale() { return new Intl.Collator(this.locale ? this.locale : []).resolvedOptions().locale } } const Bm = ["bottom", "center", "top"]; class Dc { constructor(e, r, a, u, p, f) { this.text = e, this.image = r, this.scale = a, this.fontStack = u, this.textColor = p, this.verticalAlign = f } } class Vn { constructor(e) { this.sections = e } static fromString(e) { return new Vn([new Dc(e, null, null, null, null, null)]) } isEmpty() { return this.sections.length === 0 || !this.sections.some(e => e.text.length !== 0 || e.image && e.image.name.length !== 0) } static factory(e) { return e instanceof Vn ? e : Vn.fromString(e) } toString() { return this.sections.length === 0 ? "" : this.sections.map(e => e.text).join("") } } class xn { constructor(e) { this.values = e.slice() } static parse(e) { if (e instanceof xn) return e; if (typeof e == "number") return new xn([e, e, e, e]); if (Array.isArray(e) && !(e.length < 1 || e.length > 4)) { for (const r of e) if (typeof r != "number") return; switch (e.length) { case 1: e = [e[0], e[0], e[0], e[0]]; break; case 2: e = [e[0], e[1], e[0], e[1]]; break; case 3: e = [e[0], e[1], e[2], e[1]] }return new xn(e) } } toString() { return JSON.stringify(this.values) } static interpolate(e, r, a) { return new xn(zo(e.values, r.values, a)) } } class br { constructor(e) { this.values = e.slice() } static parse(e) { if (e instanceof br) return e; if (typeof e == "number") return new br([e]); if (Array.isArray(e)) { for (const r of e) if (typeof r != "number") return; return new br(e) } } toString() { return JSON.stringify(this.values) } static interpolate(e, r, a) { return new br(zo(e.values, r.values, a)) } } class Et { constructor(e) { this.values = e.slice() } static parse(e) { if (e instanceof Et) return e; if (typeof e == "string") { const a = Rt.parse(e); return a ? new Et([a]) : void 0 } if (!Array.isArray(e)) return; const r = []; for (const a of e) { if (typeof a != "string") return; const u = Rt.parse(a); if (!u) return; r.push(u) } return new Et(r) } toString() { return JSON.stringify(this.values) } static interpolate(e, r, a, u = "rgb") { const p = []; if (e.values.length != r.values.length) throw new Error(`colorArray: Arrays have mismatched length (${e.values.length} vs. ${r.values.length}), cannot interpolate.`); for (let f = 0; f < e.values.length; f++)p.push(Rt.interpolate(e.values[f], r.values[f], a, u)); return new Et(p) } } class sr extends Error { constructor(e) { super(e), this.name = "RuntimeError" } toJSON() { return this.message } } const ws = new Set(["center", "left", "right", "top", "bottom", "top-left", "top-right", "bottom-left", "bottom-right"]); class Dn { constructor(e) { this.values = e.slice() } static parse(e) { if (e instanceof Dn) return e; if (Array.isArray(e) && !(e.length < 1) && e.length % 2 == 0) { for (let r = 0; r < e.length; r += 2) { const a = e[r], u = e[r + 1]; if (typeof a != "string" || !ws.has(a) || !Array.isArray(u) || u.length !== 2 || typeof u[0] != "number" || typeof u[1] != "number") return } return new Dn(e) } } toString() { return JSON.stringify(this.values) } static interpolate(e, r, a) { const u = e.values, p = r.values; if (u.length !== p.length) throw new sr(`Cannot interpolate values of different length. from: ${e.toString()}, to: ${r.toString()}`); const f = []; for (let _ = 0; _ < u.length; _ += 2) { if (u[_] !== p[_]) throw new sr(`Cannot interpolate values containing mismatched anchors. from[${_}]: ${u[_]}, to[${_}]: ${p[_]}`); f.push(u[_]); const [x, S] = u[_ + 1], [M, C] = p[_ + 1]; f.push([xs(x, M, a), xs(S, C, a)]) } return new Dn(f) } } class Kn { constructor(e) { this.name = e.name, this.available = e.available } toString() { return this.name } static fromString(e) { return e ? new Kn({ name: e, available: !1 }) : null } } class zn { constructor(e, r, a) { this.from = e, this.to = r, this.transition = a } static interpolate(e, r, a) { return new zn(e, r, a) } static parse(e) { return e instanceof zn ? e : Array.isArray(e) && e.length === 3 && typeof e[0] == "string" && typeof e[1] == "string" && typeof e[2] == "number" ? new zn(e[0], e[1], e[2]) : typeof e == "object" && typeof e.from == "string" && typeof e.to == "string" && typeof e.transition == "number" ? new zn(e.from, e.to, e.transition) : typeof e == "string" ? new zn(e, e, 1) : void 0 } } function Ro(n, e, r, a) { return typeof n == "number" && n >= 0 && n <= 255 && typeof e == "number" && e >= 0 && e <= 255 && typeof r == "number" && r >= 0 && r <= 255 ? a === void 0 || typeof a == "number" && a >= 0 && a <= 1 ? null : `Invalid rgba value [${[n, e, r, a].join(", ")}]: 'a' must be between 0 and 1.` : `Invalid rgba value [${(typeof a == "number" ? [n, e, r, a] : [n, e, r]).join(", ")}]: 'r', 'g', and 'b' must be between 0 and 255.` } function bs(n) { if (n === null || typeof n == "string" || typeof n == "boolean" || typeof n == "number" || n instanceof zn || n instanceof Rt || n instanceof kc || n instanceof Vn || n instanceof xn || n instanceof br || n instanceof Et || n instanceof Dn || n instanceof Kn) return !0; if (Array.isArray(n)) { for (const e of n) if (!bs(e)) return !1; return !0 } if (typeof n == "object") { for (const e in n) if (!bs(n[e])) return !1; return !0 } return !1 } function Lr(n) { if (n === null) return oi; if (typeof n == "string") return Dt; if (typeof n == "boolean") return zt; if (typeof n == "number") return at; if (n instanceof Rt) return Yn; if (n instanceof zn) return Gl; if (n instanceof kc) return Aa; if (n instanceof Vn) return ka; if (n instanceof xn) return $l; if (n instanceof br) return Da; if (n instanceof Et) return Co; if (n instanceof Dn) return za; if (n instanceof Kn) return Ao; if (Array.isArray(n)) { const e = n.length; let r; for (const a of n) { const u = Lr(a); if (r) { if (r === u) continue; r = At; break } r = u } return kn(r || At, e) } return es } function qs(n) { const e = typeof n; return n === null ? "" : e === "string" || e === "number" || e === "boolean" ? String(n) : n instanceof Rt || n instanceof zn || n instanceof Vn || n instanceof xn || n instanceof br || n instanceof Et || n instanceof Dn || n instanceof Kn ? n.toString() : JSON.stringify(n) } class ji { constructor(e, r) { this.type = e, this.value = r } static parse(e, r) { if (e.length !== 2) return r.error(`'literal' expression requires exactly one argument, but found ${e.length - 1} instead.`); if (!bs(e[1])) return r.error("invalid value"); const a = e[1]; let u = Lr(a); const p = r.expectedType; return u.kind !== "array" || u.N !== 0 || !p || p.kind !== "array" || typeof p.N == "number" && p.N !== 0 || (u = p), new ji(u, a) } evaluate() { return this.value } eachChild() { } outputDefined() { return !0 } } const Xl = { string: Dt, number: at, boolean: zt, object: es }; class Un { constructor(e, r) { this.type = e, this.args = r } static parse(e, r) { if (e.length < 2) return r.error("Expected at least one argument."); let a, u = 1; const p = e[0]; if (p === "array") { let _, x; if (e.length > 2) { const S = e[1]; if (typeof S != "string" || !(S in Xl) || S === "object") return r.error('The item type argument of "array" must be one of string, number, boolean', 1); _ = Xl[S], u++ } else _ = At; if (e.length > 3) { if (e[2] !== null && (typeof e[2] != "number" || e[2] < 0 || e[2] !== Math.floor(e[2]))) return r.error('The length argument to "array" must be a positive integer literal', 2); x = e[2], u++ } a = kn(_, x) } else { if (!Xl[p]) throw new Error(`Types doesn't contain name = ${p}`); a = Xl[p] } const f = []; for (; u < e.length; u++) { const _ = r.parse(e[u], u, At); if (!_) return null; f.push(_) } return new Un(a, f) } evaluate(e) { for (let r = 0; r < this.args.length; r++) { const a = this.args[r].evaluate(e); if (!ko(this.type, Lr(a))) return a; if (r === this.args.length - 1) throw new sr(`Expected value to be of type ${er(this.type)}, but found ${er(Lr(a))} instead.`) } throw new Error } eachChild(e) { this.args.forEach(e) } outputDefined() { return this.args.every(e => e.outputDefined()) } } const Zs = { "to-boolean": zt, "to-color": Yn, "to-number": at, "to-string": Dt }; class ts { constructor(e, r) { this.type = e, this.args = r } static parse(e, r) { if (e.length < 2) return r.error("Expected at least one argument."); const a = e[0]; if (!Zs[a]) throw new Error(`Can't parse ${a} as it is not part of the known types`); if ((a === "to-boolean" || a === "to-string") && e.length !== 2) return r.error("Expected one argument."); const u = Zs[a], p = []; for (let f = 1; f < e.length; f++) { const _ = r.parse(e[f], f, At); if (!_) return null; p.push(_) } return new ts(u, p) } evaluate(e) { switch (this.type.kind) { case "boolean": return !!this.args[0].evaluate(e); case "color": { let r, a; for (const u of this.args) { if (r = u.evaluate(e), a = null, r instanceof Rt) return r; if (typeof r == "string") { const p = e.parseColor(r); if (p) return p } else if (Array.isArray(r) && (a = r.length < 3 || r.length > 4 ? `Invalid rgba value ${JSON.stringify(r)}: expected an array containing either three or four numeric values.` : Ro(r[0], r[1], r[2], r[3]), !a)) return new Rt(r[0] / 255, r[1] / 255, r[2] / 255, r[3]) } throw new sr(a || `Could not parse color from value '${typeof r == "string" ? r : JSON.stringify(r)}'`) } case "padding": { let r; for (const a of this.args) { r = a.evaluate(e); const u = xn.parse(r); if (u) return u } throw new sr(`Could not parse padding from value '${typeof r == "string" ? r : JSON.stringify(r)}'`) } case "numberArray": { let r; for (const a of this.args) { r = a.evaluate(e); const u = br.parse(r); if (u) return u } throw new sr(`Could not parse numberArray from value '${typeof r == "string" ? r : JSON.stringify(r)}'`) } case "colorArray": { let r; for (const a of this.args) { r = a.evaluate(e); const u = Et.parse(r); if (u) return u } throw new sr(`Could not parse colorArray from value '${typeof r == "string" ? r : JSON.stringify(r)}'`) } case "variableAnchorOffsetCollection": { let r; for (const a of this.args) { r = a.evaluate(e); const u = Dn.parse(r); if (u) return u } throw new sr(`Could not parse variableAnchorOffsetCollection from value '${typeof r == "string" ? r : JSON.stringify(r)}'`) } case "number": { let r = null; for (const a of this.args) { if (r = a.evaluate(e), r === null) return 0; const u = Number(r); if (!isNaN(u)) return u } throw new sr(`Could not convert ${JSON.stringify(r)} to number.`) } case "formatted": return Vn.fromString(qs(this.args[0].evaluate(e))); case "resolvedImage": return Kn.fromString(qs(this.args[0].evaluate(e))); case "projectionDefinition": return this.args[0].evaluate(e); default: return qs(this.args[0].evaluate(e)) } } eachChild(e) { this.args.forEach(e) } outputDefined() { return this.args.every(e => e.outputDefined()) } } const $d = ["Unknown", "Point", "LineString", "Polygon"]; class zc { constructor() { this.globals = null, this.feature = null, this.featureState = null, this.formattedSection = null, this._parseColorCache = new Map, this.availableImages = null, this.canonical = null } id() { return this.feature && "id" in this.feature ? this.feature.id : null } geometryType() { return this.feature ? typeof this.feature.type == "number" ? $d[this.feature.type] : this.feature.type : null } geometry() { return this.feature && "geometry" in this.feature ? this.feature.geometry : null } canonicalID() { return this.canonical } properties() { return this.feature && this.feature.properties || {} } parseColor(e) { let r = this._parseColorCache.get(e); return r || (r = Rt.parse(e), this._parseColorCache.set(e, r)), r } } class Ws { constructor(e, r, a = [], u, p = new Ul, f = []) { this.registry = e, this.path = a, this.key = a.map(_ => `[${_}]`).join(""), this.scope = p, this.errors = f, this.expectedType = u, this._isConstant = r } parse(e, r, a, u, p = {}) { return r ? this.concat(r, a, u)._parse(e, p) : this._parse(e, p) } _parse(e, r) { function a(u, p, f) { return f === "assert" ? new Un(p, [u]) : f === "coerce" ? new ts(p, [u]) : u } if (e !== null && typeof e != "string" && typeof e != "boolean" && typeof e != "number" || (e = ["literal", e]), Array.isArray(e)) { if (e.length === 0) return this.error('Expected an array with at least one element. If you wanted a literal array, use ["literal", []].'); const u = e[0]; if (typeof u != "string") return this.error(`Expression name must be a string, but found ${typeof u} instead. If you wanted a literal array, use ["literal", [...]].`, 0), null; const p = this.registry[u]; if (p) { let f = p.parse(e, this); if (!f) return null; if (this.expectedType) { const _ = this.expectedType, x = f.type; if (_.kind !== "string" && _.kind !== "number" && _.kind !== "boolean" && _.kind !== "object" && _.kind !== "array" || x.kind !== "value") { if (_.kind === "projectionDefinition" && ["string", "array"].includes(x.kind) || ["color", "formatted", "resolvedImage"].includes(_.kind) && ["value", "string"].includes(x.kind) || ["padding", "numberArray"].includes(_.kind) && ["value", "number", "array"].includes(x.kind) || _.kind === "colorArray" && ["value", "string", "array"].includes(x.kind) || _.kind === "variableAnchorOffsetCollection" && ["value", "array"].includes(x.kind)) f = a(f, _, r.typeAnnotation || "coerce"); else if (this.checkSubtype(_, x)) return null } else f = a(f, _, r.typeAnnotation || "assert") } if (!(f instanceof ji) && f.type.kind !== "resolvedImage" && this._isConstant(f)) { const _ = new zc; try { f = new ji(f.type, f.evaluate(_)) } catch (x) { return this.error(x.message), null } } return f } return this.error(`Unknown expression "${u}". If you wanted a literal array, use ["literal", [...]].`, 0) } return this.error(e === void 0 ? "'undefined' value invalid. Use null instead." : typeof e == "object" ? 'Bare objects invalid. Use ["literal", {...}] instead.' : `Expected an array, but found ${typeof e} instead.`) } concat(e, r, a) { const u = typeof e == "number" ? this.path.concat(e) : this.path, p = a ? this.scope.concat(a) : this.scope; return new Ws(this.registry, this._isConstant, u, r || null, p, this.errors) } error(e, ...r) { const a = `${this.key}${r.map(u => `[${u}]`).join("")}`; this.errors.push(new An(a, e)) } checkSubtype(e, r) { const a = ko(e, r); return a && this.error(a), a } } class or { constructor(e, r) { this.type = r.type, this.bindings = [].concat(e), this.result = r } evaluate(e) { return this.result.evaluate(e) } eachChild(e) { for (const r of this.bindings) e(r[1]); e(this.result) } static parse(e, r) { if (e.length < 4) return r.error(`Expected at least 3 arguments, but found ${e.length - 1} instead.`); const a = []; for (let p = 1; p < e.length - 1; p += 2) { const f = e[p]; if (typeof f != "string") return r.error(`Expected string, but found ${typeof f} instead.`, p); if (/[^a-zA-Z0-9_]/.test(f)) return r.error("Variable names must contain only alphanumeric characters or '_'.", p); const _ = r.parse(e[p + 1], p + 1); if (!_) return null; a.push([f, _]) } const u = r.parse(e[e.length - 1], e.length - 1, r.expectedType, a); return u ? new or(a, u) : null } outputDefined() { return this.result.outputDefined() } } class Lo { constructor(e, r) { this.type = r.type, this.name = e, this.boundExpression = r } static parse(e, r) { if (e.length !== 2 || typeof e[1] != "string") return r.error("'var' expression requires exactly one string literal argument."); const a = e[1]; return r.scope.has(a) ? new Lo(a, r.scope.get(a)) : r.error(`Unknown variable "${a}". Make sure "${a}" has been bound in an enclosing "let" expression before using it.`, 1) } evaluate(e) { return this.boundExpression.evaluate(e) } eachChild() { } outputDefined() { return !1 } } class Nt { constructor(e, r, a) { this.type = e, this.index = r, this.input = a } static parse(e, r) { if (e.length !== 3) return r.error(`Expected 2 arguments, but found ${e.length - 1} instead.`); const a = r.parse(e[1], 1, at), u = r.parse(e[2], 2, kn(r.expectedType || At)); return a && u ? new Nt(u.type.itemType, a, u) : null } evaluate(e) { const r = this.index.evaluate(e), a = this.input.evaluate(e); if (r < 0) throw new sr(`Array index out of bounds: ${r} < 0.`); if (r >= a.length) throw new sr(`Array index out of bounds: ${r} > ${a.length - 1}.`); if (r !== Math.floor(r)) throw new sr(`Array index must be an integer, but found ${r} instead.`); return a[r] } eachChild(e) { e(this.index), e(this.input) } outputDefined() { return !1 } } class kt { constructor(e, r) { this.type = zt, this.needle = e, this.haystack = r } static parse(e, r) { if (e.length !== 3) return r.error(`Expected 2 arguments, but found ${e.length - 1} instead.`); const a = r.parse(e[1], 1, At), u = r.parse(e[2], 2, At); return a && u ? Ra(a.type, [zt, Dt, at, oi, At]) ? new kt(a, u) : r.error(`Expected first argument to be of type boolean, string, number or null, but found ${er(a.type)} instead`) : null } evaluate(e) { const r = this.needle.evaluate(e), a = this.haystack.evaluate(e); if (!a) return !1; if (!Gs(r, ["boolean", "string", "number", "null"])) throw new sr(`Expected first argument to be of type boolean, string, number or null, but found ${er(Lr(r))} instead.`); if (!Gs(a, ["string", "array"])) throw new sr(`Expected second argument to be of type array or string, but found ${er(Lr(a))} instead.`); return a.indexOf(r) >= 0 } eachChild(e) { e(this.needle), e(this.haystack) } outputDefined() { return !0 } } class Fo { constructor(e, r, a) { this.type = at, this.needle = e, this.haystack = r, this.fromIndex = a } static parse(e, r) { if (e.length <= 2 || e.length >= 5) return r.error(`Expected 2 or 3 arguments, but found ${e.length - 1} instead.`); const a = r.parse(e[1], 1, At), u = r.parse(e[2], 2, At); if (!a || !u) return null; if (!Ra(a.type, [zt, Dt, at, oi, At])) return r.error(`Expected first argument to be of type boolean, string, number or null, but found ${er(a.type)} instead`); if (e.length === 4) { const p = r.parse(e[3], 3, at); return p ? new Fo(a, u, p) : null } return new Fo(a, u) } evaluate(e) { const r = this.needle.evaluate(e), a = this.haystack.evaluate(e); if (!Gs(r, ["boolean", "string", "number", "null"])) throw new sr(`Expected first argument to be of type boolean, string, number or null, but found ${er(Lr(r))} instead.`); let u; if (this.fromIndex && (u = this.fromIndex.evaluate(e)), Gs(a, ["string"])) { const p = a.indexOf(r, u); return p === -1 ? -1 : [...a.slice(0, p)].length } if (Gs(a, ["array"])) return a.indexOf(r, u); throw new sr(`Expected second argument to be of type array or string, but found ${er(Lr(a))} instead.`) } eachChild(e) { e(this.needle), e(this.haystack), this.fromIndex && e(this.fromIndex) } outputDefined() { return !1 } } class jt { constructor(e, r, a, u, p, f) { this.inputType = e, this.type = r, this.input = a, this.cases = u, this.outputs = p, this.otherwise = f } static parse(e, r) { if (e.length < 5) return r.error(`Expected at least 4 arguments, but found only ${e.length - 1}.`); if (e.length % 2 != 1) return r.error("Expected an even number of arguments."); let a, u; r.expectedType && r.expectedType.kind !== "value" && (u = r.expectedType); const p = {}, f = []; for (let S = 2; S < e.length - 1; S += 2) { let M = e[S]; const C = e[S + 1]; Array.isArray(M) || (M = [M]); const k = r.concat(S); if (M.length === 0) return k.error("Expected at least one branch label."); for (const L of M) { if (typeof L != "number" && typeof L != "string") return k.error("Branch labels must be numbers or strings."); if (typeof L == "number" && Math.abs(L) > Number.MAX_SAFE_INTEGER) return k.error(`Branch labels must be integers no larger than ${Number.MAX_SAFE_INTEGER}.`); if (typeof L == "number" && Math.floor(L) !== L) return k.error("Numeric branch labels must be integer values."); if (a) { if (k.checkSubtype(a, Lr(L))) return null } else a = Lr(L); if (p[String(L)] !== void 0) return k.error("Branch labels must be unique."); p[String(L)] = f.length } const D = r.parse(C, S, u); if (!D) return null; u = u || D.type, f.push(D) } const _ = r.parse(e[1], 1, At); if (!_) return null; const x = r.parse(e[e.length - 1], e.length - 1, u); return x ? _.type.kind !== "value" && r.concat(1).checkSubtype(a, _.type) ? null : new jt(a, u, _, p, f, x) : null } evaluate(e) { const r = this.input.evaluate(e); return (Lr(r) === this.inputType && this.outputs[this.cases[r]] || this.otherwise).evaluate(e) } eachChild(e) { e(this.input), this.outputs.forEach(e), e(this.otherwise) } outputDefined() { return this.outputs.every(e => e.outputDefined()) && this.otherwise.outputDefined() } } class Oa { constructor(e, r, a) { this.type = e, this.branches = r, this.otherwise = a } static parse(e, r) { if (e.length < 4) return r.error(`Expected at least 3 arguments, but found only ${e.length - 1}.`); if (e.length % 2 != 0) return r.error("Expected an odd number of arguments."); let a; r.expectedType && r.expectedType.kind !== "value" && (a = r.expectedType); const u = []; for (let f = 1; f < e.length - 1; f += 2) { const _ = r.parse(e[f], f, zt); if (!_) return null; const x = r.parse(e[f + 1], f + 1, a); if (!x) return null; u.push([_, x]), a = a || x.type } const p = r.parse(e[e.length - 1], e.length - 1, a); if (!p) return null; if (!a) throw new Error("Can't infer output type"); return new Oa(a, u, p) } evaluate(e) { for (const [r, a] of this.branches) if (r.evaluate(e)) return a.evaluate(e); return this.otherwise.evaluate(e) } eachChild(e) { for (const [r, a] of this.branches) e(r), e(a); e(this.otherwise) } outputDefined() { return this.branches.every(([e, r]) => r.outputDefined()) && this.otherwise.outputDefined() } } class ai { constructor(e, r, a, u) { this.type = e, this.input = r, this.beginIndex = a, this.endIndex = u } static parse(e, r) { if (e.length <= 2 || e.length >= 5) return r.error(`Expected 2 or 3 arguments, but found ${e.length - 1} instead.`); const a = r.parse(e[1], 1, At), u = r.parse(e[2], 2, at); if (!a || !u) return null; if (!Ra(a.type, [kn(At), Dt, At])) return r.error(`Expected first argument to be of type array or string, but found ${er(a.type)} instead`); if (e.length === 4) { const p = r.parse(e[3], 3, at); return p ? new ai(a.type, a, u, p) : null } return new ai(a.type, a, u) } evaluate(e) { const r = this.input.evaluate(e), a = this.beginIndex.evaluate(e); let u; if (this.endIndex && (u = this.endIndex.evaluate(e)), Gs(r, ["string"])) return [...r].slice(a, u).join(""); if (Gs(r, ["array"])) return r.slice(a, u); throw new sr(`Expected first argument to be of type array or string, but found ${er(Lr(r))} instead.`) } eachChild(e) { e(this.input), e(this.beginIndex), this.endIndex && e(this.endIndex) } outputDefined() { return !1 } } function Bo(n, e) { const r = n.length - 1; let a, u, p = 0, f = r, _ = 0; for (; p <= f;)if (_ = Math.floor((p + f) / 2), a = n[_], u = n[_ + 1], a <= e) { if (_ === r || e < u) return _; p = _ + 1 } else { if (!(a > e)) throw new sr("Input is not a number."); f = _ - 1 } return 0 } class Ts { constructor(e, r, a) { this.type = e, this.input = r, this.labels = [], this.outputs = []; for (const [u, p] of a) this.labels.push(u), this.outputs.push(p) } static parse(e, r) { if (e.length - 1 < 4) return r.error(`Expected at least 4 arguments, but found only ${e.length - 1}.`); if ((e.length - 1) % 2 != 0) return r.error("Expected an even number of arguments."); const a = r.parse(e[1], 1, at); if (!a) return null; const u = []; let p = null; r.expectedType && r.expectedType.kind !== "value" && (p = r.expectedType); for (let f = 1; f < e.length; f += 2) { const _ = f === 1 ? -1 / 0 : e[f], x = e[f + 1], S = f, M = f + 1; if (typeof _ != "number") return r.error('Input/output pairs for "step" expressions must be defined using literal numeric values (not computed expressions) for the input values.', S); if (u.length && u[u.length - 1][0] >= _) return r.error('Input/output pairs for "step" expressions must be arranged with input values in strictly ascending order.', S); const C = r.parse(x, M, p); if (!C) return null; p = p || C.type, u.push([_, C]) } return new Ts(p, a, u) } evaluate(e) { const r = this.labels, a = this.outputs; if (r.length === 1) return a[0].evaluate(e); const u = this.input.evaluate(e); if (u <= r[0]) return a[0].evaluate(e); const p = r.length; return u >= r[p - 1] ? a[p - 1].evaluate(e) : a[Bo(r, u)].evaluate(e) } eachChild(e) { e(this.input); for (const r of this.outputs) e(r) } outputDefined() { return this.outputs.every(e => e.outputDefined()) } } function qd(n) { return n && n.__esModule && Object.prototype.hasOwnProperty.call(n, "default") ? n.default : n } var Na, Rc, Om = function () { if (Rc) return Na; function n(e, r, a, u) { this.cx = 3 * e, this.bx = 3 * (a - e) - this.cx, this.ax = 1 - this.cx - this.bx, this.cy = 3 * r, this.by = 3 * (u - r) - this.cy, this.ay = 1 - this.cy - this.by, this.p1x = e, this.p1y = r, this.p2x = a, this.p2y = u } return Rc = 1, Na = n, n.prototype = { sampleCurveX: function (e) { return ((this.ax * e + this.bx) * e + this.cx) * e }, sampleCurveY: function (e) { return ((this.ay * e + this.by) * e + this.cy) * e }, sampleCurveDerivativeX: function (e) { return (3 * this.ax * e + 2 * this.bx) * e + this.cx }, solveCurveX: function (e, r) { if (r === void 0 && (r = 1e-6), e < 0) return 0; if (e > 1) return 1; for (var a = e, u = 0; u < 8; u++) { var p = this.sampleCurveX(a) - e; if (Math.abs(p) < r) return a; var f = this.sampleCurveDerivativeX(a); if (Math.abs(f) < 1e-6) break; a -= p / f } var _ = 0, x = 1; for (a = e, u = 0; u < 20 && (p = this.sampleCurveX(a), !(Math.abs(p - e) < r)); u++)e > p ? _ = a : x = a, a = .5 * (x - _) + _; return a }, solve: function (e, r) { return this.sampleCurveY(this.solveCurveX(e, r)) } }, Na }(), Zd = qd(Om); class Rn { constructor(e, r, a, u, p) { this.type = e, this.operator = r, this.interpolation = a, this.input = u, this.labels = [], this.outputs = []; for (const [f, _] of p) this.labels.push(f), this.outputs.push(_) } static interpolationFactor(e, r, a, u) { let p = 0; if (e.name === "exponential") p = Vi(r, e.base, a, u); else if (e.name === "linear") p = Vi(r, 1, a, u); else if (e.name === "cubic-bezier") { const f = e.controlPoints; p = new Zd(f[0], f[1], f[2], f[3]).solve(Vi(r, 1, a, u)) } return p } static parse(e, r) { let [a, u, p, ...f] = e; if (!Array.isArray(u) || u.length === 0) return r.error("Expected an interpolation type expression.", 1); if (u[0] === "linear") u = { name: "linear" }; else if (u[0] === "exponential") { const S = u[1]; if (typeof S != "number") return r.error("Exponential interpolation requires a numeric base.", 1, 1); u = { name: "exponential", base: S } } else { if (u[0] !== "cubic-bezier") return r.error(`Unknown interpolation type ${String(u[0])}`, 1, 0); { const S = u.slice(1); if (S.length !== 4 || S.some(M => typeof M != "number" || M < 0 || M > 1)) return r.error("Cubic bezier interpolation requires four numeric arguments with values between 0 and 1.", 1); u = { name: "cubic-bezier", controlPoints: S } } } if (e.length - 1 < 4) return r.error(`Expected at least 4 arguments, but found only ${e.length - 1}.`); if ((e.length - 1) % 2 != 0) return r.error("Expected an even number of arguments."); if (p = r.parse(p, 2, at), !p) return null; const _ = []; let x = null; a !== "interpolate-hcl" && a !== "interpolate-lab" || r.expectedType == Co ? r.expectedType && r.expectedType.kind !== "value" && (x = r.expectedType) : x = Yn; for (let S = 0; S < f.length; S += 2) { const M = f[S], C = f[S + 1], k = S + 3, D = S + 4; if (typeof M != "number") return r.error('Input/output pairs for "interpolate" expressions must be defined using literal numeric values (not computed expressions) for the input values.', k); if (_.length && _[_.length - 1][0] >= M) return r.error('Input/output pairs for "interpolate" expressions must be arranged with input values in strictly ascending order.', k); const L = r.parse(C, D, x); if (!L) return null; x = x || L.type, _.push([M, L]) } return wi(x, at) || wi(x, Gl) || wi(x, Yn) || wi(x, $l) || wi(x, Da) || wi(x, Co) || wi(x, za) || wi(x, kn(at)) ? new Rn(x, a, u, p, _) : r.error(`Type ${er(x)} is not interpolatable.`) } evaluate(e) { const r = this.labels, a = this.outputs; if (r.length === 1) return a[0].evaluate(e); const u = this.input.evaluate(e); if (u <= r[0]) return a[0].evaluate(e); const p = r.length; if (u >= r[p - 1]) return a[p - 1].evaluate(e); const f = Bo(r, u), _ = Rn.interpolationFactor(this.interpolation, u, r[f], r[f + 1]), x = a[f].evaluate(e), S = a[f + 1].evaluate(e); switch (this.operator) { case "interpolate": switch (this.type.kind) { case "number": return xs(x, S, _); case "color": return Rt.interpolate(x, S, _); case "padding": return xn.interpolate(x, S, _); case "colorArray": return Et.interpolate(x, S, _); case "numberArray": return br.interpolate(x, S, _); case "variableAnchorOffsetCollection": return Dn.interpolate(x, S, _); case "array": return zo(x, S, _); case "projectionDefinition": return zn.interpolate(x, S, _) }case "interpolate-hcl": switch (this.type.kind) { case "color": return Rt.interpolate(x, S, _, "hcl"); case "colorArray": return Et.interpolate(x, S, _, "hcl") }case "interpolate-lab": switch (this.type.kind) { case "color": return Rt.interpolate(x, S, _, "lab"); case "colorArray": return Et.interpolate(x, S, _, "lab") } } } eachChild(e) { e(this.input); for (const r of this.outputs) e(r) } outputDefined() { return this.outputs.every(e => e.outputDefined()) } } function Vi(n, e, r, a) { const u = a - r, p = n - r; return u === 0 ? 0 : e === 1 ? p / u : (Math.pow(e, p) - 1) / (Math.pow(e, u) - 1) } const _r = { color: Rt.interpolate, number: xs, padding: xn.interpolate, numberArray: br.interpolate, colorArray: Et.interpolate, variableAnchorOffsetCollection: Dn.interpolate, array: zo }; class Hs { constructor(e, r) { this.type = e, this.args = r } static parse(e, r) { if (e.length < 2) return r.error("Expected at least one argument."); let a = null; const u = r.expectedType; u && u.kind !== "value" && (a = u); const p = []; for (const _ of e.slice(1)) { const x = r.parse(_, 1 + p.length, a, void 0, { typeAnnotation: "omit" }); if (!x) return null; a = a || x.type, p.push(x) } if (!a) throw new Error("No output type"); const f = u && p.some(_ => ko(u, _.type)); return new Hs(f ? At : a, p) } evaluate(e) { let r, a = null, u = 0; for (const p of this.args) if (u++, a = p.evaluate(e), a && a instanceof Kn && !a.available && (r || (r = a.name), a = null, u === this.args.length && (a = r)), a !== null) break; return a } eachChild(e) { this.args.forEach(e) } outputDefined() { return this.args.every(e => e.outputDefined()) } } function Lc(n, e) { return n === "==" || n === "!=" ? e.kind === "boolean" || e.kind === "string" || e.kind === "number" || e.kind === "null" || e.kind === "value" : e.kind === "string" || e.kind === "number" || e.kind === "value" } function ja(n, e, r, a) { return a.compare(e, r) === 0 } function Cr(n, e, r) { const a = n !== "==" && n !== "!="; return class j2 { constructor(p, f, _) { this.type = zt, this.lhs = p, this.rhs = f, this.collator = _, this.hasUntypedArgument = p.type.kind === "value" || f.type.kind === "value" } static parse(p, f) { if (p.length !== 3 && p.length !== 4) return f.error("Expected two or three arguments."); const _ = p[0]; let x = f.parse(p[1], 1, At); if (!x) return null; if (!Lc(_, x.type)) return f.concat(1).error(`"${_}" comparisons are not supported for type '${er(x.type)}'.`); let S = f.parse(p[2], 2, At); if (!S) return null; if (!Lc(_, S.type)) return f.concat(2).error(`"${_}" comparisons are not supported for type '${er(S.type)}'.`); if (x.type.kind !== S.type.kind && x.type.kind !== "value" && S.type.kind !== "value") return f.error(`Cannot compare types '${er(x.type)}' and '${er(S.type)}'.`); a && (x.type.kind === "value" && S.type.kind !== "value" ? x = new Un(S.type, [x]) : x.type.kind !== "value" && S.type.kind === "value" && (S = new Un(x.type, [S]))); let M = null; if (p.length === 4) { if (x.type.kind !== "string" && S.type.kind !== "string" && x.type.kind !== "value" && S.type.kind !== "value") return f.error("Cannot use collator to compare non-string types."); if (M = f.parse(p[3], 3, Aa), !M) return null } return new j2(x, S, M) } evaluate(p) { const f = this.lhs.evaluate(p), _ = this.rhs.evaluate(p); if (a && this.hasUntypedArgument) { const x = Lr(f), S = Lr(_); if (x.kind !== S.kind || x.kind !== "string" && x.kind !== "number") throw new sr(`Expected arguments for "${n}" to be (string, string) or (number, number), but found (${x.kind}, ${S.kind}) instead.`) } if (this.collator && !a && this.hasUntypedArgument) { const x = Lr(f), S = Lr(_); if (x.kind !== "string" || S.kind !== "string") return e(p, f, _) } return this.collator ? r(p, f, _, this.collator.evaluate(p)) : e(p, f, _) } eachChild(p) { p(this.lhs), p(this.rhs), this.collator && p(this.collator) } outputDefined() { return !0 } } } const Wd = Cr("==", function (n, e, r) { return e === r }, ja), Fc = Cr("!=", function (n, e, r) { return e !== r }, function (n, e, r, a) { return !ja(0, e, r, a) }), Hd = Cr("<", function (n, e, r) { return e < r }, function (n, e, r, a) { return a.compare(e, r) < 0 }), Nm = Cr(">", function (n, e, r) { return e > r }, function (n, e, r, a) { return a.compare(e, r) > 0 }), Oo = Cr("<=", function (n, e, r) { return e <= r }, function (n, e, r, a) { return a.compare(e, r) <= 0 }), Yl = Cr(">=", function (n, e, r) { return e >= r }, function (n, e, r, a) { return a.compare(e, r) >= 0 }); class No { constructor(e, r, a) { this.type = Aa, this.locale = a, this.caseSensitive = e, this.diacriticSensitive = r } static parse(e, r) { if (e.length !== 2) return r.error("Expected one argument."); const a = e[1]; if (typeof a != "object" || Array.isArray(a)) return r.error("Collator options argument must be an object."); const u = r.parse(a["case-sensitive"] !== void 0 && a["case-sensitive"], 1, zt); if (!u) return null; const p = r.parse(a["diacritic-sensitive"] !== void 0 && a["diacritic-sensitive"], 1, zt); if (!p) return null; let f = null; return a.locale && (f = r.parse(a.locale, 1, Dt), !f) ? null : new No(u, p, f) } evaluate(e) { return new kc(this.caseSensitive.evaluate(e), this.diacriticSensitive.evaluate(e), this.locale ? this.locale.evaluate(e) : null) } eachChild(e) { e(this.caseSensitive), e(this.diacriticSensitive), this.locale && e(this.locale) } outputDefined() { return !1 } } class Bc { constructor(e, r, a, u, p) { this.type = Dt, this.number = e, this.locale = r, this.currency = a, this.minFractionDigits = u, this.maxFractionDigits = p } static parse(e, r) { if (e.length !== 3) return r.error("Expected two arguments."); const a = r.parse(e[1], 1, at); if (!a) return null; const u = e[2]; if (typeof u != "object" || Array.isArray(u)) return r.error("NumberFormat options argument must be an object."); let p = null; if (u.locale && (p = r.parse(u.locale, 1, Dt), !p)) return null; let f = null; if (u.currency && (f = r.parse(u.currency, 1, Dt), !f)) return null; let _ = null; if (u["min-fraction-digits"] && (_ = r.parse(u["min-fraction-digits"], 1, at), !_)) return null; let x = null; return u["max-fraction-digits"] && (x = r.parse(u["max-fraction-digits"], 1, at), !x) ? null : new Bc(a, p, f, _, x) } evaluate(e) { return new Intl.NumberFormat(this.locale ? this.locale.evaluate(e) : [], { style: this.currency ? "currency" : "decimal", currency: this.currency ? this.currency.evaluate(e) : void 0, minimumFractionDigits: this.minFractionDigits ? this.minFractionDigits.evaluate(e) : void 0, maximumFractionDigits: this.maxFractionDigits ? this.maxFractionDigits.evaluate(e) : void 0 }).format(this.number.evaluate(e)) } eachChild(e) { e(this.number), this.locale && e(this.locale), this.currency && e(this.currency), this.minFractionDigits && e(this.minFractionDigits), this.maxFractionDigits && e(this.maxFractionDigits) } outputDefined() { return !1 } } class Va { constructor(e) { this.type = ka, this.sections = e } static parse(e, r) { if (e.length < 2) return r.error("Expected at least one argument."); const a = e[1]; if (!Array.isArray(a) && typeof a == "object") return r.error("First argument must be an image or text section."); const u = []; let p = !1; for (let f = 1; f <= e.length - 1; ++f) { const _ = e[f]; if (p && typeof _ == "object" && !Array.isArray(_)) { p = !1; let x = null; if (_["font-scale"] && (x = r.parse(_["font-scale"], 1, at), !x)) return null; let S = null; if (_["text-font"] && (S = r.parse(_["text-font"], 1, kn(Dt)), !S)) return null; let M = null; if (_["text-color"] && (M = r.parse(_["text-color"], 1, Yn), !M)) return null; let C = null; if (_["vertical-align"]) { if (typeof _["vertical-align"] == "string" && !Bm.includes(_["vertical-align"])) return r.error(`'vertical-align' must be one of: 'bottom', 'center', 'top' but found '${_["vertical-align"]}' instead.`); if (C = r.parse(_["vertical-align"], 1, Dt), !C) return null } const k = u[u.length - 1]; k.scale = x, k.font = S, k.textColor = M, k.verticalAlign = C } else { const x = r.parse(e[f], 1, At); if (!x) return null; const S = x.type.kind; if (S !== "string" && S !== "value" && S !== "null" && S !== "resolvedImage") return r.error("Formatted text type must be 'string', 'value', 'image' or 'null'."); p = !0, u.push({ content: x, scale: null, font: null, textColor: null, verticalAlign: null }) } } return new Va(u) } evaluate(e) { return new Vn(this.sections.map(r => { const a = r.content.evaluate(e); return Lr(a) === Ao ? new Dc("", a, null, null, null, r.verticalAlign ? r.verticalAlign.evaluate(e) : null) : new Dc(qs(a), null, r.scale ? r.scale.evaluate(e) : null, r.font ? r.font.evaluate(e).join(",") : null, r.textColor ? r.textColor.evaluate(e) : null, r.verticalAlign ? r.verticalAlign.evaluate(e) : null) })) } eachChild(e) { for (const r of this.sections) e(r.content), r.scale && e(r.scale), r.font && e(r.font), r.textColor && e(r.textColor), r.verticalAlign && e(r.verticalAlign) } outputDefined() { return !1 } } class jo { constructor(e) { this.type = Ao, this.input = e } static parse(e, r) { if (e.length !== 2) return r.error("Expected two arguments."); const a = r.parse(e[1], 1, Dt); return a ? new jo(a) : r.error("No image name provided.") } evaluate(e) { const r = this.input.evaluate(e), a = Kn.fromString(r); return a && e.availableImages && (a.available = e.availableImages.indexOf(r) > -1), a } eachChild(e) { e(this.input) } outputDefined() { return !1 } } class Vo { constructor(e) { this.type = at, this.input = e } static parse(e, r) { if (e.length !== 2) return r.error(`Expected 1 argument, but found ${e.length - 1} instead.`); const a = r.parse(e[1], 1); return a ? a.type.kind !== "array" && a.type.kind !== "string" && a.type.kind !== "value" ? r.error(`Expected argument of type string or array, but found ${er(a.type)} instead.`) : new Vo(a) : null } evaluate(e) { const r = this.input.evaluate(e); if (typeof r == "string") return [...r].length; if (Array.isArray(r)) return r.length; throw new sr(`Expected value to be of type string or array, but found ${er(Lr(r))} instead.`) } eachChild(e) { e(this.input) } outputDefined() { return !1 } } const Xr = 8192; function Xd(n, e) { const r = (180 + n[0]) / 360, a = (180 - 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + n[1] * Math.PI / 360))) / 360, u = Math.pow(2, e.z); return [Math.round(r * u * Xr), Math.round(a * u * Xr)] } function Uo(n, e) { const r = Math.pow(2, e.z); return [(u = (n[0] / Xr + e.x) / r, 360 * u - 180), (a = (n[1] / Xr + e.y) / r, 360 / Math.PI * Math.atan(Math.exp((180 - 360 * a) * Math.PI / 180)) - 90)]; var a, u } function Ua(n, e) { n[0] = Math.min(n[0], e[0]), n[1] = Math.min(n[1], e[1]), n[2] = Math.max(n[2], e[0]), n[3] = Math.max(n[3], e[1]) } function Xs(n, e) { return !(n[0] <= e[0] || n[2] >= e[2] || n[1] <= e[1] || n[3] >= e[3]) } function jm(n, e, r) { const a = n[0] - e[0], u = n[1] - e[1], p = n[0] - r[0], f = n[1] - r[1]; return a * f - p * u == 0 && a * p <= 0 && u * f <= 0 } function Kl(n, e, r, a) { return (u = [a[0] - r[0], a[1] - r[1]])[0] * (p = [e[0] - n[0], e[1] - n[1]])[1] - u[1] * p[0] != 0 && !(!Oc(n, e, r, a) || !Oc(r, a, n, e)); var u, p } function Vm(n, e, r) { for (const a of r) for (let u = 0; u < a.length - 1; ++u)if (Kl(n, e, a[u], a[u + 1])) return !0; return !1 } function Go(n, e, r = !1) { let a = !1; for (const _ of e) for (let x = 0; x < _.length - 1; x++) { if (jm(n, _[x], _[x + 1])) return r; (p = _[x])[1] > (u = n)[1] != (f = _[x + 1])[1] > u[1] && u[0] < (f[0] - p[0]) * (u[1] - p[1]) / (f[1] - p[1]) + p[0] && (a = !a) } var u, p, f; return a } function Ql(n, e) { for (const r of e) if (Go(n, r)) return !0; return !1 } function Yd(n, e) { for (const r of n) if (!Go(r, e)) return !1; for (let r = 0; r < n.length - 1; ++r)if (Vm(n[r], n[r + 1], e)) return !1; return !0 } function Kd(n, e) { for (const r of e) if (Yd(n, r)) return !0; return !1 } function Oc(n, e, r, a) { const u = a[0] - r[0], p = a[1] - r[1], f = (n[0] - r[0]) * p - u * (n[1] - r[1]), _ = (e[0] - r[0]) * p - u * (e[1] - r[1]); return f > 0 && _ < 0 || f < 0 && _ > 0 } function Nc(n, e, r) { const a = []; for (let u = 0; u < n.length; u++) { const p = []; for (let f = 0; f < n[u].length; f++) { const _ = Xd(n[u][f], r); Ua(e, _), p.push(_) } a.push(p) } return a } function jc(n, e, r) { const a = []; for (let u = 0; u < n.length; u++) { const p = Nc(n[u], e, r); a.push(p) } return a } function Qd(n, e, r, a) { if (n[0] < r[0] || n[0] > r[2]) { const u = .5 * a; let p = n[0] - r[0] > u ? -a : r[0] - n[0] > u ? a : 0; p === 0 && (p = n[0] - r[2] > u ? -a : r[2] - n[0] > u ? a : 0), n[0] += p } Ua(e, n) } function Jd(n, e, r, a) { const u = Math.pow(2, a.z) * Xr, p = [a.x * Xr, a.y * Xr], f = []; for (const _ of n) for (const x of _) { const S = [x.x + p[0], x.y + p[1]]; Qd(S, e, r, u), f.push(S) } return f } function ep(n, e, r, a) { const u = Math.pow(2, a.z) * Xr, p = [a.x * Xr, a.y * Xr], f = []; for (const x of n) { const S = []; for (const M of x) { const C = [M.x + p[0], M.y + p[1]]; Ua(e, C), S.push(C) } f.push(S) } if (e[2] - e[0] <= u / 2) { (_ = e)[0] = _[1] = 1 / 0, _[2] = _[3] = -1 / 0; for (const x of f) for (const S of x) Qd(S, e, r, u) } var _; return f } class Ys { constructor(e, r) { this.type = zt, this.geojson = e, this.geometries = r } static parse(e, r) { if (e.length !== 2) return r.error(`'within' expression requires exactly one argument, but found ${e.length - 1} instead.`); if (bs(e[1])) { const a = e[1]; if (a.type === "FeatureCollection") { const u = []; for (const p of a.features) { const { type: f, coordinates: _ } = p.geometry; f === "Polygon" && u.push(_), f === "MultiPolygon" && u.push(..._) } if (u.length) return new Ys(a, { type: "MultiPolygon", coordinates: u }) } else if (a.type === "Feature") { const u = a.geometry.type; if (u === "Polygon" || u === "MultiPolygon") return new Ys(a, a.geometry) } else if (a.type === "Polygon" || a.type === "MultiPolygon") return new Ys(a, a) } return r.error("'within' expression requires valid geojson object that contains polygon geometry type.") } evaluate(e) { if (e.geometry() != null && e.canonicalID() != null) { if (e.geometryType() === "Point") return function (r, a) { const u = [1 / 0, 1 / 0, -1 / 0, -1 / 0], p = [1 / 0, 1 / 0, -1 / 0, -1 / 0], f = r.canonicalID(); if (a.type === "Polygon") { const _ = Nc(a.coordinates, p, f), x = Jd(r.geometry(), u, p, f); if (!Xs(u, p)) return !1; for (const S of x) if (!Go(S, _)) return !1 } if (a.type === "MultiPolygon") { const _ = jc(a.coordinates, p, f), x = Jd(r.geometry(), u, p, f); if (!Xs(u, p)) return !1; for (const S of x) if (!Ql(S, _)) return !1 } return !0 }(e, this.geometries); if (e.geometryType() === "LineString") return function (r, a) { const u = [1 / 0, 1 / 0, -1 / 0, -1 / 0], p = [1 / 0, 1 / 0, -1 / 0, -1 / 0], f = r.canonicalID(); if (a.type === "Polygon") { const _ = Nc(a.coordinates, p, f), x = ep(r.geometry(), u, p, f); if (!Xs(u, p)) return !1; for (const S of x) if (!Yd(S, _)) return !1 } if (a.type === "MultiPolygon") { const _ = jc(a.coordinates, p, f), x = ep(r.geometry(), u, p, f); if (!Xs(u, p)) return !1; for (const S of x) if (!Kd(S, _)) return !1 } return !0 }(e, this.geometries) } return !1 } eachChild() { } outputDefined() { return !0 } } let tp = class { constructor(n = [], e = (r, a) => r < a ? -1 : r > a ? 1 : 0) { if (this.data = n, this.length = this.data.length, this.compare = e, this.length > 0) for (let r = (this.length >> 1) - 1; r >= 0; r--)this._down(r) } push(n) { this.data.push(n), this._up(this.length++) } pop() { if (this.length === 0) return; const n = this.data[0], e = this.data.pop(); return --this.length > 0 && (this.data[0] = e, this._down(0)), n } peek() { return this.data[0] } _up(n) { const { data: e, compare: r } = this, a = e[n]; for (; n > 0;) { const u = n - 1 >> 1, p = e[u]; if (r(a, p) >= 0) break; e[n] = p, n = u } e[n] = a } _down(n) { const { data: e, compare: r } = this, a = this.length >> 1, u = e[n]; for (; n < a;) { let p = 1 + (n << 1); const f = p + 1; if (f < this.length && r(e[f], e[p]) < 0 && (p = f), r(e[p], u) >= 0) break; e[n] = e[p], n = p } e[n] = u } }; function Vc(n, e, r = 0, a = n.length - 1, u = rp) { for (; a > r;) { if (a - r > 600) { const x = a - r + 1, S = e - r + 1, M = Math.log(x), C = .5 * Math.exp(2 * M / 3), k = .5 * Math.sqrt(M * C * (x - C) / x) * (S - x / 2 < 0 ? -1 : 1); Vc(n, e, Math.max(r, Math.floor(e - S * C / x + k)), Math.min(a, Math.floor(e + (x - S) * C / x + k)), u) } const p = n[e]; let f = r, _ = a; for ($o(n, r, e), u(n[a], p) > 0 && $o(n, r, a); f < _;) { for ($o(n, f, _), f++, _--; u(n[f], p) < 0;)f++; for (; u(n[_], p) > 0;)_-- } u(n[r], p) === 0 ? $o(n, r, _) : (_++, $o(n, _, a)), _ <= e && (r = _ + 1), e <= _ && (a = _ - 1) } } function $o(n, e, r) { const a = n[e]; n[e] = n[r], n[r] = a } function rp(n, e) { return n < e ? -1 : n > e ? 1 : 0 } function Jl(n, e) { if (n.length <= 1) return [n]; const r = []; let a, u; for (const p of n) { const f = Gm(p); f !== 0 && (p.area = Math.abs(f), u === void 0 && (u = f < 0), u === f < 0 ? (a && r.push(a), a = [p]) : a.push(p)) } if (a && r.push(a), e > 1) for (let p = 0; p < r.length; p++)r[p].length <= e || (Vc(r[p], e, 1, r[p].length - 1, Um), r[p] = r[p].slice(0, e)); return r } function Um(n, e) { return e.area - n.area } function Gm(n) { let e = 0; for (let r, a, u = 0, p = n.length, f = p - 1; u < p; f = u++)r = n[u], a = n[f], e += (a.x - r.x) * (r.y + a.y); return e } const np = 1 / 298.257223563, Ga = np * (2 - np), ip = Math.PI / 180; class Uc { constructor(e) { const r = 6378.137 * ip * 1e3, a = Math.cos(e * ip), u = 1 / (1 - Ga * (1 - a * a)), p = Math.sqrt(u); this.kx = r * p * a, this.ky = r * p * u * (1 - Ga) } distance(e, r) { const a = this.wrap(e[0] - r[0]) * this.kx, u = (e[1] - r[1]) * this.ky; return Math.sqrt(a * a + u * u) } pointOnLine(e, r) { let a, u, p, f, _ = 1 / 0; for (let x = 0; x < e.length - 1; x++) { let S = e[x][0], M = e[x][1], C = this.wrap(e[x + 1][0] - S) * this.kx, k = (e[x + 1][1] - M) * this.ky, D = 0; C === 0 && k === 0 || (D = (this.wrap(r[0] - S) * this.kx * C + (r[1] - M) * this.ky * k) / (C * C + k * k), D > 1 ? (S = e[x + 1][0], M = e[x + 1][1]) : D > 0 && (S += C / this.kx * D, M += k / this.ky * D)), C = this.wrap(r[0] - S) * this.kx, k = (r[1] - M) * this.ky; const L = C * C + k * k; L < _ && (_ = L, a = S, u = M, p = x, f = D) } return { point: [a, u], index: p, t: Math.max(0, Math.min(1, f)) } } wrap(e) { for (; e < -180;)e += 360; for (; e > 180;)e -= 360; return e } } function sp(n, e) { return e[0] - n[0] } function eu(n) { return n[1] - n[0] + 1 } function bi(n, e) { return n[1] >= n[0] && n[1] < e } function tu(n, e) { if (n[0] > n[1]) return [null, null]; const r = eu(n); if (e) { if (r === 2) return [n, null]; const u = Math.floor(r / 2); return [[n[0], n[0] + u], [n[0] + u, n[1]]] } if (r === 1) return [n, null]; const a = Math.floor(r / 2) - 1; return [[n[0], n[0] + a], [n[0] + a + 1, n[1]]] } function Gc(n, e) { if (!bi(e, n.length)) return [1 / 0, 1 / 0, -1 / 0, -1 / 0]; const r = [1 / 0, 1 / 0, -1 / 0, -1 / 0]; for (let a = e[0]; a <= e[1]; ++a)Ua(r, n[a]); return r } function $c(n) { const e = [1 / 0, 1 / 0, -1 / 0, -1 / 0]; for (const r of n) for (const a of r) Ua(e, a); return e } function qc(n) { return n[0] !== -1 / 0 && n[1] !== -1 / 0 && n[2] !== 1 / 0 && n[3] !== 1 / 0 } function ru(n, e, r) { if (!qc(n) || !qc(e)) return NaN; let a = 0, u = 0; return n[2] < e[0] && (a = e[0] - n[2]), n[0] > e[2] && (a = n[0] - e[2]), n[1] > e[3] && (u = n[1] - e[3]), n[3] < e[1] && (u = e[1] - n[3]), r.distance([0, 0], [a, u]) } function Ks(n, e, r) { const a = r.pointOnLine(e, n); return r.distance(n, a.point) } function Zc(n, e, r, a, u) { const p = Math.min(Ks(n, [r, a], u), Ks(e, [r, a], u)), f = Math.min(Ks(r, [n, e], u), Ks(a, [n, e], u)); return Math.min(p, f) } function $m(n, e, r, a, u) { if (!bi(e, n.length) || !bi(a, r.length)) return 1 / 0; let p = 1 / 0; for (let f = e[0]; f < e[1]; ++f) { const _ = n[f], x = n[f + 1]; for (let S = a[0]; S < a[1]; ++S) { const M = r[S], C = r[S + 1]; if (Kl(_, x, M, C)) return 0; p = Math.min(p, Zc(_, x, M, C, u)) } } return p } function op(n, e, r, a, u) { if (!bi(e, n.length) || !bi(a, r.length)) return NaN; let p = 1 / 0; for (let f = e[0]; f <= e[1]; ++f)for (let _ = a[0]; _ <= a[1]; ++_)if (p = Math.min(p, u.distance(n[f], r[_])), p === 0) return p; return p } function qm(n, e, r) { if (Go(n, e, !0)) return 0; let a = 1 / 0; for (const u of e) { const p = u[0], f = u[u.length - 1]; if (p !== f && (a = Math.min(a, Ks(n, [f, p], r)), a === 0)) return a; const _ = r.pointOnLine(u, n); if (a = Math.min(a, r.distance(n, _.point)), a === 0) return a } return a } function Zm(n, e, r, a) { if (!bi(e, n.length)) return NaN; for (let p = e[0]; p <= e[1]; ++p)if (Go(n[p], r, !0)) return 0; let u = 1 / 0; for (let p = e[0]; p < e[1]; ++p) { const f = n[p], _ = n[p + 1]; for (const x of r) for (let S = 0, M = x.length, C = M - 1; S < M; C = S++) { const k = x[C], D = x[S]; if (Kl(f, _, k, D)) return 0; u = Math.min(u, Zc(f, _, k, D, a)) } } return u } function ap(n, e) { for (const r of n) for (const a of r) if (Go(a, e, !0)) return !0; return !1 } function Wm(n, e, r, a = 1 / 0) { const u = $c(n), p = $c(e); if (a !== 1 / 0 && ru(u, p, r) >= a) return a; if (Xs(u, p)) { if (ap(n, e)) return 0 } else if (ap(e, n)) return 0; let f = 1 / 0; for (const _ of n) for (let x = 0, S = _.length, M = S - 1; x < S; M = x++) { const C = _[M], k = _[x]; for (const D of e) for (let L = 0, F = D.length, N = F - 1; L < F; N = L++) { const G = D[N], ee = D[L]; if (Kl(C, k, G, ee)) return 0; f = Math.min(f, Zc(C, k, G, ee, r)) } } return f } function Ht(n, e, r, a, u, p) { if (!p) return; const f = ru(Gc(a, p), u, r); f < e && n.push([f, p, [0, 0]]) } function nu(n, e, r, a, u, p, f) { if (!p || !f) return; const _ = ru(Gc(a, p), Gc(u, f), r); _ < e && n.push([_, p, f]) } function iu(n, e, r, a, u = 1 / 0) { let p = Math.min(a.distance(n[0], r[0][0]), u); if (p === 0) return p; const f = new tp([[0, [0, n.length - 1], [0, 0]]], sp), _ = $c(r); for (; f.length > 0;) { const x = f.pop(); if (x[0] >= p) continue; const S = x[1], M = e ? 50 : 100; if (eu(S) <= M) { if (!bi(S, n.length)) return NaN; if (e) { const C = Zm(n, S, r, a); if (isNaN(C) || C === 0) return C; p = Math.min(p, C) } else for (let C = S[0]; C <= S[1]; ++C) { const k = qm(n[C], r, a); if (p = Math.min(p, k), p === 0) return 0 } } else { const C = tu(S, e); Ht(f, p, a, n, _, C[0]), Ht(f, p, a, n, _, C[1]) } } return p } function su(n, e, r, a, u, p = 1 / 0) { let f = Math.min(p, u.distance(n[0], r[0])); if (f === 0) return f; const _ = new tp([[0, [0, n.length - 1], [0, r.length - 1]]], sp); for (; _.length > 0;) { const x = _.pop(); if (x[0] >= f) continue; const S = x[1], M = x[2], C = e ? 50 : 100, k = a ? 50 : 100; if (eu(S) <= C && eu(M) <= k) { if (!bi(S, n.length) && bi(M, r.length)) return NaN; let D; if (e && a) D = $m(n, S, r, M, u), f = Math.min(f, D); else if (e && !a) { const L = n.slice(S[0], S[1] + 1); for (let F = M[0]; F <= M[1]; ++F)if (D = Ks(r[F], L, u), f = Math.min(f, D), f === 0) return f } else if (!e && a) { const L = r.slice(M[0], M[1] + 1); for (let F = S[0]; F <= S[1]; ++F)if (D = Ks(n[F], L, u), f = Math.min(f, D), f === 0) return f } else D = op(n, S, r, M, u), f = Math.min(f, D) } else { const D = tu(S, e), L = tu(M, a); nu(_, f, u, n, r, D[0], L[0]), nu(_, f, u, n, r, D[0], L[1]), nu(_, f, u, n, r, D[1], L[0]), nu(_, f, u, n, r, D[1], L[1]) } } return f } function Wc(n) { return n.type === "MultiPolygon" ? n.coordinates.map(e => ({ type: "Polygon", coordinates: e })) : n.type === "MultiLineString" ? n.coordinates.map(e => ({ type: "LineString", coordinates: e })) : n.type === "MultiPoint" ? n.coordinates.map(e => ({ type: "Point", coordinates: e })) : [n] } class Qs { constructor(e, r) { this.type = at, this.geojson = e, this.geometries = r } static parse(e, r) { if (e.length !== 2) return r.error(`'distance' expression requires exactly one argument, but found ${e.length - 1} instead.`); if (bs(e[1])) { const a = e[1]; if (a.type === "FeatureCollection") return new Qs(a, a.features.map(u => Wc(u.geometry)).flat()); if (a.type === "Feature") return new Qs(a, Wc(a.geometry)); if ("type" in a && "coordinates" in a) return new Qs(a, Wc(a)) } return r.error("'distance' expression requires valid geojson object that contains polygon geometry type.") } evaluate(e) { if (e.geometry() != null && e.canonicalID() != null) { if (e.geometryType() === "Point") return function (r, a) { const u = r.geometry(), p = u.flat().map(x => Uo([x.x, x.y], r.canonical)); if (u.length === 0) return NaN; const f = new Uc(p[0][1]); let _ = 1 / 0; for (const x of a) { switch (x.type) { case "Point": _ = Math.min(_, su(p, !1, [x.coordinates], !1, f, _)); break; case "LineString": _ = Math.min(_, su(p, !1, x.coordinates, !0, f, _)); break; case "Polygon": _ = Math.min(_, iu(p, !1, x.coordinates, f, _)) }if (_ === 0) return _ } return _ }(e, this.geometries); if (e.geometryType() === "LineString") return function (r, a) { const u = r.geometry(), p = u.flat().map(x => Uo([x.x, x.y], r.canonical)); if (u.length === 0) return NaN; const f = new Uc(p[0][1]); let _ = 1 / 0; for (const x of a) { switch (x.type) { case "Point": _ = Math.min(_, su(p, !0, [x.coordinates], !1, f, _)); break; case "LineString": _ = Math.min(_, su(p, !0, x.coordinates, !0, f, _)); break; case "Polygon": _ = Math.min(_, iu(p, !0, x.coordinates, f, _)) }if (_ === 0) return _ } return _ }(e, this.geometries); if (e.geometryType() === "Polygon") return function (r, a) { const u = r.geometry(); if (u.length === 0 || u[0].length === 0) return NaN; const p = Jl(u, 0).map(x => x.map(S => S.map(M => Uo([M.x, M.y], r.canonical)))), f = new Uc(p[0][0][0][1]); let _ = 1 / 0; for (const x of a) for (const S of p) { switch (x.type) { case "Point": _ = Math.min(_, iu([x.coordinates], !1, S, f, _)); break; case "LineString": _ = Math.min(_, iu(x.coordinates, !0, S, f, _)); break; case "Polygon": _ = Math.min(_, Wm(S, x.coordinates, f, _)) }if (_ === 0) return _ } return _ }(e, this.geometries) } return NaN } eachChild() { } outputDefined() { return !0 } } class $a { constructor(e) { this.type = At, this.key = e } static parse(e, r) { if (e.length !== 2) return r.error(`Expected 1 argument, but found ${e.length - 1} instead.`); const a = e[1]; return a == null ? r.error("Global state property must be defined.") : typeof a != "string" ? r.error(`Global state property must be string, but found ${typeof e[1]} instead.`) : new $a(a) } evaluate(e) { var r; const a = (r = e.globals) === null || r === void 0 ? void 0 : r.globalState; return a && Object.keys(a).length !== 0 ? Fa(a, this.key) : null } eachChild() { } outputDefined() { return !1 } } const qo = { "==": Wd, "!=": Fc, ">": Nm, "<": Hd, ">=": Yl, "<=": Oo, array: Un, at: Nt, boolean: Un, case: Oa, coalesce: Hs, collator: No, format: Va, image: jo, in: kt, "index-of": Fo, interpolate: Rn, "interpolate-hcl": Rn, "interpolate-lab": Rn, length: Vo, let: or, literal: ji, match: jt, number: Un, "number-format": Bc, object: Un, slice: ai, step: Ts, string: Un, "to-boolean": ts, "to-color": ts, "to-number": ts, "to-string": ts, var: Lo, within: Ys, distance: Qs, "global-state": $a }; class li { constructor(e, r, a, u) { this.name = e, this.type = r, this._evaluate = a, this.args = u } evaluate(e) { return this._evaluate(e, this.args) } eachChild(e) { this.args.forEach(e) } outputDefined() { return !1 } static parse(e, r) { const a = e[0], u = li.definitions[a]; if (!u) return r.error(`Unknown expression "${a}". If you wanted a literal array, use ["literal", [...]].`, 0); const p = Array.isArray(u) ? u[0] : u.type, f = Array.isArray(u) ? [[u[1], u[2]]] : u.overloads, _ = f.filter(([S]) => !Array.isArray(S) || S.length === e.length - 1); let x = null; for (const [S, M] of _) { x = new Ws(r.registry, ou, r.path, null, r.scope); const C = []; let k = !1; for (let D = 1; D < e.length; D++) { const L = e[D], F = Array.isArray(S) ? S[D - 1] : S.type, N = x.parse(L, 1 + C.length, F); if (!N) { k = !0; break } C.push(N) } if (!k) if (Array.isArray(S) && S.length !== C.length) x.error(`Expected ${S.length} arguments, but found ${C.length} instead.`); else { for (let D = 0; D < C.length; D++) { const L = Array.isArray(S) ? S[D] : S.type, F = C[D]; x.concat(D + 1).checkSubtype(L, F.type) } if (x.errors.length === 0) return new li(a, p, M, C) } } if (_.length === 1) r.errors.push(...x.errors); else { const S = (_.length ? _ : f).map(([C]) => { return k = C, Array.isArray(k) ? `(${k.map(er).join(", ")})` : `(${er(k.type)}...)`; var k }).join(" | "), M = []; for (let C = 1; C < e.length; C++) { const k = r.parse(e[C], 1 + M.length); if (!k) return null; M.push(er(k.type)) } r.error(`Expected arguments of type ${S}, but found (${M.join(", ")}) instead.`) } return null } static register(e, r) { li.definitions = r; for (const a in r) e[a] = li } } function lp(n, [e, r, a, u]) { e = e.evaluate(n), r = r.evaluate(n), a = a.evaluate(n); const p = u ? u.evaluate(n) : 1, f = Ro(e, r, a, p); if (f) throw new sr(f); return new Rt(e / 255, r / 255, a / 255, p, !1) } function up(n, e) { return n in e } function Hc(n, e) { const r = e[n]; return r === void 0 ? null : r } function Js(n) { return { type: n } } function ou(n) { if (n instanceof Lo) return ou(n.boundExpression); if (n instanceof li && n.name === "error" || n instanceof No || n instanceof Ys || n instanceof Qs || n instanceof $a) return !1; const e = n instanceof ts || n instanceof Un; let r = !0; return n.eachChild(a => { r = e ? r && ou(a) : r && a instanceof ji }), !!r && au(n) && lu(n, ["zoom", "heatmap-density", "elevation", "line-progress", "accumulated", "is-supported-script"]) } function au(n) { if (n instanceof li && (n.name === "get" && n.args.length === 1 || n.name === "feature-state" || n.name === "has" && n.args.length === 1 || n.name === "properties" || n.name === "geometry-type" || n.name === "id" || /^filter-/.test(n.name)) || n instanceof Ys || n instanceof Qs) return !1; let e = !0; return n.eachChild(r => { e && !au(r) && (e = !1) }), e } function qa(n) { if (n instanceof li && n.name === "feature-state") return !1; let e = !0; return n.eachChild(r => { e && !qa(r) && (e = !1) }), e } function lu(n, e) { if (n instanceof li && e.indexOf(n.name) >= 0) return !1; let r = !0; return n.eachChild(a => { r && !lu(a, e) && (r = !1) }), r } function cp(n) { return { result: "success", value: n } } function Zo(n) { return { result: "error", value: n } } function Wo(n) { return n["property-type"] === "data-driven" || n["property-type"] === "cross-faded-data-driven" } function hp(n) { return !!n.expression && n.expression.parameters.indexOf("zoom") > -1 } function Xc(n) { return !!n.expression && n.expression.interpolated } function Lt(n) { return n instanceof Number ? "number" : n instanceof String ? "string" : n instanceof Boolean ? "boolean" : Array.isArray(n) ? "array" : n === null ? "null" : typeof n } function uu(n) { return typeof n == "object" && n !== null && !Array.isArray(n) && Lr(n) === es } function Hm(n) { return n } function dp(n, e) { const r = n.stops && typeof n.stops[0][0] == "object", a = r || !(r || n.property !== void 0), u = n.type || (Xc(e) ? "exponential" : "interval"), p = function (M) { switch (M.type) { case "color": return Rt.parse; case "padding": return xn.parse; case "numberArray": return br.parse; case "colorArray": return Et.parse; default: return null } }(e); if (p && ((n = Cn({}, n)).stops && (n.stops = n.stops.map(M => [M[0], p(M[1])])), n.default = p(n.default ? n.default : e.default)), n.colorSpace && (f = n.colorSpace) !== "rgb" && f !== "hcl" && f !== "lab") throw new Error(`Unknown color space: "${n.colorSpace}"`); var f; const _ = function (M) { switch (M) { case "exponential": return pp; case "interval": return Ym; case "categorical": return Xm; case "identity": return Km; default: throw new Error(`Unknown function type "${M}"`) } }(u); let x, S; if (u === "categorical") { x = Object.create(null); for (const M of n.stops) x[M[0]] = M[1]; S = typeof n.stops[0][0] } if (r) { const M = {}, C = []; for (let L = 0; L < n.stops.length; L++) { const F = n.stops[L], N = F[0].zoom; M[N] === void 0 && (M[N] = { zoom: N, type: n.type, property: n.property, default: n.default, stops: [] }, C.push(N)), M[N].stops.push([F[0].value, F[1]]) } const k = []; for (const L of C) k.push([M[L].zoom, dp(M[L], e)]); const D = { name: "linear" }; return { kind: "composite", interpolationType: D, interpolationFactor: Rn.interpolationFactor.bind(void 0, D), zoomStops: k.map(L => L[0]), evaluate: ({ zoom: L }, F) => pp({ stops: k, base: n.base }, e, L).evaluate(L, F) } } if (a) { const M = u === "exponential" ? { name: "exponential", base: n.base !== void 0 ? n.base : 1 } : null; return { kind: "camera", interpolationType: M, interpolationFactor: Rn.interpolationFactor.bind(void 0, M), zoomStops: n.stops.map(C => C[0]), evaluate: ({ zoom: C }) => _(n, e, C, x, S) } } return { kind: "source", evaluate(M, C) { const k = C && C.properties ? C.properties[n.property] : void 0; return k === void 0 ? Za(n.default, e.default) : _(n, e, k, x, S) } } } function Za(n, e, r) { return n !== void 0 ? n : e !== void 0 ? e : r !== void 0 ? r : void 0 } function Xm(n, e, r, a, u) { return Za(typeof r === u ? a[r] : void 0, n.default, e.default) } function Ym(n, e, r) { if (Lt(r) !== "number") return Za(n.default, e.default); const a = n.stops.length; if (a === 1 || r <= n.stops[0][0]) return n.stops[0][1]; if (r >= n.stops[a - 1][0]) return n.stops[a - 1][1]; const u = Bo(n.stops.map(p => p[0]), r); return n.stops[u][1] } function pp(n, e, r) { const a = n.base !== void 0 ? n.base : 1; if (Lt(r) !== "number") return Za(n.default, e.default); const u = n.stops.length; if (u === 1 || r <= n.stops[0][0]) return n.stops[0][1]; if (r >= n.stops[u - 1][0]) return n.stops[u - 1][1]; const p = Bo(n.stops.map(M => M[0]), r), f = function (M, C, k, D) { const L = D - k, F = M - k; return L === 0 ? 0 : C === 1 ? F / L : (Math.pow(C, F) - 1) / (Math.pow(C, L) - 1) }(r, a, n.stops[p][0], n.stops[p + 1][0]), _ = n.stops[p][1], x = n.stops[p + 1][1], S = _r[e.type] || Hm; return typeof _.evaluate == "function" ? { evaluate(...M) { const C = _.evaluate.apply(void 0, M), k = x.evaluate.apply(void 0, M); if (C !== void 0 && k !== void 0) return S(C, k, f, n.colorSpace) } } : S(_, x, f, n.colorSpace) } function Km(n, e, r) { switch (e.type) { case "color": r = Rt.parse(r); break; case "formatted": r = Vn.fromString(r.toString()); break; case "resolvedImage": r = Kn.fromString(r.toString()); break; case "padding": r = xn.parse(r); break; case "colorArray": r = Et.parse(r); break; case "numberArray": r = br.parse(r); break; default: Lt(r) === e.type || e.type === "enum" && e.values[r] || (r = void 0) }return Za(r, n.default, e.default) } li.register(qo, { error: [{ kind: "error" }, [Dt], (n, [e]) => { throw new sr(e.evaluate(n)) }], typeof: [Dt, [At], (n, [e]) => er(Lr(e.evaluate(n)))], "to-rgba": [kn(at, 4), [Yn], (n, [e]) => { const [r, a, u, p] = e.evaluate(n).rgb; return [255 * r, 255 * a, 255 * u, p] }], rgb: [Yn, [at, at, at], lp], rgba: [Yn, [at, at, at, at], lp], has: { type: zt, overloads: [[[Dt], (n, [e]) => up(e.evaluate(n), n.properties())], [[Dt, es], (n, [e, r]) => up(e.evaluate(n), r.evaluate(n))]] }, get: { type: At, overloads: [[[Dt], (n, [e]) => Hc(e.evaluate(n), n.properties())], [[Dt, es], (n, [e, r]) => Hc(e.evaluate(n), r.evaluate(n))]] }, "feature-state": [At, [Dt], (n, [e]) => Hc(e.evaluate(n), n.featureState || {})], properties: [es, [], n => n.properties()], "geometry-type": [Dt, [], n => n.geometryType()], id: [At, [], n => n.id()], zoom: [at, [], n => n.globals.zoom], "heatmap-density": [at, [], n => n.globals.heatmapDensity || 0], elevation: [at, [], n => n.globals.elevation || 0], "line-progress": [at, [], n => n.globals.lineProgress || 0], accumulated: [At, [], n => n.globals.accumulated === void 0 ? null : n.globals.accumulated], "+": [at, Js(at), (n, e) => { let r = 0; for (const a of e) r += a.evaluate(n); return r }], "*": [at, Js(at), (n, e) => { let r = 1; for (const a of e) r *= a.evaluate(n); return r }], "-": { type: at, overloads: [[[at, at], (n, [e, r]) => e.evaluate(n) - r.evaluate(n)], [[at], (n, [e]) => -e.evaluate(n)]] }, "/": [at, [at, at], (n, [e, r]) => e.evaluate(n) / r.evaluate(n)], "%": [at, [at, at], (n, [e, r]) => e.evaluate(n) % r.evaluate(n)], ln2: [at, [], () => Math.LN2], pi: [at, [], () => Math.PI], e: [at, [], () => Math.E], "^": [at, [at, at], (n, [e, r]) => Math.pow(e.evaluate(n), r.evaluate(n))], sqrt: [at, [at], (n, [e]) => Math.sqrt(e.evaluate(n))], log10: [at, [at], (n, [e]) => Math.log(e.evaluate(n)) / Math.LN10], ln: [at, [at], (n, [e]) => Math.log(e.evaluate(n))], log2: [at, [at], (n, [e]) => Math.log(e.evaluate(n)) / Math.LN2], sin: [at, [at], (n, [e]) => Math.sin(e.evaluate(n))], cos: [at, [at], (n, [e]) => Math.cos(e.evaluate(n))], tan: [at, [at], (n, [e]) => Math.tan(e.evaluate(n))], asin: [at, [at], (n, [e]) => Math.asin(e.evaluate(n))], acos: [at, [at], (n, [e]) => Math.acos(e.evaluate(n))], atan: [at, [at], (n, [e]) => Math.atan(e.evaluate(n))], min: [at, Js(at), (n, e) => Math.min(...e.map(r => r.evaluate(n)))], max: [at, Js(at), (n, e) => Math.max(...e.map(r => r.evaluate(n)))], abs: [at, [at], (n, [e]) => Math.abs(e.evaluate(n))], round: [at, [at], (n, [e]) => { const r = e.evaluate(n); return r < 0 ? -Math.round(-r) : Math.round(r) }], floor: [at, [at], (n, [e]) => Math.floor(e.evaluate(n))], ceil: [at, [at], (n, [e]) => Math.ceil(e.evaluate(n))], "filter-==": [zt, [Dt, At], (n, [e, r]) => n.properties()[e.value] === r.value], "filter-id-==": [zt, [At], (n, [e]) => n.id() === e.value], "filter-type-==": [zt, [Dt], (n, [e]) => n.geometryType() === e.value], "filter-<": [zt, [Dt, At], (n, [e, r]) => { const a = n.properties()[e.value], u = r.value; return typeof a == typeof u && a < u }], "filter-id-<": [zt, [At], (n, [e]) => { const r = n.id(), a = e.value; return typeof r == typeof a && r < a }], "filter->": [zt, [Dt, At], (n, [e, r]) => { const a = n.properties()[e.value], u = r.value; return typeof a == typeof u && a > u }], "filter-id->": [zt, [At], (n, [e]) => { const r = n.id(), a = e.value; return typeof r == typeof a && r > a }], "filter-<=": [zt, [Dt, At], (n, [e, r]) => { const a = n.properties()[e.value], u = r.value; return typeof a == typeof u && a <= u }], "filter-id-<=": [zt, [At], (n, [e]) => { const r = n.id(), a = e.value; return typeof r == typeof a && r <= a }], "filter->=": [zt, [Dt, At], (n, [e, r]) => { const a = n.properties()[e.value], u = r.value; return typeof a == typeof u && a >= u }], "filter-id->=": [zt, [At], (n, [e]) => { const r = n.id(), a = e.value; return typeof r == typeof a && r >= a }], "filter-has": [zt, [At], (n, [e]) => e.value in n.properties()], "filter-has-id": [zt, [], n => n.id() !== null && n.id() !== void 0], "filter-type-in": [zt, [kn(Dt)], (n, [e]) => e.value.indexOf(n.geometryType()) >= 0], "filter-id-in": [zt, [kn(At)], (n, [e]) => e.value.indexOf(n.id()) >= 0], "filter-in-small": [zt, [Dt, kn(At)], (n, [e, r]) => r.value.indexOf(n.properties()[e.value]) >= 0], "filter-in-large": [zt, [Dt, kn(At)], (n, [e, r]) => function (a, u, p, f) { for (; p <= f;) { const _ = p + f >> 1; if (u[_] === a) return !0; u[_] > a ? f = _ - 1 : p = _ + 1 } return !1 }(n.properties()[e.value], r.value, 0, r.value.length - 1)], all: { type: zt, overloads: [[[zt, zt], (n, [e, r]) => e.evaluate(n) && r.evaluate(n)], [Js(zt), (n, e) => { for (const r of e) if (!r.evaluate(n)) return !1; return !0 }]] }, any: { type: zt, overloads: [[[zt, zt], (n, [e, r]) => e.evaluate(n) || r.evaluate(n)], [Js(zt), (n, e) => { for (const r of e) if (r.evaluate(n)) return !0; return !1 }]] }, "!": [zt, [zt], (n, [e]) => !e.evaluate(n)], "is-supported-script": [zt, [Dt], (n, [e]) => { const r = n.globals && n.globals.isSupportedScript; return !r || r(e.evaluate(n)) }], upcase: [Dt, [Dt], (n, [e]) => e.evaluate(n).toUpperCase()], downcase: [Dt, [Dt], (n, [e]) => e.evaluate(n).toLowerCase()], concat: [Dt, Js(At), (n, e) => e.map(r => qs(r.evaluate(n))).join("")], "resolved-locale": [Dt, [Aa], (n, [e]) => e.evaluate(n).resolvedLocale()] }); class Yc { constructor(e, r, a) { this.expression = e, this._warningHistory = {}, this._evaluator = new zc, this._defaultValue = r ? function (u) { if (u.type === "color" && uu(u.default)) return new Rt(0, 0, 0, 0); switch (u.type) { case "color": return Rt.parse(u.default) || null; case "padding": return xn.parse(u.default) || null; case "numberArray": return br.parse(u.default) || null; case "colorArray": return Et.parse(u.default) || null; case "variableAnchorOffsetCollection": return Dn.parse(u.default) || null; case "projectionDefinition": return zn.parse(u.default) || null; default: return u.default === void 0 ? null : u.default } }(r) : null, this._enumValues = r && r.type === "enum" ? r.values : null, this._globalState = a } evaluateWithoutErrorHandling(e, r, a, u, p, f) { return this._globalState && (e = eo(e, this._globalState)), this._evaluator.globals = e, this._evaluator.feature = r, this._evaluator.featureState = a, this._evaluator.canonical = u, this._evaluator.availableImages = p || null, this._evaluator.formattedSection = f, this.expression.evaluate(this._evaluator) } evaluate(e, r, a, u, p, f) { this._globalState && (e = eo(e, this._globalState)), this._evaluator.globals = e, this._evaluator.feature = r || null, this._evaluator.featureState = a || null, this._evaluator.canonical = u, this._evaluator.availableImages = p || null, this._evaluator.formattedSection = f || null; try { const _ = this.expression.evaluate(this._evaluator); if (_ == null || typeof _ == "number" && _ != _) return this._defaultValue; if (this._enumValues && !(_ in this._enumValues)) throw new sr(`Expected value to be one of ${Object.keys(this._enumValues).map(x => JSON.stringify(x)).join(", ")}, but found ${JSON.stringify(_)} instead.`); return _ } catch (_) { return this._warningHistory[_.message] || (this._warningHistory[_.message] = !0, typeof console < "u" && console.warn(_.message)), this._defaultValue } } } function Ho(n) { return Array.isArray(n) && n.length > 0 && typeof n[0] == "string" && n[0] in qo } function Wa(n, e, r) { const a = new Ws(qo, ou, [], e ? function (p) { const f = { color: Yn, string: Dt, number: at, enum: Dt, boolean: zt, formatted: ka, padding: $l, numberArray: Da, colorArray: Co, projectionDefinition: Gl, resolvedImage: Ao, variableAnchorOffsetCollection: za }; return p.type === "array" ? kn(f[p.value] || At, p.length) : f[p.type] }(e) : void 0), u = a.parse(n, void 0, void 0, void 0, e && e.type === "string" ? { typeAnnotation: "coerce" } : void 0); return u ? cp(new Yc(u, e, r)) : Zo(a.errors) } class cu { constructor(e, r, a) { this.kind = e, this._styleExpression = r, this.isStateDependent = e !== "constant" && !qa(r.expression), this.globalStateRefs = Ss(r.expression), this._globalState = a } evaluateWithoutErrorHandling(e, r, a, u, p, f) { return this._globalState && (e = eo(e, this._globalState)), this._styleExpression.evaluateWithoutErrorHandling(e, r, a, u, p, f) } evaluate(e, r, a, u, p, f) { return this._globalState && (e = eo(e, this._globalState)), this._styleExpression.evaluate(e, r, a, u, p, f) } } class Kc { constructor(e, r, a, u, p) { this.kind = e, this.zoomStops = a, this._styleExpression = r, this.isStateDependent = e !== "camera" && !qa(r.expression), this.globalStateRefs = Ss(r.expression), this.interpolationType = u, this._globalState = p } evaluateWithoutErrorHandling(e, r, a, u, p, f) { return this._globalState && (e = eo(e, this._globalState)), this._styleExpression.evaluateWithoutErrorHandling(e, r, a, u, p, f) } evaluate(e, r, a, u, p, f) { return this._globalState && (e = eo(e, this._globalState)), this._styleExpression.evaluate(e, r, a, u, p, f) } interpolationFactor(e, r, a) { return this.interpolationType ? Rn.interpolationFactor(this.interpolationType, e, r, a) : 0 } } function Qc(n, e, r) { const a = Wa(n, e, r); if (a.result === "error") return a; const u = a.value.expression, p = au(u); if (!p && !Wo(e)) return Zo([new An("", "data expressions not supported")]); const f = lu(u, ["zoom"]); if (!f && !hp(e)) return Zo([new An("", "zoom expressions not supported")]); const _ = du(u); return _ || f ? _ instanceof An ? Zo([_]) : _ instanceof Rn && !Xc(e) ? Zo([new An("", '"interpolate" expressions cannot be used with this property')]) : cp(_ ? new Kc(p ? "camera" : "composite", a.value, _.labels, _ instanceof Rn ? _.interpolation : void 0, r) : new cu(p ? "constant" : "source", a.value, r)) : Zo([new An("", '"zoom" expression may only be used as input to a top-level "step" or "interpolate" expression.')]) } class hu { constructor(e, r) { this._parameters = e, this._specification = r, Cn(this, dp(this._parameters, this._specification)) } static deserialize(e) { return new hu(e._parameters, e._specification) } static serialize(e) { return { _parameters: e._parameters, _specification: e._specification } } } function du(n) { let e = null; if (n instanceof or) e = du(n.result); else if (n instanceof Hs) { for (const r of n.args) if (e = du(r), e) break } else (n instanceof Ts || n instanceof Rn) && n.input instanceof li && n.input.name === "zoom" && (e = n); return e instanceof An || n.eachChild(r => { const a = du(r); a instanceof An ? e = a : !e && a ? e = new An("", '"zoom" expression may only be used as input to a top-level "step" or "interpolate" expression.') : e && a && e !== a && (e = new An("", 'Only one zoom-based "step" or "interpolate" subexpression may be used in an expression.')) }), e } function Ss(n, e = new Set) { return n instanceof $a && e.add(n.key), n.eachChild(r => { Ss(r, e) }), e } function eo(n, e) { const { zoom: r, heatmapDensity: a, elevation: u, lineProgress: p, isSupportedScript: f, accumulated: _ } = n ?? {}; return { zoom: r, heatmapDensity: a, elevation: u, lineProgress: p, isSupportedScript: f, accumulated: _, globalState: e } } function Jc(n) { if (n === !0 || n === !1) return !0; if (!Array.isArray(n) || n.length === 0) return !1; switch (n[0]) { case "has": return n.length >= 2 && n[1] !== "$id" && n[1] !== "$type"; case "in": return n.length >= 3 && (typeof n[1] != "string" || Array.isArray(n[2])); case "!in": case "!has": case "none": return !1; case "==": case "!=": case ">": case ">=": case "<": case "<=": return n.length !== 3 || Array.isArray(n[1]) || Array.isArray(n[2]); case "any": case "all": for (const e of n.slice(1)) if (!Jc(e) && typeof e != "boolean") return !1; return !0; default: return !0 } } const Qm = { type: "boolean", default: !1, transition: !1, "property-type": "data-driven", expression: { interpolated: !1, parameters: ["zoom", "feature"] } }; function Ha(n, e) { if (n == null) return { filter: () => !0, needGeometry: !1, getGlobalStateRefs: () => new Set }; Jc(n) || (n = Xa(n)); const r = Wa(n, Qm, e); if (r.result === "error") throw new Error(r.value.map(a => `${a.key}: ${a.message}`).join(", ")); return { filter: (a, u, p) => r.value.evaluate(a, u, {}, p), needGeometry: fp(n), getGlobalStateRefs: () => Ss(r.value.expression) } } function Jm(n, e) { return n < e ? -1 : n > e ? 1 : 0 } function fp(n) { if (!Array.isArray(n)) return !1; if (n[0] === "within" || n[0] === "distance") return !0; for (let e = 1; e < n.length; e++)if (fp(n[e])) return !0; return !1 } function Xa(n) { if (!n) return !0; const e = n[0]; return n.length <= 1 ? e !== "any" : e === "==" ? pu(n[1], n[2], "==") : e === "!=" ? Ya(pu(n[1], n[2], "==")) : e === "<" || e === ">" || e === "<=" || e === ">=" ? pu(n[1], n[2], e) : e === "any" ? (r = n.slice(1), ["any"].concat(r.map(Xa))) : e === "all" ? ["all"].concat(n.slice(1).map(Xa)) : e === "none" ? ["all"].concat(n.slice(1).map(Xa).map(Ya)) : e === "in" ? mp(n[1], n.slice(2)) : e === "!in" ? Ya(mp(n[1], n.slice(2))) : e === "has" ? gp(n[1]) : e !== "!has" || Ya(gp(n[1])); var r } function pu(n, e, r) { switch (n) { case "$type": return [`filter-type-${r}`, e]; case "$id": return [`filter-id-${r}`, e]; default: return [`filter-${r}`, n, e] } } function mp(n, e) { if (e.length === 0) return !1; switch (n) { case "$type": return ["filter-type-in", ["literal", e]]; case "$id": return ["filter-id-in", ["literal", e]]; default: return e.length > 200 && !e.some(r => typeof r != typeof e[0]) ? ["filter-in-large", n, ["literal", e.sort(Jm)]] : ["filter-in-small", n, ["literal", e]] } } function gp(n) { switch (n) { case "$type": return !0; case "$id": return ["filter-has-id"]; default: return ["filter-has", n] } } function Ya(n) { return ["!", n] } function fu(n) { const e = typeof n; if (e === "number" || e === "boolean" || e === "string" || n == null) return JSON.stringify(n); if (Array.isArray(n)) { let u = "["; for (const p of n) u += `${fu(p)},`; return `${u}]` } const r = Object.keys(n).sort(); let a = "{"; for (let u = 0; u < r.length; u++)a += `${JSON.stringify(r[u])}:${fu(n[r[u]])},`; return `${a}}` } function _p(n) { let e = ""; for (const r of nr) e += `/${fu(n[r])}`; return e } function yp(n) { const e = n.value; return e ? [new Qe(n.key, e, "constants have been deprecated as of v8")] : [] } function Fr(n) { return n instanceof Number || n instanceof String || n instanceof Boolean ? n.valueOf() : n } function to(n) { if (Array.isArray(n)) return n.map(to); if (n instanceof Object && !(n instanceof Number || n instanceof String || n instanceof Boolean)) { const e = {}; for (const r in n) e[r] = to(n[r]); return e } return Fr(n) } function Qn(n) { const e = n.key, r = n.value, a = n.valueSpec || {}, u = n.objectElementValidators || {}, p = n.style, f = n.styleSpec, _ = n.validateSpec; let x = []; const S = Lt(r); if (S !== "object") return [new Qe(e, r, `object expected, ${S} found`)]; for (const M in r) { const C = M.split(".")[0], k = Fa(a, C) || a["*"]; let D; if (Fa(u, C)) D = u[C]; else if (Fa(a, C)) { if (r[M] === void 0) continue; D = _ } else if (u["*"]) D = u["*"]; else { if (!a["*"]) { x.push(new Qe(e, r[M], `unknown property "${M}"`)); continue } D = _ } x = x.concat(D({ key: (e && `${e}.`) + M, value: r[M], valueSpec: k, style: p, styleSpec: f, object: r, objectKey: M, validateSpec: _ }, r)) } for (const M in a) u[M] || a[M].required && a[M].default === void 0 && r[M] === void 0 && x.push(new Qe(e, r, `missing required property "${M}"`)); return x } function mu(n) { const e = n.value, r = n.valueSpec, a = n.style, u = n.styleSpec, p = n.key, f = n.arrayElementValidator || n.validateSpec; if (Lt(e) !== "array") return [new Qe(p, e, `array expected, ${Lt(e)} found`)]; if (r.length && e.length !== r.length) return [new Qe(p, e, `array length ${r.length} expected, length ${e.length} found`)]; let _ = { type: r.value, values: r.values }; u.$version < 7 && (_.function = r.function), Lt(r.value) === "object" && (_ = r.value); let x = []; for (let S = 0; S < e.length; S++)x = x.concat(f({ array: e, arrayIndex: S, value: e[S], valueSpec: _, validateSpec: n.validateSpec, style: a, styleSpec: u, key: `${p}[${S}]` })); return x } function Ka(n) { const e = n.key, r = n.value, a = n.valueSpec; let u = Lt(r); return u === "number" && r != r && (u = "NaN"), u !== "number" ? [new Qe(e, r, `number expected, ${u} found`)] : "minimum" in a && r < a.minimum ? [new Qe(e, r, `${r} is less than the minimum value ${a.minimum}`)] : "maximum" in a && r > a.maximum ? [new Qe(e, r, `${r} is greater than the maximum value ${a.maximum}`)] : [] } function gu(n) { const e = n.valueSpec, r = Fr(n.value.type); let a, u, p, f = {}; const _ = r !== "categorical" && n.value.property === void 0, x = !_, S = Lt(n.value.stops) === "array" && Lt(n.value.stops[0]) === "array" && Lt(n.value.stops[0][0]) === "object", M = Qn({ key: n.key, value: n.value, valueSpec: n.styleSpec.function, validateSpec: n.validateSpec, style: n.style, styleSpec: n.styleSpec, objectElementValidators: { stops: function (D) { if (r === "identity") return [new Qe(D.key, D.value, 'identity function may not have a "stops" property')]; let L = []; const F = D.value; return L = L.concat(mu({ key: D.key, value: F, valueSpec: D.valueSpec, validateSpec: D.validateSpec, style: D.style, styleSpec: D.styleSpec, arrayElementValidator: C })), Lt(F) === "array" && F.length === 0 && L.push(new Qe(D.key, F, "array must have at least one stop")), L }, default: function (D) { return D.validateSpec({ key: D.key, value: D.value, valueSpec: e, validateSpec: D.validateSpec, style: D.style, styleSpec: D.styleSpec }) } } }); return r === "identity" && _ && M.push(new Qe(n.key, n.value, 'missing required property "property"')), r === "identity" || n.value.stops || M.push(new Qe(n.key, n.value, 'missing required property "stops"')), r === "exponential" && n.valueSpec.expression && !Xc(n.valueSpec) && M.push(new Qe(n.key, n.value, "exponential functions not supported")), n.styleSpec.$version >= 8 && (x && !Wo(n.valueSpec) ? M.push(new Qe(n.key, n.value, "property functions not supported")) : _ && !hp(n.valueSpec) && M.push(new Qe(n.key, n.value, "zoom functions not supported"))), r !== "categorical" && !S || n.value.property !== void 0 || M.push(new Qe(n.key, n.value, '"property" property is required')), M; function C(D) { let L = []; const F = D.value, N = D.key; if (Lt(F) !== "array") return [new Qe(N, F, `array expected, ${Lt(F)} found`)]; if (F.length !== 2) return [new Qe(N, F, `array length 2 expected, length ${F.length} found`)]; if (S) { if (Lt(F[0]) !== "object") return [new Qe(N, F, `object expected, ${Lt(F[0])} found`)]; if (F[0].zoom === void 0) return [new Qe(N, F, "object stop key must have zoom")]; if (F[0].value === void 0) return [new Qe(N, F, "object stop key must have value")]; if (p && p > Fr(F[0].zoom)) return [new Qe(N, F[0].zoom, "stop zoom values must appear in ascending order")]; Fr(F[0].zoom) !== p && (p = Fr(F[0].zoom), u = void 0, f = {}), L = L.concat(Qn({ key: `${N}[0]`, value: F[0], valueSpec: { zoom: {} }, validateSpec: D.validateSpec, style: D.style, styleSpec: D.styleSpec, objectElementValidators: { zoom: Ka, value: k } })) } else L = L.concat(k({ key: `${N}[0]`, value: F[0], validateSpec: D.validateSpec, style: D.style, styleSpec: D.styleSpec }, F)); return Ho(to(F[1])) ? L.concat([new Qe(`${N}[1]`, F[1], "expressions are not allowed in function stops.")]) : L.concat(D.validateSpec({ key: `${N}[1]`, value: F[1], valueSpec: e, validateSpec: D.validateSpec, style: D.style, styleSpec: D.styleSpec })) } function k(D, L) { const F = Lt(D.value), N = Fr(D.value), G = D.value !== null ? D.value : L; if (a) { if (F !== a) return [new Qe(D.key, G, `${F} stop domain type must match previous stop domain type ${a}`)] } else a = F; if (F !== "number" && F !== "string" && F !== "boolean") return [new Qe(D.key, G, "stop domain value must be a number, string, or boolean")]; if (F !== "number" && r !== "categorical") { let ee = `number expected, ${F} found`; return Wo(e) && r === void 0 && (ee += '\nIf you intended to use a categorical function, specify `"type": "categorical"`.'), [new Qe(D.key, G, ee)] } return r !== "categorical" || F !== "number" || isFinite(N) && Math.floor(N) === N ? r !== "categorical" && F === "number" && u !== void 0 && N < u ? [new Qe(D.key, G, "stop domain values must appear in ascending order")] : (u = N, r === "categorical" && N in f ? [new Qe(D.key, G, "stop domain values must be unique")] : (f[N] = !0, [])) : [new Qe(D.key, G, `integer expected, found ${N}`)] } } function Es(n) { const e = (n.expressionContext === "property" ? Qc : Wa)(to(n.value), n.valueSpec); if (e.result === "error") return e.value.map(a => new Qe(`${n.key}${a.key}`, n.value, a.message)); const r = e.value.expression || e.value._styleExpression.expression; if (n.expressionContext === "property" && n.propertyKey === "text-font" && !r.outputDefined()) return [new Qe(n.key, n.value, `Invalid data expression for "${n.propertyKey}". Output values must be contained as literals within the expression.`)]; if (n.expressionContext === "property" && n.propertyType === "layout" && !qa(r)) return [new Qe(n.key, n.value, '"feature-state" data expressions are not supported with layout properties.')]; if (n.expressionContext === "filter" && !qa(r)) return [new Qe(n.key, n.value, '"feature-state" data expressions are not supported with filters.')]; if (n.expressionContext && n.expressionContext.indexOf("cluster") === 0) { if (!lu(r, ["zoom", "feature-state"])) return [new Qe(n.key, n.value, '"zoom" and "feature-state" expressions are not supported with cluster properties.')]; if (n.expressionContext === "cluster-initial" && !au(r)) return [new Qe(n.key, n.value, "Feature data expressions are not supported with initial expression part of cluster properties.")] } return [] } function Qa(n) { const e = n.key, r = n.value, a = Lt(r); return a !== "string" ? [new Qe(e, r, `color expected, ${a} found`)] : Rt.parse(String(r)) ? [] : [new Qe(e, r, `color expected, "${r}" found`)] } function ro(n) { const e = n.key, r = n.value, a = n.valueSpec, u = []; return Array.isArray(a.values) ? a.values.indexOf(Fr(r)) === -1 && u.push(new Qe(e, r, `expected one of [${a.values.join(", ")}], ${JSON.stringify(r)} found`)) : Object.keys(a.values).indexOf(Fr(r)) === -1 && u.push(new Qe(e, r, `expected one of [${Object.keys(a.values).join(", ")}], ${JSON.stringify(r)} found`)), u } function Xo(n) { return Jc(to(n.value)) ? Es(Cn({}, n, { expressionContext: "filter", valueSpec: { value: "boolean" } })) : vp(n) } function vp(n) { const e = n.value, r = n.key; if (Lt(e) !== "array") return [new Qe(r, e, `array expected, ${Lt(e)} found`)]; const a = n.styleSpec; let u, p = []; if (e.length < 1) return [new Qe(r, e, "filter array must have at least 1 element")]; switch (p = p.concat(ro({ key: `${r}[0]`, value: e[0], valueSpec: a.filter_operator, style: n.style, styleSpec: n.styleSpec })), Fr(e[0])) { case "<": case "<=": case ">": case ">=": e.length >= 2 && Fr(e[1]) === "$type" && p.push(new Qe(r, e, `"$type" cannot be use with operator "${e[0]}"`)); case "==": case "!=": e.length !== 3 && p.push(new Qe(r, e, `filter array for operator "${e[0]}" must have 3 elements`)); case "in": case "!in": e.length >= 2 && (u = Lt(e[1]), u !== "string" && p.push(new Qe(`${r}[1]`, e[1], `string expected, ${u} found`))); for (let f = 2; f < e.length; f++)u = Lt(e[f]), Fr(e[1]) === "$type" ? p = p.concat(ro({ key: `${r}[${f}]`, value: e[f], valueSpec: a.geometry_type, style: n.style, styleSpec: n.styleSpec })) : u !== "string" && u !== "number" && u !== "boolean" && p.push(new Qe(`${r}[${f}]`, e[f], `string, number, or boolean expected, ${u} found`)); break; case "any": case "all": case "none": for (let f = 1; f < e.length; f++)p = p.concat(vp({ key: `${r}[${f}]`, value: e[f], style: n.style, styleSpec: n.styleSpec })); break; case "has": case "!has": u = Lt(e[1]), e.length !== 2 ? p.push(new Qe(r, e, `filter array for "${e[0]}" operator must have 2 elements`)) : u !== "string" && p.push(new Qe(`${r}[1]`, e[1], `string expected, ${u} found`)) }return p } function xp(n, e) {
                const r = n.key, a = n.validateSpec, u = n.style, p = n.styleSpec, f = n.value, _ = n.objectKey, x = p[`${e}_${n.layerType}`]; if (!x) return []; const S = _.match(/^(.*)-transition$/); if (e === "paint" && S && x[S[1]] && x[S[1]].transition) return a({ key: r, value: f, valueSpec: p.transition, style: u, styleSpec: p }); const M = n.valueSpec || x[_]; if (!M) return [new Qe(r, f, `unknown property "${_}"`)]; let C; if (Lt(f) === "string" && Wo(M) && !M.tokens && (C = /^{([^}]+)}$/.exec(f))) return [new Qe(r, f, `"${_}" does not support interpolation syntax
Use an identity property function instead: \`{ "type": "identity", "property": ${JSON.stringify(C[1])} }\`.`)]; const k = []; return n.layerType === "symbol" && _ === "text-font" && uu(to(f)) && Fr(f.type) === "identity" && k.push(new Qe(r, f, '"text-font" does not support identity functions')), k.concat(a({ key: n.key, value: f, valueSpec: M, style: u, styleSpec: p, expressionContext: "property", propertyType: e, propertyKey: _ }))
            } function wp(n) { return xp(n, "paint") } function bp(n) { return xp(n, "layout") } function Tp(n) { let e = []; const r = n.value, a = n.key, u = n.style, p = n.styleSpec; if (Lt(r) !== "object") return [new Qe(a, r, `object expected, ${Lt(r)} found`)]; r.type || r.ref || e.push(new Qe(a, r, 'either "type" or "ref" is required')); let f = Fr(r.type); const _ = Fr(r.ref); if (r.id) { const x = Fr(r.id); for (let S = 0; S < n.arrayIndex; S++) { const M = u.layers[S]; Fr(M.id) === x && e.push(new Qe(a, r.id, `duplicate layer id "${r.id}", previously used at line ${M.id.__line__}`)) } } if ("ref" in r) { let x;["type", "source", "source-layer", "filter", "layout"].forEach(S => { S in r && e.push(new Qe(a, r[S], `"${S}" is prohibited for ref layers`)) }), u.layers.forEach(S => { Fr(S.id) === _ && (x = S) }), x ? x.ref ? e.push(new Qe(a, r.ref, "ref cannot reference another ref layer")) : f = Fr(x.type) : e.push(new Qe(a, r.ref, `ref layer "${_}" not found`)) } else if (f !== "background") if (r.source) { const x = u.sources && u.sources[r.source], S = x && Fr(x.type); x ? S === "vector" && f === "raster" ? e.push(new Qe(a, r.source, `layer "${r.id}" requires a raster source`)) : S !== "raster-dem" && f === "hillshade" || S !== "raster-dem" && f === "color-relief" ? e.push(new Qe(a, r.source, `layer "${r.id}" requires a raster-dem source`)) : S === "raster" && f !== "raster" ? e.push(new Qe(a, r.source, `layer "${r.id}" requires a vector source`)) : S !== "vector" || r["source-layer"] ? S === "raster-dem" && f !== "hillshade" && f !== "color-relief" ? e.push(new Qe(a, r.source, "raster-dem source can only be used with layer type 'hillshade' or 'color-relief'.")) : f !== "line" || !r.paint || !r.paint["line-gradient"] || S === "geojson" && x.lineMetrics || e.push(new Qe(a, r, `layer "${r.id}" specifies a line-gradient, which requires a GeoJSON source with \`lineMetrics\` enabled.`)) : e.push(new Qe(a, r, `layer "${r.id}" must specify a "source-layer"`)) : e.push(new Qe(a, r.source, `source "${r.source}" not found`)) } else e.push(new Qe(a, r, 'missing required property "source"')); return e = e.concat(Qn({ key: a, value: r, valueSpec: p.layer, style: n.style, styleSpec: n.styleSpec, validateSpec: n.validateSpec, objectElementValidators: { "*": () => [], type: () => n.validateSpec({ key: `${a}.type`, value: r.type, valueSpec: p.layer.type, style: n.style, styleSpec: n.styleSpec, validateSpec: n.validateSpec, object: r, objectKey: "type" }), filter: Xo, layout: x => Qn({ layer: r, key: x.key, value: x.value, style: x.style, styleSpec: x.styleSpec, validateSpec: x.validateSpec, objectElementValidators: { "*": S => bp(Cn({ layerType: f }, S)) } }), paint: x => Qn({ layer: r, key: x.key, value: x.value, style: x.style, styleSpec: x.styleSpec, validateSpec: x.validateSpec, objectElementValidators: { "*": S => wp(Cn({ layerType: f }, S)) } }) } })), e } function Ps(n) { const e = n.value, r = n.key, a = Lt(e); return a !== "string" ? [new Qe(r, e, `string expected, ${a} found`)] : [] } const eh = { promoteId: function ({ key: n, value: e }) { if (Lt(e) === "string") return Ps({ key: n, value: e }); { const r = []; for (const a in e) r.push(...Ps({ key: `${n}.${a}`, value: e[a] })); return r } } }; function th(n) { const e = n.value, r = n.key, a = n.styleSpec, u = n.style, p = n.validateSpec; if (!e.type) return [new Qe(r, e, '"type" is required')]; const f = Fr(e.type); let _; switch (f) { case "vector": case "raster": return _ = Qn({ key: r, value: e, valueSpec: a[`source_${f.replace("-", "_")}`], style: n.style, styleSpec: a, objectElementValidators: eh, validateSpec: p }), _; case "raster-dem": return _ = function (x) { var S; const M = (S = x.sourceName) !== null && S !== void 0 ? S : "", C = x.value, k = x.styleSpec, D = k.source_raster_dem, L = x.style; let F = []; const N = Lt(C); if (C === void 0) return F; if (N !== "object") return F.push(new Qe("source_raster_dem", C, `object expected, ${N} found`)), F; const G = Fr(C.encoding) === "custom", ee = ["redFactor", "greenFactor", "blueFactor", "baseShift"], q = x.value.encoding ? `"${x.value.encoding}"` : "Default"; for (const H in C) !G && ee.includes(H) ? F.push(new Qe(H, C[H], `In "${M}": "${H}" is only valid when "encoding" is set to "custom". ${q} encoding found`)) : D[H] ? F = F.concat(x.validateSpec({ key: H, value: C[H], valueSpec: D[H], validateSpec: x.validateSpec, style: L, styleSpec: k })) : F.push(new Qe(H, C[H], `unknown property "${H}"`)); return F }({ sourceName: r, value: e, style: n.style, styleSpec: a, validateSpec: p }), _; case "geojson": if (_ = Qn({ key: r, value: e, valueSpec: a.source_geojson, style: u, styleSpec: a, validateSpec: p, objectElementValidators: eh }), e.cluster) for (const x in e.clusterProperties) { const [S, M] = e.clusterProperties[x], C = typeof S == "string" ? [S, ["accumulated"], ["get", x]] : S; _.push(...Es({ key: `${r}.${x}.map`, value: M, expressionContext: "cluster-map" })), _.push(...Es({ key: `${r}.${x}.reduce`, value: C, expressionContext: "cluster-reduce" })) } return _; case "video": return Qn({ key: r, value: e, valueSpec: a.source_video, style: u, validateSpec: p, styleSpec: a }); case "image": return Qn({ key: r, value: e, valueSpec: a.source_image, style: u, validateSpec: p, styleSpec: a }); case "canvas": return [new Qe(r, null, "Please use runtime APIs to add canvas sources, rather than including them in stylesheets.", "source.canvas")]; default: return ro({ key: `${r}.type`, value: e.type, valueSpec: { values: ["vector", "raster", "raster-dem", "geojson", "video", "image"] } }) } } function Ja(n) { const e = n.value, r = n.styleSpec, a = r.light, u = n.style; let p = []; const f = Lt(e); if (e === void 0) return p; if (f !== "object") return p = p.concat([new Qe("light", e, `object expected, ${f} found`)]), p; for (const _ in e) { const x = _.match(/^(.*)-transition$/); p = p.concat(x && a[x[1]] && a[x[1]].transition ? n.validateSpec({ key: _, value: e[_], valueSpec: r.transition, validateSpec: n.validateSpec, style: u, styleSpec: r }) : a[_] ? n.validateSpec({ key: _, value: e[_], valueSpec: a[_], validateSpec: n.validateSpec, style: u, styleSpec: r }) : [new Qe(_, e[_], `unknown property "${_}"`)]) } return p } function Sp(n) { const e = n.value, r = n.styleSpec, a = r.sky, u = n.style, p = Lt(e); if (e === void 0) return []; if (p !== "object") return [new Qe("sky", e, `object expected, ${p} found`)]; let f = []; for (const _ in e) f = f.concat(a[_] ? n.validateSpec({ key: _, value: e[_], valueSpec: a[_], style: u, styleSpec: r }) : [new Qe(_, e[_], `unknown property "${_}"`)]); return f } function rh(n) { const e = n.value, r = n.styleSpec, a = r.terrain, u = n.style; let p = []; const f = Lt(e); if (e === void 0) return p; if (f !== "object") return p = p.concat([new Qe("terrain", e, `object expected, ${f} found`)]), p; for (const _ in e) p = p.concat(a[_] ? n.validateSpec({ key: _, value: e[_], valueSpec: a[_], validateSpec: n.validateSpec, style: u, styleSpec: r }) : [new Qe(_, e[_], `unknown property "${_}"`)]); return p } function nh(n) { let e = []; const r = n.value, a = n.key; if (Array.isArray(r)) { const u = [], p = []; for (const f in r) r[f].id && u.includes(r[f].id) && e.push(new Qe(a, r, `all the sprites' ids must be unique, but ${r[f].id} is duplicated`)), u.push(r[f].id), r[f].url && p.includes(r[f].url) && e.push(new Qe(a, r, `all the sprites' URLs must be unique, but ${r[f].url} is duplicated`)), p.push(r[f].url), e = e.concat(Qn({ key: `${a}[${f}]`, value: r[f], valueSpec: { id: { type: "string", required: !0 }, url: { type: "string", required: !0 } }, validateSpec: n.validateSpec })); return e } return Ps({ key: a, value: r }) } function Ep(n) { return !!n && n.constructor === Object } function ih(n) { return Ep(n.value) ? [] : [new Qe(n.key, n.value, `object expected, ${Lt(n.value)} found`)] } const sh = { "*": () => [], array: mu, boolean: function (n) { const e = n.value, r = n.key, a = Lt(e); return a !== "boolean" ? [new Qe(r, e, `boolean expected, ${a} found`)] : [] }, number: Ka, color: Qa, constants: yp, enum: ro, filter: Xo, function: gu, layer: Tp, object: Qn, source: th, light: Ja, sky: Sp, terrain: rh, projection: function (n) { const e = n.value, r = n.styleSpec, a = r.projection, u = n.style, p = Lt(e); if (e === void 0) return []; if (p !== "object") return [new Qe("projection", e, `object expected, ${p} found`)]; let f = []; for (const _ in e) f = f.concat(a[_] ? n.validateSpec({ key: _, value: e[_], valueSpec: a[_], style: u, styleSpec: r }) : [new Qe(_, e[_], `unknown property "${_}"`)]); return f }, projectionDefinition: function (n) { const e = n.key; let r = n.value; r = r instanceof String ? r.valueOf() : r; const a = Lt(r); return a !== "array" || function (u) { return Array.isArray(u) && u.length === 3 && typeof u[0] == "string" && typeof u[1] == "string" && typeof u[2] == "number" }(r) || function (u) { return !!["interpolate", "step", "literal"].includes(u[0]) }(r) ? ["array", "string"].includes(a) ? [] : [new Qe(e, r, `projection expected, invalid type "${a}" found`)] : [new Qe(e, r, `projection expected, invalid array ${JSON.stringify(r)} found`)] }, string: Ps, formatted: function (n) { return Ps(n).length === 0 ? [] : Es(n) }, resolvedImage: function (n) { return Ps(n).length === 0 ? [] : Es(n) }, padding: function (n) { const e = n.key, r = n.value; if (Lt(r) === "array") { if (r.length < 1 || r.length > 4) return [new Qe(e, r, `padding requires 1 to 4 values; ${r.length} values found`)]; const a = { type: "number" }; let u = []; for (let p = 0; p < r.length; p++)u = u.concat(n.validateSpec({ key: `${e}[${p}]`, value: r[p], validateSpec: n.validateSpec, valueSpec: a })); return u } return Ka({ key: e, value: r, valueSpec: {} }) }, numberArray: function (n) { const e = n.key, r = n.value; if (Lt(r) === "array") { const a = { type: "number" }; if (r.length < 1) return [new Qe(e, r, "array length at least 1 expected, length 0 found")]; let u = []; for (let p = 0; p < r.length; p++)u = u.concat(n.validateSpec({ key: `${e}[${p}]`, value: r[p], validateSpec: n.validateSpec, valueSpec: a })); return u } return Ka({ key: e, value: r, valueSpec: {} }) }, colorArray: function (n) { const e = n.key, r = n.value; if (Lt(r) === "array") { if (r.length < 1) return [new Qe(e, r, "array length at least 1 expected, length 0 found")]; let a = []; for (let u = 0; u < r.length; u++)a = a.concat(Qa({ key: `${e}[${u}]`, value: r[u] })); return a } return Qa({ key: e, value: r }) }, variableAnchorOffsetCollection: function (n) { const e = n.key, r = n.value, a = Lt(r), u = n.styleSpec; if (a !== "array" || r.length < 1 || r.length % 2 != 0) return [new Qe(e, r, "variableAnchorOffsetCollection requires a non-empty array of even length")]; let p = []; for (let f = 0; f < r.length; f += 2)p = p.concat(ro({ key: `${e}[${f}]`, value: r[f], valueSpec: u.layout_symbol["text-anchor"] })), p = p.concat(mu({ key: `${e}[${f + 1}]`, value: r[f + 1], valueSpec: { length: 2, value: "number" }, validateSpec: n.validateSpec, style: n.style, styleSpec: u })); return p }, sprite: nh, state: ih, fontFaces: function (n) { const e = n.key, r = n.value, a = n.validateSpec, u = n.styleSpec, p = n.style; if (!Ep(r)) return [new Qe(e, r, `object expected, ${Lt(r)} found`)]; const f = []; for (const _ in r) { const x = r[_], S = Lt(x); if (S === "string") f.push(...Ps({ key: `${e}.${_}`, value: x })); else if (S === "array") { const M = { url: { type: "string", required: !0 }, "unicode-range": { type: "array", value: "string" } }; for (const [C, k] of x.entries()) f.push(...Qn({ key: `${e}.${_}[${C}]`, value: k, valueSpec: M, styleSpec: u, style: p, validateSpec: a })) } else f.push(new Qe(`${e}.${_}`, x, `string or array expected, ${S} found`)) } return f } }; function Ms(n) { const e = n.value, r = n.valueSpec, a = n.styleSpec; return n.validateSpec = Ms, r.expression && uu(Fr(e)) ? gu(n) : r.expression && Ho(to(e)) ? Es(n) : r.type && sh[r.type] ? sh[r.type](n) : Qn(Cn({}, n, { valueSpec: r.type ? a[r.type] : r })) } function Pp(n) { const e = n.value, r = n.key, a = Ps(n); return a.length || (e.indexOf("{fontstack}") === -1 && a.push(new Qe(r, e, '"glyphs" url must include a "{fontstack}" token')), e.indexOf("{range}") === -1 && a.push(new Qe(r, e, '"glyphs" url must include a "{range}" token'))), a } function ui(n, e = De) { let r = []; return r = r.concat(Ms({ key: "", value: n, valueSpec: e.$root, styleSpec: e, style: n, validateSpec: Ms, objectElementValidators: { glyphs: Pp, "*": () => [] } })), n.constants && (r = r.concat(yp({ key: "constants", value: n.constants }))), Mp(r) } function Ti(n) { return function (e) { return n(Object.assign({}, e, { validateSpec: Ms })) } } function Mp(n) { return [].concat(n).sort((e, r) => e.line - r.line) } function Si(n) { return function (...e) { return Mp(n.apply(this, e)) } } ui.source = Si(Ti(th)), ui.sprite = Si(Ti(nh)), ui.glyphs = Si(Ti(Pp)), ui.light = Si(Ti(Ja)), ui.sky = Si(Ti(Sp)), ui.terrain = Si(Ti(rh)), ui.state = Si(Ti(ih)), ui.layer = Si(Ti(Tp)), ui.filter = Si(Ti(Xo)), ui.paintProperty = Si(Ti(wp)), ui.layoutProperty = Si(Ti(bp)); const eg = { type: "enum", "property-type": "data-constant", expression: { interpolated: !1, parameters: ["global-state"] }, values: { visible: {}, none: {} }, transition: !1, default: "visible" }; class el { constructor(e, r) { this._globalState = r, this.setValue(e) } evaluate() { var e; return (e = this._literalValue) !== null && e !== void 0 ? e : this._compiledValue.evaluate({}) } setValue(e) { if (e == null || e === "visible" || e === "none") return this._literalValue = e === "none" ? "none" : "visible", this._compiledValue = void 0, void (this._globalStateRefs = new Set); const r = Wa(e, eg, this._globalState); if (r.result === "error") throw this._literalValue = "visible", this._compiledValue = void 0, new Error(r.value.map(a => `${a.key}: ${a.message}`).join(", ")); this._literalValue = void 0, this._compiledValue = r.value, this._globalStateRefs = Ss(r.value.expression) } getGlobalStateRefs() { return this._globalStateRefs } } const tl = De, nn = ui, rl = nn.light, Ip = nn.sky, tg = nn.paintProperty, rg = nn.layoutProperty; function Yo(n, e) { let r = !1; if (e && e.length) for (const a of e) n.fire(new tr(new Error(a.message))), r = !0; return r } class Ko { constructor(e, r, a) { const u = this.cells = []; if (e instanceof ArrayBuffer) { this.arrayBuffer = e; const f = new Int32Array(this.arrayBuffer); e = f[0], this.d = (r = f[1]) + 2 * (a = f[2]); for (let x = 0; x < this.d * this.d; x++) { const S = f[3 + x], M = f[3 + x + 1]; u.push(S === M ? null : f.subarray(S, M)) } const _ = f[3 + u.length + 1]; this.keys = f.subarray(f[3 + u.length], _), this.bboxes = f.subarray(_), this.insert = this._insertReadonly } else { this.d = r + 2 * a; for (let f = 0; f < this.d * this.d; f++)u.push([]); this.keys = [], this.bboxes = [] } this.n = r, this.extent = e, this.padding = a, this.scale = r / e, this.uid = 0; const p = a / r * e; this.min = -p, this.max = e + p } insert(e, r, a, u, p) { this._forEachCell(r, a, u, p, this._insertCell, this.uid++, void 0, void 0), this.keys.push(e), this.bboxes.push(r), this.bboxes.push(a), this.bboxes.push(u), this.bboxes.push(p) } _insertReadonly() { throw new Error("Cannot insert into a GridIndex created from an ArrayBuffer.") } _insertCell(e, r, a, u, p, f) { this.cells[p].push(f) } query(e, r, a, u, p) { const f = this.min, _ = this.max; if (e <= f && r <= f && _ <= a && _ <= u && !p) return Array.prototype.slice.call(this.keys); { const x = []; return this._forEachCell(e, r, a, u, this._queryCell, x, {}, p), x } } _queryCell(e, r, a, u, p, f, _, x) { const S = this.cells[p]; if (S !== null) { const M = this.keys, C = this.bboxes; for (let k = 0; k < S.length; k++) { const D = S[k]; if (_[D] === void 0) { const L = 4 * D; (x ? x(C[L + 0], C[L + 1], C[L + 2], C[L + 3]) : e <= C[L + 2] && r <= C[L + 3] && a >= C[L + 0] && u >= C[L + 1]) ? (_[D] = !0, f.push(M[D])) : _[D] = !1 } } } } _forEachCell(e, r, a, u, p, f, _, x) { const S = this._convertToCellCoord(e), M = this._convertToCellCoord(r), C = this._convertToCellCoord(a), k = this._convertToCellCoord(u); for (let D = S; D <= C; D++)for (let L = M; L <= k; L++) { const F = this.d * L + D; if ((!x || x(this._convertFromCellCoord(D), this._convertFromCellCoord(L), this._convertFromCellCoord(D + 1), this._convertFromCellCoord(L + 1))) && p.call(this, e, r, a, u, F, f, _, x)) return } } _convertFromCellCoord(e) { return (e - this.padding) / this.scale } _convertToCellCoord(e) { return Math.max(0, Math.min(this.d - 1, Math.floor(e * this.scale) + this.padding)) } toArrayBuffer() { if (this.arrayBuffer) return this.arrayBuffer; const e = this.cells, r = 3 + this.cells.length + 1 + 1; let a = 0; for (let f = 0; f < this.cells.length; f++)a += this.cells[f].length; const u = new Int32Array(r + a + this.keys.length + this.bboxes.length); u[0] = this.extent, u[1] = this.n, u[2] = this.padding; let p = r; for (let f = 0; f < e.length; f++) { const _ = e[f]; u[3 + f] = p, u.set(_, p), p += _.length } return u[3 + e.length] = p, u.set(this.keys, p), p += this.keys.length, u[3 + e.length + 1] = p, u.set(this.bboxes, p), p += this.bboxes.length, u.buffer } static serialize(e, r) { const a = e.toArrayBuffer(); return r && r.push(a), { buffer: a } } static deserialize(e) { return new Ko(e.buffer) } } const Ei = {}; function pt(n, e, r = {}) { if (Ei[n]) throw new Error(`${n} is already registered.`); Object.defineProperty(e, "_classRegistryKey", { value: n, writeable: !1 }), Ei[n] = { klass: e, omit: r.omit || [], shallow: r.shallow || [] } } pt("Object", Object), pt("Set", Set), pt("TransferableGridIndex", Ko), pt("Color", Rt), pt("Error", Error), pt("AJAXError", pe), pt("ResolvedImage", Kn), pt("StylePropertyFunction", hu), pt("StyleExpression", Yc, { omit: ["_evaluator"] }), pt("ZoomDependentExpression", Kc), pt("ZoomConstantExpression", cu), pt("CompoundExpression", li, { omit: ["_evaluate"] }); for (const n in qo) qo[n]._classRegistryKey || pt(`Expression_${n}`, qo[n]); function _u(n) { return n && typeof ArrayBuffer < "u" && (n instanceof ArrayBuffer || n.constructor && n.constructor.name === "ArrayBuffer") } function oh(n) { return n.$name || n.constructor._classRegistryKey } function Qo(n) { return !function (e) { if (e === null || typeof e != "object") return !1; const r = oh(e); return !(!r || r === "Object") }(n) && (n == null || typeof n == "boolean" || typeof n == "number" || typeof n == "string" || n instanceof Boolean || n instanceof Number || n instanceof String || n instanceof Date || n instanceof RegExp || n instanceof Blob || n instanceof Error || _u(n) || ys(n) || ArrayBuffer.isView(n) || n instanceof ImageData) } function nl(n, e) { if (Qo(n)) return (_u(n) || ys(n)) && e && e.push(n), ArrayBuffer.isView(n) && e && e.push(n.buffer), n instanceof ImageData && e && e.push(n.data.buffer), n; if (Array.isArray(n)) { const p = []; for (const f of n) p.push(nl(f, e)); return p } if (typeof n != "object") throw new Error("can't serialize object of type " + typeof n); const r = oh(n); if (!r) throw new Error(`can't serialize object of unregistered class ${n.constructor.name}`); if (!Ei[r]) throw new Error(`${r} is not registered.`); const { klass: a } = Ei[r], u = a.serialize ? a.serialize(n, e) : {}; if (a.serialize) { if (e && u === e[e.length - 1]) throw new Error("statically serialized object won't survive transfer of $name property") } else { for (const p in n) { if (!n.hasOwnProperty(p) || Ei[r].omit.indexOf(p) >= 0) continue; const f = n[p]; u[p] = Ei[r].shallow.indexOf(p) >= 0 ? f : nl(f, e) } n instanceof Error && (u.message = n.message) } if (u.$name) throw new Error("$name property is reserved for worker serialization logic."); return r !== "Object" && (u.$name = r), u } function il(n) { if (Qo(n)) return n; if (Array.isArray(n)) return n.map(il); if (typeof n != "object") throw new Error("can't deserialize object of type " + typeof n); const e = oh(n) || "Object"; if (!Ei[e]) throw new Error(`can't deserialize unregistered class ${e}`); const { klass: r } = Ei[e]; if (!r) throw new Error(`can't deserialize unregistered class ${e}`); if (r.deserialize) return r.deserialize(n); const a = Object.create(r.prototype); for (const u of Object.keys(n)) { if (u === "$name") continue; const p = n[u]; a[u] = Ei[e].shallow.indexOf(u) >= 0 ? p : il(p) } return a } class ah { constructor() { this.first = !0 } update(e, r) { const a = Math.floor(e); return this.first ? (this.first = !1, this.lastIntegerZoom = a, this.lastIntegerZoomTime = 0, this.lastZoom = e, this.lastFloorZoom = a, !0) : (this.lastFloorZoom > a ? (this.lastIntegerZoom = a + 1, this.lastIntegerZoomTime = r) : this.lastFloorZoom < a && (this.lastIntegerZoom = a, this.lastIntegerZoomTime = r), e !== this.lastZoom && (this.lastZoom = e, this.lastFloorZoom = a, !0)) } } function sl(n) { return /[\u02EA\u02EB\u2E80-\u2FDF\u2FF0-\u303F\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FD-\u30FF\u3105-\u312F\u31A0-\u4DBF\u4E00-\uA48C\uA490-\uA4C6\uF900-\uFA6D\uFA70-\uFAD9\uFE10-\uFE1F\uFE30-\uFE4F\uFF00-\uFFEF]|\uD81B[\uDFE0-\uDFFF]|[\uD81C-\uD822\uD840-\uD868\uD86A-\uD86D\uD86F-\uD872\uD874-\uD879\uD880-\uD883\uD885-\uD88C][\uDC00-\uDFFF]|\uD823[\uDC00-\uDCD5\uDCFF-\uDD1E\uDD80-\uDDF2]|\uD82B[\uDFF0-\uDFFF]|\uD82C[\uDC00-\uDEFB]|\uD83C[\uDE00-\uDEFF]|\uD869[\uDC00-\uDEDF\uDF00-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEAD\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0\uDFF0-\uDFFF]|\uD87B[\uDC00-\uDE5D]|\uD87E[\uDC00-\uDE1D]|\uD884[\uDC00-\uDF4A\uDF50-\uDFFF]|\uD88D[\uDC00-\uDC79]/gim.test(String.fromCodePoint(n)) } function lh(n) { return /[\u02EA\u02EB\u1100-\u11FF\u1400-\u167F\u18B0-\u18F5\u2E80-\u2E99\u2E9B-\u2EF3\u2F00-\u2FD5\u2FF0-\u3007\u3012\u3013\u3020-\u302F\u3031-\u303F\u3041-\u3096\u309D-\u30FB\u30FD-\u30FF\u3105-\u312F\u3131-\u318E\u3190-\uA48C\uA490-\uA4C6\uA960-\uA97C\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFE10-\uFE1F\uFE30-\uFE48\uFE50-\uFE57\uFE5F-\uFE62\uFE67-\uFE6F\uFF00-\uFF07\uFF0A-\uFF0C\uFF0E-\uFF19\uFF1F-\uFF3A\uFF3C\uFF3E\uFF40-\uFF5A\uFFE0-\uFFE2\uFFE4-\uFFE7]|\uD802[\uDD80-\uDD9F]|\uD805[\uDD80-\uDDFF]|\uD806[\uDE00-\uDEBF]|\uD811[\uDC00-\uDE7F]|\uD81B[\uDFE0-\uDFE4\uDFF0-\uDFF6]|[\uD81C-\uD822\uD83D\uD840-\uD868\uD86A-\uD86D\uD86F-\uD872\uD874-\uD879\uD880-\uD883\uD885-\uD88C][\uDC00-\uDFFF]|\uD823[\uDC00-\uDCD5\uDCFF-\uDD1E\uDD80-\uDDF2]|\uD82B[\uDFF0-\uDFF3\uDFF5-\uDFFB\uDFFD\uDFFE]|\uD82C[\uDC00-\uDD22\uDD30-\uDEFB]|\uD833[\uDEC0-\uDFCF]|\uD834[\uDC00-\uDDFF\uDEE0-\uDF7F]|\uD836[\uDC00-\uDEAF]|\uD83C[\uDC00-\uDE00\uDF00-\uDFFF]|\uD83E[\uDD00-\uDEFF]|\uD869[\uDC00-\uDEDF\uDF00-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEAD\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0\uDFF0-\uDFFF]|\uD87B[\uDC00-\uDE5D]|\uD87E[\uDC00-\uDE1D]|\uD884[\uDC00-\uDF4A\uDF50-\uDFFF]|\uD88D[\uDC00-\uDC79]/gim.test(String.fromCodePoint(n)) } function Cp(n) { return /\s/u.test(String.fromCodePoint(n)) } function Jo(n) { for (const e of n) if (lh(e.codePointAt(0))) return !0; return !1 } function ng(n) { for (const e of n) if (!Ap(e.codePointAt(0))) return !1; return !0 } function yu(n) { const e = n.map(r => { try { return new RegExp(`\\p{sc=${r}}`, "u").source } catch { return null } }).filter(r => r); return new RegExp(e.join("|"), "u") } const vu = yu(["Arab", "Dupl", "Mong", "Ougr", "Syrc"]); function Ap(n) { return !vu.test(String.fromCodePoint(n)) } function uh(n) { return !(lh(n) || (e = n, /[\xA7\xA9\xAE\xB1\xBC-\xBE\xD7\xF7\u2016\u2020\u2021\u2030\u2031\u203B\u203C\u2042\u2047-\u2049\u2051\u2100-\u218F\u221E\u2234\u2235\u2300-\u2307\u230C-\u231F\u2324-\u2328\u232B\u237D-\u239A\u23BE-\u23CD\u23CF\u23D1-\u23DB\u23E2-\u2422\u2424-\u24FF\u25A0-\u2619\u2620-\u2767\u2776-\u2793\u2B12-\u2B2F\u2B50-\u2B59\u2BB8-\u2BEB\u3000-\u303F\u30A0-\u30FF\uE000-\uF8FF\uFE30-\uFE6F\uFF00-\uFFEF\uFFFC\uFFFD]|[\uDB80-\uDBFF][\uDC00-\uDFFF]/gim.test(String.fromCodePoint(e)))); var e } const kp = yu(["Adlm", "Arab", "Armi", "Avst", "Chrs", "Cprt", "Egyp", "Elym", "Gara", "Hatr", "Hebr", "Hung", "Khar", "Lydi", "Mand", "Mani", "Mend", "Merc", "Mero", "Narb", "Nbat", "Nkoo", "Orkh", "Palm", "Phli", "Phlp", "Phnx", "Prti", "Rohg", "Samr", "Sarb", "Sogo", "Syrc", "Thaa", "Todr", "Yezi"]); function ch(n) { return kp.test(String.fromCodePoint(n)) } function hh(n, e) { return !(!e && ch(n) || /[\u0900-\u0DFF\u0F00-\u109F\u1780-\u17FF]/gim.test(String.fromCodePoint(n))) } function Dp(n) { for (const e of n) if (ch(e.codePointAt(0))) return !0; return !1 } const Is = new class { constructor() { this.TIMEOUT = 5e3, this.applyArabicShaping = null, this.processBidirectionalText = null, this.processStyledBidirectionalText = null, this.pluginStatus = "unavailable", this.pluginURL = null, this.loadScriptResolve = () => { } } setState(n) { this.pluginStatus = n.pluginStatus, this.pluginURL = n.pluginURL } getState() { return { pluginStatus: this.pluginStatus, pluginURL: this.pluginURL } } setMethods(n) { if (Is.isParsed()) throw new Error("RTL text plugin already registered."); this.applyArabicShaping = n.applyArabicShaping, this.processBidirectionalText = n.processBidirectionalText, this.processStyledBidirectionalText = n.processStyledBidirectionalText, this.loadScriptResolve() } isParsed() { return this.applyArabicShaping != null && this.processBidirectionalText != null && this.processStyledBidirectionalText != null } getRTLTextPluginStatus() { return this.pluginStatus } syncState(n, e) { return c(this, void 0, void 0, function* () { if (this.isParsed()) return this.getState(); if (n.pluginStatus !== "loading") return this.setState(n), n; const r = n.pluginURL, a = new Promise(p => { this.loadScriptResolve = p }); e(r); const u = new Promise(p => setTimeout(() => p(), this.TIMEOUT)); if (yield Promise.race([a, u]), this.isParsed()) { const p = { pluginStatus: "loaded", pluginURL: r }; return this.setState(p), p } throw this.setState({ pluginStatus: "error", pluginURL: "" }), new Error(`RTL Text Plugin failed to import scripts from ${r}`) }) } }; class rr { constructor(e, r) { this.isSupportedScript = ig, this.zoom = e, r ? (this.now = r.now || 0, this.fadeDuration = r.fadeDuration || 0, this.zoomHistory = r.zoomHistory || new ah, this.transition = r.transition || {}) : (this.now = 0, this.fadeDuration = 0, this.zoomHistory = new ah, this.transition = {}) } crossFadingFactor() { return this.fadeDuration === 0 ? 1 : Math.min((this.now - this.zoomHistory.lastIntegerZoomTime) / this.fadeDuration, 1) } getCrossfadeParameters() { const e = this.zoom, r = e - Math.floor(e), a = this.crossFadingFactor(); return e > this.zoomHistory.lastIntegerZoom ? { fromScale: 2, toScale: 1, t: r + (1 - r) * a } : { fromScale: .5, toScale: 1, t: 1 - (1 - a) * r } } } function ig(n) { return function (e, r) { for (const a of e) if (!hh(a.codePointAt(0), r)) return !1; return !0 }(n, Is.getRTLTextPluginStatus() === "loaded") } const ol = "-transition"; class xu { constructor(e, r, a) { this.property = e, this.value = r, this.expression = function (u, p, f) { if (uu(u)) return new hu(u, p); if (Ho(u)) { const _ = Qc(u, p, f); if (_.result === "error") throw new Error(_.value.map(x => `${x.key}: ${x.message}`).join(", ")); return _.value } { let _ = u; return p.type === "color" && typeof u == "string" ? _ = Rt.parse(u) : p.type !== "padding" || typeof u != "number" && !Array.isArray(u) ? p.type !== "numberArray" || typeof u != "number" && !Array.isArray(u) ? p.type !== "colorArray" || typeof u != "string" && !Array.isArray(u) ? p.type === "variableAnchorOffsetCollection" && Array.isArray(u) ? _ = Dn.parse(u) : p.type === "projectionDefinition" && typeof u == "string" && (_ = zn.parse(u)) : _ = Et.parse(u) : _ = br.parse(u) : _ = xn.parse(u), { globalStateRefs: new Set, _globalState: null, kind: "constant", evaluate: () => _ } } }(r === void 0 ? e.specification.default : r, e.specification, a) } isDataDriven() { return this.expression.kind === "source" || this.expression.kind === "composite" } getGlobalStateRefs() { return this.expression.globalStateRefs || new Set } possiblyEvaluate(e, r, a) { return this.property.possiblyEvaluate(this, e, r, a) } } class wu { constructor(e, r) { this.property = e, this.value = new xu(e, void 0, r) } transitioned(e, r) { return new zp(this.property, this.value, r, Wr({}, e.transition, this.transition), e.now) } untransitioned() { return new zp(this.property, this.value, null, {}, 0) } } class dh { constructor(e, r) { this._properties = e, this._values = Object.create(e.defaultTransitionablePropertyValues), this._globalState = r } getValue(e) { return dn(this._values[e].value.value) } setValue(e, r) { Object.prototype.hasOwnProperty.call(this._values, e) || (this._values[e] = new wu(this._values[e].property, this._globalState)), this._values[e].value = new xu(this._values[e].property, r === null ? void 0 : dn(r), this._globalState) } getTransition(e) { return dn(this._values[e].transition) } setTransition(e, r) { Object.prototype.hasOwnProperty.call(this._values, e) || (this._values[e] = new wu(this._values[e].property, this._globalState)), this._values[e].transition = dn(r) || void 0 } serialize() { const e = {}; for (const r of Object.keys(this._values)) { const a = this.getValue(r); a !== void 0 && (e[r] = a); const u = this.getTransition(r); u !== void 0 && (e[`${r}${ol}`] = u) } return e } transitioned(e, r) { const a = new Rp(this._properties); for (const u of Object.keys(this._values)) a._values[u] = this._values[u].transitioned(e, r._values[u]); return a } untransitioned() { const e = new Rp(this._properties); for (const r of Object.keys(this._values)) e._values[r] = this._values[r].untransitioned(); return e } } class zp { constructor(e, r, a, u, p) { this.property = e, this.value = r, this.begin = p + u.delay || 0, this.end = this.begin + u.duration || 0, e.specification.transition && (u.delay || u.duration) && (this.prior = a) } possiblyEvaluate(e, r, a) { const u = e.now || 0, p = this.value.possiblyEvaluate(e, r, a), f = this.prior; if (f) { if (u > this.end) return this.prior = null, p; if (this.value.isDataDriven()) return this.prior = null, p; if (u < this.begin) return f.possiblyEvaluate(e, r, a); { const _ = (u - this.begin) / (this.end - this.begin); return this.property.interpolate(f.possiblyEvaluate(e, r, a), p, Zt(_)) } } return p } } class Rp { constructor(e) { this._properties = e, this._values = Object.create(e.defaultTransitioningPropertyValues) } possiblyEvaluate(e, r, a) { const u = new al(this._properties); for (const p of Object.keys(this._values)) u._values[p] = this._values[p].possiblyEvaluate(e, r, a); return u } hasTransition() { for (const e of Object.keys(this._values)) if (this._values[e].prior) return !0; return !1 } } class Lp { constructor(e, r) { this._properties = e, this._values = Object.create(e.defaultPropertyValues), this._globalState = r } hasValue(e) { return this._values[e].value !== void 0 } getValue(e) { return dn(this._values[e].value) } setValue(e, r) { this._values[e] = new xu(this._values[e].property, r === null ? void 0 : dn(r), this._globalState) } serialize() { const e = {}; for (const r of Object.keys(this._values)) { const a = this.getValue(r); a !== void 0 && (e[r] = a) } return e } possiblyEvaluate(e, r, a) { const u = new al(this._properties); for (const p of Object.keys(this._values)) u._values[p] = this._values[p].possiblyEvaluate(e, r, a); return u } } class Pi { constructor(e, r, a) { this.property = e, this.value = r, this.parameters = a } isConstant() { return this.value.kind === "constant" } constantOr(e) { return this.value.kind === "constant" ? this.value.value : e } evaluate(e, r, a, u) { return this.property.evaluate(this.value, this.parameters, e, r, a, u) } } class al { constructor(e) { this._properties = e, this._values = Object.create(e.defaultPossiblyEvaluatedValues) } get(e) { return this._values[e] } } class vt { constructor(e) { this.specification = e } possiblyEvaluate(e, r) { if (e.isDataDriven()) throw new Error("Value should not be data driven"); return e.expression.evaluate(r) } interpolate(e, r, a) { const u = _r[this.specification.type]; return u ? u(e, r, a) : e } } class bt { constructor(e, r) { this.specification = e, this.overrides = r } possiblyEvaluate(e, r, a, u) { return new Pi(this, e.expression.kind === "constant" || e.expression.kind === "camera" ? { kind: "constant", value: e.expression.evaluate(r, null, {}, a, u) } : e.expression, r) } interpolate(e, r, a) { if (e.value.kind !== "constant" || r.value.kind !== "constant") return e; if (e.value.value === void 0 || r.value.value === void 0) return new Pi(this, { kind: "constant", value: void 0 }, e.parameters); const u = _r[this.specification.type]; if (u) { const p = u(e.value.value, r.value.value, a); return new Pi(this, { kind: "constant", value: p }, e.parameters) } return e } evaluate(e, r, a, u, p, f) { return e.kind === "constant" ? e.value : e.evaluate(r, a, u, p, f) } } class ll extends bt { possiblyEvaluate(e, r, a, u) { if (e.value === void 0) return new Pi(this, { kind: "constant", value: void 0 }, r); if (e.expression.kind === "constant") { const p = e.expression.evaluate(r, null, {}, a, u), f = e.property.specification.type === "resolvedImage" && typeof p != "string" ? p.name : p, _ = this._calculate(f, f, f, r); return new Pi(this, { kind: "constant", value: _ }, r) } if (e.expression.kind === "camera") { const p = this._calculate(e.expression.evaluate({ zoom: r.zoom - 1 }), e.expression.evaluate({ zoom: r.zoom }), e.expression.evaluate({ zoom: r.zoom + 1 }), r); return new Pi(this, { kind: "constant", value: p }, r) } return new Pi(this, e.expression, r) } evaluate(e, r, a, u, p, f) { if (e.kind === "source") { const _ = e.evaluate(r, a, u, p, f); return this._calculate(_, _, _, r) } return e.kind === "composite" ? this._calculate(e.evaluate({ zoom: Math.floor(r.zoom) - 1 }, a, u), e.evaluate({ zoom: Math.floor(r.zoom) }, a, u), e.evaluate({ zoom: Math.floor(r.zoom) + 1 }, a, u), r) : e.value } _calculate(e, r, a, u) { return u.zoom > u.zoomHistory.lastIntegerZoom ? { from: e, to: r } : { from: a, to: r } } interpolate(e) { return e } } class bu { constructor(e) { this.specification = e } possiblyEvaluate(e, r, a, u) { if (e.value !== void 0) { if (e.expression.kind === "constant") { const p = e.expression.evaluate(r, null, {}, a, u); return this._calculate(p, p, p, r) } return this._calculate(e.expression.evaluate(new rr(Math.floor(r.zoom - 1), r)), e.expression.evaluate(new rr(Math.floor(r.zoom), r)), e.expression.evaluate(new rr(Math.floor(r.zoom + 1), r)), r) } } _calculate(e, r, a, u) { return u.zoom > u.zoomHistory.lastIntegerZoom ? { from: e, to: r } : { from: a, to: r } } interpolate(e) { return e } } class Tu { constructor(e) { this.specification = e } possiblyEvaluate(e, r, a, u) { return !!e.expression.evaluate(r, null, {}, a, u) } interpolate() { return !1 } } class Ln { constructor(e) { this.properties = e, this.defaultPropertyValues = {}, this.defaultTransitionablePropertyValues = {}, this.defaultTransitioningPropertyValues = {}, this.defaultPossiblyEvaluatedValues = {}, this.overridableProperties = []; for (const r in e) { const a = e[r]; a.specification.overridable && this.overridableProperties.push(r); const u = this.defaultPropertyValues[r] = new xu(a, void 0, void 0), p = this.defaultTransitionablePropertyValues[r] = new wu(a, void 0); this.defaultTransitioningPropertyValues[r] = p.untransitioned(), this.defaultPossiblyEvaluatedValues[r] = u.possiblyEvaluate({}) } } } pt("DataDrivenProperty", bt), pt("DataConstantProperty", vt), pt("CrossFadedDataDrivenProperty", ll), pt("CrossFadedProperty", bu), pt("ColorRampProperty", Tu); class ci extends Wt { constructor(e, r, a) { if (super(), this.id = e.id, this.type = e.type, this._globalState = a, this._featureFilter = { filter: () => !0, needGeometry: !1, getGlobalStateRefs: () => new Set }, e.type !== "custom" && (this.metadata = e.metadata, this.minzoom = e.minzoom, this.maxzoom = e.maxzoom, this._visibilityExpression = function (u, p) { return new el(u, p) }(this.visibility, a), e.type !== "background" && (this.source = e.source, this.sourceLayer = e["source-layer"], this.filter = e.filter, this._featureFilter = Ha(e.filter, a)), r.layout && (this._unevaluatedLayout = new Lp(r.layout, a)), r.paint)) { this._transitionablePaint = new dh(r.paint, a); for (const u in e.paint) this.setPaintProperty(u, e.paint[u], { validate: !1 }); for (const u in e.layout) this.setLayoutProperty(u, e.layout[u], { validate: !1 }); this._transitioningPaint = this._transitionablePaint.untransitioned(), this.paint = new al(r.paint) } } setFilter(e) { this.filter = e, this._featureFilter = Ha(e, this._globalState) } getCrossfadeParameters() { return this._crossfadeParameters } getLayoutProperty(e) { return e === "visibility" ? this.visibility : this._unevaluatedLayout.getValue(e) } getLayoutAffectingGlobalStateRefs() { const e = new Set; for (const r of this._visibilityExpression.getGlobalStateRefs()) e.add(r); if (this._unevaluatedLayout) for (const r in this._unevaluatedLayout._values) { const a = this._unevaluatedLayout._values[r]; for (const u of a.getGlobalStateRefs()) e.add(u) } for (const r of this._featureFilter.getGlobalStateRefs()) e.add(r); return e } getPaintAffectingGlobalStateRefs() { var e; const r = new globalThis.Map; if (this._transitionablePaint) for (const a in this._transitionablePaint._values) { const u = this._transitionablePaint._values[a].value; for (const p of u.getGlobalStateRefs()) { const f = (e = r.get(p)) !== null && e !== void 0 ? e : []; f.push({ name: a, value: u.value }), r.set(p, f) } } return r } getVisibilityAffectingGlobalStateRefs() { return this._visibilityExpression.getGlobalStateRefs() } setLayoutProperty(e, r, a = {}) { if (r == null || !this._validate(rg, `layers.${this.id}.layout.${e}`, e, r, a)) return e === "visibility" ? (this.visibility = r, this._visibilityExpression.setValue(r), void this.recalculateVisibility()) : void this._unevaluatedLayout.setValue(e, r) } getPaintProperty(e) { return e.endsWith(ol) ? this._transitionablePaint.getTransition(e.slice(0, -11)) : this._transitionablePaint.getValue(e) } setPaintProperty(e, r, a = {}) { if (r != null && this._validate(tg, `layers.${this.id}.paint.${e}`, e, r, a)) return !1; if (e.endsWith(ol)) return this._transitionablePaint.setTransition(e.slice(0, -11), r || void 0), !1; { const u = this._transitionablePaint._values[e], p = u.property.specification["property-type"] === "cross-faded-data-driven", f = u.value.isDataDriven(), _ = u.value; this._transitionablePaint.setValue(e, r), this._handleSpecialPaintPropertyUpdate(e); const x = this._transitionablePaint._values[e].value; return x.isDataDriven() || f || p || this._handleOverridablePaintPropertyUpdate(e, _, x) } } _handleSpecialPaintPropertyUpdate(e) { } _handleOverridablePaintPropertyUpdate(e, r, a) { return !1 } isHidden(e = this.minzoom, r = !1) { return !!(this.minzoom && e < (r ? Math.floor(this.minzoom) : this.minzoom)) || !!(this.maxzoom && e >= this.maxzoom) || this._evaluatedVisibility === "none" } updateTransitions(e) { this._transitioningPaint = this._transitionablePaint.transitioned(e, this._transitioningPaint) } hasTransition() { return this._transitioningPaint.hasTransition() } recalculateVisibility() { this._evaluatedVisibility = this._visibilityExpression.evaluate() } recalculate(e, r) { e.getCrossfadeParameters && (this._crossfadeParameters = e.getCrossfadeParameters()), this._unevaluatedLayout && (this.layout = this._unevaluatedLayout.possiblyEvaluate(e, void 0, r)), this.paint = this._transitioningPaint.possiblyEvaluate(e, void 0, r) } serialize() { const e = { id: this.id, type: this.type, source: this.source, "source-layer": this.sourceLayer, metadata: this.metadata, minzoom: this.minzoom, maxzoom: this.maxzoom, filter: this.filter, layout: this._unevaluatedLayout && this._unevaluatedLayout.serialize(), paint: this._transitionablePaint && this._transitionablePaint.serialize() }; return this.visibility && (e.layout = e.layout || {}, e.layout.visibility = this.visibility), vn(e, (r, a) => !(r === void 0 || a === "layout" && !Object.keys(r).length || a === "paint" && !Object.keys(r).length)) } _validate(e, r, a, u, p = {}) { return (!p || p.validate !== !1) && Yo(this, e.call(nn, { key: r, layerType: this.type, objectKey: a, value: u, styleSpec: De, style: { glyphs: !0, sprite: !0 } })) } is3D() { return !1 } isTileClipped() { return !1 } hasOffscreenPass() { return !1 } resize() { } isStateDependent() { for (const e in this.paint._values) { const r = this.paint.get(e); if (r instanceof Pi && Wo(r.property.specification) && (r.value.kind === "source" || r.value.kind === "composite") && r.value.isStateDependent) return !0 } return !1 } } let ph; var Fp = { get paint() { return ph = ph || new Ln({ "raster-opacity": new vt(De.paint_raster["raster-opacity"]), "raster-hue-rotate": new vt(De.paint_raster["raster-hue-rotate"]), "raster-brightness-min": new vt(De.paint_raster["raster-brightness-min"]), "raster-brightness-max": new vt(De.paint_raster["raster-brightness-max"]), "raster-saturation": new vt(De.paint_raster["raster-saturation"]), "raster-contrast": new vt(De.paint_raster["raster-contrast"]), "raster-resampling": new vt(De.paint_raster["raster-resampling"]), "raster-fade-duration": new vt(De.paint_raster["raster-fade-duration"]) }) } }; class sg extends ci { constructor(e, r) { super(e, Fp, r) } } const og = { Int8: Int8Array, Uint8: Uint8Array, Int16: Int16Array, Uint16: Uint16Array, Int32: Int32Array, Uint32: Uint32Array, Float32: Float32Array }; class ul { constructor(e, r) { this._structArray = e, this._pos1 = r * this.size, this._pos2 = this._pos1 / 2, this._pos4 = this._pos1 / 4, this._pos8 = this._pos1 / 8 } } class Tr { constructor() { this.isTransferred = !1, this.capacity = -1, this.resize(0) } static serialize(e, r) { return e._trim(), r && (e.isTransferred = !0, r.push(e.arrayBuffer)), { length: e.length, arrayBuffer: e.arrayBuffer } } static deserialize(e) { const r = Object.create(this.prototype); return r.arrayBuffer = e.arrayBuffer, r.length = e.length, r.capacity = e.arrayBuffer.byteLength / r.bytesPerElement, r._refreshViews(), r } _trim() { this.length !== this.capacity && (this.capacity = this.length, this.arrayBuffer = this.arrayBuffer.slice(0, this.length * this.bytesPerElement), this._refreshViews()) } clear() { this.length = 0 } resize(e) { this.reserve(e), this.length = e } reserve(e) { if (e > this.capacity) { this.capacity = Math.max(e, Math.floor(5 * this.capacity), 128), this.arrayBuffer = new ArrayBuffer(this.capacity * this.bytesPerElement); const r = this.uint8; this._refreshViews(), r && this.uint8.set(r) } } _refreshViews() { throw new Error("_refreshViews() must be implemented by each concrete StructArray layout") } } function Br(n, e = 1) { let r = 0, a = 0; return { members: n.map(u => { const p = og[u.type].BYTES_PER_ELEMENT, f = r = no(r, Math.max(e, p)), _ = u.components || 1; return a = Math.max(a, p), r += p * _, { name: u.name, type: u.type, components: _, offset: f } }), size: no(r, Math.max(a, e)), alignment: e } } function no(n, e) { return Math.ceil(n / e) * e } class cl extends Tr { _refreshViews() { this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer) } emplaceBack(e, r) { const a = this.length; return this.resize(a + 1), this.emplace(a, e, r) } emplace(e, r, a) { const u = 2 * e; return this.int16[u + 0] = r, this.int16[u + 1] = a, e } } cl.prototype.bytesPerElement = 4, pt("StructArrayLayout2i4", cl); class Su extends Tr { _refreshViews() { this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer) } emplaceBack(e, r, a) { const u = this.length; return this.resize(u + 1), this.emplace(u, e, r, a) } emplace(e, r, a, u) { const p = 3 * e; return this.int16[p + 0] = r, this.int16[p + 1] = a, this.int16[p + 2] = u, e } } Su.prototype.bytesPerElement = 6, pt("StructArrayLayout3i6", Su); class fh extends Tr { _refreshViews() { this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer) } emplaceBack(e, r, a, u) { const p = this.length; return this.resize(p + 1), this.emplace(p, e, r, a, u) } emplace(e, r, a, u, p) { const f = 4 * e; return this.int16[f + 0] = r, this.int16[f + 1] = a, this.int16[f + 2] = u, this.int16[f + 3] = p, e } } fh.prototype.bytesPerElement = 8, pt("StructArrayLayout4i8", fh); class Eu extends Tr { _refreshViews() { this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer) } emplaceBack(e, r, a, u, p, f) { const _ = this.length; return this.resize(_ + 1), this.emplace(_, e, r, a, u, p, f) } emplace(e, r, a, u, p, f, _) { const x = 6 * e; return this.int16[x + 0] = r, this.int16[x + 1] = a, this.int16[x + 2] = u, this.int16[x + 3] = p, this.int16[x + 4] = f, this.int16[x + 5] = _, e } } Eu.prototype.bytesPerElement = 12, pt("StructArrayLayout2i4i12", Eu); class mh extends Tr { _refreshViews() { this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer) } emplaceBack(e, r, a, u, p, f) { const _ = this.length; return this.resize(_ + 1), this.emplace(_, e, r, a, u, p, f) } emplace(e, r, a, u, p, f, _) { const x = 4 * e, S = 8 * e; return this.int16[x + 0] = r, this.int16[x + 1] = a, this.uint8[S + 4] = u, this.uint8[S + 5] = p, this.uint8[S + 6] = f, this.uint8[S + 7] = _, e } } mh.prototype.bytesPerElement = 8, pt("StructArrayLayout2i4ub8", mh); class hl extends Tr { _refreshViews() { this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer) } emplaceBack(e, r) { const a = this.length; return this.resize(a + 1), this.emplace(a, e, r) } emplace(e, r, a) { const u = 2 * e; return this.float32[u + 0] = r, this.float32[u + 1] = a, e } } hl.prototype.bytesPerElement = 8, pt("StructArrayLayout2f8", hl); class rs extends Tr { _refreshViews() { this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer) } emplaceBack(e, r, a, u, p, f, _, x, S, M) { const C = this.length; return this.resize(C + 1), this.emplace(C, e, r, a, u, p, f, _, x, S, M) } emplace(e, r, a, u, p, f, _, x, S, M, C) { const k = 10 * e; return this.uint16[k + 0] = r, this.uint16[k + 1] = a, this.uint16[k + 2] = u, this.uint16[k + 3] = p, this.uint16[k + 4] = f, this.uint16[k + 5] = _, this.uint16[k + 6] = x, this.uint16[k + 7] = S, this.uint16[k + 8] = M, this.uint16[k + 9] = C, e } } rs.prototype.bytesPerElement = 20, pt("StructArrayLayout10ui20", rs); class Pu extends Tr { _refreshViews() { this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer) } emplaceBack(e, r, a, u, p, f, _, x) { const S = this.length; return this.resize(S + 1), this.emplace(S, e, r, a, u, p, f, _, x) } emplace(e, r, a, u, p, f, _, x, S) { const M = 8 * e; return this.uint16[M + 0] = r, this.uint16[M + 1] = a, this.uint16[M + 2] = u, this.uint16[M + 3] = p, this.uint16[M + 4] = f, this.uint16[M + 5] = _, this.uint16[M + 6] = x, this.uint16[M + 7] = S, e } } Pu.prototype.bytesPerElement = 16, pt("StructArrayLayout8ui16", Pu); class dl extends Tr { _refreshViews() { this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer) } emplaceBack(e, r, a, u, p, f, _, x, S, M, C, k) { const D = this.length; return this.resize(D + 1), this.emplace(D, e, r, a, u, p, f, _, x, S, M, C, k) } emplace(e, r, a, u, p, f, _, x, S, M, C, k, D) { const L = 12 * e; return this.int16[L + 0] = r, this.int16[L + 1] = a, this.int16[L + 2] = u, this.int16[L + 3] = p, this.uint16[L + 4] = f, this.uint16[L + 5] = _, this.uint16[L + 6] = x, this.uint16[L + 7] = S, this.int16[L + 8] = M, this.int16[L + 9] = C, this.int16[L + 10] = k, this.int16[L + 11] = D, e } } dl.prototype.bytesPerElement = 24, pt("StructArrayLayout4i4ui4i24", dl); class Mu extends Tr { _refreshViews() { this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer) } emplaceBack(e, r, a) { const u = this.length; return this.resize(u + 1), this.emplace(u, e, r, a) } emplace(e, r, a, u) { const p = 3 * e; return this.float32[p + 0] = r, this.float32[p + 1] = a, this.float32[p + 2] = u, e } } Mu.prototype.bytesPerElement = 12, pt("StructArrayLayout3f12", Mu); class pl extends Tr { _refreshViews() { this.uint8 = new Uint8Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer) } emplaceBack(e) { const r = this.length; return this.resize(r + 1), this.emplace(r, e) } emplace(e, r) { return this.uint32[1 * e + 0] = r, e } } pl.prototype.bytesPerElement = 4, pt("StructArrayLayout1ul4", pl); class gh extends Tr { _refreshViews() { this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer) } emplaceBack(e, r, a, u, p, f, _, x, S) { const M = this.length; return this.resize(M + 1), this.emplace(M, e, r, a, u, p, f, _, x, S) } emplace(e, r, a, u, p, f, _, x, S, M) { const C = 10 * e, k = 5 * e; return this.int16[C + 0] = r, this.int16[C + 1] = a, this.int16[C + 2] = u, this.int16[C + 3] = p, this.int16[C + 4] = f, this.int16[C + 5] = _, this.uint32[k + 3] = x, this.uint16[C + 8] = S, this.uint16[C + 9] = M, e } } gh.prototype.bytesPerElement = 20, pt("StructArrayLayout6i1ul2ui20", gh); class ea extends Tr { _refreshViews() { this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer) } emplaceBack(e, r, a, u, p, f) { const _ = this.length; return this.resize(_ + 1), this.emplace(_, e, r, a, u, p, f) } emplace(e, r, a, u, p, f, _) { const x = 6 * e; return this.int16[x + 0] = r, this.int16[x + 1] = a, this.int16[x + 2] = u, this.int16[x + 3] = p, this.int16[x + 4] = f, this.int16[x + 5] = _, e } } ea.prototype.bytesPerElement = 12, pt("StructArrayLayout2i2i2i12", ea); class io extends Tr { _refreshViews() { this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer) } emplaceBack(e, r, a, u, p) { const f = this.length; return this.resize(f + 1), this.emplace(f, e, r, a, u, p) } emplace(e, r, a, u, p, f) { const _ = 4 * e, x = 8 * e; return this.float32[_ + 0] = r, this.float32[_ + 1] = a, this.float32[_ + 2] = u, this.int16[x + 6] = p, this.int16[x + 7] = f, e } } io.prototype.bytesPerElement = 16, pt("StructArrayLayout2f1f2i16", io); class _h extends Tr { _refreshViews() { this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer) } emplaceBack(e, r, a, u, p, f) { const _ = this.length; return this.resize(_ + 1), this.emplace(_, e, r, a, u, p, f) } emplace(e, r, a, u, p, f, _) { const x = 16 * e, S = 4 * e, M = 8 * e; return this.uint8[x + 0] = r, this.uint8[x + 1] = a, this.float32[S + 1] = u, this.float32[S + 2] = p, this.int16[M + 6] = f, this.int16[M + 7] = _, e } } _h.prototype.bytesPerElement = 16, pt("StructArrayLayout2ub2f2i16", _h); class fl extends Tr { _refreshViews() { this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer) } emplaceBack(e, r, a) { const u = this.length; return this.resize(u + 1), this.emplace(u, e, r, a) } emplace(e, r, a, u) { const p = 3 * e; return this.uint16[p + 0] = r, this.uint16[p + 1] = a, this.uint16[p + 2] = u, e } } fl.prototype.bytesPerElement = 6, pt("StructArrayLayout3ui6", fl); class so extends Tr { _refreshViews() { this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer) } emplaceBack(e, r, a, u, p, f, _, x, S, M, C, k, D, L, F, N, G) { const ee = this.length; return this.resize(ee + 1), this.emplace(ee, e, r, a, u, p, f, _, x, S, M, C, k, D, L, F, N, G) } emplace(e, r, a, u, p, f, _, x, S, M, C, k, D, L, F, N, G, ee) { const q = 24 * e, H = 12 * e, ne = 48 * e; return this.int16[q + 0] = r, this.int16[q + 1] = a, this.uint16[q + 2] = u, this.uint16[q + 3] = p, this.uint32[H + 2] = f, this.uint32[H + 3] = _, this.uint32[H + 4] = x, this.uint16[q + 10] = S, this.uint16[q + 11] = M, this.uint16[q + 12] = C, this.float32[H + 7] = k, this.float32[H + 8] = D, this.uint8[ne + 36] = L, this.uint8[ne + 37] = F, this.uint8[ne + 38] = N, this.uint32[H + 10] = G, this.int16[q + 22] = ee, e } } so.prototype.bytesPerElement = 48, pt("StructArrayLayout2i2ui3ul3ui2f3ub1ul1i48", so); class yh extends Tr { _refreshViews() { this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer) } emplaceBack(e, r, a, u, p, f, _, x, S, M, C, k, D, L, F, N, G, ee, q, H, ne, ae, Ie, Ue, je, Ze, nt, He) { const Ve = this.length; return this.resize(Ve + 1), this.emplace(Ve, e, r, a, u, p, f, _, x, S, M, C, k, D, L, F, N, G, ee, q, H, ne, ae, Ie, Ue, je, Ze, nt, He) } emplace(e, r, a, u, p, f, _, x, S, M, C, k, D, L, F, N, G, ee, q, H, ne, ae, Ie, Ue, je, Ze, nt, He, Ve) { const Fe = 32 * e, dt = 16 * e; return this.int16[Fe + 0] = r, this.int16[Fe + 1] = a, this.int16[Fe + 2] = u, this.int16[Fe + 3] = p, this.int16[Fe + 4] = f, this.int16[Fe + 5] = _, this.int16[Fe + 6] = x, this.int16[Fe + 7] = S, this.uint16[Fe + 8] = M, this.uint16[Fe + 9] = C, this.uint16[Fe + 10] = k, this.uint16[Fe + 11] = D, this.uint16[Fe + 12] = L, this.uint16[Fe + 13] = F, this.uint16[Fe + 14] = N, this.uint16[Fe + 15] = G, this.uint16[Fe + 16] = ee, this.uint16[Fe + 17] = q, this.uint16[Fe + 18] = H, this.uint16[Fe + 19] = ne, this.uint16[Fe + 20] = ae, this.uint16[Fe + 21] = Ie, this.uint16[Fe + 22] = Ue, this.uint32[dt + 12] = je, this.float32[dt + 13] = Ze, this.float32[dt + 14] = nt, this.uint16[Fe + 30] = He, this.uint16[Fe + 31] = Ve, e } } yh.prototype.bytesPerElement = 64, pt("StructArrayLayout8i15ui1ul2f2ui64", yh); class Iu extends Tr { _refreshViews() { this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer) } emplaceBack(e) { const r = this.length; return this.resize(r + 1), this.emplace(r, e) } emplace(e, r) { return this.float32[1 * e + 0] = r, e } } Iu.prototype.bytesPerElement = 4, pt("StructArrayLayout1f4", Iu); class Cu extends Tr { _refreshViews() { this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer) } emplaceBack(e, r, a) { const u = this.length; return this.resize(u + 1), this.emplace(u, e, r, a) } emplace(e, r, a, u) { const p = 3 * e; return this.uint16[6 * e + 0] = r, this.float32[p + 1] = a, this.float32[p + 2] = u, e } } Cu.prototype.bytesPerElement = 12, pt("StructArrayLayout1ui2f12", Cu); class vh extends Tr { _refreshViews() { this.uint8 = new Uint8Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer) } emplaceBack(e, r, a) { const u = this.length; return this.resize(u + 1), this.emplace(u, e, r, a) } emplace(e, r, a, u) { const p = 4 * e; return this.uint32[2 * e + 0] = r, this.uint16[p + 2] = a, this.uint16[p + 3] = u, e } } vh.prototype.bytesPerElement = 8, pt("StructArrayLayout1ul2ui8", vh); class m extends Tr { _refreshViews() { this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer) } emplaceBack(e, r) { const a = this.length; return this.resize(a + 1), this.emplace(a, e, r) } emplace(e, r, a) { const u = 2 * e; return this.uint16[u + 0] = r, this.uint16[u + 1] = a, e } } m.prototype.bytesPerElement = 4, pt("StructArrayLayout2ui4", m); class t extends Tr { _refreshViews() { this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer) } emplaceBack(e) { const r = this.length; return this.resize(r + 1), this.emplace(r, e) } emplace(e, r) { return this.uint16[1 * e + 0] = r, e } } t.prototype.bytesPerElement = 2, pt("StructArrayLayout1ui2", t); class s extends Tr { _refreshViews() { this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer) } emplaceBack(e, r, a, u) { const p = this.length; return this.resize(p + 1), this.emplace(p, e, r, a, u) } emplace(e, r, a, u, p) { const f = 4 * e; return this.float32[f + 0] = r, this.float32[f + 1] = a, this.float32[f + 2] = u, this.float32[f + 3] = p, e } } s.prototype.bytesPerElement = 16, pt("StructArrayLayout4f16", s); class l extends ul { get anchorPointX() { return this._structArray.int16[this._pos2 + 0] } get anchorPointY() { return this._structArray.int16[this._pos2 + 1] } get x1() { return this._structArray.int16[this._pos2 + 2] } get y1() { return this._structArray.int16[this._pos2 + 3] } get x2() { return this._structArray.int16[this._pos2 + 4] } get y2() { return this._structArray.int16[this._pos2 + 5] } get featureIndex() { return this._structArray.uint32[this._pos4 + 3] } get sourceLayerIndex() { return this._structArray.uint16[this._pos2 + 8] } get bucketIndex() { return this._structArray.uint16[this._pos2 + 9] } get anchorPoint() { return new B(this.anchorPointX, this.anchorPointY) } } l.prototype.size = 20; class d extends gh { get(e) { return new l(this, e) } } pt("CollisionBoxArray", d); class g extends ul { get anchorX() { return this._structArray.int16[this._pos2 + 0] } get anchorY() { return this._structArray.int16[this._pos2 + 1] } get glyphStartIndex() { return this._structArray.uint16[this._pos2 + 2] } get numGlyphs() { return this._structArray.uint16[this._pos2 + 3] } get vertexStartIndex() { return this._structArray.uint32[this._pos4 + 2] } get lineStartIndex() { return this._structArray.uint32[this._pos4 + 3] } get lineLength() { return this._structArray.uint32[this._pos4 + 4] } get segment() { return this._structArray.uint16[this._pos2 + 10] } get lowerSize() { return this._structArray.uint16[this._pos2 + 11] } get upperSize() { return this._structArray.uint16[this._pos2 + 12] } get lineOffsetX() { return this._structArray.float32[this._pos4 + 7] } get lineOffsetY() { return this._structArray.float32[this._pos4 + 8] } get writingMode() { return this._structArray.uint8[this._pos1 + 36] } get placedOrientation() { return this._structArray.uint8[this._pos1 + 37] } set placedOrientation(e) { this._structArray.uint8[this._pos1 + 37] = e } get hidden() { return this._structArray.uint8[this._pos1 + 38] } set hidden(e) { this._structArray.uint8[this._pos1 + 38] = e } get crossTileID() { return this._structArray.uint32[this._pos4 + 10] } set crossTileID(e) { this._structArray.uint32[this._pos4 + 10] = e } get associatedIconIndex() { return this._structArray.int16[this._pos2 + 22] } } g.prototype.size = 48; class v extends so { get(e) { return new g(this, e) } } pt("PlacedSymbolArray", v); class T extends ul { get anchorX() { return this._structArray.int16[this._pos2 + 0] } get anchorY() { return this._structArray.int16[this._pos2 + 1] } get rightJustifiedTextSymbolIndex() { return this._structArray.int16[this._pos2 + 2] } get centerJustifiedTextSymbolIndex() { return this._structArray.int16[this._pos2 + 3] } get leftJustifiedTextSymbolIndex() { return this._structArray.int16[this._pos2 + 4] } get verticalPlacedTextSymbolIndex() { return this._structArray.int16[this._pos2 + 5] } get placedIconSymbolIndex() { return this._structArray.int16[this._pos2 + 6] } get verticalPlacedIconSymbolIndex() { return this._structArray.int16[this._pos2 + 7] } get key() { return this._structArray.uint16[this._pos2 + 8] } get textBoxStartIndex() { return this._structArray.uint16[this._pos2 + 9] } get textBoxEndIndex() { return this._structArray.uint16[this._pos2 + 10] } get verticalTextBoxStartIndex() { return this._structArray.uint16[this._pos2 + 11] } get verticalTextBoxEndIndex() { return this._structArray.uint16[this._pos2 + 12] } get iconBoxStartIndex() { return this._structArray.uint16[this._pos2 + 13] } get iconBoxEndIndex() { return this._structArray.uint16[this._pos2 + 14] } get verticalIconBoxStartIndex() { return this._structArray.uint16[this._pos2 + 15] } get verticalIconBoxEndIndex() { return this._structArray.uint16[this._pos2 + 16] } get featureIndex() { return this._structArray.uint16[this._pos2 + 17] } get numHorizontalGlyphVertices() { return this._structArray.uint16[this._pos2 + 18] } get numVerticalGlyphVertices() { return this._structArray.uint16[this._pos2 + 19] } get numIconVertices() { return this._structArray.uint16[this._pos2 + 20] } get numVerticalIconVertices() { return this._structArray.uint16[this._pos2 + 21] } get useRuntimeCollisionCircles() { return this._structArray.uint16[this._pos2 + 22] } get crossTileID() { return this._structArray.uint32[this._pos4 + 12] } set crossTileID(e) { this._structArray.uint32[this._pos4 + 12] = e } get textBoxScale() { return this._structArray.float32[this._pos4 + 13] } get collisionCircleDiameter() { return this._structArray.float32[this._pos4 + 14] } get textAnchorOffsetStartIndex() { return this._structArray.uint16[this._pos2 + 30] } get textAnchorOffsetEndIndex() { return this._structArray.uint16[this._pos2 + 31] } } T.prototype.size = 64; class E extends yh { get(e) { return new T(this, e) } } pt("SymbolInstanceArray", E); class I extends Iu { getoffsetX(e) { return this.float32[1 * e + 0] } } pt("GlyphOffsetArray", I); class A extends Su { getx(e) { return this.int16[3 * e + 0] } gety(e) { return this.int16[3 * e + 1] } gettileUnitDistanceFromAnchor(e) { return this.int16[3 * e + 2] } } pt("SymbolLineVertexArray", A); class R extends ul { get textAnchor() { return this._structArray.uint16[this._pos2 + 0] } get textOffset0() { return this._structArray.float32[this._pos4 + 1] } get textOffset1() { return this._structArray.float32[this._pos4 + 2] } } R.prototype.size = 12; class z extends Cu { get(e) { return new R(this, e) } } pt("TextAnchorOffsetArray", z); class O extends ul { get featureIndex() { return this._structArray.uint32[this._pos4 + 0] } get sourceLayerIndex() { return this._structArray.uint16[this._pos2 + 2] } get bucketIndex() { return this._structArray.uint16[this._pos2 + 3] } } O.prototype.size = 8; class U extends vh { get(e) { return new O(this, e) } } pt("FeatureIndexArray", U); class X extends cl { } class Q extends cl { } class Y extends cl { } class te extends Eu { } class le extends mh { } class J extends hl { } class oe extends rs { } class ce extends Pu { } class se extends dl { } class fe extends Mu { } class Oe extends pl { } class ke extends ea { } class ze extends _h { } class Re extends fl { } class Je extends m { } const tt = Br([{ name: "a_pos", components: 2, type: "Int16" }], 4), { members: We } = tt; class it { constructor(e = []) { this._forceNewSegmentOnNextPrepare = !1, this.segments = e } prepareSegment(e, r, a, u) { const p = this.segments[this.segments.length - 1]; return e > it.MAX_VERTEX_ARRAY_LENGTH && qt(`Max vertices per segment is ${it.MAX_VERTEX_ARRAY_LENGTH}: bucket requested ${e}. Consider using the \`fillLargeMeshArrays\` function if you require meshes with more than ${it.MAX_VERTEX_ARRAY_LENGTH} vertices.`), this._forceNewSegmentOnNextPrepare || !p || p.vertexLength + e > it.MAX_VERTEX_ARRAY_LENGTH || p.sortKey !== u ? this.createNewSegment(r, a, u) : p } createNewSegment(e, r, a) { const u = { vertexOffset: e.length, primitiveOffset: r.length, vertexLength: 0, primitiveLength: 0, vaos: {} }; return a !== void 0 && (u.sortKey = a), this._forceNewSegmentOnNextPrepare = !1, this.segments.push(u), u } getOrCreateLatestSegment(e, r, a) { return this.prepareSegment(0, e, r, a) } forceNewSegmentOnNextPrepare() { this._forceNewSegmentOnNextPrepare = !0 } get() { return this.segments } destroy() { for (const e of this.segments) for (const r in e.vaos) e.vaos[r].destroy() } static simpleSegment(e, r, a, u) { return new it([{ vertexOffset: e, primitiveOffset: r, vertexLength: a, primitiveLength: u, vaos: {}, sortKey: 0 }]) } } function It(n, e) { return 256 * (n = Ct(Math.floor(n), 0, 255)) + Ct(Math.floor(e), 0, 255) } it.MAX_VERTEX_ARRAY_LENGTH = Math.pow(2, 16) - 1, pt("SegmentVector", it); const Kt = Br([{ name: "a_pattern_from", components: 4, type: "Uint16" }, { name: "a_pattern_to", components: 4, type: "Uint16" }, { name: "a_pixel_ratio_from", components: 1, type: "Uint16" }, { name: "a_pixel_ratio_to", components: 1, type: "Uint16" }]), fr = Br([{ name: "a_dasharray_from", components: 4, type: "Uint16" }, { name: "a_dasharray_to", components: 4, type: "Uint16" }]); var ar, yr, lr, Ar = { exports: {} }, vr = { exports: {} }, sn = { exports: {} }, Vr = function () { if (lr) return Ar.exports; lr = 1; var n = (ar || (ar = 1, vr.exports = function (r, a) { var u, p, f, _, x, S, M, C; for (p = r.length - (u = 3 & r.length), f = a, x = 3432918353, S = 461845907, C = 0; C < p;)M = 255 & r.charCodeAt(C) | (255 & r.charCodeAt(++C)) << 8 | (255 & r.charCodeAt(++C)) << 16 | (255 & r.charCodeAt(++C)) << 24, ++C, f = 27492 + (65535 & (_ = 5 * (65535 & (f = (f ^= M = (65535 & (M = (M = (65535 & M) * x + (((M >>> 16) * x & 65535) << 16) & 4294967295) << 15 | M >>> 17)) * S + (((M >>> 16) * S & 65535) << 16) & 4294967295) << 13 | f >>> 19)) + ((5 * (f >>> 16) & 65535) << 16) & 4294967295)) + ((58964 + (_ >>> 16) & 65535) << 16); switch (M = 0, u) { case 3: M ^= (255 & r.charCodeAt(C + 2)) << 16; case 2: M ^= (255 & r.charCodeAt(C + 1)) << 8; case 1: f ^= M = (65535 & (M = (M = (65535 & (M ^= 255 & r.charCodeAt(C))) * x + (((M >>> 16) * x & 65535) << 16) & 4294967295) << 15 | M >>> 17)) * S + (((M >>> 16) * S & 65535) << 16) & 4294967295 }return f ^= r.length, f = 2246822507 * (65535 & (f ^= f >>> 16)) + ((2246822507 * (f >>> 16) & 65535) << 16) & 4294967295, f = 3266489909 * (65535 & (f ^= f >>> 13)) + ((3266489909 * (f >>> 16) & 65535) << 16) & 4294967295, (f ^= f >>> 16) >>> 0 }), vr.exports), e = (yr || (yr = 1, sn.exports = function (r, a) { for (var u, p = r.length, f = a ^ p, _ = 0; p >= 4;)u = 1540483477 * (65535 & (u = 255 & r.charCodeAt(_) | (255 & r.charCodeAt(++_)) << 8 | (255 & r.charCodeAt(++_)) << 16 | (255 & r.charCodeAt(++_)) << 24)) + ((1540483477 * (u >>> 16) & 65535) << 16), f = 1540483477 * (65535 & f) + ((1540483477 * (f >>> 16) & 65535) << 16) ^ (u = 1540483477 * (65535 & (u ^= u >>> 24)) + ((1540483477 * (u >>> 16) & 65535) << 16)), p -= 4, ++_; switch (p) { case 3: f ^= (255 & r.charCodeAt(_ + 2)) << 16; case 2: f ^= (255 & r.charCodeAt(_ + 1)) << 8; case 1: f = 1540483477 * (65535 & (f ^= 255 & r.charCodeAt(_))) + ((1540483477 * (f >>> 16) & 65535) << 16) }return f = 1540483477 * (65535 & (f ^= f >>> 13)) + ((1540483477 * (f >>> 16) & 65535) << 16), (f ^= f >>> 15) >>> 0 }), sn.exports); return Ar.exports = n, Ar.exports.murmur3 = n, Ar.exports.murmur2 = e, Ar.exports }(), Or = $(Vr); class mn { constructor() { this.ids = [], this.positions = [], this.indexed = !1 } add(e, r, a, u) { this.ids.push(Cs(e)), this.positions.push(r, a, u) } getPositions(e) { if (!this.indexed) throw new Error("Trying to get index, but feature positions are not indexed"); const r = Cs(e); let a = 0, u = this.ids.length - 1; for (; a < u;) { const f = a + u >> 1; this.ids[f] >= r ? u = f : a = f + 1 } const p = []; for (; this.ids[a] === r;)p.push({ index: this.positions[3 * a], start: this.positions[3 * a + 1], end: this.positions[3 * a + 2] }), a++; return p } static serialize(e, r) { const a = new Float64Array(e.ids), u = new Uint32Array(e.positions); return ns(a, u, 0, a.length - 1), r && r.push(a.buffer, u.buffer), { ids: a, positions: u } } static deserialize(e) { const r = new mn; return r.ids = e.ids, r.positions = e.positions, r.indexed = !0, r } } function Cs(n) { const e = +n; return !isNaN(e) && e <= Number.MAX_SAFE_INTEGER ? e : Or(String(n)) } function ns(n, e, r, a) { for (; r < a;) { const u = n[r + a >> 1]; let p = r - 1, f = a + 1; for (; ;) { do p++; while (n[p] < u); do f--; while (n[f] > u); if (p >= f) break; Ui(n, p, f), Ui(e, 3 * p, 3 * f), Ui(e, 3 * p + 1, 3 * f + 1), Ui(e, 3 * p + 2, 3 * f + 2) } f - r < a - f ? (ns(n, e, r, f), r = f + 1) : (ns(n, e, f + 1, a), a = f) } } function Ui(n, e, r) { const a = n[e]; n[e] = n[r], n[r] = a } pt("FeaturePositionMap", mn); class Gn { constructor(e, r) { this.gl = e.gl, this.location = r } } class oo extends Gn { constructor(e, r) { super(e, r), this.current = 0 } set(e) { this.current !== e && (this.current = e, this.gl.uniform1f(this.location, e)) } } class ml extends Gn { constructor(e, r) { super(e, r), this.current = [0, 0, 0, 0] } set(e) { e[0] === this.current[0] && e[1] === this.current[1] && e[2] === this.current[2] && e[3] === this.current[3] || (this.current = e, this.gl.uniform4f(this.location, e[0], e[1], e[2], e[3])) } } class ao extends Gn { constructor(e, r) { super(e, r), this.current = Rt.transparent } set(e) { e.r === this.current.r && e.g === this.current.g && e.b === this.current.b && e.a === this.current.a || (this.current = e, this.gl.uniform4f(this.location, e.r, e.g, e.b, e.a)) } } const hi = new Float32Array(16); function Gi(n) { return [It(255 * n.r, 255 * n.g), It(255 * n.b, 255 * n.a)] } class Mi { constructor(e, r, a) { this.value = e, this.uniformNames = r.map(u => `u_${u}`), this.type = a } setUniform(e, r, a) { e.set(a.constantOr(this.value)) } getBinding(e, r, a) { return this.type === "color" ? new ao(e, r) : new oo(e, r) } } class Ii { constructor(e, r) { this.uniformNames = r.map(a => `u_${a}`), this.patternFrom = null, this.patternTo = null, this.pixelRatioFrom = 1, this.pixelRatioTo = 1 } setConstantPatternPositions(e, r) { this.pixelRatioFrom = r.pixelRatio, this.pixelRatioTo = e.pixelRatio, this.patternFrom = r.tlbr, this.patternTo = e.tlbr } setConstantDashPositions(e, r) { this.dashTo = [0, e.y, e.height, e.width], this.dashFrom = [0, r.y, r.height, r.width] } setUniform(e, r, a, u) { let p = null; u === "u_pattern_to" ? p = this.patternTo : u === "u_pattern_from" ? p = this.patternFrom : u === "u_dasharray_to" ? p = this.dashTo : u === "u_dasharray_from" ? p = this.dashFrom : u === "u_pixel_ratio_to" ? p = this.pixelRatioTo : u === "u_pixel_ratio_from" && (p = this.pixelRatioFrom), p !== null && e.set(p) } getBinding(e, r, a) { return a.substr(0, 9) === "u_pattern" || a.substr(0, 12) === "u_dasharray_" ? new ml(e, r) : new oo(e, r) } } class cr { constructor(e, r, a, u) { this.expression = e, this.type = a, this.maxValue = 0, this.paintVertexAttributes = r.map(p => ({ name: `a_${p}`, type: "Float32", components: a === "color" ? 2 : 1, offset: 0 })), this.paintVertexArray = new u } populatePaintArray(e, r, a) { const u = this.paintVertexArray.length, p = this.expression.evaluate(new rr(0, a), r, {}, a.canonical, [], a.formattedSection); this.paintVertexArray.resize(e), this._setPaintValue(u, e, p) } updatePaintArray(e, r, a, u, p) { const f = this.expression.evaluate(new rr(0, p), a, u); this._setPaintValue(e, r, f) } _setPaintValue(e, r, a) { if (this.type === "color") { const u = Gi(a); for (let p = e; p < r; p++)this.paintVertexArray.emplace(p, u[0], u[1]) } else { for (let u = e; u < r; u++)this.paintVertexArray.emplace(u, a); this.maxValue = Math.max(this.maxValue, Math.abs(a)) } } upload(e) { this.paintVertexArray && this.paintVertexArray.arrayBuffer && (this.paintVertexBuffer && this.paintVertexBuffer.buffer ? this.paintVertexBuffer.updateData(this.paintVertexArray) : this.paintVertexBuffer = e.createVertexBuffer(this.paintVertexArray, this.paintVertexAttributes, this.expression.isStateDependent)) } destroy() { this.paintVertexBuffer && this.paintVertexBuffer.destroy() } } class ur { constructor(e, r, a, u, p, f) { this.expression = e, this.uniformNames = r.map(_ => `u_${_}_t`), this.type = a, this.useIntegerZoom = u, this.zoom = p, this.maxValue = 0, this.paintVertexAttributes = r.map(_ => ({ name: `a_${_}`, type: "Float32", components: a === "color" ? 4 : 2, offset: 0 })), this.paintVertexArray = new f } populatePaintArray(e, r, a) { const u = this.expression.evaluate(new rr(this.zoom, a), r, {}, a.canonical, [], a.formattedSection), p = this.expression.evaluate(new rr(this.zoom + 1, a), r, {}, a.canonical, [], a.formattedSection), f = this.paintVertexArray.length; this.paintVertexArray.resize(e), this._setPaintValue(f, e, u, p) } updatePaintArray(e, r, a, u, p) { const f = this.expression.evaluate(new rr(this.zoom, p), a, u), _ = this.expression.evaluate(new rr(this.zoom + 1, p), a, u); this._setPaintValue(e, r, f, _) } _setPaintValue(e, r, a, u) { if (this.type === "color") { const p = Gi(a), f = Gi(u); for (let _ = e; _ < r; _++)this.paintVertexArray.emplace(_, p[0], p[1], f[0], f[1]) } else { for (let p = e; p < r; p++)this.paintVertexArray.emplace(p, a, u); this.maxValue = Math.max(this.maxValue, Math.abs(a), Math.abs(u)) } } upload(e) { this.paintVertexArray && this.paintVertexArray.arrayBuffer && (this.paintVertexBuffer && this.paintVertexBuffer.buffer ? this.paintVertexBuffer.updateData(this.paintVertexArray) : this.paintVertexBuffer = e.createVertexBuffer(this.paintVertexArray, this.paintVertexAttributes, this.expression.isStateDependent)) } destroy() { this.paintVertexBuffer && this.paintVertexBuffer.destroy() } setUniform(e, r) { const a = this.useIntegerZoom ? Math.floor(r.zoom) : r.zoom, u = Ct(this.expression.interpolationFactor(a, this.zoom, this.zoom + 1), 0, 1); e.set(u) } getBinding(e, r, a) { return new oo(e, r) } } class Jr { constructor(e, r, a, u, p, f) { this.expression = e, this.type = r, this.useIntegerZoom = a, this.zoom = u, this.layerId = f, this.zoomInPaintVertexArray = new p, this.zoomOutPaintVertexArray = new p } populatePaintArray(e, r, a) { const u = this.zoomInPaintVertexArray.length; this.zoomInPaintVertexArray.resize(e), this.zoomOutPaintVertexArray.resize(e), this._setPaintValues(u, e, this.getPositionIds(r), a) } updatePaintArray(e, r, a, u, p) { this._setPaintValues(e, r, this.getPositionIds(a), p) } _setPaintValues(e, r, a, u) { const p = this.getPositions(u); if (!p || !a) return; const f = p[a.min], _ = p[a.mid], x = p[a.max]; if (f && _ && x) for (let S = e; S < r; S++)this.emplace(this.zoomInPaintVertexArray, S, _, f), this.emplace(this.zoomOutPaintVertexArray, S, _, x) } upload(e) { if (this.zoomInPaintVertexArray && this.zoomInPaintVertexArray.arrayBuffer && this.zoomOutPaintVertexArray && this.zoomOutPaintVertexArray.arrayBuffer) { const r = this.getVertexAttributes(); this.zoomInPaintVertexBuffer = e.createVertexBuffer(this.zoomInPaintVertexArray, r, this.expression.isStateDependent), this.zoomOutPaintVertexBuffer = e.createVertexBuffer(this.zoomOutPaintVertexArray, r, this.expression.isStateDependent) } } destroy() { this.zoomOutPaintVertexBuffer && this.zoomOutPaintVertexBuffer.destroy(), this.zoomInPaintVertexBuffer && this.zoomInPaintVertexBuffer.destroy() } } class en extends Jr { getPositions(e) { return e.imagePositions } getPositionIds(e) { return e.patterns && e.patterns[this.layerId] } getVertexAttributes() { return Kt.members } emplace(e, r, a, u) { e.emplace(r, a.tlbr[0], a.tlbr[1], a.tlbr[2], a.tlbr[3], u.tlbr[0], u.tlbr[1], u.tlbr[2], u.tlbr[3], a.pixelRatio, u.pixelRatio) } } class Bp extends Jr { getPositions(e) { return e.dashPositions } getPositionIds(e) { return e.dashes && e.dashes[this.layerId] } getVertexAttributes() { return fr.members } emplace(e, r, a, u) { e.emplace(r, 0, a.y, a.height, a.width, 0, u.y, u.height, u.width) } } class Op { constructor(e, r, a) { this.binders = {}, this._buffers = []; const u = []; for (const p in e.paint._values) { if (!a(p)) continue; const f = e.paint.get(p); if (!(f instanceof Pi && Wo(f.property.specification))) continue; const _ = ag(p, e.type), x = f.value, S = f.property.specification.type, M = f.property.useIntegerZoom, C = f.property.specification["property-type"], k = C === "cross-faded" || C === "cross-faded-data-driven"; if (x.kind === "constant") this.binders[p] = k ? new Ii(x.value, _) : new Mi(x.value, _, S), u.push(`/u_${p}`); else if (x.kind === "source" || k) { const D = Np(p, S, "source"); this.binders[p] = k ? p === "line-dasharray" ? new Bp(x, S, M, r, D, e.id) : new en(x, S, M, r, D, e.id) : new cr(x, _, S, D), u.push(`/a_${p}`) } else { const D = Np(p, S, "composite"); this.binders[p] = new ur(x, _, S, M, r, D), u.push(`/z_${p}`) } } this.cacheKey = u.sort().join("") } getMaxValue(e) { const r = this.binders[e]; return r instanceof cr || r instanceof ur ? r.maxValue : 0 } populatePaintArrays(e, r, a) { for (const u in this.binders) { const p = this.binders[u]; (p instanceof cr || p instanceof ur || p instanceof Jr) && p.populatePaintArray(e, r, a) } } setConstantPatternPositions(e, r) { for (const a in this.binders) { const u = this.binders[a]; u instanceof Ii && u.setConstantPatternPositions(e, r) } } setConstantDashPositions(e, r) { for (const a in this.binders) { const u = this.binders[a]; u instanceof Ii && u.setConstantDashPositions(e, r) } } updatePaintArrays(e, r, a, u, p) { let f = !1; for (const _ in e) { const x = r.getPositions(_); for (const S of x) { const M = a.feature(S.index); for (const C in this.binders) { const k = this.binders[C]; if ((k instanceof cr || k instanceof ur || k instanceof Jr) && k.expression.isStateDependent === !0) { const D = u.paint.get(C); k.expression = D.value, k.updatePaintArray(S.start, S.end, M, e[_], p), f = !0 } } } } return f } defines() { const e = []; for (const r in this.binders) { const a = this.binders[r]; (a instanceof Mi || a instanceof Ii) && e.push(...a.uniformNames.map(u => `#define HAS_UNIFORM_${u}`)) } return e } getBinderAttributes() { const e = []; for (const r in this.binders) { const a = this.binders[r]; if (a instanceof cr || a instanceof ur) for (let u = 0; u < a.paintVertexAttributes.length; u++)e.push(a.paintVertexAttributes[u].name); else if (a instanceof Jr) { const u = a.getVertexAttributes(); for (const p of u) e.push(p.name) } } return e } getBinderUniforms() { const e = []; for (const r in this.binders) { const a = this.binders[r]; if (a instanceof Mi || a instanceof Ii || a instanceof ur) for (const u of a.uniformNames) e.push(u) } return e } getPaintVertexBuffers() { return this._buffers } getUniforms(e, r) { const a = []; for (const u in this.binders) { const p = this.binders[u]; if (p instanceof Mi || p instanceof Ii || p instanceof ur) { for (const f of p.uniformNames) if (r[f]) { const _ = p.getBinding(e, r[f], f); a.push({ name: f, property: u, binding: _ }) } } } return a } setUniforms(e, r, a, u) { for (const { name: p, property: f, binding: _ } of r) this.binders[f].setUniform(_, u, a.get(f), p) } updatePaintBuffers(e) { this._buffers = []; for (const r in this.binders) { const a = this.binders[r]; if (e && a instanceof Jr) { const u = e.fromScale === 2 ? a.zoomInPaintVertexBuffer : a.zoomOutPaintVertexBuffer; u && this._buffers.push(u) } else (a instanceof cr || a instanceof ur) && a.paintVertexBuffer && this._buffers.push(a.paintVertexBuffer) } } upload(e) { for (const r in this.binders) { const a = this.binders[r]; (a instanceof cr || a instanceof ur || a instanceof Jr) && a.upload(e) } this.updatePaintBuffers() } destroy() { for (const e in this.binders) { const r = this.binders[e]; (r instanceof cr || r instanceof ur || r instanceof Jr) && r.destroy() } } } class lo { constructor(e, r, a = () => !0) { this.programConfigurations = {}; for (const u of e) this.programConfigurations[u.id] = new Op(u, r, a); this.needsUpload = !1, this._featureMap = new mn, this._bufferOffset = 0 } populatePaintArrays(e, r, a, u) { for (const p in this.programConfigurations) this.programConfigurations[p].populatePaintArrays(e, r, u); r.id !== void 0 && this._featureMap.add(r.id, a, this._bufferOffset, e), this._bufferOffset = e, this.needsUpload = !0 } updatePaintArrays(e, r, a, u) { for (const p of a) this.needsUpload = this.programConfigurations[p.id].updatePaintArrays(e, this._featureMap, r, p, u) || this.needsUpload } get(e) { return this.programConfigurations[e] } upload(e) { if (this.needsUpload) { for (const r in this.programConfigurations) this.programConfigurations[r].upload(e); this.needsUpload = !1 } } destroy() { for (const e in this.programConfigurations) this.programConfigurations[e].destroy() } } function ag(n, e) { return { "text-opacity": ["opacity"], "icon-opacity": ["opacity"], "text-color": ["fill_color"], "icon-color": ["fill_color"], "text-halo-color": ["halo_color"], "icon-halo-color": ["halo_color"], "text-halo-blur": ["halo_blur"], "icon-halo-blur": ["halo_blur"], "text-halo-width": ["halo_width"], "icon-halo-width": ["halo_width"], "line-gap-width": ["gapwidth"], "line-dasharray": ["dasharray_to", "dasharray_from"], "line-pattern": ["pattern_to", "pattern_from", "pixel_ratio_to", "pixel_ratio_from"], "fill-pattern": ["pattern_to", "pattern_from", "pixel_ratio_to", "pixel_ratio_from"], "fill-extrusion-pattern": ["pattern_to", "pattern_from", "pixel_ratio_to", "pixel_ratio_from"] }[n] || [n.replace(`${e}-`, "").replace(/-/g, "_")] } function Np(n, e, r) { const a = { color: { source: hl, composite: s }, number: { source: Iu, composite: hl } }, u = function (p) { return { "line-pattern": { source: oe, composite: oe }, "fill-pattern": { source: oe, composite: oe }, "fill-extrusion-pattern": { source: oe, composite: oe }, "line-dasharray": { source: ce, composite: ce } }[p] }(n); return u && u[r] || a[e][r] } pt("ConstantBinder", Mi), pt("CrossFadedConstantBinder", Ii), pt("SourceExpressionBinder", cr), pt("CrossFadedPatternBinder", en), pt("CrossFadedDasharrayBinder", Bp), pt("CompositeExpressionBinder", ur), pt("ProgramConfiguration", Op, { omit: ["_buffers"] }), pt("ProgramConfigurationSet", lo); const xh = Math.pow(2, 14) - 1, As = -xh - 1; function ks(n) { const e = Se / n.extent, r = n.loadGeometry(); for (let a = 0; a < r.length; a++) { const u = r[a]; for (let p = 0; p < u.length; p++) { const f = u[p], _ = Math.round(f.x * e), x = Math.round(f.y * e); f.x = Ct(_, As, xh), f.y = Ct(x, As, xh), (_ < f.x || _ > f.x + 1 || x < f.y || x > f.y + 1) && qt("Geometry exceeds allowed extent, reduce your vector tile buffer size") } } return r } function Ds(n, e) { return { type: n.type, id: n.id, properties: n.properties, geometry: e ? ks(n) : [] } } const wh = -32768; function bh(n, e, r, a, u) { n.emplaceBack(wh + 8 * e + a, wh + 8 * r + u) } class Au { constructor(e) { this.zoom = e.zoom, this.overscaling = e.overscaling, this.layers = e.layers, this.layerIds = this.layers.map(r => r.id), this.index = e.index, this.hasDependencies = !1, this.layoutVertexArray = new Q, this.indexArray = new Re, this.segments = new it, this.programConfigurations = new lo(e.layers, e.zoom), this.stateDependentLayerIds = this.layers.filter(r => r.isStateDependent()).map(r => r.id) } populate(e, r, a) { const u = this.layers[0], p = []; let f = null, _ = !1, x = u.type === "heatmap"; if (u.type === "circle") { const M = u; f = M.layout.get("circle-sort-key"), _ = !f.isConstant(), x = x || M.paint.get("circle-pitch-alignment") === "map" } const S = x ? r.subdivisionGranularity.circle : 1; for (const { feature: M, id: C, index: k, sourceLayerIndex: D } of e) { const L = this.layers[0]._featureFilter.needGeometry, F = Ds(M, L); if (!this.layers[0]._featureFilter.filter(new rr(this.zoom), F, a)) continue; const N = _ ? f.evaluate(F, {}, a) : void 0, G = { id: C, properties: M.properties, type: M.type, sourceLayerIndex: D, index: k, geometry: L ? F.geometry : ks(M), patterns: {}, sortKey: N }; p.push(G) } _ && p.sort((M, C) => M.sortKey - C.sortKey); for (const M of p) { const { geometry: C, index: k, sourceLayerIndex: D } = M, L = e[k].feature; this.addFeature(M, C, k, a, S), r.featureIndex.insert(L, C, k, D, this.index) } } update(e, r, a) { this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(e, r, this.stateDependentLayers, { imagePositions: a }) } isEmpty() { return this.layoutVertexArray.length === 0 } uploadPending() { return !this.uploaded || this.programConfigurations.needsUpload } upload(e) { this.uploaded || (this.layoutVertexBuffer = e.createVertexBuffer(this.layoutVertexArray, We), this.indexBuffer = e.createIndexBuffer(this.indexArray)), this.programConfigurations.upload(e), this.uploaded = !0 } destroy() { this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy()) } addFeature(e, r, a, u, p = 1) { let f; switch (p) { case 1: f = [0, 7]; break; case 3: f = [0, 2, 5, 7]; break; case 5: f = [0, 1, 3, 4, 6, 7]; break; case 7: f = [0, 1, 2, 3, 4, 5, 6, 7]; break; default: throw new Error(`Invalid circle bucket granularity: ${p}; valid values are 1, 3, 5, 7.`) }const _ = f.length; for (const x of r) for (const S of x) { const M = S.x, C = S.y; if (M < 0 || M >= Se || C < 0 || C >= Se) continue; const k = this.segments.prepareSegment(_ * _, this.layoutVertexArray, this.indexArray, e.sortKey), D = k.vertexLength; for (let L = 0; L < _; L++)for (let F = 0; F < _; F++)bh(this.layoutVertexArray, M, C, f[F], f[L]); for (let L = 0; L < _ - 1; L++)for (let F = 0; F < _ - 1; F++) { const N = D + L * _ + F, G = D + (L + 1) * _ + F; this.indexArray.emplaceBack(N, G + 1, N + 1), this.indexArray.emplaceBack(N, G, G + 1) } k.vertexLength += _ * _, k.primitiveLength += (_ - 1) * (_ - 1) * 2 } this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, e, a, { imagePositions: {}, canonical: u }) } } function ku(n, e) { for (let r = 0; r < n.length; r++)if (Du(e, n[r])) return !0; for (let r = 0; r < e.length; r++)if (Du(n, e[r])) return !0; return !!lg(n, e) } function jp(n, e, r) { return !!Du(n, e) || !!ug(e, n, r) } function j0(n, e) { if (n.length === 1) return U0(e, n[0]); for (let r = 0; r < e.length; r++) { const a = e[r]; for (let u = 0; u < a.length; u++)if (Du(n, a[u])) return !0 } for (let r = 0; r < n.length; r++)if (U0(e, n[r])) return !0; for (let r = 0; r < e.length; r++)if (lg(n, e[r])) return !0; return !1 } function rT(n, e, r) { if (n.length > 1) { if (lg(n, e)) return !0; for (let a = 0; a < e.length; a++)if (ug(e[a], n, r)) return !0 } for (let a = 0; a < n.length; a++)if (ug(n[a], e, r)) return !0; return !1 } function lg(n, e) { if (n.length === 0 || e.length === 0) return !1; for (let r = 0; r < n.length - 1; r++) { const a = n[r], u = n[r + 1]; for (let p = 0; p < e.length - 1; p++)if (nT(a, u, e[p], e[p + 1])) return !0 } return !1 } function nT(n, e, r, a) { return Gt(n, r, a) !== Gt(e, r, a) && Gt(n, e, r) !== Gt(n, e, a) } function ug(n, e, r) { const a = r * r; if (e.length === 1) return n.distSqr(e[0]) < a; for (let u = 1; u < e.length; u++)if (V0(n, e[u - 1], e[u]) < a) return !0; return !1 } function V0(n, e, r) { const a = e.distSqr(r); if (a === 0) return n.distSqr(e); const u = ((n.x - e.x) * (r.x - e.x) + (n.y - e.y) * (r.y - e.y)) / a; return n.distSqr(u < 0 ? e : u > 1 ? r : r.sub(e)._mult(u)._add(e)) } function U0(n, e) { let r, a, u, p = !1; for (let f = 0; f < n.length; f++) { r = n[f]; for (let _ = 0, x = r.length - 1; _ < r.length; x = _++)a = r[_], u = r[x], a.y > e.y != u.y > e.y && e.x < (u.x - a.x) * (e.y - a.y) / (u.y - a.y) + a.x && (p = !p) } return p } function Du(n, e) { let r = !1; for (let a = 0, u = n.length - 1; a < n.length; u = a++) { const p = n[a], f = n[u]; p.y > e.y != f.y > e.y && e.x < (f.x - p.x) * (e.y - p.y) / (f.y - p.y) + p.x && (r = !r) } return r } function iT(n, e, r) { const a = r[0], u = r[2]; if (n.x < a.x && e.x < a.x || n.x > u.x && e.x > u.x || n.y < a.y && e.y < a.y || n.y > u.y && e.y > u.y) return !1; const p = Gt(n, e, r[0]); return p !== Gt(n, e, r[1]) || p !== Gt(n, e, r[2]) || p !== Gt(n, e, r[3]) } function zu(n, e, r) { const a = e.paint.get(n).value; return a.kind === "constant" ? a.value : r.programConfigurations.get(e.id).getMaxValue(n) } function Vp(n) { return Math.sqrt(n[0] * n[0] + n[1] * n[1]) } function Up(n, e, r, a, u) { if (!e[0] && !e[1]) return n; const p = B.convert(e)._mult(u); r === "viewport" && p._rotate(-a); const f = []; for (let _ = 0; _ < n.length; _++)f.push(n[_].sub(p)); return f } function sT(n) { const e = []; for (let r = 0; r < n.length; r++) { const a = n[r], u = e.at(-1); (r === 0 || u && !a.equals(u)) && e.push(a) } return e } function oT({ queryGeometry: n, size: e }, r) { return jp(n, r, e) } function aT({ queryGeometry: n, size: e, transform: r, unwrappedTileID: a, getElevation: u }, p) { return jp(n, p, e * (r.projectTileCoordinates(p.x, p.y, a, u).signedDistanceFromCamera / r.cameraToCenterDistance)) } function lT({ queryGeometry: n, size: e, transform: r, unwrappedTileID: a, getElevation: u }, p) { const f = r.projectTileCoordinates(p.x, p.y, a, u).signedDistanceFromCamera, _ = e * (r.cameraToCenterDistance / f); return jp(n, cg(p, r, a, u), _) } function uT({ queryGeometry: n, size: e, transform: r, unwrappedTileID: a, getElevation: u }, p) { return jp(n, cg(p, r, a, u), e) } function G0({ queryGeometry: n, size: e, transform: r, unwrappedTileID: a, getElevation: u, pitchAlignment: p = "map", pitchScale: f = "map" }, _) { const x = p === "map" ? f === "map" ? oT : aT : f === "map" ? lT : uT, S = { queryGeometry: n, size: e, transform: r, unwrappedTileID: a, getElevation: u }; for (const M of _) for (const C of M) if (x(S, C)) return !0; return !1 } function cg(n, e, r, a) { const u = e.projectTileCoordinates(n.x, n.y, r, a).point; return new B((.5 * u.x + .5) * e.width, (.5 * -u.y + .5) * e.height) } let $0, q0; pt("CircleBucket", Au, { omit: ["layers"] }); var cT = { get paint() { return q0 = q0 || new Ln({ "circle-radius": new bt(De.paint_circle["circle-radius"]), "circle-color": new bt(De.paint_circle["circle-color"]), "circle-blur": new bt(De.paint_circle["circle-blur"]), "circle-opacity": new bt(De.paint_circle["circle-opacity"]), "circle-translate": new vt(De.paint_circle["circle-translate"]), "circle-translate-anchor": new vt(De.paint_circle["circle-translate-anchor"]), "circle-pitch-scale": new vt(De.paint_circle["circle-pitch-scale"]), "circle-pitch-alignment": new vt(De.paint_circle["circle-pitch-alignment"]), "circle-stroke-width": new bt(De.paint_circle["circle-stroke-width"]), "circle-stroke-color": new bt(De.paint_circle["circle-stroke-color"]), "circle-stroke-opacity": new bt(De.paint_circle["circle-stroke-opacity"]) }) }, get layout() { return $0 = $0 || new Ln({ "circle-sort-key": new bt(De.layout_circle["circle-sort-key"]) }) } }; class hT extends ci { constructor(e, r) { super(e, cT, r) } createBucket(e) { return new Au(e) } queryRadius(e) { const r = e; return zu("circle-radius", this, r) + zu("circle-stroke-width", this, r) + Vp(this.paint.get("circle-translate")) } queryIntersectsFeature({ queryGeometry: e, feature: r, featureState: a, geometry: u, transform: p, pixelsToTileUnits: f, unwrappedTileID: _, getElevation: x }) { const S = Up(e, this.paint.get("circle-translate"), this.paint.get("circle-translate-anchor"), -p.bearingInRadians, f), M = this.paint.get("circle-radius").evaluate(r, a) + this.paint.get("circle-stroke-width").evaluate(r, a), C = this.paint.get("circle-pitch-scale"), k = this.paint.get("circle-pitch-alignment"); let D, L; return k === "map" ? (D = S, L = M * f) : (D = function (F, N, G, ee) { return F.map(q => cg(q, N, G, ee)) }(S, p, _, x), L = M), G0({ queryGeometry: D, size: L, transform: p, unwrappedTileID: _, getElevation: x, pitchAlignment: k, pitchScale: C }, u) } } class Z0 extends Au { } let W0; pt("HeatmapBucket", Z0, { omit: ["layers"] }); var dT = { get paint() { return W0 = W0 || new Ln({ "heatmap-radius": new bt(De.paint_heatmap["heatmap-radius"]), "heatmap-weight": new bt(De.paint_heatmap["heatmap-weight"]), "heatmap-intensity": new vt(De.paint_heatmap["heatmap-intensity"]), "heatmap-color": new Tu(De.paint_heatmap["heatmap-color"]), "heatmap-opacity": new vt(De.paint_heatmap["heatmap-opacity"]) }) } }; function hg(n, { width: e, height: r }, a, u) { if (u) { if (u instanceof Uint8ClampedArray) u = new Uint8Array(u.buffer); else if (u.length !== e * r * a) throw new RangeError(`mismatched image size. expected: ${u.length} but got: ${e * r * a}`) } else u = new Uint8Array(e * r * a); return n.width = e, n.height = r, n.data = u, n } function H0(n, { width: e, height: r }, a) { if (e === n.width && r === n.height) return; const u = hg({}, { width: e, height: r }, a); dg(n, u, { x: 0, y: 0 }, { x: 0, y: 0 }, { width: Math.min(n.width, e), height: Math.min(n.height, r) }, a), n.width = e, n.height = r, n.data = u.data } function dg(n, e, r, a, u, p) { if (u.width === 0 || u.height === 0) return e; if (u.width > n.width || u.height > n.height || r.x > n.width - u.width || r.y > n.height - u.height) throw new RangeError("out of range source coordinates for image copy"); if (u.width > e.width || u.height > e.height || a.x > e.width - u.width || a.y > e.height - u.height) throw new RangeError("out of range destination coordinates for image copy"); const f = n.data, _ = e.data; if (f === _) throw new Error("srcData equals dstData, so image is already copied"); for (let x = 0; x < u.height; x++) { const S = ((r.y + x) * n.width + r.x) * p, M = ((a.y + x) * e.width + a.x) * p; for (let C = 0; C < u.width * p; C++)_[M + C] = f[S + C] } return e } class Th { constructor(e, r) { hg(this, e, 1, r) } resize(e) { H0(this, e, 1) } clone() { return new Th({ width: this.width, height: this.height }, new Uint8Array(this.data)) } static copy(e, r, a, u, p) { dg(e, r, a, u, p, 1) } } class Jn { constructor(e, r) { hg(this, e, 4, r) } resize(e) { H0(this, e, 4) } replace(e, r) { r ? this.data.set(e) : this.data = e instanceof Uint8ClampedArray ? new Uint8Array(e.buffer) : e } clone() { return new Jn({ width: this.width, height: this.height }, new Uint8Array(this.data)) } static copy(e, r, a, u, p) { dg(e, r, a, u, p, 4) } setPixel(e, r, a) { const u = 4 * (e * this.width + r); this.data[u + 0] = Math.round(255 * a.r / a.a), this.data[u + 1] = Math.round(255 * a.g / a.a), this.data[u + 2] = Math.round(255 * a.b / a.a), this.data[u + 3] = Math.round(255 * a.a) } } function X0(n) { const e = {}, r = n.resolution || 256, a = n.clips ? n.clips.length : 1, u = n.image || new Jn({ width: r, height: a }); if (Math.log(r) / Math.LN2 % 1 != 0) throw new Error(`width is not a power of 2 - ${r}`); const p = (f, _, x) => { e[n.evaluationKey] = x; const S = n.expression.evaluate(e); u.setPixel(f / 4 / r, _ / 4, S) }; if (n.clips) for (let f = 0, _ = 0; f < a; ++f, _ += 4 * r)for (let x = 0, S = 0; x < r; x++, S += 4) { const M = x / (r - 1), { start: C, end: k } = n.clips[f]; p(_, S, C * (1 - M) + k * M) } else for (let f = 0, _ = 0; f < r; f++, _ += 4)p(0, _, f / (r - 1)); return u } pt("AlphaImage", Th), pt("RGBAImage", Jn); const pg = "big-fb"; class pT extends ci { createBucket(e) { return new Z0(e) } constructor(e, r) { super(e, dT, r), this.heatmapFbos = new Map, this._updateColorRamp() } _handleSpecialPaintPropertyUpdate(e) { e === "heatmap-color" && this._updateColorRamp() } _updateColorRamp() { this.colorRamp = X0({ expression: this._transitionablePaint._values["heatmap-color"].value.expression, evaluationKey: "heatmapDensity", image: this.colorRamp }), this.colorRampTexture = null } resize() { this.heatmapFbos.has(pg) && this.heatmapFbos.delete(pg) } queryRadius(e) { return zu("heatmap-radius", this, e) } queryIntersectsFeature({ queryGeometry: e, feature: r, featureState: a, geometry: u, transform: p, pixelsToTileUnits: f, unwrappedTileID: _, getElevation: x }) { return G0({ queryGeometry: e, size: this.paint.get("heatmap-radius").evaluate(r, a) * f, transform: p, unwrappedTileID: _, getElevation: x }, u) } hasOffscreenPass() { return this.paint.get("heatmap-opacity") !== 0 && !this.isHidden() } } let Y0; var fT = { get paint() { return Y0 = Y0 || new Ln({ "hillshade-illumination-direction": new vt(De.paint_hillshade["hillshade-illumination-direction"]), "hillshade-illumination-altitude": new vt(De.paint_hillshade["hillshade-illumination-altitude"]), "hillshade-illumination-anchor": new vt(De.paint_hillshade["hillshade-illumination-anchor"]), "hillshade-exaggeration": new vt(De.paint_hillshade["hillshade-exaggeration"]), "hillshade-shadow-color": new vt(De.paint_hillshade["hillshade-shadow-color"]), "hillshade-highlight-color": new vt(De.paint_hillshade["hillshade-highlight-color"]), "hillshade-accent-color": new vt(De.paint_hillshade["hillshade-accent-color"]), "hillshade-method": new vt(De.paint_hillshade["hillshade-method"]) }) } }; class mT extends ci { constructor(e, r) { super(e, fT, r), this.recalculate({ zoom: 0, zoomHistory: {} }, void 0) } getIlluminationProperties() { let e = this.paint.get("hillshade-illumination-direction").values, r = this.paint.get("hillshade-illumination-altitude").values, a = this.paint.get("hillshade-highlight-color").values, u = this.paint.get("hillshade-shadow-color").values; const p = Math.max(e.length, r.length, a.length, u.length); e = e.concat(Array(p - e.length).fill(e.at(-1))), r = r.concat(Array(p - r.length).fill(r.at(-1))), a = a.concat(Array(p - a.length).fill(a.at(-1))), u = u.concat(Array(p - u.length).fill(u.at(-1))); const f = r.map(Io); return { directionRadians: e.map(Io), altitudeRadians: f, shadowColor: u, highlightColor: a } } hasOffscreenPass() { return this.paint.get("hillshade-exaggeration") !== 0 && !this.isHidden() } } let K0; var gT = { get paint() { return K0 = K0 || new Ln({ "color-relief-opacity": new vt(De["paint_color-relief"]["color-relief-opacity"]), "color-relief-color": new Tu(De["paint_color-relief"]["color-relief-color"]) }) } }; class fg { constructor(e, r, a, u) { this.context = e, this.format = a, this.texture = e.gl.createTexture(), this.update(r, u) } update(e, r, a) { const { width: u, height: p } = e, f = !(this.size && this.size[0] === u && this.size[1] === p || a), { context: _ } = this, { gl: x } = _; if (this.useMipmap = !!(r && r.useMipmap), x.bindTexture(x.TEXTURE_2D, this.texture), _.pixelStoreUnpackFlipY.set(!1), _.pixelStoreUnpack.set(1), _.pixelStoreUnpackPremultiplyAlpha.set(this.format === x.RGBA && (!r || r.premultiply !== !1)), f) this.size = [u, p], e instanceof HTMLImageElement || e instanceof HTMLCanvasElement || e instanceof HTMLVideoElement || e instanceof ImageData || ys(e) ? x.texImage2D(x.TEXTURE_2D, 0, this.format, this.format, x.UNSIGNED_BYTE, e) : x.texImage2D(x.TEXTURE_2D, 0, this.format, u, p, 0, this.format, x.UNSIGNED_BYTE, e.data); else { const { x: S, y: M } = a || { x: 0, y: 0 }; e instanceof HTMLImageElement || e instanceof HTMLCanvasElement || e instanceof HTMLVideoElement || e instanceof ImageData || ys(e) ? x.texSubImage2D(x.TEXTURE_2D, 0, S, M, x.RGBA, x.UNSIGNED_BYTE, e) : x.texSubImage2D(x.TEXTURE_2D, 0, S, M, u, p, x.RGBA, x.UNSIGNED_BYTE, e.data) } this.useMipmap && this.isSizePowerOfTwo() && x.generateMipmap(x.TEXTURE_2D), _.pixelStoreUnpackFlipY.setDefault(), _.pixelStoreUnpack.setDefault(), _.pixelStoreUnpackPremultiplyAlpha.setDefault() } bind(e, r, a) { const { context: u } = this, { gl: p } = u; p.bindTexture(p.TEXTURE_2D, this.texture), a !== p.LINEAR_MIPMAP_NEAREST || this.isSizePowerOfTwo() || (a = p.LINEAR), e !== this.filter && (p.texParameteri(p.TEXTURE_2D, p.TEXTURE_MAG_FILTER, e), p.texParameteri(p.TEXTURE_2D, p.TEXTURE_MIN_FILTER, a || e), this.filter = e), r !== this.wrap && (p.texParameteri(p.TEXTURE_2D, p.TEXTURE_WRAP_S, r), p.texParameteri(p.TEXTURE_2D, p.TEXTURE_WRAP_T, r), this.wrap = r) } isSizePowerOfTwo() { return this.size[0] === this.size[1] && Math.log(this.size[0]) / Math.LN2 % 1 == 0 } destroy() { const { gl: e } = this.context; e.deleteTexture(this.texture), this.texture = null } } class Q0 { constructor(e, r, a, u = 1, p = 1, f = 1, _ = 0) { if (this.uid = e, r.height !== r.width) throw new RangeError("DEM tiles must be square"); if (a && !["mapbox", "terrarium", "custom"].includes(a)) return void qt(`"${a}" is not a valid encoding type. Valid types include "mapbox", "terrarium" and "custom".`); this.stride = r.height; const x = this.dim = r.height - 2; switch (this.data = new Uint32Array(r.data.buffer), a) { case "terrarium": this.redFactor = 256, this.greenFactor = 1, this.blueFactor = 1 / 256, this.baseShift = 32768; break; case "custom": this.redFactor = u, this.greenFactor = p, this.blueFactor = f, this.baseShift = _; break; default: this.redFactor = 6553.6, this.greenFactor = 25.6, this.blueFactor = .1, this.baseShift = 1e4 }for (let S = 0; S < x; S++)this.data[this._idx(-1, S)] = this.data[this._idx(0, S)], this.data[this._idx(x, S)] = this.data[this._idx(x - 1, S)], this.data[this._idx(S, -1)] = this.data[this._idx(S, 0)], this.data[this._idx(S, x)] = this.data[this._idx(S, x - 1)]; this.data[this._idx(-1, -1)] = this.data[this._idx(0, 0)], this.data[this._idx(x, -1)] = this.data[this._idx(x - 1, 0)], this.data[this._idx(-1, x)] = this.data[this._idx(0, x - 1)], this.data[this._idx(x, x)] = this.data[this._idx(x - 1, x - 1)], this.min = Number.MAX_SAFE_INTEGER, this.max = Number.MIN_SAFE_INTEGER; for (let S = 0; S < x; S++)for (let M = 0; M < x; M++) { const C = this.get(S, M); C > this.max && (this.max = C), C < this.min && (this.min = C) } } get(e, r) { const a = new Uint8Array(this.data.buffer), u = 4 * this._idx(e, r); return this.unpack(a[u], a[u + 1], a[u + 2]) } getUnpackVector() { return [this.redFactor, this.greenFactor, this.blueFactor, this.baseShift] } _idx(e, r) { if (e < -1 || e >= this.dim + 1 || r < -1 || r >= this.dim + 1) throw new RangeError(`Out of range source coordinates for DEM data. x: ${e}, y: ${r}, dim: ${this.dim}`); return (r + 1) * this.stride + (e + 1) } unpack(e, r, a) { return e * this.redFactor + r * this.greenFactor + a * this.blueFactor - this.baseShift } pack(e) { return J0(e, this.getUnpackVector()) } getPixels() { return new Jn({ width: this.stride, height: this.stride }, new Uint8Array(this.data.buffer)) } backfillBorder(e, r, a) { if (this.dim !== e.dim) throw new Error("dem dimension mismatch"); let u = r * this.dim, p = r * this.dim + this.dim, f = a * this.dim, _ = a * this.dim + this.dim; switch (r) { case -1: u = p - 1; break; case 1: p = u + 1 }switch (a) { case -1: f = _ - 1; break; case 1: _ = f + 1 }const x = -r * this.dim, S = -a * this.dim; for (let M = f; M < _; M++)for (let C = u; C < p; C++)this.data[this._idx(C, M)] = e.data[this._idx(C + x, M + S)] } } function J0(n, e) { const r = e[0], a = e[1], u = e[2], p = e[3], f = Math.min(r, a, u), _ = Math.round((n + p) / f); return { r: Math.floor(_ * f / r) % 256, g: Math.floor(_ * f / a) % 256, b: Math.floor(_ * f / u) % 256 } } pt("DEMData", Q0); class _T extends ci { constructor(e, r) { super(e, gT, r) } _createColorRamp(e) { const r = { elevationStops: [], colorStops: [] }, a = this._transitionablePaint._values["color-relief-color"].value.expression; if (a instanceof cu && a._styleExpression.expression instanceof Rn) { this.colorRampExpression = a; const f = a._styleExpression.expression; r.elevationStops = f.labels, r.colorStops = []; for (const _ of r.elevationStops) r.colorStops.push(f.evaluate({ globals: { elevation: _ } })) } if (r.elevationStops.length < 1 && (r.elevationStops = [0], r.colorStops = [Rt.transparent]), r.elevationStops.length < 2 && (r.elevationStops.push(r.elevationStops[0] + 1), r.colorStops.push(r.colorStops[0])), r.elevationStops.length <= e) return r; const u = { elevationStops: [], colorStops: [] }, p = (r.elevationStops.length - 1) / (e - 1); for (let f = 0; f < r.elevationStops.length - .5; f += p)u.elevationStops.push(r.elevationStops[Math.round(f)]), u.colorStops.push(r.colorStops[Math.round(f)]); return qt(`Too many colors in specification of ${this.id} color-relief layer, may not render properly. Max possible colors: ${e}, provided: ${r.elevationStops.length}`), u } _colorRampChanged() { return this.colorRampExpression != this._transitionablePaint._values["color-relief-color"].value.expression } getColorRampTextures(e, r, a) { if (this.colorRampTextures && !this._colorRampChanged()) return this.colorRampTextures; const u = this._createColorRamp(r), p = new Jn({ width: u.colorStops.length, height: 1 }), f = new Jn({ width: u.colorStops.length, height: 1 }); for (let _ = 0; _ < u.elevationStops.length; _++) { const x = J0(u.elevationStops[_], a); f.setPixel(0, _, new Rt(x.r / 255, x.g / 255, x.b / 255, 1)), p.setPixel(0, _, u.colorStops[_]) } return this.colorRampTextures = { elevationTexture: new fg(e, f, e.gl.RGBA), colorTexture: new fg(e, p, e.gl.RGBA) }, this.colorRampTextures } hasOffscreenPass() { return !this.isHidden() && !!this.colorRampTextures } } const yT = Br([{ name: "a_pos", components: 2, type: "Int16" }], 4), { members: vT } = yT; function Gp(n, e, r) { const a = r.patternDependencies; let u = !1; for (const p of e) { const f = p.paint.get(`${n}-pattern`); f.isConstant() || (u = !0); const _ = f.constantOr(null); _ && (u = !0, a[_.to] = !0, a[_.from] = !0) } return u } function mg(n, e, r, a, u) { const { zoom: p } = a, f = u.patternDependencies; for (const _ of e) { const x = _.paint.get(`${n}-pattern`).value; if (x.kind !== "constant") { let S = x.evaluate({ zoom: p - 1 }, r, {}, u.availableImages), M = x.evaluate({ zoom: p }, r, {}, u.availableImages), C = x.evaluate({ zoom: p + 1 }, r, {}, u.availableImages); S = S && S.name ? S.name : S, M = M && M.name ? M.name : M, C = C && C.name ? C.name : C, f[S] = !0, f[M] = !0, f[C] = !0, r.patterns[_.id] = { min: S, mid: M, max: C } } } return r } function ev(n, e, r, a, u) { let p; if (u === function (f, _, x, S) { let M = 0; for (let C = _, k = x - S; C < x; C += S)M += (f[k] - f[C]) * (f[C + 1] + f[k + 1]), k = C; return M }(n, e, r, a) > 0) for (let f = e; f < r; f += a)p = iv(f / a | 0, n[f], n[f + 1], p); else for (let f = r - a; f >= e; f -= a)p = iv(f / a | 0, n[f], n[f + 1], p); return p && Ru(p, p.next) && (Mh(p), p = p.next), p } function gl(n, e) { if (!n) return n; e || (e = n); let r, a = n; do if (r = !1, a.steiner || !Ru(a, a.next) && Ur(a.prev, a, a.next) !== 0) a = a.next; else { if (Mh(a), a = e = a.prev, a === a.next) break; r = !0 } while (r || a !== e); return e } function Sh(n, e, r, a, u, p, f) { if (!n) return; !f && p && function (x, S, M, C) { let k = x; do k.z === 0 && (k.z = gg(k.x, k.y, S, M, C)), k.prevZ = k.prev, k.nextZ = k.next, k = k.next; while (k !== x); k.prevZ.nextZ = null, k.prevZ = null, function (D) { let L, F = 1; do { let N, G = D; D = null; let ee = null; for (L = 0; G;) { L++; let q = G, H = 0; for (let ae = 0; ae < F && (H++, q = q.nextZ, q); ae++); let ne = F; for (; H > 0 || ne > 0 && q;)H !== 0 && (ne === 0 || !q || G.z <= q.z) ? (N = G, G = G.nextZ, H--) : (N = q, q = q.nextZ, ne--), ee ? ee.nextZ = N : D = N, N.prevZ = ee, ee = N; G = q } ee.nextZ = null, F *= 2 } while (L > 1) }(k) }(n, a, u, p); let _ = n; for (; n.prev !== n.next;) { const x = n.prev, S = n.next; if (p ? wT(n, a, u, p) : xT(n)) e.push(x.i, n.i, S.i), Mh(n), n = S.next, _ = S.next; else if ((n = S) === _) { f ? f === 1 ? Sh(n = bT(gl(n), e), e, r, a, u, p, 2) : f === 2 && TT(n, e, r, a, u, p) : Sh(gl(n), e, r, a, u, p, 1); break } } } function xT(n) { const e = n.prev, r = n, a = n.next; if (Ur(e, r, a) >= 0) return !1; const u = e.x, p = r.x, f = a.x, _ = e.y, x = r.y, S = a.y, M = Math.min(u, p, f), C = Math.min(_, x, S), k = Math.max(u, p, f), D = Math.max(_, x, S); let L = a.next; for (; L !== e;) { if (L.x >= M && L.x <= k && L.y >= C && L.y <= D && Eh(u, _, p, x, f, S, L.x, L.y) && Ur(L.prev, L, L.next) >= 0) return !1; L = L.next } return !0 } function wT(n, e, r, a) { const u = n.prev, p = n, f = n.next; if (Ur(u, p, f) >= 0) return !1; const _ = u.x, x = p.x, S = f.x, M = u.y, C = p.y, k = f.y, D = Math.min(_, x, S), L = Math.min(M, C, k), F = Math.max(_, x, S), N = Math.max(M, C, k), G = gg(D, L, e, r, a), ee = gg(F, N, e, r, a); let q = n.prevZ, H = n.nextZ; for (; q && q.z >= G && H && H.z <= ee;) { if (q.x >= D && q.x <= F && q.y >= L && q.y <= N && q !== u && q !== f && Eh(_, M, x, C, S, k, q.x, q.y) && Ur(q.prev, q, q.next) >= 0 || (q = q.prevZ, H.x >= D && H.x <= F && H.y >= L && H.y <= N && H !== u && H !== f && Eh(_, M, x, C, S, k, H.x, H.y) && Ur(H.prev, H, H.next) >= 0)) return !1; H = H.nextZ } for (; q && q.z >= G;) { if (q.x >= D && q.x <= F && q.y >= L && q.y <= N && q !== u && q !== f && Eh(_, M, x, C, S, k, q.x, q.y) && Ur(q.prev, q, q.next) >= 0) return !1; q = q.prevZ } for (; H && H.z <= ee;) { if (H.x >= D && H.x <= F && H.y >= L && H.y <= N && H !== u && H !== f && Eh(_, M, x, C, S, k, H.x, H.y) && Ur(H.prev, H, H.next) >= 0) return !1; H = H.nextZ } return !0 } function bT(n, e) { let r = n; do { const a = r.prev, u = r.next.next; !Ru(a, u) && rv(a, r, r.next, u) && Ph(a, u) && Ph(u, a) && (e.push(a.i, r.i, u.i), Mh(r), Mh(r.next), r = n = u), r = r.next } while (r !== n); return gl(r) } function TT(n, e, r, a, u, p) { let f = n; do { let _ = f.next.next; for (; _ !== f.prev;) { if (f.i !== _.i && IT(f, _)) { let x = nv(f, _); return f = gl(f, f.next), x = gl(x, x.next), Sh(f, e, r, a, u, p, 0), void Sh(x, e, r, a, u, p, 0) } _ = _.next } f = f.next } while (f !== n) } function ST(n, e) { let r = n.x - e.x; return r === 0 && (r = n.y - e.y, r === 0) && (r = (n.next.y - n.y) / (n.next.x - n.x) - (e.next.y - e.y) / (e.next.x - e.x)), r } function ET(n, e) { const r = function (u, p) { let f = p; const _ = u.x, x = u.y; let S, M = -1 / 0; if (Ru(u, f)) return f; do { if (Ru(u, f.next)) return f.next; if (x <= f.y && x >= f.next.y && f.next.y !== f.y) { const F = f.x + (x - f.y) * (f.next.x - f.x) / (f.next.y - f.y); if (F <= _ && F > M && (M = F, S = f.x < f.next.x ? f : f.next, F === _)) return S } f = f.next } while (f !== p); if (!S) return null; const C = S, k = S.x, D = S.y; let L = 1 / 0; f = S; do { if (_ >= f.x && f.x >= k && _ !== f.x && tv(x < D ? _ : M, x, k, D, x < D ? M : _, x, f.x, f.y)) { const F = Math.abs(x - f.y) / (_ - f.x); Ph(f, u) && (F < L || F === L && (f.x > S.x || f.x === S.x && PT(S, f))) && (S = f, L = F) } f = f.next } while (f !== C); return S }(n, e); if (!r) return e; const a = nv(r, n); return gl(a, a.next), gl(r, r.next) } function PT(n, e) { return Ur(n.prev, n, e.prev) < 0 && Ur(e.next, n, n.next) < 0 } function gg(n, e, r, a, u) { return (n = 1431655765 & ((n = 858993459 & ((n = 252645135 & ((n = 16711935 & ((n = (n - r) * u | 0) | n << 8)) | n << 4)) | n << 2)) | n << 1)) | (e = 1431655765 & ((e = 858993459 & ((e = 252645135 & ((e = 16711935 & ((e = (e - a) * u | 0) | e << 8)) | e << 4)) | e << 2)) | e << 1)) << 1 } function MT(n) { let e = n, r = n; do (e.x < r.x || e.x === r.x && e.y < r.y) && (r = e), e = e.next; while (e !== n); return r } function tv(n, e, r, a, u, p, f, _) { return (u - f) * (e - _) >= (n - f) * (p - _) && (n - f) * (a - _) >= (r - f) * (e - _) && (r - f) * (p - _) >= (u - f) * (a - _) } function Eh(n, e, r, a, u, p, f, _) { return !(n === f && e === _) && tv(n, e, r, a, u, p, f, _) } function IT(n, e) { return n.next.i !== e.i && n.prev.i !== e.i && !function (r, a) { let u = r; do { if (u.i !== r.i && u.next.i !== r.i && u.i !== a.i && u.next.i !== a.i && rv(u, u.next, r, a)) return !0; u = u.next } while (u !== r); return !1 }(n, e) && (Ph(n, e) && Ph(e, n) && function (r, a) { let u = r, p = !1; const f = (r.x + a.x) / 2, _ = (r.y + a.y) / 2; do u.y > _ != u.next.y > _ && u.next.y !== u.y && f < (u.next.x - u.x) * (_ - u.y) / (u.next.y - u.y) + u.x && (p = !p), u = u.next; while (u !== r); return p }(n, e) && (Ur(n.prev, n, e.prev) || Ur(n, e.prev, e)) || Ru(n, e) && Ur(n.prev, n, n.next) > 0 && Ur(e.prev, e, e.next) > 0) } function Ur(n, e, r) { return (e.y - n.y) * (r.x - e.x) - (e.x - n.x) * (r.y - e.y) } function Ru(n, e) { return n.x === e.x && n.y === e.y } function rv(n, e, r, a) { const u = qp(Ur(n, e, r)), p = qp(Ur(n, e, a)), f = qp(Ur(r, a, n)), _ = qp(Ur(r, a, e)); return u !== p && f !== _ || !(u !== 0 || !$p(n, r, e)) || !(p !== 0 || !$p(n, a, e)) || !(f !== 0 || !$p(r, n, a)) || !(_ !== 0 || !$p(r, e, a)) } function $p(n, e, r) { return e.x <= Math.max(n.x, r.x) && e.x >= Math.min(n.x, r.x) && e.y <= Math.max(n.y, r.y) && e.y >= Math.min(n.y, r.y) } function qp(n) { return n > 0 ? 1 : n < 0 ? -1 : 0 } function Ph(n, e) { return Ur(n.prev, n, n.next) < 0 ? Ur(n, e, n.next) >= 0 && Ur(n, n.prev, e) >= 0 : Ur(n, e, n.prev) < 0 || Ur(n, n.next, e) < 0 } function nv(n, e) { const r = _g(n.i, n.x, n.y), a = _g(e.i, e.x, e.y), u = n.next, p = e.prev; return n.next = e, e.prev = n, r.next = u, u.prev = r, a.next = r, r.prev = a, p.next = a, a.prev = p, a } function iv(n, e, r, a) { const u = _g(n, e, r); return a ? (u.next = a.next, u.prev = a, a.next.prev = u, a.next = u) : (u.prev = u, u.next = u), u } function Mh(n) { n.next.prev = n.prev, n.prev.next = n.next, n.prevZ && (n.prevZ.nextZ = n.nextZ), n.nextZ && (n.nextZ.prevZ = n.prevZ) } function _g(n, e, r) { return { i: n, x: e, y: r, prev: null, next: null, z: 0, prevZ: null, nextZ: null, steiner: !1 } } class Lu { constructor(e, r) { if (r > e) throw new Error("Min granularity must not be greater than base granularity."); this._baseZoomGranularity = e, this._minGranularity = r } getGranularityForZoomLevel(e) { return Math.max(Math.floor(this._baseZoomGranularity / (1 << e)), this._minGranularity, 1) } } class Zp { constructor(e) { this.fill = e.fill, this.line = e.line, this.tile = e.tile, this.stencil = e.stencil, this.circle = e.circle } } Zp.noSubdivision = new Zp({ fill: new Lu(0, 0), line: new Lu(0, 0), tile: new Lu(0, 0), stencil: new Lu(0, 0), circle: 1 }), pt("SubdivisionGranularityExpression", Lu), pt("SubdivisionGranularitySetting", Zp); const Fu = -32768, Ih = 32767; class CT { constructor(e, r) { this._vertexBuffer = [], this._vertexDictionary = new Map, this._used = !1, this._granularity = e, this._granularityCellSize = Se / e, this._canonical = r } _getKey(e, r) { return (e += 32768) << 16 | r + 32768 } _vertexToIndex(e, r) { if (e < -32768 || r < -32768 || e > 32767 || r > 32767) throw new Error("Vertex coordinates are out of signed 16 bit integer range."); const a = 0 | Math.round(e), u = 0 | Math.round(r), p = this._getKey(a, u); if (this._vertexDictionary.has(p)) return this._vertexDictionary.get(p); const f = this._vertexBuffer.length / 2; return this._vertexDictionary.set(p, f), this._vertexBuffer.push(a, u), f } _subdivideTrianglesScanline(e) { if (this._granularity < 2) return function (u, p) { const f = []; for (let _ = 0; _ < p.length; _ += 3) { const x = p[_], S = p[_ + 1], M = p[_ + 2], C = u[2 * x], k = u[2 * x + 1]; (u[2 * S] - C) * (u[2 * M + 1] - k) - (u[2 * S + 1] - k) * (u[2 * M] - C) > 0 ? (f.push(x), f.push(M), f.push(S)) : (f.push(x), f.push(S), f.push(M)) } return f }(this._vertexBuffer, e); const r = [], a = e.length; for (let u = 0; u < a; u += 3) { const p = [e[u + 0], e[u + 1], e[u + 2]], f = [this._vertexBuffer[2 * e[u + 0] + 0], this._vertexBuffer[2 * e[u + 0] + 1], this._vertexBuffer[2 * e[u + 1] + 0], this._vertexBuffer[2 * e[u + 1] + 1], this._vertexBuffer[2 * e[u + 2] + 0], this._vertexBuffer[2 * e[u + 2] + 1]]; let _ = 1 / 0, x = 1 / 0, S = -1 / 0, M = -1 / 0; for (let F = 0; F < 3; F++) { const N = f[2 * F], G = f[2 * F + 1]; _ = Math.min(_, N), S = Math.max(S, N), x = Math.min(x, G), M = Math.max(M, G) } if (_ === S || x === M) continue; const C = Math.floor(_ / this._granularityCellSize), k = Math.ceil(S / this._granularityCellSize), D = Math.floor(x / this._granularityCellSize), L = Math.ceil(M / this._granularityCellSize); if (C !== k || D !== L) for (let F = D; F < L; F++) { const N = this._scanlineGenerateVertexRingForCellRow(F, f, p); AT(this._vertexBuffer, N, r) } else r.push(...p) } return r } _scanlineGenerateVertexRingForCellRow(e, r, a) { const u = e * this._granularityCellSize, p = u + this._granularityCellSize, f = []; for (let _ = 0; _ < 3; _++) { const x = r[2 * _], S = r[2 * _ + 1], M = r[2 * (_ + 1) % 6], C = r[(2 * (_ + 1) + 1) % 6], k = r[2 * (_ + 2) % 6], D = r[(2 * (_ + 2) + 1) % 6], L = M - x, F = C - S, N = L === 0, G = F === 0, ee = (u - S) / F, q = (p - S) / F, H = Math.min(ee, q), ne = Math.max(ee, q); if (!G && (H >= 1 || ne <= 0) || G && (S < u || S > p)) { C >= u && C <= p && f.push(a[(_ + 1) % 3]); continue } !G && H > 0 && f.push(this._vertexToIndex(x + L * H, S + F * H)); const ae = x + L * Math.max(H, 0), Ie = x + L * Math.min(ne, 1); N || this._generateIntraEdgeVertices(f, x, S, M, C, ae, Ie), !G && ne < 1 && f.push(this._vertexToIndex(x + L * ne, S + F * ne)), (G || C >= u && C <= p) && f.push(a[(_ + 1) % 3]), !G && (C <= u || C >= p) && this._generateInterEdgeVertices(f, x, S, M, C, k, D, Ie, u, p) } return f } _generateIntraEdgeVertices(e, r, a, u, p, f, _) { const x = u - r, S = p - a, M = S === 0, C = M ? Math.min(r, u) : Math.min(f, _), k = M ? Math.max(r, u) : Math.max(f, _), D = Math.floor(C / this._granularityCellSize) + 1, L = Math.ceil(k / this._granularityCellSize) - 1; if (M ? r < u : f < _) for (let F = D; F <= L; F++) { const N = F * this._granularityCellSize; e.push(this._vertexToIndex(N, a + S * (N - r) / x)) } else for (let F = L; F >= D; F--) { const N = F * this._granularityCellSize; e.push(this._vertexToIndex(N, a + S * (N - r) / x)) } } _generateInterEdgeVertices(e, r, a, u, p, f, _, x, S, M) { const C = p - a, k = f - u, D = _ - p, L = (S - p) / D, F = (M - p) / D, N = Math.min(L, F), G = Math.max(L, F), ee = u + k * N; let q = Math.floor(Math.min(ee, x) / this._granularityCellSize) + 1, H = Math.ceil(Math.max(ee, x) / this._granularityCellSize) - 1, ne = x < ee; const ae = D === 0; if (ae && (_ === S || _ === M)) return; if (ae || N >= 1 || G <= 0) { const Ue = a - _, je = f + (r - f) * Math.min((S - _) / Ue, (M - _) / Ue); q = Math.floor(Math.min(je, x) / this._granularityCellSize) + 1, H = Math.ceil(Math.max(je, x) / this._granularityCellSize) - 1, ne = x < je } const Ie = C > 0 ? M : S; if (ne) for (let Ue = q; Ue <= H; Ue++)e.push(this._vertexToIndex(Ue * this._granularityCellSize, Ie)); else for (let Ue = H; Ue >= q; Ue--)e.push(this._vertexToIndex(Ue * this._granularityCellSize, Ie)) } _generateOutline(e) { const r = []; for (const a of e) { const u = _l(a, this._granularity, !0), p = this._pointArrayToIndices(u), f = []; for (let _ = 1; _ < p.length; _++)f.push(p[_ - 1]), f.push(p[_]); r.push(f) } return r } _handlePoles(e) { let r = !1, a = !1; this._canonical && (this._canonical.y === 0 && (r = !0), this._canonical.y === (1 << this._canonical.z) - 1 && (a = !0)), (r || a) && this._fillPoles(e, r, a) } _ensureNoPoleVertices() { const e = this._vertexBuffer; for (let r = 0; r < e.length; r += 2) { const a = e[r + 1]; a === Fu && (e[r + 1] = -32767), a === Ih && (e[r + 1] = 32766) } } _generatePoleQuad(e, r, a, u, p, f) { u > p != (f === Fu) ? (e.push(r), e.push(a), e.push(this._vertexToIndex(u, f)), e.push(a), e.push(this._vertexToIndex(p, f)), e.push(this._vertexToIndex(u, f))) : (e.push(a), e.push(r), e.push(this._vertexToIndex(u, f)), e.push(this._vertexToIndex(p, f)), e.push(a), e.push(this._vertexToIndex(u, f))) } _fillPoles(e, r, a) { const u = this._vertexBuffer, p = Se, f = e.length; for (let _ = 2; _ < f; _ += 3) { const x = e[_ - 2], S = e[_ - 1], M = e[_], C = u[2 * x], k = u[2 * x + 1], D = u[2 * S], L = u[2 * S + 1], F = u[2 * M], N = u[2 * M + 1]; r && (k === 0 && L === 0 && this._generatePoleQuad(e, x, S, C, D, Fu), L === 0 && N === 0 && this._generatePoleQuad(e, S, M, D, F, Fu), N === 0 && k === 0 && this._generatePoleQuad(e, M, x, F, C, Fu)), a && (k === p && L === p && this._generatePoleQuad(e, x, S, C, D, Ih), L === p && N === p && this._generatePoleQuad(e, S, M, D, F, Ih), N === p && k === p && this._generatePoleQuad(e, M, x, F, C, Ih)) } } _initializeVertices(e) { for (let r = 0; r < e.length; r += 2)this._vertexToIndex(e[r], e[r + 1]) } subdividePolygonInternal(e, r) { if (this._used) throw new Error("Subdivision: multiple use not allowed."); this._used = !0; const { flattened: a, holeIndices: u } = function (_) { const x = [], S = []; for (const M of _) if (M.length !== 0) { M !== _[0] && x.push(S.length / 2); for (let C = 0; C < M.length; C++)S.push(M[C].x), S.push(M[C].y) } return { flattened: S, holeIndices: x } }(e); let p; this._initializeVertices(a); try { const _ = function (S, M, C = 2) { const k = M && M.length, D = k ? M[0] * C : S.length; let L = ev(S, 0, D, C, !0); const F = []; if (!L || L.next === L.prev) return F; let N, G, ee; if (k && (L = function (q, H, ne, ae) { const Ie = []; for (let Ue = 0, je = H.length; Ue < je; Ue++) { const Ze = ev(q, H[Ue] * ae, Ue < je - 1 ? H[Ue + 1] * ae : q.length, ae, !1); Ze === Ze.next && (Ze.steiner = !0), Ie.push(MT(Ze)) } Ie.sort(ST); for (let Ue = 0; Ue < Ie.length; Ue++)ne = ET(Ie[Ue], ne); return ne }(S, M, L, C)), S.length > 80 * C) { N = S[0], G = S[1]; let q = N, H = G; for (let ne = C; ne < D; ne += C) { const ae = S[ne], Ie = S[ne + 1]; ae < N && (N = ae), Ie < G && (G = Ie), ae > q && (q = ae), Ie > H && (H = Ie) } ee = Math.max(q - N, H - G), ee = ee !== 0 ? 32767 / ee : 0 } return Sh(L, F, C, N, G, ee, 0), F }(a, u), x = this._convertIndices(a, _); p = this._subdivideTrianglesScanline(x) } catch (_) { console.error(_) } let f = []; return r && (f = this._generateOutline(e)), this._ensureNoPoleVertices(), this._handlePoles(p), { verticesFlattened: this._vertexBuffer, indicesTriangles: p, indicesLineList: f } } _convertIndices(e, r) { const a = []; for (let u = 0; u < r.length; u++)a.push(this._vertexToIndex(e[2 * r[u]], e[2 * r[u] + 1])); return a } _pointArrayToIndices(e) { const r = []; for (let a = 0; a < e.length; a++) { const u = e[a]; r.push(this._vertexToIndex(u.x, u.y)) } return r } } function sv(n, e, r, a = !0) { return new CT(r, e).subdividePolygonInternal(n, a) } function _l(n, e, r = !1) { if (!n || n.length < 1) return []; if (n.length < 2) return []; const a = n[0], u = n[n.length - 1], p = r && (a.x !== u.x || a.y !== u.y); if (e < 2) return p ? [...n, n[0]] : [...n]; const f = Math.floor(Se / e), _ = []; _.push(new B(n[0].x, n[0].y)); const x = n.length, S = p ? x : x - 1; for (let M = 0; M < S; M++) { const C = n[M], k = M < x - 1 ? n[M + 1] : n[0], D = C.x, L = C.y, F = k.x, N = k.y, G = D !== F, ee = L !== N; if (!G && !ee) continue; const q = F - D, H = N - L, ne = Math.abs(q), ae = Math.abs(H); let Ie = D, Ue = L; for (; ;) { const Ze = q > 0 ? (Math.floor(Ie / f) + 1) * f : (Math.ceil(Ie / f) - 1) * f, nt = H > 0 ? (Math.floor(Ue / f) + 1) * f : (Math.ceil(Ue / f) - 1) * f, He = Math.abs(Ie - Ze), Ve = Math.abs(Ue - nt), Fe = Math.abs(Ie - F), dt = Math.abs(Ue - N), ut = G ? He / ne : Number.POSITIVE_INFINITY, gt = ee ? Ve / ae : Number.POSITIVE_INFINITY; if ((Fe <= He || !G) && (dt <= Ve || !ee)) break; if (ut < gt && G || !ee) { Ie = Ze, Ue += H * ut; const ot = new B(Ie, Math.round(Ue)); _[_.length - 1].x === ot.x && _[_.length - 1].y === ot.y || _.push(ot) } else { Ie += q * gt, Ue = nt; const ot = new B(Math.round(Ie), Ue); _[_.length - 1].x === ot.x && _[_.length - 1].y === ot.y || _.push(ot) } } const je = new B(F, N); _[_.length - 1].x === je.x && _[_.length - 1].y === je.y || _.push(je) } return _ } function AT(n, e, r) { if (e.length === 0) throw new Error("Subdivision vertex ring is empty."); let a = 0, u = n[2 * e[0]]; for (let x = 1; x < e.length; x++) { const S = n[2 * e[x]]; S < u && (u = S, a = x) } const p = e.length; let f = a, _ = (f + 1) % p; for (; ;) { const x = f - 1 >= 0 ? f - 1 : p - 1, S = (_ + 1) % p, M = n[2 * e[x]], C = n[2 * e[S]], k = n[2 * e[f]], D = n[2 * e[f] + 1], L = n[2 * e[_] + 1]; let F = !1; if (M < C) F = !0; else if (M > C) F = !1; else { const N = L - D, G = -(n[2 * e[_]] - k), ee = D < L ? 1 : -1; ((M - k) * N + (n[2 * e[x] + 1] - D) * G) * ee > ((C - k) * N + (n[2 * e[S] + 1] - D) * G) * ee && (F = !0) } if (F) { const N = e[x], G = e[f], ee = e[_]; N !== G && N !== ee && G !== ee && r.push(ee, G, N), f--, f < 0 && (f = p - 1) } else { const N = e[S], G = e[f], ee = e[_]; N !== G && N !== ee && G !== ee && r.push(ee, G, N), _++, _ >= p && (_ = 0) } if (x === S) break } } function ov(n, e, r, a, u, p, f, _, x) { const S = u.length / 2, M = f && _ && x; if (S < it.MAX_VERTEX_ARRAY_LENGTH) { const C = e.prepareSegment(S, r, a), k = C.vertexLength; for (let F = 0; F < p.length; F += 3)a.emplaceBack(k + p[F], k + p[F + 1], k + p[F + 2]); let D, L; C.vertexLength += S, C.primitiveLength += p.length / 3, M && (L = f.prepareSegment(S, r, _), D = L.vertexLength, L.vertexLength += S); for (let F = 0; F < u.length; F += 2)n(u[F], u[F + 1]); if (M) for (let F = 0; F < x.length; F++) { const N = x[F]; for (let G = 1; G < N.length; G += 2)_.emplaceBack(D + N[G - 1], D + N[G]); L.primitiveLength += N.length / 2 } } else (function (C, k, D, L, F, N) { const G = []; for (let ae = 0; ae < L.length / 2; ae++)G.push(-1); const ee = { count: 0 }; let q = 0, H = C.getOrCreateLatestSegment(k, D), ne = H.vertexLength; for (let ae = 2; ae < F.length; ae += 3) { const Ie = F[ae - 2], Ue = F[ae - 1], je = F[ae]; let Ze = G[Ie] < q, nt = G[Ue] < q, He = G[je] < q; H.vertexLength + ((Ze ? 1 : 0) + (nt ? 1 : 0) + (He ? 1 : 0)) > it.MAX_VERTEX_ARRAY_LENGTH && (H = C.createNewSegment(k, D), q = ee.count, Ze = !0, nt = !0, He = !0, ne = 0); const Ve = Ch(G, L, N, ee, Ie, Ze, H), Fe = Ch(G, L, N, ee, Ue, nt, H), dt = Ch(G, L, N, ee, je, He, H); D.emplaceBack(ne + Ve - q, ne + Fe - q, ne + dt - q), H.primitiveLength++ } })(e, r, a, u, p, n), M && function (C, k, D, L, F, N) { const G = []; for (let ae = 0; ae < L.length / 2; ae++)G.push(-1); const ee = { count: 0 }; let q = 0, H = C.getOrCreateLatestSegment(k, D), ne = H.vertexLength; for (let ae = 0; ae < F.length; ae++) { const Ie = F[ae]; for (let Ue = 1; Ue < F[ae].length; Ue += 2) { const je = Ie[Ue - 1], Ze = Ie[Ue]; let nt = G[je] < q, He = G[Ze] < q; H.vertexLength + ((nt ? 1 : 0) + (He ? 1 : 0)) > it.MAX_VERTEX_ARRAY_LENGTH && (H = C.createNewSegment(k, D), q = ee.count, nt = !0, He = !0, ne = 0); const Ve = Ch(G, L, N, ee, je, nt, H), Fe = Ch(G, L, N, ee, Ze, He, H); D.emplaceBack(ne + Ve - q, ne + Fe - q), H.primitiveLength++ } } }(f, r, _, u, x, n), e.forceNewSegmentOnNextPrepare(), f == null || f.forceNewSegmentOnNextPrepare() } function Ch(n, e, r, a, u, p, f) { if (p) { const _ = a.count; return r(e[2 * u], e[2 * u + 1]), n[u] = a.count, a.count++, f.vertexLength++, _ } return n[u] } class yg { constructor(e) { this.zoom = e.zoom, this.overscaling = e.overscaling, this.layers = e.layers, this.layerIds = this.layers.map(r => r.id), this.index = e.index, this.hasDependencies = !1, this.patternFeatures = [], this.layoutVertexArray = new Y, this.indexArray = new Re, this.indexArray2 = new Je, this.programConfigurations = new lo(e.layers, e.zoom), this.segments = new it, this.segments2 = new it, this.stateDependentLayerIds = this.layers.filter(r => r.isStateDependent()).map(r => r.id) } populate(e, r, a) { this.hasDependencies = Gp("fill", this.layers, r); const u = this.layers[0].layout.get("fill-sort-key"), p = !u.isConstant(), f = []; for (const { feature: _, id: x, index: S, sourceLayerIndex: M } of e) { const C = this.layers[0]._featureFilter.needGeometry, k = Ds(_, C); if (!this.layers[0]._featureFilter.filter(new rr(this.zoom), k, a)) continue; const D = p ? u.evaluate(k, {}, a, r.availableImages) : void 0, L = { id: x, properties: _.properties, type: _.type, sourceLayerIndex: M, index: S, geometry: C ? k.geometry : ks(_), patterns: {}, sortKey: D }; f.push(L) } p && f.sort((_, x) => _.sortKey - x.sortKey); for (const _ of f) { const { geometry: x, index: S, sourceLayerIndex: M } = _; if (this.hasDependencies) { const C = mg("fill", this.layers, _, { zoom: this.zoom }, r); this.patternFeatures.push(C) } else this.addFeature(_, x, S, a, {}, r.subdivisionGranularity); r.featureIndex.insert(e[S].feature, x, S, M, this.index) } } update(e, r, a) { this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(e, r, this.stateDependentLayers, { imagePositions: a }) } addFeatures(e, r, a) { for (const u of this.patternFeatures) this.addFeature(u, u.geometry, u.index, r, a, e.subdivisionGranularity) } isEmpty() { return this.layoutVertexArray.length === 0 } uploadPending() { return !this.uploaded || this.programConfigurations.needsUpload } upload(e) { this.uploaded || (this.layoutVertexBuffer = e.createVertexBuffer(this.layoutVertexArray, vT), this.indexBuffer = e.createIndexBuffer(this.indexArray), this.indexBuffer2 = e.createIndexBuffer(this.indexArray2)), this.programConfigurations.upload(e), this.uploaded = !0 } destroy() { this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.indexBuffer2.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.segments2.destroy()) } addFeature(e, r, a, u, p, f) { for (const _ of Jl(r, 500)) { const x = sv(_, u, f.fill.getGranularityForZoomLevel(u.z)), S = this.layoutVertexArray; ov((M, C) => { S.emplaceBack(M, C) }, this.segments, this.layoutVertexArray, this.indexArray, x.verticesFlattened, x.indicesTriangles, this.segments2, this.indexArray2, x.indicesLineList) } this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, e, a, { imagePositions: p, canonical: u }) } } let av, lv; pt("FillBucket", yg, { omit: ["layers", "patternFeatures"] }); var kT = { get paint() { return lv = lv || new Ln({ "fill-antialias": new vt(De.paint_fill["fill-antialias"]), "fill-opacity": new bt(De.paint_fill["fill-opacity"]), "fill-color": new bt(De.paint_fill["fill-color"]), "fill-outline-color": new bt(De.paint_fill["fill-outline-color"]), "fill-translate": new vt(De.paint_fill["fill-translate"]), "fill-translate-anchor": new vt(De.paint_fill["fill-translate-anchor"]), "fill-pattern": new ll(De.paint_fill["fill-pattern"]) }) }, get layout() { return av = av || new Ln({ "fill-sort-key": new bt(De.layout_fill["fill-sort-key"]) }) } }; class DT extends ci { constructor(e, r) { super(e, kT, r) } recalculate(e, r) { super.recalculate(e, r); const a = this.paint._values["fill-outline-color"]; a.value.kind === "constant" && a.value.value === void 0 && (this.paint._values["fill-outline-color"] = this.paint._values["fill-color"]) } createBucket(e) { return new yg(e) } queryRadius() { return Vp(this.paint.get("fill-translate")) } queryIntersectsFeature({ queryGeometry: e, geometry: r, transform: a, pixelsToTileUnits: u }) { return j0(Up(e, this.paint.get("fill-translate"), this.paint.get("fill-translate-anchor"), -a.bearingInRadians, u), r) } isTileClipped() { return !0 } } const zT = Br([{ name: "a_pos", components: 2, type: "Int16" }, { name: "a_normal_ed", components: 4, type: "Int16" }], 4), RT = Br([{ name: "a_centroid", components: 2, type: "Int16" }], 4), { members: LT } = zT; class Ah { constructor(e, r, a, u, p) { this.properties = {}, this.extent = a, this.type = 0, this.id = void 0, this._pbf = e, this._geometry = -1, this._keys = u, this._values = p, e.readFields(FT, this, r) } loadGeometry() { const e = this._pbf; e.pos = this._geometry; const r = e.readVarint() + e.pos, a = []; let u, p = 1, f = 0, _ = 0, x = 0; for (; e.pos < r;) { if (f <= 0) { const S = e.readVarint(); p = 7 & S, f = S >> 3 } if (f--, p === 1 || p === 2) _ += e.readSVarint(), x += e.readSVarint(), p === 1 && (u && a.push(u), u = []), u && u.push(new B(_, x)); else { if (p !== 7) throw new Error(`unknown command ${p}`); u && u.push(u[0].clone()) } } return u && a.push(u), a } bbox() { const e = this._pbf; e.pos = this._geometry; const r = e.readVarint() + e.pos; let a = 1, u = 0, p = 0, f = 0, _ = 1 / 0, x = -1 / 0, S = 1 / 0, M = -1 / 0; for (; e.pos < r;) { if (u <= 0) { const C = e.readVarint(); a = 7 & C, u = C >> 3 } if (u--, a === 1 || a === 2) p += e.readSVarint(), f += e.readSVarint(), p < _ && (_ = p), p > x && (x = p), f < S && (S = f), f > M && (M = f); else if (a !== 7) throw new Error(`unknown command ${a}`) } return [_, S, x, M] } toGeoJSON(e, r, a) { const u = this.extent * Math.pow(2, a), p = this.extent * e, f = this.extent * r, _ = this.loadGeometry(); function x(k) { return [360 * (k.x + p) / u - 180, 360 / Math.PI * Math.atan(Math.exp((1 - 2 * (k.y + f) / u) * Math.PI)) - 90] } function S(k) { return k.map(x) } let M; if (this.type === 1) { const k = []; for (const L of _) k.push(L[0]); const D = S(k); M = k.length === 1 ? { type: "Point", coordinates: D[0] } : { type: "MultiPoint", coordinates: D } } else if (this.type === 2) { const k = _.map(S); M = k.length === 1 ? { type: "LineString", coordinates: k[0] } : { type: "MultiLineString", coordinates: k } } else { if (this.type !== 3) throw new Error("unknown feature type"); { const k = uv(_), D = []; for (const L of k) D.push(L.map(S)); M = D.length === 1 ? { type: "Polygon", coordinates: D[0] } : { type: "MultiPolygon", coordinates: D } } } const C = { type: "Feature", geometry: M, properties: this.properties }; return this.id != null && (C.id = this.id), C } } function FT(n, e, r) { n === 1 ? e.id = r.readVarint() : n === 2 ? function (a, u) { const p = a.readVarint() + a.pos; for (; a.pos < p;) { const f = u._keys[a.readVarint()], _ = u._values[a.readVarint()]; u.properties[f] = _ } }(r, e) : n === 3 ? e.type = r.readVarint() : n === 4 && (e._geometry = r.pos) } function uv(n) { const e = n.length; if (e <= 1) return [n]; const r = []; let a, u; for (let p = 0; p < e; p++) { const f = BT(n[p]); f !== 0 && (u === void 0 && (u = f < 0), u === f < 0 ? (a && r.push(a), a = [n[p]]) : a && a.push(n[p])) } return a && r.push(a), r } function BT(n) { let e = 0; for (let r, a, u = 0, p = n.length, f = p - 1; u < p; f = u++)r = n[u], a = n[f], e += (a.x - r.x) * (r.y + a.y); return e } Ah.types = ["Unknown", "Point", "LineString", "Polygon"]; class OT { constructor(e, r) { this.version = 1, this.name = "", this.extent = 4096, this.length = 0, this._pbf = e, this._keys = [], this._values = [], this._features = [], e.readFields(NT, this, r), this.length = this._features.length } feature(e) { if (e < 0 || e >= this._features.length) throw new Error("feature index out of bounds"); this._pbf.pos = this._features[e]; const r = this._pbf.readVarint() + this._pbf.pos; return new Ah(this._pbf, r, this.extent, this._keys, this._values) } } function NT(n, e, r) { n === 15 ? e.version = r.readVarint() : n === 1 ? e.name = r.readString() : n === 5 ? e.extent = r.readVarint() : n === 2 ? e._features.push(r.pos) : n === 3 ? e._keys.push(r.readString()) : n === 4 && e._values.push(function (a) { let u = null; const p = a.readVarint() + a.pos; for (; a.pos < p;) { const f = a.readVarint() >> 3; u = f === 1 ? a.readString() : f === 2 ? a.readFloat() : f === 3 ? a.readDouble() : f === 4 ? a.readVarint64() : f === 5 ? a.readVarint() : f === 6 ? a.readSVarint() : f === 7 ? a.readBoolean() : null } if (u == null) throw new Error("unknown feature value"); return u }(r)) } class cv { constructor(e, r) { this.layers = e.readFields(jT, {}, r) } } function jT(n, e, r) { if (n === 3) { const a = new OT(r, r.readVarint() + r.pos); a.length && (e[a.name] = a) } } const vg = Math.pow(2, 13); function kh(n, e, r, a, u, p, f, _) { n.emplaceBack(e, r, 2 * Math.floor(a * vg) + f, u * vg * 2, p * vg * 2, Math.round(_)) } class xg { constructor(e) { this.zoom = e.zoom, this.overscaling = e.overscaling, this.layers = e.layers, this.layerIds = this.layers.map(r => r.id), this.index = e.index, this.hasDependencies = !1, this.layoutVertexArray = new te, this.centroidVertexArray = new X, this.indexArray = new Re, this.programConfigurations = new lo(e.layers, e.zoom), this.segments = new it, this.stateDependentLayerIds = this.layers.filter(r => r.isStateDependent()).map(r => r.id) } populate(e, r, a) { this.features = [], this.hasDependencies = Gp("fill-extrusion", this.layers, r); for (const { feature: u, id: p, index: f, sourceLayerIndex: _ } of e) { const x = this.layers[0]._featureFilter.needGeometry, S = Ds(u, x); if (!this.layers[0]._featureFilter.filter(new rr(this.zoom), S, a)) continue; const M = { id: p, sourceLayerIndex: _, index: f, geometry: x ? S.geometry : ks(u), properties: u.properties, type: u.type, patterns: {} }; this.hasDependencies ? this.features.push(mg("fill-extrusion", this.layers, M, { zoom: this.zoom }, r)) : this.addFeature(M, M.geometry, f, a, {}, r.subdivisionGranularity), r.featureIndex.insert(u, M.geometry, f, _, this.index, !0) } } addFeatures(e, r, a) { for (const u of this.features) { const { geometry: p } = u; this.addFeature(u, p, u.index, r, a, e.subdivisionGranularity) } } update(e, r, a) { this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(e, r, this.stateDependentLayers, { imagePositions: a }) } isEmpty() { return this.layoutVertexArray.length === 0 && this.centroidVertexArray.length === 0 } uploadPending() { return !this.uploaded || this.programConfigurations.needsUpload } upload(e) { this.uploaded || (this.layoutVertexBuffer = e.createVertexBuffer(this.layoutVertexArray, LT), this.centroidVertexBuffer = e.createVertexBuffer(this.centroidVertexArray, RT.members, !0), this.indexBuffer = e.createIndexBuffer(this.indexArray)), this.programConfigurations.upload(e), this.uploaded = !0 } destroy() { this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.centroidVertexBuffer.destroy()) } addFeature(e, r, a, u, p, f) { for (const _ of Jl(r, 500)) { const x = { x: 0, y: 0, sampleCount: 0 }, S = this.layoutVertexArray.length; this.processPolygon(x, u, e, _, f); const M = this.layoutVertexArray.length - S, C = Math.floor(x.x / x.sampleCount), k = Math.floor(x.y / x.sampleCount); for (let D = 0; D < M; D++)this.centroidVertexArray.emplaceBack(C, k) } this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, e, a, { imagePositions: p, canonical: u }) } processPolygon(e, r, a, u, p) { if (u.length < 1 || hv(u[0])) return; for (const C of u) C.length !== 0 && VT(e, C); const f = { segment: this.segments.prepareSegment(4, this.layoutVertexArray, this.indexArray) }, _ = p.fill.getGranularityForZoomLevel(r.z), x = Ah.types[a.type] === "Polygon"; for (const C of u) { if (C.length === 0 || hv(C)) continue; const k = _l(C, _, x); this._generateSideFaces(k, f) } if (!x) return; const S = sv(u, r, _, !1), M = this.layoutVertexArray; ov((C, k) => { kh(M, C, k, 0, 0, 1, 1, 0) }, this.segments, this.layoutVertexArray, this.indexArray, S.verticesFlattened, S.indicesTriangles) } _generateSideFaces(e, r) { let a = 0; for (let u = 1; u < e.length; u++) { const p = e[u], f = e[u - 1]; if (UT(p, f)) continue; r.segment.vertexLength + 4 > it.MAX_VERTEX_ARRAY_LENGTH && (r.segment = this.segments.prepareSegment(4, this.layoutVertexArray, this.indexArray)); const _ = p.sub(f)._perp()._unit(), x = f.dist(p); a + x > 32768 && (a = 0), kh(this.layoutVertexArray, p.x, p.y, _.x, _.y, 0, 0, a), kh(this.layoutVertexArray, p.x, p.y, _.x, _.y, 0, 1, a), a += x, kh(this.layoutVertexArray, f.x, f.y, _.x, _.y, 0, 0, a), kh(this.layoutVertexArray, f.x, f.y, _.x, _.y, 0, 1, a); const S = r.segment.vertexLength; this.indexArray.emplaceBack(S, S + 2, S + 1), this.indexArray.emplaceBack(S + 1, S + 2, S + 3), r.segment.vertexLength += 4, r.segment.primitiveLength += 2 } } } function VT(n, e) { for (let r = 0; r < e.length; r++) { const a = e[r]; r === e.length - 1 && e[0].x === a.x && e[0].y === a.y || (n.x += a.x, n.y += a.y, n.sampleCount++) } } function UT(n, e) { return n.x === e.x && (n.x < 0 || n.x > Se) || n.y === e.y && (n.y < 0 || n.y > Se) } function hv(n) { return n.every(e => e.x < 0) || n.every(e => e.x > Se) || n.every(e => e.y < 0) || n.every(e => e.y > Se) } let dv; pt("FillExtrusionBucket", xg, { omit: ["layers", "features"] }); var GT = { get paint() { return dv = dv || new Ln({ "fill-extrusion-opacity": new vt(De["paint_fill-extrusion"]["fill-extrusion-opacity"]), "fill-extrusion-color": new bt(De["paint_fill-extrusion"]["fill-extrusion-color"]), "fill-extrusion-translate": new vt(De["paint_fill-extrusion"]["fill-extrusion-translate"]), "fill-extrusion-translate-anchor": new vt(De["paint_fill-extrusion"]["fill-extrusion-translate-anchor"]), "fill-extrusion-pattern": new ll(De["paint_fill-extrusion"]["fill-extrusion-pattern"]), "fill-extrusion-height": new bt(De["paint_fill-extrusion"]["fill-extrusion-height"]), "fill-extrusion-base": new bt(De["paint_fill-extrusion"]["fill-extrusion-base"]), "fill-extrusion-vertical-gradient": new vt(De["paint_fill-extrusion"]["fill-extrusion-vertical-gradient"]) }) } }; class $T extends ci { constructor(e, r) { super(e, GT, r) } createBucket(e) { return new xg(e) } queryRadius() { return Vp(this.paint.get("fill-extrusion-translate")) } is3D() { return !0 } queryIntersectsFeature({ queryGeometry: e, feature: r, featureState: a, geometry: u, transform: p, pixelsToTileUnits: f, pixelPosMatrix: _ }) { const x = Up(e, this.paint.get("fill-extrusion-translate"), this.paint.get("fill-extrusion-translate-anchor"), -p.bearingInRadians, f), S = this.paint.get("fill-extrusion-height").evaluate(r, a), M = this.paint.get("fill-extrusion-base").evaluate(r, a), C = function (D, L) { const F = []; for (const N of D) { const G = [N.x, N.y, 0, 1]; Ne(G, G, L), F.push(new B(G[0] / G[3], G[1] / G[3])) } return F }(x, _), k = function (D, L, F, N) { const G = [], ee = [], q = N[8] * L, H = N[9] * L, ne = N[10] * L, ae = N[11] * L, Ie = N[8] * F, Ue = N[9] * F, je = N[10] * F, Ze = N[11] * F; for (const nt of D) { const He = [], Ve = []; for (const Fe of nt) { const dt = Fe.x, ut = Fe.y, gt = N[0] * dt + N[4] * ut + N[12], ot = N[1] * dt + N[5] * ut + N[13], xt = N[2] * dt + N[6] * ut + N[14], Vt = N[3] * dt + N[7] * ut + N[15], Ft = xt + ne, xr = Vt + ae, Tn = gt + Ie, Yr = ot + Ue, wr = xt + je, mr = Vt + Ze, Xt = new B((gt + q) / xr, (ot + H) / xr); Xt.z = Ft / xr, He.push(Xt); const kr = new B(Tn / mr, Yr / mr); kr.z = wr / mr, Ve.push(kr) } G.push(He), ee.push(Ve) } return [G, ee] }(u, M, S, _); return function (D, L, F) { let N = 1 / 0; j0(F, L) && (N = pv(F, L[0])); for (let G = 0; G < L.length; G++) { const ee = L[G], q = D[G]; for (let H = 0; H < ee.length - 1; H++) { const ne = ee[H], ae = [ne, ee[H + 1], q[H + 1], q[H], ne]; ku(F, ae) && (N = Math.min(N, pv(F, ae))) } } return N !== 1 / 0 && N }(k[0], k[1], C) } } function Dh(n, e) { return n.x * e.x + n.y * e.y } function pv(n, e) { if (n.length === 1) { let r = 0; const a = e[r++]; let u; for (; !u || a.equals(u);)if (u = e[r++], !u) return 1 / 0; for (; r < e.length; r++) { const p = e[r], f = n[0], _ = u.sub(a), x = p.sub(a), S = f.sub(a), M = Dh(_, _), C = Dh(_, x), k = Dh(x, x), D = Dh(S, _), L = Dh(S, x), F = M * k - C * C, N = (k * D - C * L) / F, G = (M * L - C * D) / F, ee = a.z * (1 - N - G) + u.z * N + p.z * G; if (isFinite(ee)) return ee } return 1 / 0 } { let r = 1 / 0; for (const a of e) r = Math.min(r, a.z); return r } } const qT = Br([{ name: "a_pos_normal", components: 2, type: "Int16" }, { name: "a_data", components: 4, type: "Uint8" }], 4), { members: ZT } = qT, WT = Br([{ name: "a_uv_x", components: 1, type: "Float32" }, { name: "a_split_index", components: 1, type: "Float32" }]), { members: HT } = WT, XT = Math.cos(Math.PI / 180 * 37.5), fv = Math.pow(2, 14) / .5; class wg { constructor(e) { this.zoom = e.zoom, this.overscaling = e.overscaling, this.layers = e.layers, this.layerIds = this.layers.map(r => r.id), this.index = e.index, this.hasDependencies = !1, this.patternFeatures = [], this.lineClipsArray = [], this.gradients = {}, this.layers.forEach(r => { this.gradients[r.id] = {} }), this.layoutVertexArray = new le, this.layoutVertexArray2 = new J, this.indexArray = new Re, this.programConfigurations = new lo(e.layers, e.zoom), this.segments = new it, this.maxLineLength = 0, this.stateDependentLayerIds = this.layers.filter(r => r.isStateDependent()).map(r => r.id) } populate(e, r, a) { this.hasDependencies = Gp("line", this.layers, r) || this.hasLineDasharray(this.layers); const u = this.layers[0].layout.get("line-sort-key"), p = !u.isConstant(), f = []; for (const { feature: _, id: x, index: S, sourceLayerIndex: M } of e) { const C = this.layers[0]._featureFilter.needGeometry, k = Ds(_, C); if (!this.layers[0]._featureFilter.filter(new rr(this.zoom), k, a)) continue; const D = p ? u.evaluate(k, {}, a) : void 0, L = { id: x, properties: _.properties, type: _.type, sourceLayerIndex: M, index: S, geometry: C ? k.geometry : ks(_), patterns: {}, dashes: {}, sortKey: D }; f.push(L) } p && f.sort((_, x) => _.sortKey - x.sortKey); for (const _ of f) { const { geometry: x, index: S, sourceLayerIndex: M } = _; this.hasDependencies ? (Gp("line", this.layers, r) ? mg("line", this.layers, _, { zoom: this.zoom }, r) : this.hasLineDasharray(this.layers) && this.addLineDashDependencies(this.layers, _, this.zoom, r), this.patternFeatures.push(_)) : this.addFeature(_, x, S, a, {}, {}, r.subdivisionGranularity), r.featureIndex.insert(e[S].feature, x, S, M, this.index) } } update(e, r, a, u) { this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(e, r, this.stateDependentLayers, { imagePositions: a, dashPositions: u }) } addFeatures(e, r, a, u) { for (const p of this.patternFeatures) this.addFeature(p, p.geometry, p.index, r, a, u, e.subdivisionGranularity) } isEmpty() { return this.layoutVertexArray.length === 0 } uploadPending() { return !this.uploaded || this.programConfigurations.needsUpload } upload(e) { this.uploaded || (this.layoutVertexArray2.length !== 0 && (this.layoutVertexBuffer2 = e.createVertexBuffer(this.layoutVertexArray2, HT)), this.layoutVertexBuffer = e.createVertexBuffer(this.layoutVertexArray, ZT), this.indexBuffer = e.createIndexBuffer(this.indexArray)), this.programConfigurations.upload(e), this.uploaded = !0 } destroy() { this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy()) } lineFeatureClips(e) { if (e.properties && Object.prototype.hasOwnProperty.call(e.properties, "mapbox_clip_start") && Object.prototype.hasOwnProperty.call(e.properties, "mapbox_clip_end")) return { start: +e.properties.mapbox_clip_start, end: +e.properties.mapbox_clip_end } } addFeature(e, r, a, u, p, f, _) { const x = this.layers[0].layout, S = x.get("line-join").evaluate(e, {}), M = x.get("line-cap"), C = x.get("line-miter-limit"), k = x.get("line-round-limit"); this.lineClips = this.lineFeatureClips(e); for (const D of r) this.addLine(D, e, S, M, C, k, u, _); this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, e, a, { imagePositions: p, dashPositions: f, canonical: u }) } addLine(e, r, a, u, p, f, _, x) { if (this.distance = 0, this.scaledDistance = 0, this.totalDistance = 0, e = _l(e, _ ? x.line.getGranularityForZoomLevel(_.z) : 1), this.lineClips) { this.lineClipsArray.push(this.lineClips); for (let q = 0; q < e.length - 1; q++)this.totalDistance += e[q].dist(e[q + 1]); this.updateScaledDistance(), this.maxLineLength = Math.max(this.maxLineLength, this.totalDistance) } const S = Ah.types[r.type] === "Polygon"; let M = e.length; for (; M >= 2 && e[M - 1].equals(e[M - 2]);)M--; let C = 0; for (; C < M - 1 && e[C].equals(e[C + 1]);)C++; if (M < (S ? 3 : 2)) return; a === "bevel" && (p = 1.05); const k = this.overscaling <= 16 ? 122880 / (512 * this.overscaling) : 0, D = this.segments.prepareSegment(10 * M, this.layoutVertexArray, this.indexArray); let L, F, N, G, ee; this.e1 = this.e2 = -1, S && (L = e[M - 2], ee = e[C].sub(L)._unit()._perp()); for (let q = C; q < M; q++) { if (N = q === M - 1 ? S ? e[C + 1] : void 0 : e[q + 1], N && e[q].equals(N)) continue; ee && (G = ee), L && (F = L), L = e[q], ee = N ? N.sub(L)._unit()._perp() : G, G = G || ee; let H = G.add(ee); H.x === 0 && H.y === 0 || H._unit(); const ne = G.x * ee.x + G.y * ee.y, ae = H.x * ee.x + H.y * ee.y, Ie = ae !== 0 ? 1 / ae : 1 / 0, Ue = 2 * Math.sqrt(2 - 2 * ae), je = ae < XT && F && N, Ze = G.x * ee.y - G.y * ee.x > 0; if (je && q > C) { const Ve = L.dist(F); if (Ve > 2 * k) { const Fe = L.sub(L.sub(F)._mult(k / Ve)._round()); this.updateDistance(F, Fe), this.addCurrentVertex(Fe, G, 0, 0, D), F = Fe } } const nt = F && N; let He = nt ? a : S ? "butt" : u; if (nt && He === "round" && (Ie < f ? He = "miter" : Ie <= 2 && (He = "fakeround")), He === "miter" && Ie > p && (He = "bevel"), He === "bevel" && (Ie > 2 && (He = "flipbevel"), Ie < p && (He = "miter")), F && this.updateDistance(F, L), He === "miter") H._mult(Ie), this.addCurrentVertex(L, H, 0, 0, D); else if (He === "flipbevel") { if (Ie > 100) H = ee.mult(-1); else { const Ve = Ie * G.add(ee).mag() / G.sub(ee).mag(); H._perp()._mult(Ve * (Ze ? -1 : 1)) } this.addCurrentVertex(L, H, 0, 0, D), this.addCurrentVertex(L, H.mult(-1), 0, 0, D) } else if (He === "bevel" || He === "fakeround") { const Ve = -Math.sqrt(Ie * Ie - 1), Fe = Ze ? Ve : 0, dt = Ze ? 0 : Ve; if (F && this.addCurrentVertex(L, G, Fe, dt, D), He === "fakeround") { const ut = Math.round(180 * Ue / Math.PI / 20); for (let gt = 1; gt < ut; gt++) { let ot = gt / ut; if (ot !== .5) { const Vt = ot - .5; ot += ot * Vt * (ot - 1) * ((1.0904 + ne * (ne * (3.55645 - 1.43519 * ne) - 3.2452)) * Vt * Vt + (.848013 + ne * (.215638 * ne - 1.06021))) } const xt = ee.sub(G)._mult(ot)._add(G)._unit()._mult(Ze ? -1 : 1); this.addHalfVertex(L, xt.x, xt.y, !1, Ze, 0, D) } } N && this.addCurrentVertex(L, ee, -Fe, -dt, D) } else if (He === "butt") this.addCurrentVertex(L, H, 0, 0, D); else if (He === "square") { const Ve = F ? 1 : -1; this.addCurrentVertex(L, H, Ve, Ve, D) } else He === "round" && (F && (this.addCurrentVertex(L, G, 0, 0, D), this.addCurrentVertex(L, G, 1, 1, D, !0)), N && (this.addCurrentVertex(L, ee, -1, -1, D, !0), this.addCurrentVertex(L, ee, 0, 0, D))); if (je && q < M - 1) { const Ve = L.dist(N); if (Ve > 2 * k) { const Fe = L.add(N.sub(L)._mult(k / Ve)._round()); this.updateDistance(L, Fe), this.addCurrentVertex(Fe, ee, 0, 0, D), L = Fe } } } } addCurrentVertex(e, r, a, u, p, f = !1) { const _ = r.y * u - r.x, x = -r.y - r.x * u; this.addHalfVertex(e, r.x + r.y * a, r.y - r.x * a, f, !1, a, p), this.addHalfVertex(e, _, x, f, !0, -u, p), this.distance > fv / 2 && this.totalDistance === 0 && (this.distance = 0, this.updateScaledDistance(), this.addCurrentVertex(e, r, a, u, p, f)) } addHalfVertex({ x: e, y: r }, a, u, p, f, _, x) { const S = .5 * (this.lineClips ? this.scaledDistance * (fv - 1) : this.scaledDistance); this.layoutVertexArray.emplaceBack((e << 1) + (p ? 1 : 0), (r << 1) + (f ? 1 : 0), Math.round(63 * a) + 128, Math.round(63 * u) + 128, 1 + (_ === 0 ? 0 : _ < 0 ? -1 : 1) | (63 & S) << 2, S >> 6), this.lineClips && this.layoutVertexArray2.emplaceBack((this.scaledDistance - this.lineClips.start) / (this.lineClips.end - this.lineClips.start), this.lineClipsArray.length); const M = x.vertexLength++; this.e1 >= 0 && this.e2 >= 0 && (this.indexArray.emplaceBack(this.e1, M, this.e2), x.primitiveLength++), f ? this.e2 = M : this.e1 = M } updateScaledDistance() { this.scaledDistance = this.lineClips ? this.lineClips.start + (this.lineClips.end - this.lineClips.start) * this.distance / this.totalDistance : this.distance } updateDistance(e, r) { this.distance += e.dist(r), this.updateScaledDistance() } hasLineDasharray(e) { for (const r of e) { const a = r.paint.get("line-dasharray"); if (a && !a.isConstant()) return !0 } return !1 } addLineDashDependencies(e, r, a, u) { for (const p of e) { const f = p.paint.get("line-dasharray"); if (!f || f.value.kind === "constant") continue; const _ = p.layout.get("line-cap") === "round", x = { dasharray: f.value.evaluate({ zoom: a - 1 }, r, {}), round: _ }, S = { dasharray: f.value.evaluate({ zoom: a }, r, {}), round: _ }, M = { dasharray: f.value.evaluate({ zoom: a + 1 }, r, {}), round: _ }, C = `${x.dasharray.join(",")},${x.round}`, k = `${S.dasharray.join(",")},${S.round}`, D = `${M.dasharray.join(",")},${M.round}`; u.dashDependencies[C] = x, u.dashDependencies[k] = S, u.dashDependencies[D] = M, r.dashes[p.id] = { min: C, mid: k, max: D } } } } let mv, gv; pt("LineBucket", wg, { omit: ["layers", "patternFeatures"] }); var _v = { get paint() { return gv = gv || new Ln({ "line-opacity": new bt(De.paint_line["line-opacity"]), "line-color": new bt(De.paint_line["line-color"]), "line-translate": new vt(De.paint_line["line-translate"]), "line-translate-anchor": new vt(De.paint_line["line-translate-anchor"]), "line-width": new bt(De.paint_line["line-width"]), "line-gap-width": new bt(De.paint_line["line-gap-width"]), "line-offset": new bt(De.paint_line["line-offset"]), "line-blur": new bt(De.paint_line["line-blur"]), "line-dasharray": new ll(De.paint_line["line-dasharray"]), "line-pattern": new ll(De.paint_line["line-pattern"]), "line-gradient": new Tu(De.paint_line["line-gradient"]) }) }, get layout() { return mv = mv || new Ln({ "line-cap": new vt(De.layout_line["line-cap"]), "line-join": new bt(De.layout_line["line-join"]), "line-miter-limit": new vt(De.layout_line["line-miter-limit"]), "line-round-limit": new vt(De.layout_line["line-round-limit"]), "line-sort-key": new bt(De.layout_line["line-sort-key"]) }) } }; class YT extends bt { possiblyEvaluate(e, r) { return r = new rr(Math.floor(r.zoom), { now: r.now, fadeDuration: r.fadeDuration, zoomHistory: r.zoomHistory, transition: r.transition }), super.possiblyEvaluate(e, r) } evaluate(e, r, a, u) { return r = Wr({}, r, { zoom: Math.floor(r.zoom) }), super.evaluate(e, r, a, u) } } let Wp; class KT extends ci { constructor(e, r) { super(e, _v, r), this.gradientVersion = 0, Wp || (Wp = new YT(_v.paint.properties["line-width"].specification), Wp.useIntegerZoom = !0) } _handleSpecialPaintPropertyUpdate(e) { if (e === "line-gradient") { const r = this.gradientExpression(); this.stepInterpolant = !!function (a) { return a._styleExpression !== void 0 }(r) && r._styleExpression.expression instanceof Ts, this.gradientVersion = (this.gradientVersion + 1) % Number.MAX_SAFE_INTEGER } } gradientExpression() { return this._transitionablePaint._values["line-gradient"].value.expression } recalculate(e, r) { super.recalculate(e, r), this.paint._values["line-floorwidth"] = Wp.possiblyEvaluate(this._transitioningPaint._values["line-width"].value, e) } createBucket(e) { return new wg(e) } queryRadius(e) { const r = e, a = yv(zu("line-width", this, r), zu("line-gap-width", this, r)), u = zu("line-offset", this, r); return a / 2 + Math.abs(u) + Vp(this.paint.get("line-translate")) } queryIntersectsFeature({ queryGeometry: e, feature: r, featureState: a, geometry: u, transform: p, pixelsToTileUnits: f }) { const _ = Up(e, this.paint.get("line-translate"), this.paint.get("line-translate-anchor"), -p.bearingInRadians, f), x = f / 2 * yv(this.paint.get("line-width").evaluate(r, a), this.paint.get("line-gap-width").evaluate(r, a)), S = this.paint.get("line-offset").evaluate(r, a); return S && (u = function (M, C) { const k = []; for (let D = 0; D < M.length; D++) { const L = sT(M[D]), F = []; for (let N = 0; N < L.length; N++) { const G = L[N], ee = L[N - 1], q = L[N + 1], H = N === 0 ? new B(0, 0) : G.sub(ee)._unit()._perp(), ne = N === L.length - 1 ? new B(0, 0) : q.sub(G)._unit()._perp(), ae = H._add(ne)._unit(), Ie = ae.x * ne.x + ae.y * ne.y; Ie !== 0 && ae._mult(1 / Ie), F.push(ae._mult(C)._add(G)) } k.push(F) } return k }(u, S * f)), function (M, C, k) { for (let D = 0; D < C.length; D++) { const L = C[D]; if (M.length >= 3) { for (let F = 0; F < L.length; F++)if (Du(M, L[F])) return !0 } if (rT(M, L, k)) return !0 } return !1 }(_, u, x) } isTileClipped() { return !0 } } function yv(n, e) { return e > 0 ? e + 2 * n : n } const QT = Br([{ name: "a_pos_offset", components: 4, type: "Int16" }, { name: "a_data", components: 4, type: "Uint16" }, { name: "a_pixeloffset", components: 4, type: "Int16" }], 4), JT = Br([{ name: "a_projected_pos", components: 3, type: "Float32" }], 4); Br([{ name: "a_fade_opacity", components: 1, type: "Uint32" }], 4); const eS = Br([{ name: "a_placed", components: 2, type: "Uint8" }, { name: "a_shift", components: 2, type: "Float32" }, { name: "a_box_real", components: 2, type: "Int16" }]); Br([{ type: "Int16", name: "anchorPointX" }, { type: "Int16", name: "anchorPointY" }, { type: "Int16", name: "x1" }, { type: "Int16", name: "y1" }, { type: "Int16", name: "x2" }, { type: "Int16", name: "y2" }, { type: "Uint32", name: "featureIndex" }, { type: "Uint16", name: "sourceLayerIndex" }, { type: "Uint16", name: "bucketIndex" }]); const vv = Br([{ name: "a_pos", components: 2, type: "Int16" }, { name: "a_anchor_pos", components: 2, type: "Int16" }, { name: "a_extrude", components: 2, type: "Int16" }], 4), tS = Br([{ name: "a_pos", components: 2, type: "Float32" }, { name: "a_radius", components: 1, type: "Float32" }, { name: "a_flags", components: 2, type: "Int16" }], 4); function rS(n, e, r) { return n.sections.forEach(a => { a.text = function (u, p, f) { const _ = p.layout.get("text-transform").evaluate(f, {}); return _ === "uppercase" ? u = u.toLocaleUpperCase() : _ === "lowercase" && (u = u.toLocaleLowerCase()), Is.applyArabicShaping && (u = Is.applyArabicShaping(u)), u }(a.text, e, r) }), n } Br([{ name: "triangle", components: 3, type: "Uint16" }]), Br([{ type: "Int16", name: "anchorX" }, { type: "Int16", name: "anchorY" }, { type: "Uint16", name: "glyphStartIndex" }, { type: "Uint16", name: "numGlyphs" }, { type: "Uint32", name: "vertexStartIndex" }, { type: "Uint32", name: "lineStartIndex" }, { type: "Uint32", name: "lineLength" }, { type: "Uint16", name: "segment" }, { type: "Uint16", name: "lowerSize" }, { type: "Uint16", name: "upperSize" }, { type: "Float32", name: "lineOffsetX" }, { type: "Float32", name: "lineOffsetY" }, { type: "Uint8", name: "writingMode" }, { type: "Uint8", name: "placedOrientation" }, { type: "Uint8", name: "hidden" }, { type: "Uint32", name: "crossTileID" }, { type: "Int16", name: "associatedIconIndex" }]), Br([{ type: "Int16", name: "anchorX" }, { type: "Int16", name: "anchorY" }, { type: "Int16", name: "rightJustifiedTextSymbolIndex" }, { type: "Int16", name: "centerJustifiedTextSymbolIndex" }, { type: "Int16", name: "leftJustifiedTextSymbolIndex" }, { type: "Int16", name: "verticalPlacedTextSymbolIndex" }, { type: "Int16", name: "placedIconSymbolIndex" }, { type: "Int16", name: "verticalPlacedIconSymbolIndex" }, { type: "Uint16", name: "key" }, { type: "Uint16", name: "textBoxStartIndex" }, { type: "Uint16", name: "textBoxEndIndex" }, { type: "Uint16", name: "verticalTextBoxStartIndex" }, { type: "Uint16", name: "verticalTextBoxEndIndex" }, { type: "Uint16", name: "iconBoxStartIndex" }, { type: "Uint16", name: "iconBoxEndIndex" }, { type: "Uint16", name: "verticalIconBoxStartIndex" }, { type: "Uint16", name: "verticalIconBoxEndIndex" }, { type: "Uint16", name: "featureIndex" }, { type: "Uint16", name: "numHorizontalGlyphVertices" }, { type: "Uint16", name: "numVerticalGlyphVertices" }, { type: "Uint16", name: "numIconVertices" }, { type: "Uint16", name: "numVerticalIconVertices" }, { type: "Uint16", name: "useRuntimeCollisionCircles" }, { type: "Uint32", name: "crossTileID" }, { type: "Float32", name: "textBoxScale" }, { type: "Float32", name: "collisionCircleDiameter" }, { type: "Uint16", name: "textAnchorOffsetStartIndex" }, { type: "Uint16", name: "textAnchorOffsetEndIndex" }]), Br([{ type: "Float32", name: "offsetX" }]), Br([{ type: "Int16", name: "x" }, { type: "Int16", name: "y" }, { type: "Int16", name: "tileUnitDistanceFromAnchor" }]), Br([{ type: "Uint16", name: "textAnchor" }, { type: "Float32", components: 2, name: "textOffset" }]); var on = 24; const zh = { "!": "", "#": "", $: "", "%": "", "&": "", "(": "", ")": "", "*": "", "+": "", ",": "", "-": "", ".": "", "/": "", ":": "", ";": "", "<": "", "=": "", ">": "", "?": "", "@": "", "[": "", "\\": "", "]": "", "^": "", _: "", "`": "", "{": "", "|": "", "}": "", "~": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "" }, nS = { 10: !0, 32: !0, 38: !0, 41: !0, 43: !0, 45: !0, 47: !0, 173: !0, 183: !0, 8203: !0, 8208: !0, 8211: !0, 8231: !0 }, iS = { 40: !0 }; function xv(n, e, r, a, u, p) { if ("fontStack" in e) { const f = r[e.fontStack], _ = f && f[n]; return _ ? _.metrics.advance * e.scale + u : 0 } { const f = a[e.imageName]; return f ? f.displaySize[0] * e.scale * on / p + u : 0 } } function wv(n, e, r, a) { const u = Math.pow(n - e, 2); return a ? n < e ? u / 2 : 2 * u : u + Math.abs(r) * r } function sS(n, e, r) { let a = 0; return n === 10 && (a -= 1e4), r && (a += 150), n !== 40 && n !== 65288 || (a += 50), e !== 41 && e !== 65289 || (a += 50), a } function bv(n, e, r, a, u, p) { let f = null, _ = wv(e, r, u, p); for (const x of a) { const S = wv(e - x.x, r, u, p) + x.badness; S <= _ && (f = x, _ = S) } return { index: n, x: e, priorBreak: f, badness: _ } } function Tv(n) { return n ? Tv(n.priorBreak).concat(n.index) : [] } class Bu { constructor(e = "", r = [], a = []) { this.text = e, this.sections = r, this.sectionIndex = a, this.imageSectionID = null } static fromFeature(e, r) { const a = new Bu; for (let u = 0; u < e.sections.length; u++) { const p = e.sections[u]; p.image ? a.addImageSection(p) : a.addTextSection(p, r) } return a } length() { return [...this.text].length } getSection(e) { return this.sections[this.sectionIndex[e]] } getSectionIndex(e) { return this.sectionIndex[e] } verticalizePunctuation() { this.text = function (e) { let r = "", a = { premature: !0, value: void 0 }; const u = e[Symbol.iterator](); let p = u.next(); const f = e[Symbol.iterator](); f.next(); let _ = f.next(); for (; !p.done;)r += !_.done && uh(_.value.codePointAt(0)) && !zh[_.value] || !a.premature && uh(a.value.codePointAt(0)) && !zh[a.value] || !zh[p.value] ? p.value : zh[p.value], a = { value: p.value, premature: !1 }, p = u.next(), _ = f.next(); return r }(this.text) } hasZeroWidthSpaces() { return this.text.includes("") } trim() { const e = this.text.match(/^\s*/), r = e ? e[0].length : 0, a = this.text.match(/\S\s*$/), u = a ? a[0].length - 1 : 0; this.text = this.text.substring(r, this.text.length - u), this.sectionIndex = this.sectionIndex.slice(r, this.sectionIndex.length - u) } substring(e, r) { const a = [...this.text].slice(e, r).join(""), u = this.sectionIndex.slice(e, r); return new Bu(a, this.sections, u) } toCodeUnitIndex(e) { return [...this.text].slice(0, e).join("").length } toString() { return this.text } getMaxScale() { return this.sectionIndex.reduce((e, r) => Math.max(e, this.sections[r].scale), 0) } getMaxImageSize(e) { let r = 0, a = 0; for (let u = 0; u < this.length(); u++) { const p = this.getSection(u); if ("imageName" in p) { const f = e[p.imageName]; if (!f) continue; const _ = f.displaySize; r = Math.max(r, _[0]), a = Math.max(a, _[1]) } } return { maxImageWidth: r, maxImageHeight: a } } addTextSection(e, r) { this.text += e.text, this.sections.push({ scale: e.scale || 1, verticalAlign: e.verticalAlign || "bottom", fontStack: e.fontStack || r }); const a = this.sections.length - 1; this.sectionIndex.push(...[...e.text].map(() => a)) } addImageSection(e) { const r = e.image ? e.image.name : ""; if (r.length === 0) return void qt("Can't add FormattedSection with an empty image."); const a = this.getNextImageSectionCharCode(); a ? (this.text += String.fromCharCode(a), this.sections.push({ scale: 1, verticalAlign: e.verticalAlign || "bottom", imageName: r }), this.sectionIndex.push(this.sections.length - 1)) : qt("Reached maximum number of images 6401") } getNextImageSectionCharCode() { return this.imageSectionID ? this.imageSectionID >= 63743 ? null : ++this.imageSectionID : (this.imageSectionID = 57344, this.imageSectionID) } determineLineBreaks(e, r, a, u, p) { const f = [], _ = this.determineAverageLineWidth(e, r, a, u, p), x = this.hasZeroWidthSpaces(); let S = 0, M = 0; const C = this.text[Symbol.iterator](); let k = C.next(); const D = this.text[Symbol.iterator](); D.next(); let L = D.next(); const F = this.text[Symbol.iterator](); F.next(), F.next(); let N = F.next(); for (; !k.done;) { const G = this.getSection(M), ee = k.value.codePointAt(0); if (Cp(ee) || (S += xv(ee, G, a, u, e, p)), !L.done) { const q = sl(ee), H = L.value.codePointAt(0); (nS[ee] || q || "imageName" in G || !N.done && iS[H]) && f.push(bv(M + 1, S, _, f, sS(ee, H, q && x), !1)) } M++, k = C.next(), L = D.next(), N = F.next() } return Tv(bv(this.length(), S, _, f, 0, !0)) } determineAverageLineWidth(e, r, a, u, p) { let f = 0, _ = 0; for (const x of this.text) { const S = this.getSection(_); f += xv(x.codePointAt(0), S, a, u, e, p), _++ } return f / Math.max(1, Math.ceil(f / r)) } } const bg = 4294967296, Sv = 1 / bg, Ev = typeof TextDecoder > "u" ? null : new TextDecoder("utf-8"); class Hp { constructor(e = new Uint8Array(16)) { this.buf = ArrayBuffer.isView(e) ? e : new Uint8Array(e), this.dataView = new DataView(this.buf.buffer), this.pos = 0, this.type = 0, this.length = this.buf.length } readFields(e, r, a = this.length) { for (; this.pos < a;) { const u = this.readVarint(), p = u >> 3, f = this.pos; this.type = 7 & u, e(p, r, this), this.pos === f && this.skip(u) } return r } readMessage(e, r) { return this.readFields(e, r, this.readVarint() + this.pos) } readFixed32() { const e = this.dataView.getUint32(this.pos, !0); return this.pos += 4, e } readSFixed32() { const e = this.dataView.getInt32(this.pos, !0); return this.pos += 4, e } readFixed64() { const e = this.dataView.getUint32(this.pos, !0) + this.dataView.getUint32(this.pos + 4, !0) * bg; return this.pos += 8, e } readSFixed64() { const e = this.dataView.getUint32(this.pos, !0) + this.dataView.getInt32(this.pos + 4, !0) * bg; return this.pos += 8, e } readFloat() { const e = this.dataView.getFloat32(this.pos, !0); return this.pos += 4, e } readDouble() { const e = this.dataView.getFloat64(this.pos, !0); return this.pos += 8, e } readVarint(e) { const r = this.buf; let a, u; return u = r[this.pos++], a = 127 & u, u < 128 ? a : (u = r[this.pos++], a |= (127 & u) << 7, u < 128 ? a : (u = r[this.pos++], a |= (127 & u) << 14, u < 128 ? a : (u = r[this.pos++], a |= (127 & u) << 21, u < 128 ? a : (u = r[this.pos], a |= (15 & u) << 28, function (p, f, _) { const x = _.buf; let S, M; if (M = x[_.pos++], S = (112 & M) >> 4, M < 128 || (M = x[_.pos++], S |= (127 & M) << 3, M < 128) || (M = x[_.pos++], S |= (127 & M) << 10, M < 128) || (M = x[_.pos++], S |= (127 & M) << 17, M < 128) || (M = x[_.pos++], S |= (127 & M) << 24, M < 128) || (M = x[_.pos++], S |= (1 & M) << 31, M < 128)) return Ou(p, S, f); throw new Error("Expected varint not more than 10 bytes") }(a, e, this))))) } readVarint64() { return this.readVarint(!0) } readSVarint() { const e = this.readVarint(); return e % 2 == 1 ? (e + 1) / -2 : e / 2 } readBoolean() { return !!this.readVarint() } readString() { const e = this.readVarint() + this.pos, r = this.pos; return this.pos = e, e - r >= 12 && Ev ? Ev.decode(this.buf.subarray(r, e)) : function (a, u, p) { let f = "", _ = u; for (; _ < p;) { const x = a[_]; let S, M, C, k = null, D = x > 239 ? 4 : x > 223 ? 3 : x > 191 ? 2 : 1; if (_ + D > p) break; D === 1 ? x < 128 && (k = x) : D === 2 ? (S = a[_ + 1], (192 & S) == 128 && (k = (31 & x) << 6 | 63 & S, k <= 127 && (k = null))) : D === 3 ? (S = a[_ + 1], M = a[_ + 2], (192 & S) == 128 && (192 & M) == 128 && (k = (15 & x) << 12 | (63 & S) << 6 | 63 & M, (k <= 2047 || k >= 55296 && k <= 57343) && (k = null))) : D === 4 && (S = a[_ + 1], M = a[_ + 2], C = a[_ + 3], (192 & S) == 128 && (192 & M) == 128 && (192 & C) == 128 && (k = (15 & x) << 18 | (63 & S) << 12 | (63 & M) << 6 | 63 & C, (k <= 65535 || k >= 1114112) && (k = null))), k === null ? (k = 65533, D = 1) : k > 65535 && (k -= 65536, f += String.fromCharCode(k >>> 10 & 1023 | 55296), k = 56320 | 1023 & k), f += String.fromCharCode(k), _ += D } return f }(this.buf, r, e) } readBytes() { const e = this.readVarint() + this.pos, r = this.buf.subarray(this.pos, e); return this.pos = e, r } readPackedVarint(e = [], r) { const a = this.readPackedEnd(); for (; this.pos < a;)e.push(this.readVarint(r)); return e } readPackedSVarint(e = []) { const r = this.readPackedEnd(); for (; this.pos < r;)e.push(this.readSVarint()); return e } readPackedBoolean(e = []) { const r = this.readPackedEnd(); for (; this.pos < r;)e.push(this.readBoolean()); return e } readPackedFloat(e = []) { const r = this.readPackedEnd(); for (; this.pos < r;)e.push(this.readFloat()); return e } readPackedDouble(e = []) { const r = this.readPackedEnd(); for (; this.pos < r;)e.push(this.readDouble()); return e } readPackedFixed32(e = []) { const r = this.readPackedEnd(); for (; this.pos < r;)e.push(this.readFixed32()); return e } readPackedSFixed32(e = []) { const r = this.readPackedEnd(); for (; this.pos < r;)e.push(this.readSFixed32()); return e } readPackedFixed64(e = []) { const r = this.readPackedEnd(); for (; this.pos < r;)e.push(this.readFixed64()); return e } readPackedSFixed64(e = []) { const r = this.readPackedEnd(); for (; this.pos < r;)e.push(this.readSFixed64()); return e } readPackedEnd() { return this.type === 2 ? this.readVarint() + this.pos : this.pos + 1 } skip(e) { const r = 7 & e; if (r === 0) for (; this.buf[this.pos++] > 127;); else if (r === 2) this.pos = this.readVarint() + this.pos; else if (r === 5) this.pos += 4; else { if (r !== 1) throw new Error(`Unimplemented type: ${r}`); this.pos += 8 } } writeTag(e, r) { this.writeVarint(e << 3 | r) } realloc(e) { let r = this.length || 16; for (; r < this.pos + e;)r *= 2; if (r !== this.length) { const a = new Uint8Array(r); a.set(this.buf), this.buf = a, this.dataView = new DataView(a.buffer), this.length = r } } finish() { return this.length = this.pos, this.pos = 0, this.buf.subarray(0, this.length) } writeFixed32(e) { this.realloc(4), this.dataView.setInt32(this.pos, e, !0), this.pos += 4 } writeSFixed32(e) { this.realloc(4), this.dataView.setInt32(this.pos, e, !0), this.pos += 4 } writeFixed64(e) { this.realloc(8), this.dataView.setInt32(this.pos, -1 & e, !0), this.dataView.setInt32(this.pos + 4, Math.floor(e * Sv), !0), this.pos += 8 } writeSFixed64(e) { this.realloc(8), this.dataView.setInt32(this.pos, -1 & e, !0), this.dataView.setInt32(this.pos + 4, Math.floor(e * Sv), !0), this.pos += 8 } writeVarint(e) { (e = +e || 0) > 268435455 || e < 0 ? function (r, a) { let u, p; if (r >= 0 ? (u = r % 4294967296 | 0, p = r / 4294967296 | 0) : (u = ~(-r % 4294967296), p = ~(-r / 4294967296), 4294967295 ^ u ? u = u + 1 | 0 : (u = 0, p = p + 1 | 0)), r >= 18446744073709552e3 || r < -18446744073709552e3) throw new Error("Given varint doesn't fit into 10 bytes"); a.realloc(10), function (f, _, x) { x.buf[x.pos++] = 127 & f | 128, f >>>= 7, x.buf[x.pos++] = 127 & f | 128, f >>>= 7, x.buf[x.pos++] = 127 & f | 128, f >>>= 7, x.buf[x.pos++] = 127 & f | 128, x.buf[x.pos] = 127 & (f >>>= 7) }(u, 0, a), function (f, _) { const x = (7 & f) << 4; _.buf[_.pos++] |= x | ((f >>>= 3) ? 128 : 0), f && (_.buf[_.pos++] = 127 & f | ((f >>>= 7) ? 128 : 0), f && (_.buf[_.pos++] = 127 & f | ((f >>>= 7) ? 128 : 0), f && (_.buf[_.pos++] = 127 & f | ((f >>>= 7) ? 128 : 0), f && (_.buf[_.pos++] = 127 & f | ((f >>>= 7) ? 128 : 0), f && (_.buf[_.pos++] = 127 & f))))) }(p, a) }(e, this) : (this.realloc(4), this.buf[this.pos++] = 127 & e | (e > 127 ? 128 : 0), e <= 127 || (this.buf[this.pos++] = 127 & (e >>>= 7) | (e > 127 ? 128 : 0), e <= 127 || (this.buf[this.pos++] = 127 & (e >>>= 7) | (e > 127 ? 128 : 0), e <= 127 || (this.buf[this.pos++] = e >>> 7 & 127)))) } writeSVarint(e) { this.writeVarint(e < 0 ? 2 * -e - 1 : 2 * e) } writeBoolean(e) { this.writeVarint(+e) } writeString(e) { e = String(e), this.realloc(4 * e.length), this.pos++; const r = this.pos; this.pos = function (u, p, f) { for (let _, x, S = 0; S < p.length; S++) { if (_ = p.charCodeAt(S), _ > 55295 && _ < 57344) { if (!x) { _ > 56319 || S + 1 === p.length ? (u[f++] = 239, u[f++] = 191, u[f++] = 189) : x = _; continue } if (_ < 56320) { u[f++] = 239, u[f++] = 191, u[f++] = 189, x = _; continue } _ = x - 55296 << 10 | _ - 56320 | 65536, x = null } else x && (u[f++] = 239, u[f++] = 191, u[f++] = 189, x = null); _ < 128 ? u[f++] = _ : (_ < 2048 ? u[f++] = _ >> 6 | 192 : (_ < 65536 ? u[f++] = _ >> 12 | 224 : (u[f++] = _ >> 18 | 240, u[f++] = _ >> 12 & 63 | 128), u[f++] = _ >> 6 & 63 | 128), u[f++] = 63 & _ | 128) } return f }(this.buf, e, this.pos); const a = this.pos - r; a >= 128 && Pv(r, a, this), this.pos = r - 1, this.writeVarint(a), this.pos += a } writeFloat(e) { this.realloc(4), this.dataView.setFloat32(this.pos, e, !0), this.pos += 4 } writeDouble(e) { this.realloc(8), this.dataView.setFloat64(this.pos, e, !0), this.pos += 8 } writeBytes(e) { const r = e.length; this.writeVarint(r), this.realloc(r); for (let a = 0; a < r; a++)this.buf[this.pos++] = e[a] } writeRawMessage(e, r) { this.pos++; const a = this.pos; e(r, this); const u = this.pos - a; u >= 128 && Pv(a, u, this), this.pos = a - 1, this.writeVarint(u), this.pos += u } writeMessage(e, r, a) { this.writeTag(e, 2), this.writeRawMessage(r, a) } writePackedVarint(e, r) { r.length && this.writeMessage(e, oS, r) } writePackedSVarint(e, r) { r.length && this.writeMessage(e, aS, r) } writePackedBoolean(e, r) { r.length && this.writeMessage(e, cS, r) } writePackedFloat(e, r) { r.length && this.writeMessage(e, lS, r) } writePackedDouble(e, r) { r.length && this.writeMessage(e, uS, r) } writePackedFixed32(e, r) { r.length && this.writeMessage(e, hS, r) } writePackedSFixed32(e, r) { r.length && this.writeMessage(e, dS, r) } writePackedFixed64(e, r) { r.length && this.writeMessage(e, pS, r) } writePackedSFixed64(e, r) { r.length && this.writeMessage(e, fS, r) } writeBytesField(e, r) { this.writeTag(e, 2), this.writeBytes(r) } writeFixed32Field(e, r) { this.writeTag(e, 5), this.writeFixed32(r) } writeSFixed32Field(e, r) { this.writeTag(e, 5), this.writeSFixed32(r) } writeFixed64Field(e, r) { this.writeTag(e, 1), this.writeFixed64(r) } writeSFixed64Field(e, r) { this.writeTag(e, 1), this.writeSFixed64(r) } writeVarintField(e, r) { this.writeTag(e, 0), this.writeVarint(r) } writeSVarintField(e, r) { this.writeTag(e, 0), this.writeSVarint(r) } writeStringField(e, r) { this.writeTag(e, 2), this.writeString(r) } writeFloatField(e, r) { this.writeTag(e, 5), this.writeFloat(r) } writeDoubleField(e, r) { this.writeTag(e, 1), this.writeDouble(r) } writeBooleanField(e, r) { this.writeVarintField(e, +r) } } function Ou(n, e, r) { return r ? 4294967296 * e + (n >>> 0) : 4294967296 * (e >>> 0) + (n >>> 0) } function Pv(n, e, r) { const a = e <= 16383 ? 1 : e <= 2097151 ? 2 : e <= 268435455 ? 3 : Math.floor(Math.log(e) / (7 * Math.LN2)); r.realloc(a); for (let u = r.pos - 1; u >= n; u--)r.buf[u + a] = r.buf[u] } function oS(n, e) { for (let r = 0; r < n.length; r++)e.writeVarint(n[r]) } function aS(n, e) { for (let r = 0; r < n.length; r++)e.writeSVarint(n[r]) } function lS(n, e) { for (let r = 0; r < n.length; r++)e.writeFloat(n[r]) } function uS(n, e) { for (let r = 0; r < n.length; r++)e.writeDouble(n[r]) } function cS(n, e) { for (let r = 0; r < n.length; r++)e.writeBoolean(n[r]) } function hS(n, e) { for (let r = 0; r < n.length; r++)e.writeFixed32(n[r]) } function dS(n, e) { for (let r = 0; r < n.length; r++)e.writeSFixed32(n[r]) } function pS(n, e) { for (let r = 0; r < n.length; r++)e.writeFixed64(n[r]) } function fS(n, e) { for (let r = 0; r < n.length; r++)e.writeSFixed64(n[r]) } function mS(n, e, r) { n === 1 && r.readMessage(gS, e) } function gS(n, e, r) { if (n === 3) { const { id: a, bitmap: u, width: p, height: f, left: _, top: x, advance: S } = r.readMessage(_S, {}); e.push({ id: a, bitmap: new Th({ width: p + 6, height: f + 6 }, u), metrics: { width: p, height: f, left: _, top: x, advance: S } }) } } function _S(n, e, r) { n === 1 ? e.id = r.readVarint() : n === 2 ? e.bitmap = r.readBytes() : n === 3 ? e.width = r.readVarint() : n === 4 ? e.height = r.readVarint() : n === 5 ? e.left = r.readSVarint() : n === 6 ? e.top = r.readSVarint() : n === 7 && (e.advance = r.readVarint()) } function Mv(n) { let e = 0, r = 0; for (const f of n) e += f.w * f.h, r = Math.max(r, f.w); n.sort((f, _) => _.h - f.h); const a = [{ x: 0, y: 0, w: Math.max(Math.ceil(Math.sqrt(e / .95)), r), h: 1 / 0 }]; let u = 0, p = 0; for (const f of n) for (let _ = a.length - 1; _ >= 0; _--) { const x = a[_]; if (!(f.w > x.w || f.h > x.h)) { if (f.x = x.x, f.y = x.y, p = Math.max(p, f.y + f.h), u = Math.max(u, f.x + f.w), f.w === x.w && f.h === x.h) { const S = a.pop(); S && _ < a.length && (a[_] = S) } else f.h === x.h ? (x.x += f.w, x.w -= f.w) : f.w === x.w ? (x.y += f.h, x.h -= f.h) : (a.push({ x: x.x + f.w, y: x.y, w: x.w - f.w, h: f.h }), x.y += f.h, x.h -= f.h); break } } return { w: u, h: p, fill: e / (u * p) || 0 } } class Tg { constructor(e, { pixelRatio: r, version: a, stretchX: u, stretchY: p, content: f, textFitWidth: _, textFitHeight: x }) { this.paddedRect = e, this.pixelRatio = r, this.stretchX = u, this.stretchY = p, this.content = f, this.version = a, this.textFitWidth = _, this.textFitHeight = x } get tl() { return [this.paddedRect.x + 1, this.paddedRect.y + 1] } get br() { return [this.paddedRect.x + this.paddedRect.w - 1, this.paddedRect.y + this.paddedRect.h - 1] } get tlbr() { return this.tl.concat(this.br) } get displaySize() { return [(this.paddedRect.w - 2) / this.pixelRatio, (this.paddedRect.h - 2) / this.pixelRatio] } } class Iv { constructor(e, r) { const a = {}, u = {}; this.haveRenderCallbacks = []; const p = []; this.addImages(e, a, p), this.addImages(r, u, p); const { w: f, h: _ } = Mv(p), x = new Jn({ width: f || 1, height: _ || 1 }); for (const S in e) { const M = e[S], C = a[S].paddedRect; Jn.copy(M.data, x, { x: 0, y: 0 }, { x: C.x + 1, y: C.y + 1 }, M.data) } for (const S in r) { const M = r[S], C = u[S].paddedRect, k = C.x + 1, D = C.y + 1, L = M.data.width, F = M.data.height; Jn.copy(M.data, x, { x: 0, y: 0 }, { x: k, y: D }, M.data), Jn.copy(M.data, x, { x: 0, y: F - 1 }, { x: k, y: D - 1 }, { width: L, height: 1 }), Jn.copy(M.data, x, { x: 0, y: 0 }, { x: k, y: D + F }, { width: L, height: 1 }), Jn.copy(M.data, x, { x: L - 1, y: 0 }, { x: k - 1, y: D }, { width: 1, height: F }), Jn.copy(M.data, x, { x: 0, y: 0 }, { x: k + L, y: D }, { width: 1, height: F }) } this.image = x, this.iconPositions = a, this.patternPositions = u } addImages(e, r, a) { for (const u in e) { const p = e[u], f = { x: 0, y: 0, w: p.data.width + 2, h: p.data.height + 2 }; a.push(f), r[u] = new Tg(f, p), p.hasRenderCallback && this.haveRenderCallbacks.push(u) } } patchUpdatedImages(e, r) { e.dispatchRenderCallbacks(this.haveRenderCallbacks); for (const a in e.updatedImages) this.patchUpdatedImage(this.iconPositions[a], e.getImage(a), r), this.patchUpdatedImage(this.patternPositions[a], e.getImage(a), r) } patchUpdatedImage(e, r, a) { if (!e || !r || e.version === r.version) return; e.version = r.version; const [u, p] = e.tl; a.update(r.data, void 0, { x: u, y: p }) } } var ta; function Xp(n, e, r, a, u, p, f, _, x, S, M, C, k, D, L) { const F = Bu.fromFeature(n, u); let N; C === b.az.vertical && F.verticalizePunctuation(); let G = F.determineLineBreaks(S, p, e, a, D); const { processBidirectionalText: ee, processStyledBidirectionalText: q } = Is; if (ee && F.sections.length === 1) { N = [], G = G.map(Ie => F.toCodeUnitIndex(Ie)); const ae = ee(F.toString(), G); for (const Ie of ae) { const Ue = [...Ie].map(() => 0); N.push(new Bu(Ie, F.sections, Ue)) } } else if (q) { N = [], G = G.map(je => F.toCodeUnitIndex(je)); let ae = 0; const Ie = []; for (const je of F.text) Ie.push(...Array(je.length).fill(F.sectionIndex[ae])), ae++; const Ue = q(F.text, Ie, G); for (const je of Ue) { const Ze = []; let nt = ""; for (const He of je[0]) Ze.push(je[1][nt.length]), nt += He; N.push(new Bu(je[0], F.sections, Ze)) } } else N = function (ae, Ie) { const Ue = []; let je = 0; for (const Ze of Ie) Ue.push(ae.substring(je, Ze)), je = Ze; return je < ae.length() && Ue.push(ae.substring(je, ae.length())), Ue }(F, G); const H = [], ne = { positionedLines: H, text: F.toString(), top: M[1], bottom: M[1], left: M[0], right: M[0], writingMode: C, iconsInText: !1, verticalizable: !1 }; return function (ae, Ie, Ue, je, Ze, nt, He, Ve, Fe, dt, ut, gt) { let ot = 0, xt = 0, Vt = 0, Ft = 0; const xr = Ve === "right" ? 1 : Ve === "left" ? 0 : .5, Tn = on / gt; let Yr = 0; for (const Xt of Ze) { Xt.trim(); const kr = Xt.getMaxScale(), Nr = { positionedGlyphs: [], lineOffset: 0 }; ae.positionedLines[Yr] = Nr; const hr = Nr.positionedGlyphs; let ei = 0; if (!Xt.length()) { xt += nt, ++Yr; continue } const Sn = yS(je, Xt, Tn); let ti = 0; for (const un of Xt.text) { const Sr = Xt.getSection(ti), Kr = un.codePointAt(0), Dr = vS(Fe, ut, Kr), cn = { glyph: Kr, imageName: null, x: ot, y: xt + -17, vertical: Dr, scale: 1, fontStack: "", sectionIndex: Xt.getSectionIndex(ti), metrics: null, rect: null }; let ho; if ("fontStack" in Sr) { if (ho = xS(Sr, Kr, Dr, Sn, Ie, Ue), !ho) continue; cn.fontStack = Sr.fontStack } else { if (ae.iconsInText = !0, Sr.scale *= Tn, ho = wS(Sr, Dr, kr, Sn, je), !ho) continue; ei = Math.max(ei, ho.imageOffset), cn.imageName = Sr.imageName } const { rect: os, metrics: jh, baselineOffset: oa } = ho; cn.y += oa, cn.scale = Sr.scale, cn.metrics = jh, cn.rect = os, hr.push(cn), Dr ? (ae.verticalizable = !0, ot += ("imageName" in Sr ? jh.advance : on) * Sr.scale + dt) : ot += jh.advance * Sr.scale + dt, ti++ } hr.length !== 0 && (Vt = Math.max(ot - dt, Vt), bS(hr, 0, hr.length - 1, xr)), ot = 0, Nr.lineOffset = Math.max(ei, (kr - 1) * on); const $i = nt * kr + ei; xt += $i, Ft = Math.max($i, Ft), ++Yr } const { horizontalAlign: wr, verticalAlign: mr } = Sg(He); (function (Xt, kr, Nr, hr, ei, Sn, ti, $i, un) { const Sr = (kr - Nr) * ei; let Kr = 0; Kr = Sn !== ti ? -$i * hr - -17 : -hr * un * ti + .5 * ti; for (const Dr of Xt) for (const cn of Dr.positionedGlyphs) cn.x += Sr, cn.y += Kr })(ae.positionedLines, xr, wr, mr, Vt, Ft, nt, xt, Ze.length), ae.top += -mr * xt, ae.bottom = ae.top + xt, ae.left += -wr * Vt, ae.right = ae.left + Vt }(ne, e, r, a, N, f, _, x, C, S, k, L), !function (ae) { for (const Ie of ae) if (Ie.positionedGlyphs.length !== 0) return !1; return !0 }(H) && ne } function Sg(n) { let e = .5, r = .5; switch (n) { case "right": case "top-right": case "bottom-right": e = 1; break; case "left": case "top-left": case "bottom-left": e = 0 }switch (n) { case "bottom": case "bottom-right": case "bottom-left": r = 1; break; case "top": case "top-right": case "top-left": r = 0 }return { horizontalAlign: e, verticalAlign: r } } function yS(n, e, r) { const a = e.getMaxScale() * on, { maxImageWidth: u, maxImageHeight: p } = e.getMaxImageSize(n), f = Math.max(a, p * r); return { verticalLineContentWidth: Math.max(a, u * r), horizontalLineContentHeight: f } } function Cv(n) { switch (n) { case "top": return 0; case "center": return .5; default: return 1 } } function vS(n, e, r) { return !(n === b.az.horizontal || !e && !lh(r) || e && (Cp(r) || (a = r, new RegExp("\\p{sc=Arab}", "u").test(String.fromCodePoint(a))))); var a } function xS(n, e, r, a, u, p) { const f = p[n.fontStack], _ = function (S, M, C, k) { if (S && S.rect) return S; const D = M[C.fontStack], L = D && D[k]; return L ? { rect: null, metrics: L.metrics } : null }(f && f[e], u, n, e); if (_ === null) return null; let x; if (r) x = a.verticalLineContentWidth - n.scale * on; else { const S = Cv(n.verticalAlign); x = (a.horizontalLineContentHeight - n.scale * on) * S } return { rect: _.rect, metrics: _.metrics, baselineOffset: x } } function wS(n, e, r, a, u) { const p = u[n.imageName]; if (!p) return null; const f = p.paddedRect, _ = p.displaySize, x = { width: _[0], height: _[1], left: 1, top: -3, advance: e ? _[1] : _[0] }; let S; if (e) S = a.verticalLineContentWidth - _[1] * n.scale; else { const M = Cv(n.verticalAlign); S = (a.horizontalLineContentHeight - _[1] * n.scale) * M } return { rect: f, metrics: x, baselineOffset: S, imageOffset: (e ? _[0] : _[1]) * n.scale - on * r } } function bS(n, e, r, a) { if (a === 0) return; const u = n[r], p = (n[r].x + u.metrics.advance * u.scale) * a; for (let f = e; f <= r; f++)n[f].x -= p } function TS(n, e, r) { const { horizontalAlign: a, verticalAlign: u } = Sg(r), p = e[0] - n.displaySize[0] * a, f = e[1] - n.displaySize[1] * u; return { image: n, top: f, bottom: f + n.displaySize[1], left: p, right: p + n.displaySize[0] } } function Av(n) { var e, r; let a = n.left, u = n.top, p = n.right - a, f = n.bottom - u; const _ = (e = n.image.textFitWidth) !== null && e !== void 0 ? e : "stretchOrShrink", x = (r = n.image.textFitHeight) !== null && r !== void 0 ? r : "stretchOrShrink", S = (n.image.content[2] - n.image.content[0]) / (n.image.content[3] - n.image.content[1]); if (x === "proportional") { if (_ === "stretchOnly" && p / f < S || _ === "proportional") { const M = Math.ceil(f * S); a *= M / p, p = M } } else if (_ === "proportional" && x === "stretchOnly" && S !== 0 && p / f > S) { const M = Math.ceil(p / S); u *= M / f, f = M } return { x1: a, y1: u, x2: a + p, y2: u + f } } function kv(n, e, r, a, u, p) { const f = n.image; let _; if (f.content) { const N = f.content, G = f.pixelRatio || 1; _ = [N[0] / G, N[1] / G, f.displaySize[0] - N[2] / G, f.displaySize[1] - N[3] / G] } const x = e.left * p, S = e.right * p; let M, C, k, D; r === "width" || r === "both" ? (D = u[0] + x - a[3], C = u[0] + S + a[1]) : (D = u[0] + (x + S - f.displaySize[0]) / 2, C = D + f.displaySize[0]); const L = e.top * p, F = e.bottom * p; return r === "height" || r === "both" ? (M = u[1] + L - a[0], k = u[1] + F + a[2]) : (M = u[1] + (L + F - f.displaySize[1]) / 2, k = M + f.displaySize[1]), { image: f, top: M, right: C, bottom: k, left: D, collisionPadding: _ } } pt("ImagePosition", Tg), pt("ImageAtlas", Iv), b.az = void 0, (ta = b.az || (b.az = {}))[ta.none = 0] = "none", ta[ta.horizontal = 1] = "horizontal", ta[ta.vertical = 2] = "vertical", ta[ta.horizontalOnly = 3] = "horizontalOnly"; const uo = 128, ra = 32640; function Dv(n, e) { const { expression: r } = e; if (r.kind === "constant") return { kind: "constant", layoutSize: r.evaluate(new rr(n + 1)) }; if (r.kind === "source") return { kind: "source" }; { const { zoomStops: a, interpolationType: u } = r; let p = 0; for (; p < a.length && a[p] <= n;)p++; p = Math.max(0, p - 1); let f = p; for (; f < a.length && a[f] < n + 1;)f++; f = Math.min(a.length - 1, f); const _ = a[p], x = a[f]; return r.kind === "composite" ? { kind: "composite", minZoom: _, maxZoom: x, interpolationType: u } : { kind: "camera", minZoom: _, maxZoom: x, minSize: r.evaluate(new rr(_)), maxSize: r.evaluate(new rr(x)), interpolationType: u } } } function Eg(n, e, r) { let a = "never"; const u = n.get(e); return u ? a = u : n.get(r) && (a = "always"), a } const SS = [{ name: "a_fade_opacity", components: 1, type: "Uint8", offset: 0 }]; function Yp(n, e, r, a, u, p, f, _, x, S, M, C, k) { const D = _ ? Math.min(ra, Math.round(_[0])) : 0, L = _ ? Math.min(ra, Math.round(_[1])) : 0; n.emplaceBack(e, r, Math.round(32 * a), Math.round(32 * u), p, f, (D << 1) + (x ? 1 : 0), L, 16 * S, 16 * M, 256 * C, 256 * k) } function Pg(n, e, r) { n.emplaceBack(e.x, e.y, r), n.emplaceBack(e.x, e.y, r), n.emplaceBack(e.x, e.y, r), n.emplaceBack(e.x, e.y, r) } function ES(n) { for (const e of n.sections) if (Dp(e.text)) return !0; return !1 } class Mg { constructor(e) { this.layoutVertexArray = new se, this.indexArray = new Re, this.programConfigurations = e, this.segments = new it, this.dynamicLayoutVertexArray = new fe, this.opacityVertexArray = new Oe, this.hasVisibleVertices = !1, this.placedSymbolArray = new v } isEmpty() { return this.layoutVertexArray.length === 0 && this.indexArray.length === 0 && this.dynamicLayoutVertexArray.length === 0 && this.opacityVertexArray.length === 0 } upload(e, r, a, u) { this.isEmpty() || (a && (this.layoutVertexBuffer = e.createVertexBuffer(this.layoutVertexArray, QT.members), this.indexBuffer = e.createIndexBuffer(this.indexArray, r), this.dynamicLayoutVertexBuffer = e.createVertexBuffer(this.dynamicLayoutVertexArray, JT.members, !0), this.opacityVertexBuffer = e.createVertexBuffer(this.opacityVertexArray, SS, !0), this.opacityVertexBuffer.itemSize = 1), (a || u) && this.programConfigurations.upload(e)) } destroy() { this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.dynamicLayoutVertexBuffer.destroy(), this.opacityVertexBuffer.destroy()) } } pt("SymbolBuffers", Mg); class Ig { constructor(e, r, a) { this.layoutVertexArray = new e, this.layoutAttributes = r, this.indexArray = new a, this.segments = new it, this.collisionVertexArray = new ze } upload(e) { this.layoutVertexBuffer = e.createVertexBuffer(this.layoutVertexArray, this.layoutAttributes), this.indexBuffer = e.createIndexBuffer(this.indexArray), this.collisionVertexBuffer = e.createVertexBuffer(this.collisionVertexArray, eS.members, !0) } destroy() { this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.segments.destroy(), this.collisionVertexBuffer.destroy()) } } pt("CollisionBuffers", Ig); class Nu { constructor(e) { this.collisionBoxArray = e.collisionBoxArray, this.zoom = e.zoom, this.overscaling = e.overscaling, this.layers = e.layers, this.layerIds = this.layers.map(f => f.id), this.index = e.index, this.pixelRatio = e.pixelRatio, this.sourceLayerIndex = e.sourceLayerIndex, this.hasDependencies = !1, this.hasRTLText = !1, this.sortKeyRanges = [], this.collisionCircleArray = []; const r = this.layers[0]._unevaluatedLayout._values; this.textSizeData = Dv(this.zoom, r["text-size"]), this.iconSizeData = Dv(this.zoom, r["icon-size"]); const a = this.layers[0].layout, u = a.get("symbol-sort-key"), p = a.get("symbol-z-order"); this.canOverlap = Eg(a, "text-overlap", "text-allow-overlap") !== "never" || Eg(a, "icon-overlap", "icon-allow-overlap") !== "never" || a.get("text-ignore-placement") || a.get("icon-ignore-placement"), this.sortFeaturesByKey = p !== "viewport-y" && !u.isConstant(), this.sortFeaturesByY = (p === "viewport-y" || p === "auto" && !this.sortFeaturesByKey) && this.canOverlap, a.get("symbol-placement") === "point" && (this.writingModes = a.get("text-writing-mode").map(f => b.az[f])), this.stateDependentLayerIds = this.layers.filter(f => f.isStateDependent()).map(f => f.id), this.sourceID = e.sourceID } createArrays() { this.text = new Mg(new lo(this.layers, this.zoom, e => /^text/.test(e))), this.icon = new Mg(new lo(this.layers, this.zoom, e => /^icon/.test(e))), this.glyphOffsetArray = new I, this.lineVertexArray = new A, this.symbolInstances = new E, this.textAnchorOffsets = new z } calculateGlyphDependencies(e, r, a, u, p) { for (const f of e) if (r[f.codePointAt(0)] = !0, (a || u) && p) { const _ = zh[f]; _ && (r[_.codePointAt(0)] = !0) } } populate(e, r, a) { const u = this.layers[0], p = u.layout, f = p.get("text-font"), _ = p.get("text-field"), x = p.get("icon-image"), S = (_.value.kind !== "constant" || _.value.value instanceof Vn && !_.value.value.isEmpty() || _.value.value.toString().length > 0) && (f.value.kind !== "constant" || f.value.value.length > 0), M = x.value.kind !== "constant" || !!x.value.value || Object.keys(x.parameters).length > 0, C = p.get("symbol-sort-key"); if (this.features = [], !S && !M) return; const k = r.iconDependencies, D = r.glyphDependencies, L = r.availableImages, F = new rr(this.zoom); for (const { feature: N, id: G, index: ee, sourceLayerIndex: q } of e) { const H = u._featureFilter.needGeometry, ne = Ds(N, H); if (!u._featureFilter.filter(F, ne, a)) continue; let ae, Ie; if (H || (ne.geometry = ks(N)), S) { const je = u.getValueAndResolveTokens("text-field", ne, a, L), Ze = Vn.factory(je), nt = this.hasRTLText = this.hasRTLText || ES(Ze); (!nt || Is.getRTLTextPluginStatus() === "unavailable" || nt && Is.isParsed()) && (ae = rS(Ze, u, ne)) } if (M) { const je = u.getValueAndResolveTokens("icon-image", ne, a, L); Ie = je instanceof Kn ? je : Kn.fromString(je) } if (!ae && !Ie) continue; const Ue = this.sortFeaturesByKey ? C.evaluate(ne, {}, a) : void 0; if (this.features.push({ id: G, text: ae, icon: Ie, index: ee, sourceLayerIndex: q, geometry: ne.geometry, properties: N.properties, type: Ah.types[N.type], sortKey: Ue }), Ie && (k[Ie.name] = !0), ae) { const je = f.evaluate(ne, {}, a).join(","), Ze = p.get("text-rotation-alignment") !== "viewport" && p.get("symbol-placement") !== "point"; this.allowVerticalPlacement = this.writingModes && this.writingModes.indexOf(b.az.vertical) >= 0; for (const nt of ae.sections) if (nt.image) k[nt.image.name] = !0; else { const He = Jo(ae.toString()), Ve = nt.fontStack || je, Fe = D[Ve] = D[Ve] || {}; this.calculateGlyphDependencies(nt.text, Fe, Ze, this.allowVerticalPlacement, He) } } } p.get("symbol-placement") === "line" && (this.features = function (N) { const G = {}, ee = {}, q = []; let H = 0; function ne(je) { q.push(N[je]), H++ } function ae(je, Ze, nt) { const He = ee[je]; return delete ee[je], ee[Ze] = He, q[He].geometry[0].pop(), q[He].geometry[0] = q[He].geometry[0].concat(nt[0]), He } function Ie(je, Ze, nt) { const He = G[Ze]; return delete G[Ze], G[je] = He, q[He].geometry[0].shift(), q[He].geometry[0] = nt[0].concat(q[He].geometry[0]), He } function Ue(je, Ze, nt) { const He = nt ? Ze[0][Ze[0].length - 1] : Ze[0][0]; return `${je}:${He.x}:${He.y}` } for (let je = 0; je < N.length; je++) { const Ze = N[je], nt = Ze.geometry, He = Ze.text ? Ze.text.toString() : null; if (!He) { ne(je); continue } const Ve = Ue(He, nt), Fe = Ue(He, nt, !0); if (Ve in ee && Fe in G && ee[Ve] !== G[Fe]) { const dt = Ie(Ve, Fe, nt), ut = ae(Ve, Fe, q[dt].geometry); delete G[Ve], delete ee[Fe], ee[Ue(He, q[ut].geometry, !0)] = ut, q[dt].geometry = null } else Ve in ee ? ae(Ve, Fe, nt) : Fe in G ? Ie(Ve, Fe, nt) : (ne(je), G[Ve] = H - 1, ee[Fe] = H - 1) } return q.filter(je => je.geometry) }(this.features)), this.sortFeaturesByKey && this.features.sort((N, G) => N.sortKey - G.sortKey) } update(e, r, a) { this.stateDependentLayers.length && (this.text.programConfigurations.updatePaintArrays(e, r, this.layers, { imagePositions: a }), this.icon.programConfigurations.updatePaintArrays(e, r, this.layers, { imagePositions: a })) } isEmpty() { return this.symbolInstances.length === 0 && !this.hasRTLText } uploadPending() { return !this.uploaded || this.text.programConfigurations.needsUpload || this.icon.programConfigurations.needsUpload } upload(e) { !this.uploaded && this.hasDebugData() && (this.textCollisionBox.upload(e), this.iconCollisionBox.upload(e)), this.text.upload(e, this.sortFeaturesByY, !this.uploaded, this.text.programConfigurations.needsUpload), this.icon.upload(e, this.sortFeaturesByY, !this.uploaded, this.icon.programConfigurations.needsUpload), this.uploaded = !0 } destroyDebugData() { this.textCollisionBox.destroy(), this.iconCollisionBox.destroy() } destroy() { this.text.destroy(), this.icon.destroy(), this.hasDebugData() && this.destroyDebugData() } addToLineVertexArray(e, r) { const a = this.lineVertexArray.length; if (e.segment !== void 0) { let u = e.dist(r[e.segment + 1]), p = e.dist(r[e.segment]); const f = {}; for (let _ = e.segment + 1; _ < r.length; _++)f[_] = { x: r[_].x, y: r[_].y, tileUnitDistanceFromAnchor: u }, _ < r.length - 1 && (u += r[_ + 1].dist(r[_])); for (let _ = e.segment || 0; _ >= 0; _--)f[_] = { x: r[_].x, y: r[_].y, tileUnitDistanceFromAnchor: p }, _ > 0 && (p += r[_ - 1].dist(r[_])); for (let _ = 0; _ < r.length; _++) { const x = f[_]; this.lineVertexArray.emplaceBack(x.x, x.y, x.tileUnitDistanceFromAnchor) } } return { lineStartIndex: a, lineLength: this.lineVertexArray.length - a } } addSymbols(e, r, a, u, p, f, _, x, S, M, C, k) { const D = e.indexArray, L = e.layoutVertexArray, F = e.segments.prepareSegment(4 * r.length, L, D, this.canOverlap ? f.sortKey : void 0), N = this.glyphOffsetArray.length, G = F.vertexLength, ee = this.allowVerticalPlacement && _ === b.az.vertical ? Math.PI / 2 : 0, q = f.text && f.text.sections; for (let H = 0; H < r.length; H++) { const { tl: ne, tr: ae, bl: Ie, br: Ue, tex: je, pixelOffsetTL: Ze, pixelOffsetBR: nt, minFontScaleX: He, minFontScaleY: Ve, glyphOffset: Fe, isSDF: dt, sectionIndex: ut } = r[H], gt = F.vertexLength, ot = Fe[1]; Yp(L, x.x, x.y, ne.x, ot + ne.y, je.x, je.y, a, dt, Ze.x, Ze.y, He, Ve), Yp(L, x.x, x.y, ae.x, ot + ae.y, je.x + je.w, je.y, a, dt, nt.x, Ze.y, He, Ve), Yp(L, x.x, x.y, Ie.x, ot + Ie.y, je.x, je.y + je.h, a, dt, Ze.x, nt.y, He, Ve), Yp(L, x.x, x.y, Ue.x, ot + Ue.y, je.x + je.w, je.y + je.h, a, dt, nt.x, nt.y, He, Ve), Pg(e.dynamicLayoutVertexArray, x, ee), D.emplaceBack(gt, gt + 2, gt + 1), D.emplaceBack(gt + 1, gt + 2, gt + 3), F.vertexLength += 4, F.primitiveLength += 2, this.glyphOffsetArray.emplaceBack(Fe[0]), H !== r.length - 1 && ut === r[H + 1].sectionIndex || e.programConfigurations.populatePaintArrays(L.length, f, f.index, { imagePositions: {}, canonical: k, formattedSection: q && q[ut] }) } e.placedSymbolArray.emplaceBack(x.x, x.y, N, this.glyphOffsetArray.length - N, G, S, M, x.segment, a ? a[0] : 0, a ? a[1] : 0, u[0], u[1], _, 0, !1, 0, C) } _addCollisionDebugVertex(e, r, a, u, p, f) { return r.emplaceBack(0, 0), e.emplaceBack(a.x, a.y, u, p, Math.round(f.x), Math.round(f.y)) } addCollisionDebugVertices(e, r, a, u, p, f, _) { const x = p.segments.prepareSegment(4, p.layoutVertexArray, p.indexArray), S = x.vertexLength, M = p.layoutVertexArray, C = p.collisionVertexArray, k = _.anchorX, D = _.anchorY; this._addCollisionDebugVertex(M, C, f, k, D, new B(e, r)), this._addCollisionDebugVertex(M, C, f, k, D, new B(a, r)), this._addCollisionDebugVertex(M, C, f, k, D, new B(a, u)), this._addCollisionDebugVertex(M, C, f, k, D, new B(e, u)), x.vertexLength += 4; const L = p.indexArray; L.emplaceBack(S, S + 1), L.emplaceBack(S + 1, S + 2), L.emplaceBack(S + 2, S + 3), L.emplaceBack(S + 3, S), x.primitiveLength += 4 } addDebugCollisionBoxes(e, r, a, u) { for (let p = e; p < r; p++) { const f = this.collisionBoxArray.get(p); this.addCollisionDebugVertices(f.x1, f.y1, f.x2, f.y2, u ? this.textCollisionBox : this.iconCollisionBox, f.anchorPoint, a) } } generateCollisionDebugBuffers() { this.hasDebugData() && this.destroyDebugData(), this.textCollisionBox = new Ig(ke, vv.members, Je), this.iconCollisionBox = new Ig(ke, vv.members, Je); for (let e = 0; e < this.symbolInstances.length; e++) { const r = this.symbolInstances.get(e); this.addDebugCollisionBoxes(r.textBoxStartIndex, r.textBoxEndIndex, r, !0), this.addDebugCollisionBoxes(r.verticalTextBoxStartIndex, r.verticalTextBoxEndIndex, r, !0), this.addDebugCollisionBoxes(r.iconBoxStartIndex, r.iconBoxEndIndex, r, !1), this.addDebugCollisionBoxes(r.verticalIconBoxStartIndex, r.verticalIconBoxEndIndex, r, !1) } } _deserializeCollisionBoxesForSymbol(e, r, a, u, p, f, _, x, S) { const M = {}; for (let C = r; C < a; C++) { const k = e.get(C); M.textBox = { x1: k.x1, y1: k.y1, x2: k.x2, y2: k.y2, anchorPointX: k.anchorPointX, anchorPointY: k.anchorPointY }, M.textFeatureIndex = k.featureIndex; break } for (let C = u; C < p; C++) { const k = e.get(C); M.verticalTextBox = { x1: k.x1, y1: k.y1, x2: k.x2, y2: k.y2, anchorPointX: k.anchorPointX, anchorPointY: k.anchorPointY }, M.verticalTextFeatureIndex = k.featureIndex; break } for (let C = f; C < _; C++) { const k = e.get(C); M.iconBox = { x1: k.x1, y1: k.y1, x2: k.x2, y2: k.y2, anchorPointX: k.anchorPointX, anchorPointY: k.anchorPointY }, M.iconFeatureIndex = k.featureIndex; break } for (let C = x; C < S; C++) { const k = e.get(C); M.verticalIconBox = { x1: k.x1, y1: k.y1, x2: k.x2, y2: k.y2, anchorPointX: k.anchorPointX, anchorPointY: k.anchorPointY }, M.verticalIconFeatureIndex = k.featureIndex; break } return M } deserializeCollisionBoxes(e) { this.collisionArrays = []; for (let r = 0; r < this.symbolInstances.length; r++) { const a = this.symbolInstances.get(r); this.collisionArrays.push(this._deserializeCollisionBoxesForSymbol(e, a.textBoxStartIndex, a.textBoxEndIndex, a.verticalTextBoxStartIndex, a.verticalTextBoxEndIndex, a.iconBoxStartIndex, a.iconBoxEndIndex, a.verticalIconBoxStartIndex, a.verticalIconBoxEndIndex)) } } hasTextData() { return this.text.segments.get().length > 0 } hasIconData() { return this.icon.segments.get().length > 0 } hasDebugData() { return this.textCollisionBox && this.iconCollisionBox } hasTextCollisionBoxData() { return this.hasDebugData() && this.textCollisionBox.segments.get().length > 0 } hasIconCollisionBoxData() { return this.hasDebugData() && this.iconCollisionBox.segments.get().length > 0 } addIndicesForPlacedSymbol(e, r) { const a = e.placedSymbolArray.get(r), u = a.vertexStartIndex + 4 * a.numGlyphs; for (let p = a.vertexStartIndex; p < u; p += 4)e.indexArray.emplaceBack(p, p + 2, p + 1), e.indexArray.emplaceBack(p + 1, p + 2, p + 3) } getSortedSymbolIndexes(e) { if (this.sortedAngle === e && this.symbolInstanceIndexes !== void 0) return this.symbolInstanceIndexes; const r = Math.sin(e), a = Math.cos(e), u = [], p = [], f = []; for (let _ = 0; _ < this.symbolInstances.length; ++_) { f.push(_); const x = this.symbolInstances.get(_); u.push(0 | Math.round(r * x.anchorX + a * x.anchorY)), p.push(x.featureIndex) } return f.sort((_, x) => u[_] - u[x] || p[x] - p[_]), f } addToSortKeyRanges(e, r) { const a = this.sortKeyRanges[this.sortKeyRanges.length - 1]; a && a.sortKey === r ? a.symbolInstanceEnd = e + 1 : this.sortKeyRanges.push({ sortKey: r, symbolInstanceStart: e, symbolInstanceEnd: e + 1 }) } sortFeatures(e) { if (this.sortFeaturesByY && this.sortedAngle !== e && !(this.text.segments.get().length > 1 || this.icon.segments.get().length > 1)) { this.symbolInstanceIndexes = this.getSortedSymbolIndexes(e), this.sortedAngle = e, this.text.indexArray.clear(), this.icon.indexArray.clear(), this.featureSortOrder = []; for (const r of this.symbolInstanceIndexes) { const a = this.symbolInstances.get(r); this.featureSortOrder.push(a.featureIndex), [a.rightJustifiedTextSymbolIndex, a.centerJustifiedTextSymbolIndex, a.leftJustifiedTextSymbolIndex].forEach((u, p, f) => { u >= 0 && f.indexOf(u) === p && this.addIndicesForPlacedSymbol(this.text, u) }), a.verticalPlacedTextSymbolIndex >= 0 && this.addIndicesForPlacedSymbol(this.text, a.verticalPlacedTextSymbolIndex), a.placedIconSymbolIndex >= 0 && this.addIndicesForPlacedSymbol(this.icon, a.placedIconSymbolIndex), a.verticalPlacedIconSymbolIndex >= 0 && this.addIndicesForPlacedSymbol(this.icon, a.verticalPlacedIconSymbolIndex) } this.text.indexBuffer && this.text.indexBuffer.updateData(this.text.indexArray), this.icon.indexBuffer && this.icon.indexBuffer.updateData(this.icon.indexArray) } } } let zv, Rv; pt("SymbolBucket", Nu, { omit: ["layers", "collisionBoxArray", "features", "compareText"] }), Nu.MAX_GLYPHS = 65535, Nu.addDynamicAttributes = Pg; var Cg = { get paint() { return Rv = Rv || new Ln({ "icon-opacity": new bt(De.paint_symbol["icon-opacity"]), "icon-color": new bt(De.paint_symbol["icon-color"]), "icon-halo-color": new bt(De.paint_symbol["icon-halo-color"]), "icon-halo-width": new bt(De.paint_symbol["icon-halo-width"]), "icon-halo-blur": new bt(De.paint_symbol["icon-halo-blur"]), "icon-translate": new vt(De.paint_symbol["icon-translate"]), "icon-translate-anchor": new vt(De.paint_symbol["icon-translate-anchor"]), "text-opacity": new bt(De.paint_symbol["text-opacity"]), "text-color": new bt(De.paint_symbol["text-color"], { runtimeType: Yn, getOverride: n => n.textColor, hasOverride: n => !!n.textColor }), "text-halo-color": new bt(De.paint_symbol["text-halo-color"]), "text-halo-width": new bt(De.paint_symbol["text-halo-width"]), "text-halo-blur": new bt(De.paint_symbol["text-halo-blur"]), "text-translate": new vt(De.paint_symbol["text-translate"]), "text-translate-anchor": new vt(De.paint_symbol["text-translate-anchor"]) }) }, get layout() { return zv = zv || new Ln({ "symbol-placement": new vt(De.layout_symbol["symbol-placement"]), "symbol-spacing": new vt(De.layout_symbol["symbol-spacing"]), "symbol-avoid-edges": new vt(De.layout_symbol["symbol-avoid-edges"]), "symbol-sort-key": new bt(De.layout_symbol["symbol-sort-key"]), "symbol-z-order": new vt(De.layout_symbol["symbol-z-order"]), "icon-allow-overlap": new vt(De.layout_symbol["icon-allow-overlap"]), "icon-overlap": new vt(De.layout_symbol["icon-overlap"]), "icon-ignore-placement": new vt(De.layout_symbol["icon-ignore-placement"]), "icon-optional": new vt(De.layout_symbol["icon-optional"]), "icon-rotation-alignment": new vt(De.layout_symbol["icon-rotation-alignment"]), "icon-size": new bt(De.layout_symbol["icon-size"]), "icon-text-fit": new vt(De.layout_symbol["icon-text-fit"]), "icon-text-fit-padding": new vt(De.layout_symbol["icon-text-fit-padding"]), "icon-image": new bt(De.layout_symbol["icon-image"]), "icon-rotate": new bt(De.layout_symbol["icon-rotate"]), "icon-padding": new bt(De.layout_symbol["icon-padding"]), "icon-keep-upright": new vt(De.layout_symbol["icon-keep-upright"]), "icon-offset": new bt(De.layout_symbol["icon-offset"]), "icon-anchor": new bt(De.layout_symbol["icon-anchor"]), "icon-pitch-alignment": new vt(De.layout_symbol["icon-pitch-alignment"]), "text-pitch-alignment": new vt(De.layout_symbol["text-pitch-alignment"]), "text-rotation-alignment": new vt(De.layout_symbol["text-rotation-alignment"]), "text-field": new bt(De.layout_symbol["text-field"]), "text-font": new bt(De.layout_symbol["text-font"]), "text-size": new bt(De.layout_symbol["text-size"]), "text-max-width": new bt(De.layout_symbol["text-max-width"]), "text-line-height": new vt(De.layout_symbol["text-line-height"]), "text-letter-spacing": new bt(De.layout_symbol["text-letter-spacing"]), "text-justify": new bt(De.layout_symbol["text-justify"]), "text-radial-offset": new bt(De.layout_symbol["text-radial-offset"]), "text-variable-anchor": new vt(De.layout_symbol["text-variable-anchor"]), "text-variable-anchor-offset": new bt(De.layout_symbol["text-variable-anchor-offset"]), "text-anchor": new bt(De.layout_symbol["text-anchor"]), "text-max-angle": new vt(De.layout_symbol["text-max-angle"]), "text-writing-mode": new vt(De.layout_symbol["text-writing-mode"]), "text-rotate": new bt(De.layout_symbol["text-rotate"]), "text-padding": new vt(De.layout_symbol["text-padding"]), "text-keep-upright": new vt(De.layout_symbol["text-keep-upright"]), "text-transform": new bt(De.layout_symbol["text-transform"]), "text-offset": new bt(De.layout_symbol["text-offset"]), "text-allow-overlap": new vt(De.layout_symbol["text-allow-overlap"]), "text-overlap": new vt(De.layout_symbol["text-overlap"]), "text-ignore-placement": new vt(De.layout_symbol["text-ignore-placement"]), "text-optional": new vt(De.layout_symbol["text-optional"]) }) } }; class Lv { constructor(e) { if (e.property.overrides === void 0) throw new Error("overrides must be provided to instantiate FormatSectionOverride class"); this.type = e.property.overrides ? e.property.overrides.runtimeType : oi, this.defaultValue = e } evaluate(e) { if (e.formattedSection) { const r = this.defaultValue.property.overrides; if (r && r.hasOverride(e.formattedSection)) return r.getOverride(e.formattedSection) } return e.feature && e.featureState ? this.defaultValue.evaluate(e.feature, e.featureState) : this.defaultValue.property.specification.default } eachChild(e) { this.defaultValue.isConstant() || e(this.defaultValue.value._styleExpression.expression) } outputDefined() { return !1 } serialize() { return null } } pt("FormatSectionOverride", Lv, { omit: ["defaultValue"] }); class Kp extends ci { constructor(e, r) { super(e, Cg, r) } recalculate(e, r) { if (super.recalculate(e, r), this.layout.get("icon-rotation-alignment") === "auto" && (this.layout._values["icon-rotation-alignment"] = this.layout.get("symbol-placement") !== "point" ? "map" : "viewport"), this.layout.get("text-rotation-alignment") === "auto" && (this.layout._values["text-rotation-alignment"] = this.layout.get("symbol-placement") !== "point" ? "map" : "viewport"), this.layout.get("text-pitch-alignment") === "auto" && (this.layout._values["text-pitch-alignment"] = this.layout.get("text-rotation-alignment") === "map" ? "map" : "viewport"), this.layout.get("icon-pitch-alignment") === "auto" && (this.layout._values["icon-pitch-alignment"] = this.layout.get("icon-rotation-alignment")), this.layout.get("symbol-placement") === "point") { const a = this.layout.get("text-writing-mode"); if (a) { const u = []; for (const p of a) u.indexOf(p) < 0 && u.push(p); this.layout._values["text-writing-mode"] = u } else this.layout._values["text-writing-mode"] = ["horizontal"] } this._setPaintOverrides() } getValueAndResolveTokens(e, r, a, u) { const p = this.layout.get(e).evaluate(r, {}, a, u), f = this._unevaluatedLayout._values[e]; return f.isDataDriven() || Ho(f.value) || !p ? p : function (_, x) { return x.replace(/{([^{}]+)}/g, (S, M) => _ && M in _ ? String(_[M]) : "") }(r.properties, p) } createBucket(e) { return new Nu(e) } queryRadius() { return 0 } queryIntersectsFeature() { throw new Error("Should take a different path in FeatureIndex") } _setPaintOverrides() { for (const e of Cg.paint.overridableProperties) { if (!Kp.hasPaintOverride(this.layout, e)) continue; const r = this.paint.get(e), a = new Lv(r), u = new Yc(a, r.property.specification); let p = null; p = r.value.kind === "constant" || r.value.kind === "source" ? new cu("source", u) : new Kc("composite", u, r.value.zoomStops), this.paint._values[e] = new Pi(r.property, p, r.parameters) } } _handleOverridablePaintPropertyUpdate(e, r, a) { return !(!this.layout || r.isDataDriven() || a.isDataDriven()) && Kp.hasPaintOverride(this.layout, e) } static hasPaintOverride(e, r) { const a = e.get("text-field"), u = Cg.paint.properties[r]; let p = !1; const f = _ => { for (const x of _) if (u.overrides && u.overrides.hasOverride(x)) return void (p = !0) }; if (a.value.kind === "constant" && a.value.value instanceof Vn) f(a.value.value.sections); else if (a.value.kind === "source" || a.value.kind === "composite") { const _ = S => { p || (S instanceof ji && Lr(S.value) === ka ? f(S.value.sections) : S instanceof Va ? f(S.sections) : S.eachChild(_)) }, x = a.value; x._styleExpression && _(x._styleExpression.expression) } return p } } let Fv; var PS = { get paint() { return Fv = Fv || new Ln({ "background-color": new vt(De.paint_background["background-color"]), "background-pattern": new bu(De.paint_background["background-pattern"]), "background-opacity": new vt(De.paint_background["background-opacity"]) }) } }; class MS extends ci { constructor(e, r) { super(e, PS, r) } } class IS extends ci { constructor(e, r) { super(e, {}, r), this.onAdd = a => { this.implementation.onAdd && this.implementation.onAdd(a, a.painter.context.gl) }, this.onRemove = a => { this.implementation.onRemove && this.implementation.onRemove(a, a.painter.context.gl) }, this.implementation = e } is3D() { return this.implementation.renderingMode === "3d" } hasOffscreenPass() { return this.implementation.prerender !== void 0 } recalculate() { } updateTransitions() { } hasTransition() { return !1 } serialize() { throw new Error("Custom layers cannot be serialized") } } class CS { constructor(e) { this._methodToThrottle = e, this._triggered = !1, typeof MessageChannel < "u" && (this._channel = new MessageChannel, this._channel.port2.onmessage = () => { this._triggered = !1, this._methodToThrottle() }) } trigger() { this._triggered || (this._triggered = !0, this._channel ? this._channel.port1.postMessage(!0) : setTimeout(() => { this._triggered = !1, this._methodToThrottle() }, 0)) } remove() { delete this._channel, this._methodToThrottle = () => { } } } const AS = { once: !0 }, Ag = 63710088e-1; class na { constructor(e, r) { if (isNaN(e) || isNaN(r)) throw new Error(`Invalid LngLat object: (${e}, ${r})`); if (this.lng = +e, this.lat = +r, this.lat > 90 || this.lat < -90) throw new Error("Invalid LngLat latitude value: must be between -90 and 90") } wrap() { return new na(Yt(this.lng, -180, 180), this.lat) } toArray() { return [this.lng, this.lat] } toString() { return `LngLat(${this.lng}, ${this.lat})` } distanceTo(e) { const r = Math.PI / 180, a = this.lat * r, u = e.lat * r, p = Math.sin(a) * Math.sin(u) + Math.cos(a) * Math.cos(u) * Math.cos((e.lng - this.lng) * r); return Ag * Math.acos(Math.min(p, 1)) } static convert(e) { if (e instanceof na) return e; if (Array.isArray(e) && (e.length === 2 || e.length === 3)) return new na(Number(e[0]), Number(e[1])); if (!Array.isArray(e) && typeof e == "object" && e !== null) return new na(Number("lng" in e ? e.lng : e.lon), Number(e.lat)); throw new Error("`LngLatLike` argument must be specified as a LngLat instance, an object {lng: <lng>, lat: <lat>}, an object {lon: <lng>, lat: <lat>}, or an array of [<lng>, <lat>]") } } const Bv = 2 * Math.PI * Ag; function Ov(n) { return Bv * Math.cos(n * Math.PI / 180) } function Nv(n) { return (180 + n) / 360 } function jv(n) { return (180 - 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + n * Math.PI / 360))) / 360 } function Vv(n, e) { return n / Ov(e) } function Uv(n) { return 360 * n - 180 } function Qp(n) { return 360 / Math.PI * Math.atan(Math.exp((180 - 360 * n) * Math.PI / 180)) - 90 } function Gv(n, e) { return n * Ov(Qp(e)) } class Rh { constructor(e, r, a = 0) { this.x = +e, this.y = +r, this.z = +a } static fromLngLat(e, r = 0) { const a = na.convert(e); return new Rh(Nv(a.lng), jv(a.lat), Vv(r, a.lat)) } toLngLat() { return new na(Uv(this.x), Qp(this.y)) } toAltitude() { return Gv(this.z, this.y) } meterInMercatorCoordinateUnits() { return 1 / Bv * (e = Qp(this.y), 1 / Math.cos(e * Math.PI / 180)); var e } } function $v(n, e, r) { var a = 2 * Math.PI * 6378137 / 256 / Math.pow(2, r); return [n * a - 2 * Math.PI * 6378137 / 2, e * a - 2 * Math.PI * 6378137 / 2] } class kg { constructor(e, r, a) { if (!function (u, p, f) { return !(u < 0 || u > 25 || f < 0 || f >= Math.pow(2, u) || p < 0 || p >= Math.pow(2, u)) }(e, r, a)) throw new Error(`x=${r}, y=${a}, z=${e} outside of bounds. 0<=x<${Math.pow(2, e)}, 0<=y<${Math.pow(2, e)} 0<=z<=25 `); this.z = e, this.x = r, this.y = a, this.key = ju(0, e, e, r, a) } equals(e) { return this.z === e.z && this.x === e.x && this.y === e.y } url(e, r, a) { const u = function (f, _, x) { var S = $v(256 * f, 256 * (_ = Math.pow(2, x) - _ - 1), x), M = $v(256 * (f + 1), 256 * (_ + 1), x); return S[0] + "," + S[1] + "," + M[0] + "," + M[1] }(this.x, this.y, this.z), p = function (f, _, x) { let S, M = ""; for (let C = f; C > 0; C--)S = 1 << C - 1, M += (_ & S ? 1 : 0) + (x & S ? 2 : 0); return M }(this.z, this.x, this.y); return e[(this.x + this.y) % e.length].replace(/{prefix}/g, (this.x % 16).toString(16) + (this.y % 16).toString(16)).replace(/{z}/g, String(this.z)).replace(/{x}/g, String(this.x)).replace(/{y}/g, String(a === "tms" ? Math.pow(2, this.z) - this.y - 1 : this.y)).replace(/{ratio}/g, r > 1 ? "@2x" : "").replace(/{quadkey}/g, p).replace(/{bbox-epsg-3857}/g, u) } isChildOf(e) { const r = this.z - e.z; return r > 0 && e.x === this.x >> r && e.y === this.y >> r } getTilePoint(e) { const r = Math.pow(2, this.z); return new B((e.x * r - this.x) * Se, (e.y * r - this.y) * Se) } toString() { return `${this.z}/${this.x}/${this.y}` } } class qv { constructor(e, r) { this.wrap = e, this.canonical = r, this.key = ju(e, r.z, r.z, r.x, r.y) } } class Ci { constructor(e, r, a, u, p) { if (this.terrainRttPosMatrix32f = null, e < a) throw new Error(`overscaledZ should be >= z; overscaledZ = ${e}; z = ${a}`); this.overscaledZ = e, this.wrap = r, this.canonical = new kg(a, +u, +p), this.key = ju(r, e, a, u, p) } clone() { return new Ci(this.overscaledZ, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y) } equals(e) { return this.overscaledZ === e.overscaledZ && this.wrap === e.wrap && this.canonical.equals(e.canonical) } scaledTo(e) { if (e > this.overscaledZ) throw new Error(`targetZ > this.overscaledZ; targetZ = ${e}; overscaledZ = ${this.overscaledZ}`); const r = this.canonical.z - e; return e > this.canonical.z ? new Ci(e, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y) : new Ci(e, this.wrap, e, this.canonical.x >> r, this.canonical.y >> r) } isOverscaled() { return this.overscaledZ > this.canonical.z } calculateScaledKey(e, r) { if (e > this.overscaledZ) throw new Error(`targetZ > this.overscaledZ; targetZ = ${e}; overscaledZ = ${this.overscaledZ}`); const a = this.canonical.z - e; return e > this.canonical.z ? ju(this.wrap * +r, e, this.canonical.z, this.canonical.x, this.canonical.y) : ju(this.wrap * +r, e, e, this.canonical.x >> a, this.canonical.y >> a) } isChildOf(e) { if (e.wrap !== this.wrap || this.overscaledZ - e.overscaledZ <= 0) return !1; if (e.overscaledZ === 0) return this.overscaledZ > 0; const r = this.canonical.z - e.canonical.z; return !(r < 0) && e.canonical.x === this.canonical.x >> r && e.canonical.y === this.canonical.y >> r } children(e) { if (this.overscaledZ >= e) return [new Ci(this.overscaledZ + 1, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y)]; const r = this.canonical.z + 1, a = 2 * this.canonical.x, u = 2 * this.canonical.y; return [new Ci(r, this.wrap, r, a, u), new Ci(r, this.wrap, r, a + 1, u), new Ci(r, this.wrap, r, a, u + 1), new Ci(r, this.wrap, r, a + 1, u + 1)] } isLessThan(e) { return this.wrap < e.wrap || !(this.wrap > e.wrap) && (this.overscaledZ < e.overscaledZ || !(this.overscaledZ > e.overscaledZ) && (this.canonical.x < e.canonical.x || !(this.canonical.x > e.canonical.x) && this.canonical.y < e.canonical.y)) } wrapped() { return new Ci(this.overscaledZ, 0, this.canonical.z, this.canonical.x, this.canonical.y) } unwrapTo(e) { return new Ci(this.overscaledZ, e, this.canonical.z, this.canonical.x, this.canonical.y) } overscaleFactor() { return Math.pow(2, this.overscaledZ - this.canonical.z) } toUnwrapped() { return new qv(this.wrap, this.canonical) } toString() { return `${this.overscaledZ}/${this.canonical.x}/${this.canonical.y}` } getTilePoint(e) { return this.canonical.getTilePoint(new Rh(e.x - this.wrap, e.y)) } } function ju(n, e, r, a, u) { (n *= 2) < 0 && (n = -1 * n - 1); const p = 1 << r; return (p * p * n + p * u + a).toString(36) + r.toString(36) + e.toString(36) } function Dg(n, e) { return e ? n.properties[e] : n.id } function kS(n, e) { const r = { id: n.id }; if (e.removeAllProperties && (delete n.removeProperties, delete n.addOrUpdateProperties, delete e.removeProperties), e.removeProperties) for (const a of e.removeProperties) { const u = n.addOrUpdateProperties.findIndex(p => p.key === a); u > -1 && n.addOrUpdateProperties.splice(u, 1) } return (n.removeAllProperties || e.removeAllProperties) && (r.removeAllProperties = !0), (n.removeProperties || e.removeProperties) && (r.removeProperties = [...n.removeProperties || [], ...e.removeProperties || []]), (n.addOrUpdateProperties || e.addOrUpdateProperties) && (r.addOrUpdateProperties = [...n.addOrUpdateProperties || [], ...e.addOrUpdateProperties || []]), (n.newGeometry || e.newGeometry) && (r.newGeometry = e.newGeometry || n.newGeometry), r } function Zv(n) { var e, r; if (!n) return {}; const a = {}; return a.removeAll = n.removeAll, a.remove = new Set(n.remove || []), a.add = new Map((e = n.add) === null || e === void 0 ? void 0 : e.map(u => [u.id, u])), a.update = new Map((r = n.update) === null || r === void 0 ? void 0 : r.map(u => [u.id, u])), a } pt("CanonicalTileID", kg), pt("OverscaledTileID", Ci, { omit: ["terrainRttPosMatrix32f"] }); class yl { constructor() { this.minX = 1 / 0, this.maxX = -1 / 0, this.minY = 1 / 0, this.maxY = -1 / 0 } extend(e) { return this.minX = Math.min(this.minX, e.x), this.minY = Math.min(this.minY, e.y), this.maxX = Math.max(this.maxX, e.x), this.maxY = Math.max(this.maxY, e.y), this } expandBy(e) { return this.minX -= e, this.minY -= e, this.maxX += e, this.maxY += e, (this.minX > this.maxX || this.minY > this.maxY) && (this.minX = 1 / 0, this.maxX = -1 / 0, this.minY = 1 / 0, this.maxY = -1 / 0), this } shrinkBy(e) { return this.expandBy(-e) } map(e) { const r = new yl; return r.extend(e(new B(this.minX, this.minY))), r.extend(e(new B(this.maxX, this.minY))), r.extend(e(new B(this.minX, this.maxY))), r.extend(e(new B(this.maxX, this.maxY))), r } static fromPoints(e) { const r = new yl; for (const a of e) r.extend(a); return r } contains(e) { return e.x >= this.minX && e.x <= this.maxX && e.y >= this.minY && e.y <= this.maxY } empty() { return this.minX > this.maxX } width() { return this.maxX - this.minX } height() { return this.maxY - this.minY } covers(e) { return !this.empty() && !e.empty() && e.minX >= this.minX && e.maxX <= this.maxX && e.minY >= this.minY && e.maxY <= this.maxY } intersects(e) { return !this.empty() && !e.empty() && e.minX <= this.maxX && e.maxX >= this.minX && e.minY <= this.maxY && e.maxY >= this.minY } } class Wv { constructor(e) { this._stringToNumber = {}, this._numberToString = []; for (let r = 0; r < e.length; r++) { const a = e[r]; this._stringToNumber[a] = r, this._numberToString[r] = a } } encode(e) { return this._stringToNumber[e] } decode(e) { if (e >= this._numberToString.length) throw new Error(`Out of bounds. Index requested n=${e} can't be >= this._numberToString.length ${this._numberToString.length}`); return this._numberToString[e] } } class Hv { constructor(e, r, a, u, p) { this.type = "Feature", this._vectorTileFeature = e, this._x = a, this._y = u, this._z = r, this.properties = e.properties, this.id = p } projectPoint(e, r, a, u) { return [360 * (e.x + r) / u - 180, 360 / Math.PI * Math.atan(Math.exp((1 - 2 * (e.y + a) / u) * Math.PI)) - 90] } projectLine(e, r, a, u) { return e.map(p => this.projectPoint(p, r, a, u)) } get geometry() { if (this._geometry) return this._geometry; const e = this._vectorTileFeature, r = e.extent * Math.pow(2, this._z), a = e.extent * this._x, u = e.extent * this._y, p = e.loadGeometry(); switch (e.type) { case 1: { const f = []; for (const x of p) f.push(x[0]); const _ = this.projectLine(f, a, u, r); this._geometry = f.length === 1 ? { type: "Point", coordinates: _[0] } : { type: "MultiPoint", coordinates: _ }; break } case 2: { const f = p.map(_ => this.projectLine(_, a, u, r)); this._geometry = f.length === 1 ? { type: "LineString", coordinates: f[0] } : { type: "MultiLineString", coordinates: f }; break } case 3: { const f = uv(p), _ = []; for (const x of f) _.push(x.map(S => this.projectLine(S, a, u, r))); this._geometry = _.length === 1 ? { type: "Polygon", coordinates: _[0] } : { type: "MultiPolygon", coordinates: _ }; break } default: throw new Error(`unknown feature type: ${e.type}`) }return this._geometry } set geometry(e) { this._geometry = e } toJSON() { const e = { geometry: this.geometry }; for (const r in this) r !== "_geometry" && r !== "_vectorTileFeature" && r !== "_x" && r !== "_y" && r !== "_z" && (e[r] = this[r]); return e } } class Vu { constructor(e, r, a) { rt(this, "_name"); rt(this, "dataBuffer"); rt(this, "nullabilityBuffer"); rt(this, "_size"); this._name = e, this.dataBuffer = r, typeof a == "number" ? this._size = a : (this.nullabilityBuffer = a, this._size = a.size()) } getValue(e) { return this.nullabilityBuffer && !this.nullabilityBuffer.get(e) ? null : this.getValueFromBuffer(e) } has(e) { return this.nullabilityBuffer && this.nullabilityBuffer.get(e) || !this.nullabilityBuffer } get name() { return this._name } get size() { return this._size } } class Jp extends Vu { } class zg extends Jp { getValueFromBuffer(e) { return this.dataBuffer[e] } } class Rg extends Jp { getValueFromBuffer(e) { return this.dataBuffer[e] } } class Xv extends Vu { constructor(r, a, u, p) { super(r, a, p); rt(this, "delta"); this.delta = u } } class Lg extends Xv { constructor(e, r, a, u) { super(e, Int32Array.of(r), a, u) } getValueFromBuffer(e) { return this.dataBuffer[0] + e * this.delta } } class Fg extends Vu { constructor(e, r, a) { super(e, Int32Array.of(r), a) } getValueFromBuffer(e) { return this.dataBuffer[0] } } class DS { constructor(e, r, a, u, p = 4096) { rt(this, "_name"); rt(this, "_geometryVector"); rt(this, "_idVector"); rt(this, "_propertyVectors"); rt(this, "_extent"); rt(this, "propertyVectorsMap"); this._name = e, this._geometryVector = r, this._idVector = a, this._propertyVectors = u, this._extent = p } get name() { return this._name } get idVector() { return this._idVector } get geometryVector() { return this._geometryVector } get propertyVectors() { return this._propertyVectors } getPropertyVector(e) { return this.propertyVectorsMap || (this.propertyVectorsMap = new Map(this._propertyVectors.map(r => [r.name, r]))), this.propertyVectorsMap.get(e) } *[Symbol.iterator]() { const e = this.geometryVector[Symbol.iterator](); let r = 0; for (; r < this.numFeatures;) { let a; this.idVector && (a = this.containsMaxSaveIntegerValues(this.idVector) ? Number(this.idVector.getValue(r)) : this.idVector.getValue(r)); const u = e == null ? void 0 : e.next().value, p = {}; for (const f of this.propertyVectors) { if (!f) continue; const _ = f.name, x = f.getValue(r); x !== null && (p[_] = x) } r++, yield { id: a, geometry: u, properties: p } } } get numFeatures() { return this.geometryVector.numGeometries } get extent() { return this._extent } getFeatures() { const e = [], r = this.geometryVector.getGeometries(); for (let a = 0; a < this.numFeatures; a++) { let u; this.idVector && (u = this.containsMaxSaveIntegerValues(this.idVector) ? Number(this.idVector.getValue(a)) : this.idVector.getValue(a)); const p = { coordinates: r[a], type: this.geometryVector.geometryType(a) }, f = {}; for (const _ of this.propertyVectors) { if (!_) continue; const x = _.name, S = _.getValue(a); S !== null && (f[x] = S) } e.push({ id: u, geometry: p, properties: f }) } return e } containsMaxSaveIntegerValues(e) { return e instanceof zg || e instanceof Fg && e instanceof Lg || e instanceof Rg } } class zS { constructor(e) { rt(this, "value"); this.value = e } get() { return this.value } set(e) { this.value = e } increment() { return this.value++ } add(e) { this.value += e } } var Ot, co, wn, is, vl, di, an, ln, Yv, Ai; function gn(n, e, r) { const a = new Int32Array(r); let u = 0, p = e.get(); for (let f = 0; f < a.length; f++) { let _ = n[p++], x = 127 & _; _ < 128 || (_ = n[p++], x |= (127 & _) << 7, _ < 128 || (_ = n[p++], x |= (127 & _) << 14, _ < 128 || (_ = n[p++], x |= (127 & _) << 21, _ < 128 || (_ = n[p++], x |= (15 & _) << 28)))), a[u++] = x } return e.set(p), a } function ef(n, e, r) { const a = new BigInt64Array(r); for (let u = 0; u < a.length; u++)a[u] = LS(n, e); return a } function RS(n, e) { let r, a; return a = n[e.get()], e.increment(), r = 127 & a, a < 128 ? r : (a = n[e.get()], e.increment(), r |= (127 & a) << 7, a < 128 ? r : (a = n[e.get()], e.increment(), r |= (127 & a) << 14, a < 128 ? r : (a = n[e.get()], e.increment(), r |= (127 & a) << 21, a < 128 ? r : (a = n[e.get()], r |= (15 & a) << 28, function (u, p, f) { let _, x; if (x = p[f.get()], f.increment(), _ = (112 & x) >> 4, x < 128 || (x = p[f.get()], f.increment(), _ |= (127 & x) << 3, x < 128) || (x = p[f.get()], f.increment(), _ |= (127 & x) << 10, x < 128) || (x = p[f.get()], f.increment(), _ |= (127 & x) << 17, x < 128) || (x = p[f.get()], f.increment(), _ |= (127 & x) << 24, x < 128) || (x = p[f.get()], f.increment(), _ |= (1 & x) << 31, x < 128)) return 4294967296 * _ + (u >>> 0); throw new Error("Expected varint not more than 10 bytes") }(r, n, e))))) } function Kv(n, e, r, a) { throw new Error("FastPFor is not implemented yet.") } function xl(n) { return n >>> 1 ^ -(1 & n) } function Uu(n) { return n >> 1n ^ -(1n & n) } function LS(n, e) { let r = 0n, a = 0, u = e.get(); for (; u < n.length;) { const p = n[u++]; if (r |= BigInt(127 & p) << BigInt(a), !(128 & p)) break; if (a += 7, a >= 64) throw new Error("Varint too long") } return e.set(u), r } function Qv(n, e, r) { const a = new Int32Array(r); let u = 0; for (let p = 0; p < e; p++) { const f = n[p]; a.fill(n[p + e], u, u + f), u += f } return a } function Jv(n, e, r) { const a = new BigInt64Array(r); let u = 0; for (let p = 0; p < e; p++) { const f = Number(n[p]); a.fill(n[p + e], u, u + f), u += f } return a } function ex(n, e, r) { const a = new Float64Array(r); let u = 0; for (let p = 0; p < e; p++) { const f = n[p]; a.fill(n[p + e], u, u + f), u += f } return a } function Bg(n) { const e = n.length / 4 * 4; let r = 1; if (e >= 4) for (let a = n[0]; r < e - 4; r += 4)a = n[r] += a, a = n[r + 1] += a, a = n[r + 2] += a, a = n[r + 3] += a; for (; r != n.length;)n[r] += n[r - 1], ++r } function tx(n) { n[0] = n[0] >>> 1 ^ -(1 & n[0]), n[1] = n[1] >>> 1 ^ -(1 & n[1]); const e = n.length / 4 * 4; let r = 2; if (e >= 4) for (; r < e - 4; r += 4) { const a = n[r], u = n[r + 1], p = n[r + 2], f = n[r + 3]; n[r] = (a >>> 1 ^ -(1 & a)) + n[r - 2], n[r + 1] = (u >>> 1 ^ -(1 & u)) + n[r - 1], n[r + 2] = (p >>> 1 ^ -(1 & p)) + n[r], n[r + 3] = (f >>> 1 ^ -(1 & f)) + n[r + 1] } for (; r != n.length; r += 2)n[r] = (n[r] >>> 1 ^ -(1 & n[r])) + n[r - 2], n[r + 1] = (n[r + 1] >>> 1 ^ -(1 & n[r + 1])) + n[r - 1] } (function (n) { n.NONE = "NONE", n.DELTA = "DELTA", n.COMPONENTWISE_DELTA = "COMPONENTWISE_DELTA", n.RLE = "RLE", n.MORTON = "MORTON", n.PDE = "PDE" })(Ot || (Ot = {})), function (n) { n.NONE = "NONE", n.FAST_PFOR = "FAST_PFOR", n.VARINT = "VARINT", n.ALP = "ALP" }(co || (co = {})), function (n) { n.PRESENT = "PRESENT", n.DATA = "DATA", n.OFFSET = "OFFSET", n.LENGTH = "LENGTH" }(wn || (wn = {})); class Og { constructor(e, r, a) { rt(this, "_dictionaryType"); rt(this, "_offsetType"); rt(this, "_lengthType"); this._dictionaryType = e, this._offsetType = r, this._lengthType = a } get dictionaryType() { return this._dictionaryType } get offsetType() { return this._offsetType } get lengthType() { return this._lengthType } } function $n(n, e) { const r = function (a, u) { const p = a[u.get()], f = Object.values(wn)[p >> 4]; let _ = null; switch (f) { case wn.DATA: _ = new Og(Object.values(is)[15 & p]); break; case wn.OFFSET: _ = new Og(null, Object.values(vl)[15 & p]); break; case wn.LENGTH: _ = new Og(null, null, Object.values(di)[15 & p]) }u.increment(); const x = a[u.get()], S = Object.values(Ot)[x >> 5], M = Object.values(Ot)[x >> 2 & 7], C = Object.values(co)[3 & x]; u.increment(); const k = gn(a, u, 2), D = k[0]; return { physicalStreamType: f, logicalStreamType: _, logicalLevelTechnique1: S, logicalLevelTechnique2: M, physicalLevelTechnique: C, numValues: D, byteLength: k[1], decompressedCount: D } }(n, e); return r.logicalLevelTechnique1 === Ot.MORTON ? function (a, u, p) { const f = gn(u, p, 2); return { physicalStreamType: a.physicalStreamType, logicalStreamType: a.logicalStreamType, logicalLevelTechnique1: a.logicalLevelTechnique1, logicalLevelTechnique2: a.logicalLevelTechnique2, physicalLevelTechnique: a.physicalLevelTechnique, numValues: a.numValues, byteLength: a.byteLength, decompressedCount: a.decompressedCount, numBits: f[0], coordinateShift: f[1] } }(r, n, e) : Ot.RLE !== r.logicalLevelTechnique1 && Ot.RLE !== r.logicalLevelTechnique2 || co.NONE === r.physicalLevelTechnique ? r : function (a, u, p) { const f = gn(u, p, 2); return { physicalStreamType: a.physicalStreamType, logicalStreamType: a.logicalStreamType, logicalLevelTechnique1: a.logicalLevelTechnique1, logicalLevelTechnique2: a.logicalLevelTechnique2, physicalLevelTechnique: a.physicalLevelTechnique, numValues: a.numValues, byteLength: a.byteLength, decompressedCount: f[1], runs: f[0], numRleValues: f[1] } }(r, n, e) } (function (n) { n.NONE = "NONE", n.SINGLE = "SINGLE", n.SHARED = "SHARED", n.VERTEX = "VERTEX", n.MORTON = "MORTON", n.FSST = "FSST" })(is || (is = {})), function (n) { n.VERTEX = "VERTEX", n.INDEX = "INDEX", n.STRING = "STRING", n.KEY = "KEY" }(vl || (vl = {})), function (n) { n.VAR_BINARY = "VAR_BINARY", n.GEOMETRIES = "GEOMETRIES", n.PARTS = "PARTS", n.RINGS = "RINGS", n.TRIANGLES = "TRIANGLES", n.SYMBOL = "SYMBOL", n.DICTIONARY = "DICTIONARY" }(di || (di = {})), function (n) { n[n.FLAT = 0] = "FLAT", n[n.CONST = 1] = "CONST", n[n.SEQUENCE = 2] = "SEQUENCE", n[n.DICTIONARY = 3] = "DICTIONARY", n[n.FSST_DICTIONARY = 4] = "FSST_DICTIONARY" }(an || (an = {})); class ss { constructor(e, r) { rt(this, "values"); rt(this, "_size"); this.values = e, this._size = r } get(e) { const r = Math.floor(e / 8); return (this.values[r] >> e % 8 & 1) == 1 } set(e, r) { const a = Math.floor(e / 8); this.values[a] = this.values[a] | (r ? 1 : 0) << e % 8 } getInt(e) { const r = Math.floor(e / 8); return this.values[r] >> e % 8 & 1 } size() { return this._size } getBuffer() { return this.values } } function qn(n, e, r, a, u) { return function (p, f, _) { switch (f.logicalLevelTechnique1) { case Ot.DELTA: return f.logicalLevelTechnique2 === Ot.RLE ? function (x, S, M) { const C = new Int32Array(M); let k = 0, D = 0; for (let L = 0; L < S; L++) { const F = x[L], N = xl(x[L + S]); for (let G = 0; G < F; G++)D += N, C[k++] = D } return C }(p, f.runs, f.numRleValues) : (function (x) { x[0] = x[0] >>> 1 ^ -(1 & x[0]); const S = x.length / 4 * 4; let M = 1; if (S >= 4) for (; M < S - 4; M += 4) { const C = x[M], k = x[M + 1], D = x[M + 2], L = x[M + 3]; x[M] = (C >>> 1 ^ -(1 & C)) + x[M - 1], x[M + 1] = (k >>> 1 ^ -(1 & k)) + x[M], x[M + 2] = (D >>> 1 ^ -(1 & D)) + x[M + 1], x[M + 3] = (L >>> 1 ^ -(1 & L)) + x[M + 2] } for (; M != x.length; ++M)x[M] = (x[M] >>> 1 ^ -(1 & x[M])) + x[M - 1] }(p), p); case Ot.RLE: return function (x, S, M) { return M ? function (C, k, D) { const L = new Int32Array(D); let F = 0; for (let N = 0; N < k; N++) { const G = C[N]; let ee = C[N + k]; ee = ee >>> 1 ^ -(1 & ee), L.fill(ee, F, F + G), F += G } return L }(x, S.runs, S.numRleValues) : Qv(x, S.runs, S.numRleValues) }(p, f, _); case Ot.MORTON: return Bg(p), p; case Ot.COMPONENTWISE_DELTA: return tx(p), p; case Ot.NONE: return _ && function (x) { for (let S = 0; S < x.length; S++) { const M = x[S]; x[S] = M >>> 1 ^ -(1 & M) } }(p), p; default: throw new Error(`The specified Logical level technique is not supported: ${f.logicalLevelTechnique1}`) } }(tf(n, e, r), r, a) } function ia(n, e, r) { return function (a, u) { if (u.logicalLevelTechnique1 === Ot.DELTA && u.logicalLevelTechnique2 === Ot.NONE) return function (f) { const _ = new Int32Array(f.length + 1); _[0] = 0, _[1] = xl(f[0]); let x = _[1], S = 2; for (; S != _.length; ++S) { const M = f[S - 1]; x += M >>> 1 ^ -(1 & M), _[S] = _[S - 1] + x } return _ }(a); if (u.logicalLevelTechnique1 === Ot.RLE && u.logicalLevelTechnique2 === Ot.NONE) return function (f, _, x) { const S = new Int32Array(x + 1); S[0] = 0; let M = 1, C = S[0]; for (let k = 0; k < _; k++) { const D = f[k], L = f[k + _]; for (let F = M; F < M + D; F++)S[F] = L + C, C = S[F]; M += D } return S }(a, u.runs, u.numRleValues); if (u.logicalLevelTechnique1 === Ot.NONE && u.logicalLevelTechnique2 === Ot.NONE) { (function (f) { let _ = 0; for (let x = 0; x < f.length; x++)f[x] += _, _ = f[x] })(a); const p = new Int32Array(u.numValues + 1); return p[0] = 0, p.set(a, 1), p } if (u.logicalLevelTechnique1 === Ot.DELTA && u.logicalLevelTechnique2 === Ot.RLE) { const p = function (f, _, x) { const S = new Int32Array(x + 1); S[0] = 0; let M = 1, C = S[0]; for (let k = 0; k < _; k++) { const D = f[k]; let L = f[k + _]; L = L >>> 1 ^ -(1 & L); for (let F = M; F < M + D; F++)S[F] = L + C, C = S[F]; M += D } return S }(a, u.runs, u.numRleValues); return Bg(p), p } throw new Error("Only delta encoding is supported for transforming length to offset streams yet.") }(tf(n, e, r), r) } function tf(n, e, r) { const a = r.physicalLevelTechnique; if (a === co.FAST_PFOR) return Kv(); if (a === co.VARINT) return gn(n, e, r.numValues); if (a === co.NONE) { const u = e.get(); e.add(r.byteLength); const p = n.subarray(u, e.get()); return new Int32Array(p) } throw new Error("Specified physicalLevelTechnique is not supported (yet).") } function Ng(n, e, r, a) { const u = tf(n, e, r); if (u.length === 1) { const p = u[0]; return a ? xl(p) : p } return a ? function (p) { return xl(p[1]) }(u) : function (p) { return p[1] }(u) } function rx(n, e, r) { return function (a) { if (a.length == 2) { const u = xl(a[1]); return [u, u] } return [xl(a[2]), xl(a[3])] }(tf(n, e, r)) } function nx(n, e, r) { return function (a) { if (a.length == 2) { const u = Uu(a[1]); return [u, u] } return [Uu(a[2]), Uu(a[3])] }(ef(n, e, r.numValues)) } function ix(n, e, r, a) { return function (u, p, f) { switch (p.logicalLevelTechnique1) { case Ot.DELTA: return p.logicalLevelTechnique2 === Ot.RLE ? function (_, x, S) { const M = new BigInt64Array(S); let C = 0, k = 0n; for (let D = 0; D < x; D++) { const L = Number(_[D]), F = Uu(_[D + x]); for (let N = 0; N < L; N++)k += F, M[C++] = k } return M }(u, p.runs, p.numRleValues) : (function (_) { _[0] = _[0] >> 1n ^ -(1n & _[0]); const x = _.length / 4 * 4; let S = 1; if (x >= 4) for (; S < x - 4; S += 4) { const M = _[S], C = _[S + 1], k = _[S + 2], D = _[S + 3]; _[S] = (M >> 1n ^ -(1n & M)) + _[S - 1], _[S + 1] = (C >> 1n ^ -(1n & C)) + _[S], _[S + 2] = (k >> 1n ^ -(1n & k)) + _[S + 1], _[S + 3] = (D >> 1n ^ -(1n & D)) + _[S + 2] } for (; S != _.length; ++S)_[S] = (_[S] >> 1n ^ -(1n & _[S])) + _[S - 1] }(u), u); case Ot.RLE: return function (_, x, S) { return S ? function (M, C, k) { const D = new BigInt64Array(k); let L = 0; for (let F = 0; F < C; F++) { const N = Number(M[F]); let G = M[F + C]; G = G >> 1n ^ -(1n & G), D.fill(G, L, L + N), L += N } return D }(_, x.runs, x.numRleValues) : Jv(_, x.runs, x.numRleValues) }(u, p, f); case Ot.NONE: return f && function (_) { for (let x = 0; x < _.length; x++) { const S = _[x]; _[x] = S >> 1n ^ -(1n & S) } }(u), u; default: throw new Error(`The specified Logical level technique is not supported: ${p.logicalLevelTechnique1}`) } }(ef(n, e, r.numValues), r, a) } function sx(n, e, r, a) { const u = ef(n, e, r.numValues); if (u.length === 1) { const p = u[0]; return a ? Uu(p) : p } return a ? function (p) { return Uu(p[1]) }(u) : function (p) { return p[1] }(u) } function jg(n, e, r, a, u) { return function (p, f, _, x) { switch (f.logicalLevelTechnique1) { case Ot.DELTA: return f.logicalLevelTechnique2 === Ot.RLE && (p = Qv(p, f.runs, f.numRleValues)), function (S, M) { const C = new Int32Array(S.size()); let k = 0; S.get(0) ? (C[0] = S.get(0) ? M[0] >>> 1 ^ -(1 & M[0]) : 0, k = 1) : C[0] = 0; let D = 1; for (; D != C.length; ++D)C[D] = S.get(D) ? C[D - 1] + (M[k] >>> 1 ^ -(1 & M[k++])) : C[D - 1]; return C }(x, p); case Ot.RLE: return function (S, M, C, k) { const D = M; return C ? function (L, F, N) { const G = new Int32Array(L.size()); let ee = 0; for (let q = 0; q < N; q++) { const H = F[q]; let ne = F[q + N]; ne = ne >>> 1 ^ -(1 & ne); for (let ae = ee; ae < ee + H; ae++)L.get(ae) ? G[ae] = ne : (G[ae] = 0, ee++); ee += H } return G }(k, S, D.runs) : function (L, F, N) { const G = new Int32Array(L.size()); let ee = 0; for (let q = 0; q < N; q++) { const H = F[q], ne = F[q + N]; for (let ae = ee; ae < ee + H; ae++)L.get(ae) ? G[ae] = ne : (G[ae] = 0, ee++); ee += H } return G }(k, S, D.runs) }(p, f, _, x); case Ot.MORTON: return Bg(p), p; case Ot.COMPONENTWISE_DELTA: return tx(p), p; case Ot.NONE: return p = _ ? function (S, M) { const C = new Int32Array(S.size()); let k = 0, D = 0; for (; D != C.length; ++D)if (S.get(D)) { const L = M[k++]; C[D] = L >>> 1 ^ -(1 & L) } else C[D] = 0; return C }(x, p) : function (S, M) { const C = new Int32Array(S.size()); let k = 0, D = 0; for (; D != C.length; ++D)C[D] = S.get(D) ? M[k++] : 0; return C }(x, p), p; default: throw new Error("The specified Logical level technique is not supported") } }(r.physicalLevelTechnique === co.FAST_PFOR ? Kv() : gn(n, e, r.numValues), r, a, u) } function rf(n, e, r, a) { const u = n.logicalLevelTechnique1; if (u === Ot.RLE) return n.runs === 1 ? an.CONST : an.FLAT; const p = e instanceof ss ? e.size() : e; if (u === Ot.DELTA && n.logicalLevelTechnique2 === Ot.RLE) { const f = n.runs, _ = 2; if (n.numRleValues !== p) return an.FLAT; if (f === 1) return an.SEQUENCE; if (f === 2) { const x = a.get(); let S; if (n.physicalLevelTechnique === co.VARINT) S = gn(r, a, 4); else { const M = a.get(); S = new Int32Array(r.buffer, r.byteOffset + M, 4) } if (a.set(x), S[2] === _ && S[3] === _) return an.SEQUENCE } } return n.numValues === 1 ? an.CONST : an.FLAT } class ox extends Jp { getValueFromBuffer(e) { return this.dataBuffer[e] } } class ax extends Xv { constructor(e, r, a, u) { super(e, BigInt64Array.of(r), a, u) } getValueFromBuffer(e) { return this.dataBuffer[0] + BigInt(e) * this.delta } } class Gu { constructor(e, r, a) { rt(this, "_geometryOffsets"); rt(this, "_partOffsets"); rt(this, "_ringOffsets"); this._geometryOffsets = e, this._partOffsets = r, this._ringOffsets = a } get geometryOffsets() { return this._geometryOffsets } get partOffsets() { return this._partOffsets } get ringOffsets() { return this._ringOffsets } } function Vg(n, e, r) { return { x: lx(n, e) - r, y: lx(n >> 1, e) - r } } function lx(n, e) { let r = 0; for (let a = 0; a < e; a++)r |= (n & 1 << 2 * a) >> a; return r } (function (n) { n[n.POINT = 0] = "POINT", n[n.LINESTRING = 1] = "LINESTRING", n[n.POLYGON = 2] = "POLYGON", n[n.MULTIPOINT = 3] = "MULTIPOINT", n[n.MULTILINESTRING = 4] = "MULTILINESTRING", n[n.MULTIPOLYGON = 5] = "MULTIPOLYGON" })(ln || (ln = {})), function (n) { n[n.POINT = 0] = "POINT", n[n.LINESTRING = 1] = "LINESTRING", n[n.POLYGON = 2] = "POLYGON" }(Yv || (Yv = {})), function (n) { n[n.MORTON = 0] = "MORTON", n[n.VEC_2 = 1] = "VEC_2", n[n.VEC_3 = 2] = "VEC_3" }(Ai || (Ai = {})); class FS { createPoint(e) { return [[e]] } createMultiPoint(e) { return e.map(r => [r]) } createLineString(e) { return [e] } createMultiLineString(e) { return e } createPolygon(e, r) { return [e].concat(r) } createMultiPolygon(e) { return e.flat() } } function ux(n) { const e = new Array(n.numGeometries); let r = 1, a = 1, u = 1, p = 0; const f = new FS; let _ = 0, x = 0; const S = n.mortonSettings, M = n.topologyVector, C = M.geometryOffsets, k = M.partOffsets, D = M.ringOffsets, L = n.vertexOffsets, F = n.containsPolygonGeometry(), N = n.vertexBuffer; for (let G = 0; G < n.numGeometries; G++) { const ee = n.geometryType(G); if (ee === ln.POINT) { if (L && L.length !== 0) if (n.vertexBufferType === Ai.VEC_2) { const q = 2 * L[x++], H = new B(N[q], N[q + 1]); e[p++] = f.createPoint(H) } else { const q = Vg(N[L[x++]], S.numBits, S.coordinateShift), H = new B(q.x, q.y); e[p++] = f.createPoint(H) } else { const q = new B(N[_++], N[_++]); e[p++] = f.createPoint(q) } C && u++, k && r++, D && a++ } else if (ee === ln.MULTIPOINT) { const q = C[u] - C[u - 1]; u++; const H = new Array(q); if (L && L.length !== 0) { for (let ne = 0; ne < q; ne++) { const ae = 2 * L[x++]; H[ne] = new B(N[ae], N[ae + 1]) } e[p++] = f.createMultiPoint(H) } else { for (let ne = 0; ne < q; ne++) { const ae = N[_++], Ie = N[_++]; H[ne] = new B(ae, Ie) } e[p++] = f.createMultiPoint(H) } } else if (ee === ln.LINESTRING) { let q, H = 0; F ? (H = D[a] - D[a - 1], a++) : H = k[r] - k[r - 1], r++, L && L.length !== 0 ? (q = n.vertexBufferType === Ai.VEC_2 ? Gg(N, L, x, H, !1) : $g(N, L, x, H, !1, S), x += H) : (q = Ug(N, _, H, !1), _ += 2 * H), e[p++] = f.createLineString(q), C && u++ } else if (ee === ln.POLYGON) { const q = k[r] - k[r - 1]; r++; const H = new Array(q - 1); let ne = D[a] - D[a - 1]; if (a++, L && L.length !== 0) { const ae = n.vertexBufferType === Ai.VEC_2 ? sf(N, L, x, ne) : of(N, L, x, ne, 0, S); x += ne; for (let Ie = 0; Ie < H.length; Ie++)ne = D[a] - D[a - 1], a++, H[Ie] = n.vertexBufferType === Ai.VEC_2 ? sf(N, L, x, ne) : of(N, L, x, ne, 0, S), x += ne; e[p++] = f.createPolygon(ae, H) } else { const ae = nf(N, _, ne); _ += 2 * ne; for (let Ie = 0; Ie < H.length; Ie++)ne = D[a] - D[a - 1], a++, H[Ie] = nf(N, _, ne), _ += 2 * ne; e[p++] = f.createPolygon(ae, H) } C && u++ } else if (ee === ln.MULTILINESTRING) { const q = C[u] - C[u - 1]; u++; const H = new Array(q); if (L && L.length !== 0) { for (let ne = 0; ne < q; ne++) { let ae = 0; F ? (ae = D[a] - D[a - 1], a++) : ae = k[r] - k[r - 1], r++; const Ie = n.vertexBufferType === Ai.VEC_2 ? Gg(N, L, x, ae, !1) : $g(N, L, x, ae, !1, S); H[ne] = Ie, x += ae } e[p++] = f.createMultiLineString(H) } else { for (let ne = 0; ne < q; ne++) { let ae = 0; F ? (ae = D[a] - D[a - 1], a++) : ae = k[r] - k[r - 1], r++, H[ne] = Ug(N, _, ae, !1), _ += 2 * ae } e[p++] = f.createMultiLineString(H) } } else { if (ee !== ln.MULTIPOLYGON) throw new Error("The specified geometry type is currently not supported."); { const q = C[u] - C[u - 1]; u++; const H = new Array(q); let ne = 0; if (L && L.length !== 0) { for (let ae = 0; ae < q; ae++) { const Ie = k[r] - k[r - 1]; r++; const Ue = new Array(Ie - 1); ne = D[a] - D[a - 1], a++; const je = n.vertexBufferType === Ai.VEC_2 ? sf(N, L, x, ne) : of(N, L, x, ne, 0, S); x += ne; for (let Ze = 0; Ze < Ue.length; Ze++)ne = D[a] - D[a - 1], a++, Ue[Ze] = n.vertexBufferType === Ai.VEC_2 ? sf(N, L, x, ne) : of(N, L, x, ne, 0, S), x += ne; H[ae] = f.createPolygon(je, Ue) } e[p++] = f.createMultiPolygon(H) } else { for (let ae = 0; ae < q; ae++) { const Ie = k[r] - k[r - 1]; r++; const Ue = new Array(Ie - 1); ne = D[a] - D[a - 1], a++; const je = nf(N, _, ne); _ += 2 * ne; for (let Ze = 0; Ze < Ue.length; Ze++) { const nt = D[a] - D[a - 1]; a++, Ue[Ze] = nf(N, _, nt), _ += 2 * nt } H[ae] = f.createPolygon(je, Ue) } e[p++] = f.createMultiPolygon(H) } } } } return e } function nf(n, e, r) { return Ug(n, e, r, !0) } function sf(n, e, r, a) { return Gg(n, e, r, a, !0) } function of(n, e, r, a, u, p) { return $g(n, e, r, a, !0, p) } function Ug(n, e, r, a) { const u = new Array(a ? r + 1 : r); for (let p = 0; p < 2 * r; p += 2)u[p / 2] = new B(n[e + p], n[e + p + 1]); return a && (u[u.length - 1] = u[0]), u } function Gg(n, e, r, a, u) { const p = new Array(u ? a + 1 : a); for (let f = 0; f < 2 * a; f += 2) { const _ = 2 * e[r + f / 2]; p[f / 2] = new B(n[_], n[_ + 1]) } return u && (p[p.length - 1] = p[0]), p } function $g(n, e, r, a, u, p) { const f = new Array(u ? a + 1 : a); for (let _ = 0; _ < a; _++) { const x = Vg(n[e[r + _]], p.numBits, p.coordinateShift); f[_] = new B(x.x, x.y) } return u && (f[f.length - 1] = f[0]), f } class cx { constructor(e, r, a, u, p) { rt(this, "_vertexBufferType"); rt(this, "_topologyVector"); rt(this, "_vertexOffsets"); rt(this, "_vertexBuffer"); rt(this, "_mortonSettings"); this._vertexBufferType = e, this._topologyVector = r, this._vertexOffsets = a, this._vertexBuffer = u, this._mortonSettings = p } get vertexBufferType() { return this._vertexBufferType } get topologyVector() { return this._topologyVector } get vertexOffsets() { return this._vertexOffsets } get vertexBuffer() { return this._vertexBuffer } *[Symbol.iterator]() { const e = ux(this); let r = 0; for (; r < this.numGeometries;)yield { coordinates: e[r], type: this.geometryType(r) }, r++ } getSimpleEncodedVertex(e) { const r = this.vertexOffsets ? 2 * this.vertexOffsets[e] : 2 * e; return [this.vertexBuffer[r], this.vertexBuffer[r + 1]] } getVertex(e) { if (this.vertexOffsets && this.mortonSettings) { const a = Vg(this.vertexBuffer[this.vertexOffsets[e]], this.mortonSettings.numBits, this.mortonSettings.coordinateShift); return [a.x, a.y] } const r = this.vertexOffsets ? 2 * this.vertexOffsets[e] : 2 * e; return [this.vertexBuffer[r], this.vertexBuffer[r + 1]] } getGeometries() { return ux(this) } get mortonSettings() { return this._mortonSettings } } class hx extends cx { constructor(r, a, u, p, f, _, x) { super(u, p, f, _, x); rt(this, "_numGeometries"); rt(this, "_geometryType"); this._numGeometries = r, this._geometryType = a } geometryType(r) { return this._geometryType } get numGeometries() { return this._numGeometries } containsPolygonGeometry() { return this._geometryType === ln.POLYGON || this._geometryType === ln.MULTIPOLYGON } containsSingleGeometryType() { return !0 } } class dx extends cx { constructor(r, a, u, p, f, _) { super(r, u, p, f, _); rt(this, "_geometryTypes"); this._geometryTypes = a } geometryType(r) { return this._geometryTypes[r] } get numGeometries() { return this._geometryTypes.length } containsPolygonGeometry() { for (let r = 0; r < this.numGeometries; r++)if (this.geometryType(r) === ln.POLYGON || this.geometryType(r) === ln.MULTIPOLYGON) return !0; return !1 } containsSingleGeometryType() { return !1 } } class px { constructor(e, r, a, u) { rt(this, "_triangleOffsets"); rt(this, "_indexBuffer"); rt(this, "_vertexBuffer"); rt(this, "_topologyVector"); this._triangleOffsets = e, this._indexBuffer = r, this._vertexBuffer = a, this._topologyVector = u } get triangleOffsets() { return this._triangleOffsets } get indexBuffer() { return this._indexBuffer } get vertexBuffer() { return this._vertexBuffer } get topologyVector() { return this._topologyVector } getGeometries() { if (!this._topologyVector) throw new Error("Cannot convert GpuVector to coordinates without topology information"); const e = new Array(this.numGeometries), r = this._topologyVector, a = r.partOffsets, u = r.ringOffsets, p = r.geometryOffsets; let f = 0, _ = 1, x = 1, S = 1; for (let M = 0; M < this.numGeometries; M++)switch (this.geometryType(M)) { case ln.POLYGON: { const C = a[_] - a[_ - 1]; _++; const k = []; for (let D = 0; D < C; D++) { const L = u[x] - u[x - 1]; x++; const F = []; for (let N = 0; N < L; N++) { const G = this._vertexBuffer[f++], ee = this._vertexBuffer[f++]; F.push(new B(G, ee)) } F.length > 0 && F.push(F[0]), k.push(F) } e[M] = k, p && S++ } break; case ln.MULTIPOLYGON: { const C = p[S] - p[S - 1]; S++; const k = []; for (let D = 0; D < C; D++) { const L = a[_] - a[_ - 1]; _++; for (let F = 0; F < L; F++) { const N = u[x] - u[x - 1]; x++; const G = []; for (let ee = 0; ee < N; ee++) { const q = this._vertexBuffer[f++], H = this._vertexBuffer[f++]; G.push(new B(q, H)) } G.length > 0 && G.push(G[0]), k.push(G) } } e[M] = k } }return e } [Symbol.iterator]() { return null } } function fx(n, e, r, a, u, p) { return new BS(n, e, r, a, u, p) } class BS extends px { constructor(r, a, u, p, f, _) { super(u, p, f, _); rt(this, "_numGeometries"); rt(this, "_geometryType"); this._numGeometries = r, this._geometryType = a } geometryType(r) { return this._geometryType } get numGeometries() { return this._numGeometries } containsSingleGeometryType() { return !0 } } function mx(n, e, r, a, u) { return new OS(n, e, r, a, u) } class OS extends px { constructor(r, a, u, p, f) { super(a, u, p, f); rt(this, "_geometryTypes"); this._geometryTypes = r } geometryType(r) { return this._geometryTypes[r] } get numGeometries() { return this._geometryTypes.length } containsSingleGeometryType() { return !1 } } function NS(n, e, r, a, u) { const p = $n(n, r); let f = null, _ = null, x = null, S = null, M = null, C = null, k = null, D = null; if (rf(p, a, n, r) === an.CONST) { const F = Ng(n, r, p, !1); for (let N = 0; N < e - 1; N++) { const G = $n(n, r); switch (G.physicalStreamType) { case wn.LENGTH: switch (G.logicalStreamType.lengthType) { case di.GEOMETRIES: f = ia(n, r, G); break; case di.PARTS: _ = ia(n, r, G); break; case di.RINGS: x = ia(n, r, G); break; case di.TRIANGLES: k = ia(n, r, G) }break; case wn.OFFSET: switch (G.logicalStreamType.offsetType) { case vl.VERTEX: S = qn(n, r, G, !1); break; case vl.INDEX: D = qn(n, r, G, !1) }break; case wn.DATA: is.VERTEX === G.logicalStreamType.dictionaryType ? M = qn(n, r, G, !0) : (C = { numBits: G.numBits, coordinateShift: G.coordinateShift }, M = qn(n, r, G, !1)) } } return D !== null ? f != null || _ != null ? fx(a, F, k, D, M, new Gu(f, _, x)) : fx(a, F, k, D, M) : C === null ? function (N, G, ee, q, H) { return new hx(N, G, Ai.VEC_2, ee, q, H) }(a, F, new Gu(f, _, x), S, M) : function (N, G, ee, q, H, ne) { return new hx(N, G, Ai.MORTON, ee, q, H, ne) }(a, F, new Gu(f, _, x), S, M, C) } const L = qn(n, r, p, !1); for (let F = 0; F < e - 1; F++) { const N = $n(n, r); switch (N.physicalStreamType) { case wn.LENGTH: switch (N.logicalStreamType.lengthType) { case di.GEOMETRIES: f = qn(n, r, N, !1); break; case di.PARTS: _ = qn(n, r, N, !1); break; case di.RINGS: x = qn(n, r, N, !1); break; case di.TRIANGLES: k = ia(n, r, N) }break; case wn.OFFSET: switch (N.logicalStreamType.offsetType) { case vl.VERTEX: S = qn(n, r, N, !1); break; case vl.INDEX: D = qn(n, r, N, !1) }break; case wn.DATA: is.VERTEX === N.logicalStreamType.dictionaryType ? M = qn(n, r, N, !0) : (C = { numBits: N.numBits, coordinateShift: N.coordinateShift }, M = qn(n, r, N, !1)) } } return D !== null && _ === null ? mx(L, k, D, M) : (f !== null ? (f = qg(L, f, 2), _ !== null && x !== null ? (_ = gx(L, f, _, !1), x = function (F, N, G, ee) { const q = new Int32Array(G[G.length - 1] + 1); let H = 0; q[0] = H; let ne = 1, ae = 1, Ie = 0; for (let Ue = 0; Ue < F.length; Ue++) { const je = F[Ue], Ze = N[Ue + 1] - N[Ue]; if (je !== 0 && je !== 3) for (let nt = 0; nt < Ze; nt++) { const He = G[ne] - G[ne - 1]; ne++; for (let Ve = 0; Ve < He; Ve++)H = q[ae++] = H + ee[Ie++] } else for (let nt = 0; nt < Ze; nt++)q[ae++] = ++H, ne++ } return q }(L, f, _, x)) : _ !== null && (_ = function (F, N, G) { const ee = new Int32Array(N[N.length - 1] + 1); let q = 0; ee[0] = q; let H = 1, ne = 0; for (let ae = 0; ae < F.length; ae++) { const Ie = F[ae], Ue = N[ae + 1] - N[ae]; if (Ie === 4 || Ie === 1) for (let je = 0; je < Ue; je++)q = ee[H++] = q + G[ne++]; else for (let je = 0; je < Ue; je++)ee[H++] = ++q } return ee }(L, f, _))) : _ !== null && x !== null ? (_ = qg(L, _, 1), x = gx(L, _, x, !0)) : _ !== null && (_ = qg(L, _, 0)), D !== null ? mx(L, k, D, M, new Gu(f, _, x)) : C === null ? function (F, N, G, ee) { return new dx(Ai.VEC_2, F, N, G, ee) }(L, new Gu(f, _, x), S, M) : function (F, N, G, ee, q) { return new dx(Ai.MORTON, F, N, G, ee, q) }(L, new Gu(f, _, x), S, M, C)) } function qg(n, e, r) { const a = new Int32Array(n.length + 1); let u = 0; a[0] = u; let p = 0; for (let f = 0; f < n.length; f++)u = a[f + 1] = u + (n[f] > r ? e[p++] : 1); return a } function gx(n, e, r, a) { const u = new Int32Array(e[e.length - 1] + 1); let p = 0; u[0] = p; let f = 1, _ = 0; for (let x = 0; x < n.length; x++) { const S = n[x], M = e[x + 1] - e[x]; if (S === 5 || S === 2 || a && (S === 4 || S === 1)) for (let C = 0; C < M; C++)p = u[f++] = p + r[_++]; else for (let C = 0; C < M; C++)u[f++] = ++p } return u } class jS extends Vu { constructor(r, a, u) { super(r, a.getBuffer(), u); rt(this, "dataVector"); this.dataVector = a } getValueFromBuffer(r) { return this.dataVector.get(r) } } class VS extends Jp { getValueFromBuffer(e) { return this.dataBuffer[e] } } class _x extends Vu { constructor(e, r, a) { super(e, BigInt64Array.of(r), a) } getValueFromBuffer(e) { return this.dataBuffer[0] } } function Lh(n, e, r) { return yx(n, Math.ceil(e / 8), r) } function yx(n, e, r) { const a = new Uint8Array(e); let u = 0; for (; u < e;) { const p = n[r.increment()]; if (p <= 127) { const f = p + 3, _ = n[r.increment()], x = u + f; a.fill(_, u, x), u = x } else { const f = 256 - p; for (let _ = 0; _ < f; _++)a[u++] = n[r.increment()] } } return a } const US = new TextDecoder; function Zg(n, e, r) { return r - e >= 12 ? US.decode(n.subarray(e, r)) : function (a, u, p) { let f = "", _ = u; for (; _ < p;) { const x = a[_]; let S, M, C, k = null, D = x > 239 ? 4 : x > 223 ? 3 : x > 191 ? 2 : 1; if (_ + D > p) break; D === 1 ? x < 128 && (k = x) : D === 2 ? (S = a[_ + 1], (192 & S) == 128 && (k = (31 & x) << 6 | 63 & S, k <= 127 && (k = null))) : D === 3 ? (S = a[_ + 1], M = a[_ + 2], (192 & S) == 128 && (192 & M) == 128 && (k = (15 & x) << 12 | (63 & S) << 6 | 63 & M, (k <= 2047 || k >= 55296 && k <= 57343) && (k = null))) : D === 4 && (S = a[_ + 1], M = a[_ + 2], C = a[_ + 3], (192 & S) == 128 && (192 & M) == 128 && (192 & C) == 128 && (k = (15 & x) << 18 | (63 & S) << 12 | (63 & M) << 6 | 63 & C, (k <= 65535 || k >= 1114112) && (k = null))), k === null ? (k = 65533, D = 1) : k > 65535 && (k -= 65536, f += String.fromCharCode(k >>> 10 & 1023 | 55296), k = 56320 | 1023 & k), f += String.fromCharCode(k), _ += D } return f }(n, e, r) } class Wg extends Vu { constructor(r, a, u, p) { super(r, u, p); rt(this, "offsetBuffer"); this.offsetBuffer = a } } class vx extends Wg { constructor(r, a, u, p) { super(r, a, u, p ?? a.length - 1); rt(this, "textEncoder"); this.textEncoder = new TextEncoder } getValueFromBuffer(r) { return Zg(this.dataBuffer, this.offsetBuffer[r], this.offsetBuffer[r + 1]) } } class $u extends Wg { constructor(r, a, u, p, f) { super(r, u, p, f ?? a.length); rt(this, "indexBuffer"); rt(this, "textEncoder"); this.indexBuffer = a, this.indexBuffer = a, this.textEncoder = new TextEncoder } getValueFromBuffer(r) { const a = this.indexBuffer[r]; return Zg(this.dataBuffer, this.offsetBuffer[a], this.offsetBuffer[a + 1]) } } class xx extends Wg { constructor(r, a, u, p, f, _, x) { super(r, u, p, x); rt(this, "indexBuffer"); rt(this, "symbolOffsetBuffer"); rt(this, "symbolTableBuffer"); rt(this, "textEncoder"); rt(this, "symbolLengthBuffer"); rt(this, "lengthBuffer"); rt(this, "decodedDictionary"); this.indexBuffer = a, this.symbolOffsetBuffer = f, this.symbolTableBuffer = _, this.textEncoder = new TextEncoder } getValueFromBuffer(r) { this.decodedDictionary == null && (this.symbolLengthBuffer == null && (this.symbolLengthBuffer = this.offsetToLengthBuffer(this.symbolOffsetBuffer), this.lengthBuffer = this.offsetToLengthBuffer(this.offsetBuffer)), this.decodedDictionary = function (u, p, f) { const _ = [], x = new Array(p.length).fill(0); for (let S = 1; S < p.length; S++)x[S] = x[S - 1] + p[S - 1]; for (let S = 0; S < f.length; S++)if (f[S] === 255) _.push(f[++S]); else { const M = p[f[S]], C = x[f[S]]; for (let k = 0; k < M; k++)_.push(u[C + k]) } return new Uint8Array(_) }(this.symbolTableBuffer, this.symbolLengthBuffer, this.dataBuffer)); const a = this.indexBuffer[r]; return Zg(this.decodedDictionary, this.offsetBuffer[a], this.offsetBuffer[a + 1]) } offsetToLengthBuffer(r) { const a = new Uint32Array(r.length - 1); let u = r[0]; for (let p = 1; p < r.length; p++) { const f = r[p]; a[p - 1] = f - u, u = f } return a } } function GS(n, e, r, a, u, p) { return r.type === "scalarType" ? function (f, _, x, S, M, C) { let k = null, D = 0; if (f === 0) return null; if (C.nullable) { const F = $n(_, x); D = F.numValues; const N = x.get(), G = Lh(_, D, x); x.set(N + F.byteLength), k = new ss(G, F.numValues) } const L = k ?? S; switch (M.physicalType) { case 4: case 3: return function (F, N, G, ee, q) { const H = $n(F, N), ne = rf(H, q, F, N), ae = ee.physicalType === 3; if (ne === an.FLAT) { const Ie = Fh(q) ? jg(F, N, H, ae, q) : qn(F, N, H, ae); return new zg(G.name, Ie, q) } if (ne === an.SEQUENCE) { const Ie = rx(F, N, H); return new Lg(G.name, Ie[0], Ie[1], H.numRleValues) } { const Ie = Ng(F, N, H, ae); return new Fg(G.name, Ie, q) } }(_, x, C, M, L); case 9: return function (F, N, G, ee, q) { let H = null, ne = null, ae = null, Ie = null, Ue = null, je = null, Ze = null, nt = null; for (let He = 0; He < ee; He++) { const Ve = $n(N, G); if (Ve.byteLength !== 0) switch (Ve.physicalStreamType) { case wn.PRESENT: { const Fe = Lh(N, Ve.numValues, G); je = new ss(Fe, Ve.numValues); break } case wn.OFFSET: ne = q != null || je != null ? jg(N, G, Ve, !1, q ?? je) : qn(N, G, Ve, !1); break; case wn.LENGTH: { const Fe = ia(N, G, Ve); di.DICTIONARY === Ve.logicalStreamType.lengthType ? H = Fe : di.SYMBOL === Ve.logicalStreamType.lengthType ? Ie = Fe : Ze = Fe; break } case wn.DATA: { const Fe = N.subarray(G.get(), G.get() + Ve.byteLength); G.add(Ve.byteLength); const dt = Ve.logicalStreamType.dictionaryType; is.FSST === dt ? Ue = Fe : is.SINGLE === dt || is.SHARED === dt ? ae = Fe : is.NONE === dt && (nt = Fe); break } } } return function (He, Ve, Fe, dt, ut, gt, ot) { return Ve ? new xx(He, Fe, dt, ut, gt, Ve, ot) : null }(F, Ue, ne, H, ae, Ie, q ?? je) ?? function (He, Ve, Fe, dt, ut) { return Ve ? ut ? new $u(He, Fe, dt, Ve, ut) : new $u(He, Fe, dt, Ve) : null }(F, ae, ne, H, q ?? je) ?? function (He, Ve, Fe, dt, ut) { if (!Ve || !Fe) return null; if (dt) return ut ? new $u(He, dt, Ve, Fe, ut) : new $u(He, dt, Ve, Fe); if (ut && ut.size() !== Ve.length - 1) { const gt = new Int32Array(ut.size()); let ot = 0; for (let xt = 0; xt < ut.size(); xt++)gt[xt] = ut.get(xt) ? ot++ : 0; return new $u(He, gt, Ve, Fe, ut) } return ut ? new vx(He, Ve, Fe, ut) : new vx(He, Ve, Fe) }(F, Ze, nt, ne, q ?? je) }(C.name, _, x, C.nullable ? f - 1 : f, k); case 0: return function (F, N, G, ee, q) { const H = $n(F, N), ne = H.numValues, ae = N.get(), Ie = Fh(q) ? function (je, Ze, nt, He) { const Ve = yx(je, Math.ceil(Ze / 8), nt), Fe = new ss(Ve, Ze), dt = He.size(), ut = new ss(new Uint8Array(dt), dt); let gt = 0; for (let ot = 0; ot < He.size(); ot++) { const xt = !!He.get(ot) && Fe.get(gt++); ut.set(ot, xt) } return ut.getBuffer() }(F, ne, N, q) : Lh(F, ne, N); N.set(ae + H.byteLength); const Ue = new ss(Ie, ne); return new jS(G.name, Ue, q) }(_, x, C, 0, L); case 6: case 5: return function (F, N, G, ee, q) { const H = $n(F, N), ne = rf(H, ee, F, N), ae = q.physicalType === 5; if (ne === an.FLAT) { const Ie = Fh(ee) ? function (Ue, je, Ze, nt, He) { return function (Ve, Fe, dt, ut) { switch (Fe.logicalLevelTechnique1) { case Ot.DELTA: return Fe.logicalLevelTechnique2 === Ot.RLE && (Ve = Jv(Ve, Fe.runs, Fe.numRleValues)), function (gt, ot) { const xt = new BigInt64Array(gt.size()); let Vt = 0; gt.get(0) ? (xt[0] = gt.get(0) ? ot[0] >> 1n ^ -(1n & ot[0]) : 0n, Vt = 1) : xt[0] = 0n; let Ft = 1; for (; Ft != xt.length; ++Ft)xt[Ft] = gt.get(Ft) ? xt[Ft - 1] + (ot[Vt] >> 1n ^ -(1n & ot[Vt++])) : xt[Ft - 1]; return xt }(ut, Ve); case Ot.RLE: return function (gt, ot, xt, Vt) { const Ft = ot; return xt ? function (xr, Tn, Yr) { const wr = new BigInt64Array(xr.size()); let mr = 0; for (let Xt = 0; Xt < Yr; Xt++) { const kr = Number(Tn[Xt]); let Nr = Tn[Xt + Yr]; Nr = Nr >> 1n ^ -(1n & Nr); for (let hr = mr; hr < mr + kr; hr++)xr.get(hr) ? wr[hr] = Nr : (wr[hr] = 0n, mr++); mr += kr } return wr }(Vt, gt, Ft.runs) : function (xr, Tn, Yr) { const wr = new BigInt64Array(xr.size()); let mr = 0; for (let Xt = 0; Xt < Yr; Xt++) { const kr = Number(Tn[Xt]), Nr = Tn[Xt + Yr]; for (let hr = mr; hr < mr + kr; hr++)xr.get(hr) ? wr[hr] = Nr : (wr[hr] = 0n, mr++); mr += kr } return wr }(Vt, gt, Ft.runs) }(Ve, Fe, dt, ut); case Ot.NONE: return Ve = dt ? function (gt, ot) { const xt = new BigInt64Array(gt.size()); let Vt = 0, Ft = 0; for (; Ft != xt.length; ++Ft)if (gt.get(Ft)) { const xr = ot[Vt++]; xt[Ft] = xr >> 1n ^ -(1n & xr) } else xt[Ft] = 0n; return xt }(ut, Ve) : function (gt, ot) { const xt = new BigInt64Array(gt.size()); let Vt = 0, Ft = 0; for (; Ft != xt.length; ++Ft)xt[Ft] = gt.get(Ft) ? ot[Vt++] : 0n; return xt }(ut, Ve), Ve; default: throw new Error("The specified Logical level technique is not supported") } }(ef(Ue, je, Ze.numValues), Ze, nt, He) }(F, N, H, ae, ee) : ix(F, N, H, ae); return new ox(G.name, Ie, ee) } if (ne === an.SEQUENCE) { const Ie = nx(F, N, H); return new ax(G.name, Ie[0], Ie[1], H.numRleValues) } { const Ie = sx(F, N, H, ae); return new _x(G.name, Ie, ee) } }(_, x, C, L, M); case 7: return function (F, N, G, ee) { const q = $n(F, N), H = Fh(ee) ? function (ne, ae, Ie, Ue) { const je = ae.get(), Ze = je + Ue * Float32Array.BYTES_PER_ELEMENT, nt = new Uint8Array(ne.subarray(je, Ze)).buffer, He = new Float32Array(nt); ae.set(Ze); const Ve = Ie.size(), Fe = new Float32Array(Ve); let dt = 0; for (let ut = 0; ut < Ve; ut++)Fe[ut] = Ie.get(ut) ? He[dt++] : 0; return Fe }(F, N, ee, q.numValues) : function (ne, ae, Ie) { const Ue = ae.get(), je = Ue + Ie * Float32Array.BYTES_PER_ELEMENT, Ze = new Uint8Array(ne.subarray(Ue, je)).buffer, nt = new Float32Array(Ze); return ae.set(je), nt }(F, N, q.numValues); return new VS(G.name, H, ee) }(_, x, C, L); case 8: return function (F, N, G, ee) { const q = $n(F, N), H = Fh(ee) ? function (ne, ae, Ie, Ue) { const je = ae.get(), Ze = je + Ue * Float64Array.BYTES_PER_ELEMENT, nt = new Uint8Array(ne.subarray(je, Ze)).buffer, He = new Float64Array(nt); ae.set(Ze); const Ve = Ie.size(), Fe = new Float64Array(Ve); let dt = 0; for (let ut = 0; ut < Ve; ut++)Fe[ut] = Ie.get(ut) ? He[dt++] : 0; return Fe }(F, N, ee, q.numValues) : function (ne, ae, Ie) { const Ue = ae.get(), je = Ue + Ie * Float64Array.BYTES_PER_ELEMENT, Ze = new Uint8Array(ne.subarray(Ue, je)).buffer, nt = new Float64Array(Ze); return ae.set(je), nt }(F, N, q.numValues); return new Rg(G.name, H, ee) }(_, x, C, L); default: throw new Error(`The specified data type for the field is currently not supported: ${M}`) } }(a, n, e, u, r.scalarType, r) : a != 1 ? null : function (f, _, x, S) { let M = null, C = null, k = null, D = null, L = !1; for (; !L;) { const ee = $n(f, _); switch (ee.physicalStreamType) { case wn.LENGTH: di.DICTIONARY === ee.logicalStreamType.lengthType ? M = ia(f, _, ee) : k = ia(f, _, ee); break; case wn.DATA: is.SINGLE === ee.logicalStreamType.dictionaryType || is.SHARED === ee.logicalStreamType.dictionaryType ? (C = f.subarray(_.get(), _.get() + ee.byteLength), L = !0) : D = f.subarray(_.get(), _.get() + ee.byteLength), _.add(ee.byteLength) } } const F = x.complexType.children, N = []; let G = 0; for (const ee of F) { const q = gn(f, _, 1)[0]; if (q == 0) continue; const H = `${x.name}${ee.name === "default" ? "" : ":" + ee.name}`; if (q !== 2 || ee.type !== "scalarField" || ee.scalarField.physicalType !== 9) throw new Error("Currently only optional string fields are implemented for a struct."); const ne = $n(f, _), ae = Lh(f, ne.numValues, _), Ie = $n(f, _), Ue = Ie.decompressedCount !== S ? jg(f, _, Ie, !1, new ss(ae, ne.numValues)) : qn(f, _, Ie, !1); N[G++] = D ? new xx(H, Ue, M, C, k, D, new ss(ae, ne.numValues)) : new $u(H, Ue, M, C, new ss(ae, ne.numValues)) } return N }(n, e, r, u) } function Fh(n) { return n instanceof ss } function $S(n) { if (n.name === "id") return !1; if (n.type === "scalarType") { const e = n.scalarType; if (e.type === "physicalType") switch (e.physicalType) { case 0: case 1: case 2: case 3: case 4: case 5: case 6: case 7: case 8: default: return !1; case 9: return !0 } else if (e.type === "logicalType") return !1 } else if (n.type === "complexType") { const e = n.complexType; if (e.type === "physicalType") switch (e.physicalType) { case 0: case 1: return !0; default: return !1 } } return console.warn("Unexpected column type in hasStreamCount", n), !1 } const qS = new TextDecoder; function wx(n, e) { const r = gn(n, e, 1)[0]; if (r === 0) return ""; const a = e.get(), u = n.subarray(a, a + r); return e.add(r), qS.decode(u) } function bx(n, e) { const r = gn(n, e, 1)[0] >>> 0, a = !!(4 & r), u = !!(2 & r), p = gn(n, e, 1)[0] >>> 0, f = {}; if (1 & r && (f.nullable = !0), u) { const _ = {}; if (a ? (_.type = "logicalType", _.logicalType = p) : (_.type = "physicalType", _.physicalType = p), 8 & r) { const x = gn(n, e, 1)[0] >>> 0; _.children = new Array(x); for (let S = 0; S < x; S++)_.children[S] = bx(n, e) } f.type = "complexField", f.complexField = _ } else { const _ = {}; a ? (_.type = "logicalType", _.logicalType = p) : (_.type = "physicalType", _.physicalType = p), f.type = "scalarField", f.scalarField = _ } return f } function ZS(n, e) { const r = gn(n, e, 1)[0] >>> 0, a = function (u) { switch (u) { case 0: case 1: case 2: case 3: { const p = {}; p.nullable = !!(1 & u), p.columnScope = 0; const f = {}; return f.physicalType = u > 1 ? 6 : 4, f.type = "physicalType", p.scalarType = f, p.type = "scalarType", p } case 4: { const p = { nullable: !1, columnScope: 0 }, f = { type: "physicalType", physicalType: 0 }; return p.type = "complexType", p.complexType = f, p } case 30: { const p = { nullable: !1, columnScope: 0 }, f = { type: "physicalType", physicalType: 1 }; return p.type = "complexType", p.complexType = f, p } default: return function (p) { let f = null; switch (p) { case 10: case 11: f = 0; break; case 12: case 13: f = 1; break; case 14: case 15: f = 2; break; case 16: case 17: f = 3; break; case 18: case 19: f = 4; break; case 20: case 21: f = 5; break; case 22: case 23: f = 6; break; case 24: case 25: f = 7; break; case 26: case 27: f = 8; break; case 28: case 29: f = 9; break; default: return null }const _ = {}; _.nullable = !!(1 & p), _.columnScope = 0; const x = { type: "physicalType" }; return x.physicalType = f, _.type = "scalarType", _.scalarType = x, _ }(u) } }(r); if (!a) throw new Error(`Unsupported column type code: ${r}`); if (function (u) { return u >= 10 }(r) ? a.name = wx(n, e) : r >= 0 && r <= 3 ? a.name = "id" : r === 4 && (a.name = "geometry"), function (u) { return u === 30 }(r)) { const u = gn(n, e, 1)[0] >>> 0, p = a.complexType; p.children = new Array(u); for (let f = 0; f < u; f++)p.children[f] = bx(n, e) } return a } function WS(n, e) { const r = { featureTables: [] }, a = {}; a.name = wx(n, e); const u = gn(n, e, 1)[0] >>> 0, p = gn(n, e, 1)[0] >>> 0; a.columns = new Array(p); for (let f = 0; f < p; f++)a.columns[f] = ZS(n, e); return r.featureTables.push(a), [r, u] } function HS(n, e, r, a, u, p, f = !1) { const _ = e.scalarType.physicalType, x = rf(u, p, n, r); if (_ === 4) switch (x) { case an.FLAT: { const S = qn(n, r, u, !1); return new zg(a, S, p) } case an.SEQUENCE: { const S = rx(n, r, u); return new Lg(a, S[0], S[1], u.numRleValues) } case an.CONST: { const S = Ng(n, r, u, !1); return new Fg(a, S, p) } } else switch (x) { case an.FLAT: { if (f) { const M = function (C, k, D, L) { const F = function (N, G, ee) { const q = new Float64Array(G); for (let H = 0; H < G; H++)q[H] = RS(N, ee); return q }(C, D.numValues, k); return function (N, G, ee) { switch (G.logicalLevelTechnique1) { case Ot.DELTA: return G.logicalLevelTechnique2 === Ot.RLE && (N = ex(N, G.runs, G.numRleValues)), function (q) { q[0] = q[0] % 2 == 1 ? (q[0] + 1) / -2 : q[0] / 2; const H = q.length / 4 * 4; let ne = 1; if (H >= 4) for (; ne < H - 4; ne += 4) { const ae = q[ne], Ie = q[ne + 1], Ue = q[ne + 2], je = q[ne + 3]; q[ne] = (ae % 2 == 1 ? (ae + 1) / -2 : ae / 2) + q[ne - 1], q[ne + 1] = (Ie % 2 == 1 ? (Ie + 1) / -2 : Ie / 2) + q[ne], q[ne + 2] = (Ue % 2 == 1 ? (Ue + 1) / -2 : Ue / 2) + q[ne + 1], q[ne + 3] = (je % 2 == 1 ? (je + 1) / -2 : je / 2) + q[ne + 2] } for (; ne != q.length; ++ne)q[ne] = (q[ne] % 2 == 1 ? (q[ne] + 1) / -2 : q[ne] / 2) + q[ne - 1] }(N), N; case Ot.RLE: return function (q, H, ne) { return ex(q, H.runs, H.numRleValues) }(N, G); case Ot.NONE: return N; default: throw new Error(`The specified Logical level technique is not supported: ${G.logicalLevelTechnique1}`) } }(F, D) }(n, r, u); return new Rg(a, M, p) } const S = ix(n, r, u, !1); return new ox(a, S, p) } case an.SEQUENCE: { const S = nx(n, r, u); return new ax(a, S[0], S[1], u.numRleValues) } case an.CONST: { const S = sx(n, r, u, !1); return new _x(a, S, p) } }throw new Error("Vector type not supported for id column.") } class XS { constructor(e, r) { var a; switch (this._featureData = e, this.properties = this._featureData.properties || {}, (a = this._featureData.geometry) === null || a === void 0 ? void 0 : a.type) { case ln.POINT: case ln.MULTIPOINT: this.type = 1; break; case ln.LINESTRING: case ln.MULTILINESTRING: this.type = 2; break; case ln.POLYGON: case ln.MULTIPOLYGON: this.type = 3; break; default: this.type = 0 }this.extent = r, this.id = Number(this._featureData.id) } loadGeometry() { const e = []; for (const r of this._featureData.geometry.coordinates) { const a = []; for (const u of r) a.push(new B(u.x, u.y)); e.push(a) } return e } } class YS { constructor(e) { this.features = [], this.featureTable = e, this.name = e.name, this.extent = e.extent, this.version = 2, this.features = e.getFeatures(), this.length = this.features.length } feature(e) { return new XS(this.features[e], this.extent) } } class Tx { constructor(e) { this.layers = {}; const r = function (a, u, p = !0) { const f = new zS(0), _ = []; for (; f.get() < a.length;) { const x = gn(a, f, 1)[0] >>> 0, S = f.get() + x; if (S > a.length) throw new Error(`Block overruns tile: ${S} > ${a.length}`); if (gn(a, f, 1)[0] >>> 0 != 1) { f.set(S); continue } const M = WS(a, f), C = M[1], k = M[0].featureTables[0]; let D = null, L = null; const F = []; let N = 0; for (const ee of k.columns) { const q = ee.name; if (q === "id") { let H = null; if (ee.nullable) { const ae = $n(a, f), Ie = f.get(), Ue = Lh(a, ae.numValues, f); f.set(Ie + ae.byteLength), H = new ss(Ue, ae.numValues) } const ne = $n(a, f); N = ne.decompressedCount, D = HS(a, ee, f, q, ne, H ?? N, p) } else if (q === "geometry") { const H = gn(a, f, 1)[0]; if (N === 0) { const ne = f.get(); N = $n(a, f).decompressedCount, f.set(ne) } L = NS(a, H, f, N) } else { const H = $S(ee) ? gn(a, f, 1)[0] : 1; if (H === 0 && ee.type === "scalarType") continue; const ne = GS(a, f, ee, H, N); if (ne) if (Array.isArray(ne)) for (const ae of ne) F.push(ae); else F.push(ne) } } const G = new DS(k.name, L, D, F, C); _.push(G), f.set(S) } return _ }(new Uint8Array(e)); this.layers = r.reduce((a, u) => Object.assign(Object.assign({}, a), { [u.name]: new YS(u) }), {}) } } class KS { constructor(e, r) { this.feature = e, this.type = e.type, this.properties = e.tags ? e.tags : {}, this.extent = r, "id" in e && (typeof e.id == "string" ? this.id = parseInt(e.id, 10) : typeof e.id != "number" || isNaN(e.id) || (this.id = e.id)) } loadGeometry() { const e = [], r = this.feature.type === 1 ? [this.feature.geometry] : this.feature.geometry; for (const a of r) { const u = []; for (const p of a) u.push(new B(p[0], p[1])); e.push(u) } return e } } const Bh = "_geojsonTileLayer"; function QS(n, e) { e.writeVarintField(15, n.version || 1), e.writeStringField(1, n.name || ""), e.writeVarintField(5, n.extent || 4096); const r = { keys: [], values: [], keycache: {}, valuecache: {} }; for (let p = 0; p < n.length; p++)r.feature = n.feature(p), e.writeMessage(2, JS, r); const a = r.keys; for (const p of a) e.writeStringField(3, p); const u = r.values; for (const p of u) e.writeMessage(4, rE, p) } function JS(n, e) { if (!n.feature) return; const r = n.feature; r.id !== void 0 && e.writeVarintField(1, r.id), e.writeMessage(2, eE, n), e.writeVarintField(3, r.type), e.writeMessage(4, tE, r) } function eE(n, e) { var r; for (const a in (r = n.feature) == null ? void 0 : r.properties) { let u = n.feature.properties[a], p = n.keycache[a]; if (u == null) continue; p === void 0 && (n.keys.push(a), p = n.keys.length - 1, n.keycache[a] = p), e.writeVarint(p), typeof u != "string" && typeof u != "boolean" && typeof u != "number" && (u = JSON.stringify(u)); const f = typeof u + ":" + u; let _ = n.valuecache[f]; _ === void 0 && (n.values.push(u), _ = n.values.length - 1, n.valuecache[f] = _), e.writeVarint(_) } } function Hg(n, e) { return (e << 3) + (7 & n) } function Sx(n) { return n << 1 ^ n >> 31 } function tE(n, e) { const r = n.loadGeometry(), a = n.type; let u = 0, p = 0; for (const f of r) { let _ = 1; a === 1 && (_ = f.length), e.writeVarint(Hg(1, _)); const x = a === 3 ? f.length - 1 : f.length; for (let S = 0; S < x; S++) { S === 1 && a !== 1 && e.writeVarint(Hg(2, x - 1)); const M = f[S].x - u, C = f[S].y - p; e.writeVarint(Sx(M)), e.writeVarint(Sx(C)), u += M, p += C } n.type === 3 && e.writeVarint(Hg(7, 1)) } } function rE(n, e) { const r = typeof n; r === "string" ? e.writeStringField(1, n) : r === "boolean" ? e.writeBooleanField(7, n) : r === "number" && (n % 1 != 0 ? e.writeDoubleField(3, n) : n < 0 ? e.writeSVarintField(6, n) : e.writeVarintField(5, n)) } class Ex { constructor(e, r) { this.tileID = e, this.x = e.canonical.x, this.y = e.canonical.y, this.z = e.canonical.z, this.grid = new Ko(Se, 16, 0), this.grid3D = new Ko(Se, 16, 0), this.featureIndexArray = new U, this.promoteId = r } insert(e, r, a, u, p, f) { const _ = this.featureIndexArray.length; this.featureIndexArray.emplaceBack(a, u, p); const x = f ? this.grid3D : this.grid; for (let S = 0; S < r.length; S++) { const M = r[S], C = [1 / 0, 1 / 0, -1 / 0, -1 / 0]; for (let k = 0; k < M.length; k++) { const D = M[k]; C[0] = Math.min(C[0], D.x), C[1] = Math.min(C[1], D.y), C[2] = Math.max(C[2], D.x), C[3] = Math.max(C[3], D.y) } C[0] < Se && C[1] < Se && C[2] >= 0 && C[3] >= 0 && x.insert(_, C[0], C[1], C[2], C[3]) } } loadVTLayers() { return this.vtLayers || (this.vtLayers = this.encoding !== "mlt" ? new cv(new Hp(this.rawTileData)).layers : new Tx(this.rawTileData).layers, this.sourceLayerCoder = new Wv(this.vtLayers ? Object.keys(this.vtLayers).sort() : [Bh])), this.vtLayers } query(e, r, a, u) { this.loadVTLayers(); const p = e.params, f = Se / e.tileSize / e.scale, _ = Ha(p.filter, p.globalState), x = e.queryGeometry, S = e.queryPadding * f, M = yl.fromPoints(x), C = this.grid.query(M.minX - S, M.minY - S, M.maxX + S, M.maxY + S), k = yl.fromPoints(e.cameraQueryGeometry).expandBy(S), D = this.grid3D.query(k.minX, k.minY, k.maxX, k.maxY, (N, G, ee, q) => function (H, ne, ae, Ie, Ue) { for (const Ze of H) if (ne <= Ze.x && ae <= Ze.y && Ie >= Ze.x && Ue >= Ze.y) return !0; const je = [new B(ne, ae), new B(ne, Ue), new B(Ie, Ue), new B(Ie, ae)]; if (H.length > 2) { for (const Ze of je) if (Du(H, Ze)) return !0 } for (let Ze = 0; Ze < H.length - 1; Ze++)if (iT(H[Ze], H[Ze + 1], je)) return !0; return !1 }(e.cameraQueryGeometry, N - S, G - S, ee + S, q + S)); for (const N of D) C.push(N); C.sort(nE); const L = {}; let F; for (let N = 0; N < C.length; N++) { const G = C[N]; if (G === F) continue; F = G; const ee = this.featureIndexArray.get(G); let q = null; this.loadMatchingFeature(L, ee.bucketIndex, ee.sourceLayerIndex, ee.featureIndex, _, p.layers, p.availableImages, r, a, u, (H, ne, ae) => (q || (q = ks(H)), ne.queryIntersectsFeature({ queryGeometry: x, feature: H, featureState: ae, geometry: q, zoom: this.z, transform: e.transform, pixelsToTileUnits: f, pixelPosMatrix: e.pixelPosMatrix, unwrappedTileID: this.tileID.toUnwrapped(), getElevation: e.getElevation }))) } return L } loadMatchingFeature(e, r, a, u, p, f, _, x, S, M, C) { const k = this.bucketLayerIDs[r]; if (f && !k.some(N => f.has(N))) return; const D = this.sourceLayerCoder.decode(a), L = this.vtLayers[D].feature(u); if (p.needGeometry) { const N = Ds(L, !0); if (!p.filter(new rr(this.tileID.overscaledZ), N, this.tileID.canonical)) return } else if (!p.filter(new rr(this.tileID.overscaledZ), L)) return; const F = this.getId(L, D); for (let N = 0; N < k.length; N++) { const G = k[N]; if (f && !f.has(G)) continue; const ee = x[G]; if (!ee) continue; let q = {}; F && M && (q = M.getState(ee.sourceLayer || Bh, F)); const H = Wr({}, S[G]); H.paint = Px(H.paint, ee.paint, L, q, _), H.layout = Px(H.layout, ee.layout, L, q, _); const ne = !C || C(L, ee, q); if (!ne) continue; const ae = new Hv(L, this.z, this.x, this.y, F); ae.layer = H; let Ie = e[G]; Ie === void 0 && (Ie = e[G] = []), Ie.push({ featureIndex: u, feature: ae, intersectionZ: ne }) } } lookupSymbolFeatures(e, r, a, u, p, f, _, x) { const S = {}; this.loadVTLayers(); const M = Ha(p.filterSpec, p.globalState); for (const C of e) this.loadMatchingFeature(S, a, u, C, M, f, _, x, r); return S } hasLayer(e) { for (const r of this.bucketLayerIDs) for (const a of r) if (e === a) return !0; return !1 } getId(e, r) { var a; let u = e.id; return this.promoteId && (u = e.properties[typeof this.promoteId == "string" ? this.promoteId : this.promoteId[r]], typeof u == "boolean" && (u = Number(u)), u === void 0 && (!((a = e.properties) === null || a === void 0) && a.cluster) && this.promoteId && (u = Number(e.properties.cluster_id))), u } } function Px(n, e, r, a, u) { return In(n, (p, f) => { const _ = e instanceof al ? e.get(f) : null; return _ && _.evaluate ? _.evaluate(r, a, u) : _ }) } function nE(n, e) { return e - n } function Mx(n, e, r, a, u) { const p = []; for (let f = 0; f < n.length; f++) { const _ = n[f]; let x; for (let S = 0; S < _.length - 1; S++) { let M = _[S], C = _[S + 1]; M.x < e && C.x < e || (M.x < e ? M = new B(e, M.y + (e - M.x) / (C.x - M.x) * (C.y - M.y))._round() : C.x < e && (C = new B(e, M.y + (e - M.x) / (C.x - M.x) * (C.y - M.y))._round()), M.y < r && C.y < r || (M.y < r ? M = new B(M.x + (r - M.y) / (C.y - M.y) * (C.x - M.x), r)._round() : C.y < r && (C = new B(M.x + (r - M.y) / (C.y - M.y) * (C.x - M.x), r)._round()), M.x >= a && C.x >= a || (M.x >= a ? M = new B(a, M.y + (a - M.x) / (C.x - M.x) * (C.y - M.y))._round() : C.x >= a && (C = new B(a, M.y + (a - M.x) / (C.x - M.x) * (C.y - M.y))._round()), M.y >= u && C.y >= u || (M.y >= u ? M = new B(M.x + (u - M.y) / (C.y - M.y) * (C.x - M.x), u)._round() : C.y >= u && (C = new B(M.x + (u - M.y) / (C.y - M.y) * (C.x - M.x), u)._round()), x && M.equals(x[x.length - 1]) || (x = [M], p.push(x)), x.push(C))))) } } return p } function Ix(n, e, r, a, u) { switch (e) { case 1: return function (p, f, _, x) { const S = []; for (const M of p) for (const C of M) { const k = x === 0 ? C.x : C.y; k >= f && k <= _ && S.push([C]) } return S }(n, r, a, u); case 2: return Cx(n, r, a, u, !1); case 3: return Cx(n, r, a, u, !0) }return [] } function iE(n, e, r, a, u) { const p = a === 0 ? sE : oE; let f = []; const _ = []; for (let M = 0; M < n.length - 1; M++) { const C = n[M], k = n[M + 1], D = a === 0 ? C.x : C.y, L = a === 0 ? k.x : k.y; let F = !1; D < e ? L > e && f.push(p(C, k, e)) : D > r ? L < r && f.push(p(C, k, r)) : f.push(C), L < e && D >= e && (f.push(p(C, k, e)), F = !0), L > r && D <= r && (f.push(p(C, k, r)), F = !0), !u && F && (_.push(f), f = []) } const x = n.length - 1, S = a === 0 ? n[x].x : n[x].y; return S >= e && S <= r && f.push(n[x]), u && f.length > 0 && !f[0].equals(f[f.length - 1]) && f.push(new B(f[0].x, f[0].y)), f.length > 0 && _.push(f), _ } function Cx(n, e, r, a, u) { const p = []; for (const f of n) { const _ = iE(f, e, r, a, u); _.length > 0 && p.push(..._) } return p } function sE(n, e, r) { return new B(r, n.y + (r - n.x) / (e.x - n.x) * (e.y - n.y)) } function oE(n, e, r) { return new B(n.x + (r - n.y) / (e.y - n.y) * (e.x - n.x), r) } pt("FeatureIndex", Ex, { omit: ["rawTileData", "sourceLayerCoder"] }); class sa extends B { constructor(e, r, a, u) { super(e, r), this.angle = a, u !== void 0 && (this.segment = u) } clone() { return new sa(this.x, this.y, this.angle, this.segment) } } function Ax(n, e, r, a, u) { if (e.segment === void 0 || r === 0) return !0; let p = e, f = e.segment + 1, _ = 0; for (; _ > -r / 2;) { if (f--, f < 0) return !1; _ -= n[f].dist(p), p = n[f] } _ += n[f].dist(n[f + 1]), f++; const x = []; let S = 0; for (; _ < r / 2;) { const M = n[f], C = n[f + 1]; if (!C) return !1; let k = n[f - 1].angleTo(M) - M.angleTo(C); for (k = Math.abs((k + 3 * Math.PI) % (2 * Math.PI) - Math.PI), x.push({ distance: _, angleDelta: k }), S += k; _ - x[0].distance > a;)S -= x.shift().angleDelta; if (S > u) return !1; f++, _ += M.dist(C) } return !0 } function kx(n) { let e = 0; for (let r = 0; r < n.length - 1; r++)e += n[r].dist(n[r + 1]); return e } function Dx(n, e, r) { return n ? .6 * e * r : 0 } function zx(n, e) { return Math.max(n ? n.right - n.left : 0, e ? e.right - e.left : 0) } function aE(n, e, r, a, u, p) { const f = Dx(r, u, p), _ = zx(r, a) * p; let x = 0; const S = kx(n) / 2; for (let M = 0; M < n.length - 1; M++) { const C = n[M], k = n[M + 1], D = C.dist(k); if (x + D > S) { const L = (S - x) / D, F = _r.number(C.x, k.x, L), N = _r.number(C.y, k.y, L), G = new sa(F, N, k.angleTo(C), M); return G._round(), !f || Ax(n, G, _, f, e) ? G : void 0 } x += D } } function lE(n, e, r, a, u, p, f, _, x) { const S = Dx(a, p, f), M = zx(a, u), C = M * f, k = n[0].x === 0 || n[0].x === x || n[0].y === 0 || n[0].y === x; return e - C < e / 4 && (e = C + e / 4), Rx(n, k ? e / 2 * _ % e : (M / 2 + 2 * p) * f * _ % e, e, S, r, C, k, !1, x) } function Rx(n, e, r, a, u, p, f, _, x) { const S = p / 2, M = kx(n); let C = 0, k = e - r, D = []; for (let L = 0; L < n.length - 1; L++) { const F = n[L], N = n[L + 1], G = F.dist(N), ee = N.angleTo(F); for (; k + r < C + G;) { k += r; const q = (k - C) / G, H = _r.number(F.x, N.x, q), ne = _r.number(F.y, N.y, q); if (H >= 0 && H < x && ne >= 0 && ne < x && k - S >= 0 && k + S <= M) { const ae = new sa(H, ne, ee, L); ae._round(), a && !Ax(n, ae, p, a, u) || D.push(ae) } } C += G } return _ || D.length || f || (D = Rx(n, C / 2, r, a, u, p, f, !0, x)), D } function Lx(n, e, r, a) { const u = [], p = n.image, f = p.pixelRatio, _ = p.paddedRect.w - 2, x = p.paddedRect.h - 2; let S = { x1: n.left, y1: n.top, x2: n.right, y2: n.bottom }; const M = p.stretchX || [[0, _]], C = p.stretchY || [[0, x]], k = (Fe, dt) => Fe + dt[1] - dt[0], D = M.reduce(k, 0), L = C.reduce(k, 0), F = _ - D, N = x - L; let G = 0, ee = D, q = 0, H = L, ne = 0, ae = F, Ie = 0, Ue = N; if (p.content && a) { const Fe = p.content, dt = Fe[2] - Fe[0], ut = Fe[3] - Fe[1]; (p.textFitWidth || p.textFitHeight) && (S = Av(n)), G = af(M, 0, Fe[0]), q = af(C, 0, Fe[1]), ee = af(M, Fe[0], Fe[2]), H = af(C, Fe[1], Fe[3]), ne = Fe[0] - G, Ie = Fe[1] - q, ae = dt - ee, Ue = ut - H } const je = S.x1, Ze = S.y1, nt = S.x2 - je, He = S.y2 - Ze, Ve = (Fe, dt, ut, gt) => { const ot = lf(Fe.stretch - G, ee, nt, je), xt = uf(Fe.fixed - ne, ae, Fe.stretch, D), Vt = lf(dt.stretch - q, H, He, Ze), Ft = uf(dt.fixed - Ie, Ue, dt.stretch, L), xr = lf(ut.stretch - G, ee, nt, je), Tn = uf(ut.fixed - ne, ae, ut.stretch, D), Yr = lf(gt.stretch - q, H, He, Ze), wr = uf(gt.fixed - Ie, Ue, gt.stretch, L), mr = new B(ot, Vt), Xt = new B(xr, Vt), kr = new B(xr, Yr), Nr = new B(ot, Yr), hr = new B(xt / f, Ft / f), ei = new B(Tn / f, wr / f), Sn = e * Math.PI / 180; if (Sn) { const un = Math.sin(Sn), Sr = Math.cos(Sn), Kr = [Sr, -un, un, Sr]; mr._matMult(Kr), Xt._matMult(Kr), Nr._matMult(Kr), kr._matMult(Kr) } const ti = Fe.stretch + Fe.fixed, $i = dt.stretch + dt.fixed; return { tl: mr, tr: Xt, bl: Nr, br: kr, tex: { x: p.paddedRect.x + 1 + ti, y: p.paddedRect.y + 1 + $i, w: ut.stretch + ut.fixed - ti, h: gt.stretch + gt.fixed - $i }, writingMode: void 0, glyphOffset: [0, 0], sectionIndex: 0, pixelOffsetTL: hr, pixelOffsetBR: ei, minFontScaleX: ae / f / nt, minFontScaleY: Ue / f / He, isSDF: r } }; if (a && (p.stretchX || p.stretchY)) { const Fe = Fx(M, F, D), dt = Fx(C, N, L); for (let ut = 0; ut < Fe.length - 1; ut++) { const gt = Fe[ut], ot = Fe[ut + 1]; for (let xt = 0; xt < dt.length - 1; xt++)u.push(Ve(gt, dt[xt], ot, dt[xt + 1])) } } else u.push(Ve({ fixed: 0, stretch: -1 }, { fixed: 0, stretch: -1 }, { fixed: 0, stretch: _ + 1 }, { fixed: 0, stretch: x + 1 })); return u } function af(n, e, r) { let a = 0; for (const u of n) a += Math.max(e, Math.min(r, u[1])) - Math.max(e, Math.min(r, u[0])); return a } function Fx(n, e, r) { const a = [{ fixed: -1, stretch: 0 }]; for (const [u, p] of n) { const f = a[a.length - 1]; a.push({ fixed: u - f.stretch, stretch: f.stretch }), a.push({ fixed: u - f.stretch, stretch: f.stretch + (p - u) }) } return a.push({ fixed: e + 1, stretch: r }), a } function lf(n, e, r, a) { return n / e * r + a } function uf(n, e, r, a) { return n - e * r / a } pt("Anchor", sa); class cf { constructor(e, r, a, u, p, f, _, x, S, M) { var C; if (this.boxStartIndex = e.length, S) { let k = f.top, D = f.bottom; const L = f.collisionPadding; L && (k -= L[1], D += L[3]); let F = D - k; F > 0 && (F = Math.max(10, F), this.circleDiameter = F) } else { const k = !((C = f.image) === null || C === void 0) && C.content && (f.image.textFitWidth || f.image.textFitHeight) ? Av(f) : { x1: f.left, y1: f.top, x2: f.right, y2: f.bottom }; k.y1 = k.y1 * _ - x[0], k.y2 = k.y2 * _ + x[2], k.x1 = k.x1 * _ - x[3], k.x2 = k.x2 * _ + x[1]; const D = f.collisionPadding; if (D && (k.x1 -= D[0] * _, k.y1 -= D[1] * _, k.x2 += D[2] * _, k.y2 += D[3] * _), M) { const L = new B(k.x1, k.y1), F = new B(k.x2, k.y1), N = new B(k.x1, k.y2), G = new B(k.x2, k.y2), ee = M * Math.PI / 180; L._rotate(ee), F._rotate(ee), N._rotate(ee), G._rotate(ee), k.x1 = Math.min(L.x, F.x, N.x, G.x), k.x2 = Math.max(L.x, F.x, N.x, G.x), k.y1 = Math.min(L.y, F.y, N.y, G.y), k.y2 = Math.max(L.y, F.y, N.y, G.y) } e.emplaceBack(r.x, r.y, k.x1, k.y1, k.x2, k.y2, a, u, p) } this.boxEndIndex = e.length } } class uE { constructor(e = [], r = (a, u) => a < u ? -1 : a > u ? 1 : 0) { if (this.data = e, this.length = this.data.length, this.compare = r, this.length > 0) for (let a = (this.length >> 1) - 1; a >= 0; a--)this._down(a) } push(e) { this.data.push(e), this._up(this.length++) } pop() { if (this.length === 0) return; const e = this.data[0], r = this.data.pop(); return --this.length > 0 && (this.data[0] = r, this._down(0)), e } peek() { return this.data[0] } _up(e) { const { data: r, compare: a } = this, u = r[e]; for (; e > 0;) { const p = e - 1 >> 1, f = r[p]; if (a(u, f) >= 0) break; r[e] = f, e = p } r[e] = u } _down(e) { const { data: r, compare: a } = this, u = this.length >> 1, p = r[e]; for (; e < u;) { let f = 1 + (e << 1); const _ = f + 1; if (_ < this.length && a(r[_], r[f]) < 0 && (f = _), a(r[f], p) >= 0) break; r[e] = r[f], e = f } r[e] = p } } function cE(n, e = 1, r = !1) { const a = yl.fromPoints(n[0]), u = Math.min(a.width(), a.height()); let p = u / 2; const f = new uE([], hE), { minX: _, minY: x, maxX: S, maxY: M } = a; if (u === 0) return new B(_, x); for (let D = _; D < S; D += u)for (let L = x; L < M; L += u)f.push(new qu(D + p, L + p, p, n)); let C = function (D) { let L = 0, F = 0, N = 0; const G = D[0]; for (let ee = 0, q = G.length, H = q - 1; ee < q; H = ee++) { const ne = G[ee], ae = G[H], Ie = ne.x * ae.y - ae.x * ne.y; F += (ne.x + ae.x) * Ie, N += (ne.y + ae.y) * Ie, L += 3 * Ie } return new qu(F / L, N / L, 0, D) }(n), k = f.length; for (; f.length;) { const D = f.pop(); (D.d > C.d || !C.d) && (C = D, r && console.log("found best %d after %d probes", Math.round(1e4 * D.d) / 1e4, k)), D.max - C.d <= e || (p = D.h / 2, f.push(new qu(D.p.x - p, D.p.y - p, p, n)), f.push(new qu(D.p.x + p, D.p.y - p, p, n)), f.push(new qu(D.p.x - p, D.p.y + p, p, n)), f.push(new qu(D.p.x + p, D.p.y + p, p, n)), k += 4) } return r && (console.log(`num probes: ${k}`), console.log(`best distance: ${C.d}`)), C.p } function hE(n, e) { return e.max - n.max } function qu(n, e, r, a) { this.p = new B(n, e), this.h = r, this.d = function (u, p) { let f = !1, _ = 1 / 0; for (let x = 0; x < p.length; x++) { const S = p[x]; for (let M = 0, C = S.length, k = C - 1; M < C; k = M++) { const D = S[M], L = S[k]; D.y > u.y != L.y > u.y && u.x < (L.x - D.x) * (u.y - D.y) / (L.y - D.y) + D.x && (f = !f), _ = Math.min(_, V0(u, D, L)) } } return (f ? 1 : -1) * Math.sqrt(_) }(this.p, a), this.max = this.d + this.h * Math.SQRT2 } var bn; b.aP = void 0, (bn = b.aP || (b.aP = {}))[bn.center = 1] = "center", bn[bn.left = 2] = "left", bn[bn.right = 3] = "right", bn[bn.top = 4] = "top", bn[bn.bottom = 5] = "bottom", bn[bn["top-left"] = 6] = "top-left", bn[bn["top-right"] = 7] = "top-right", bn[bn["bottom-left"] = 8] = "bottom-left", bn[bn["bottom-right"] = 9] = "bottom-right"; const Xg = Number.POSITIVE_INFINITY; function Bx(n, e) { return e[1] !== Xg ? function (r, a, u) { let p = 0, f = 0; switch (a = Math.abs(a), u = Math.abs(u), r) { case "top-right": case "top-left": case "top": f = u - 7; break; case "bottom-right": case "bottom-left": case "bottom": f = 7 - u }switch (r) { case "top-right": case "bottom-right": case "right": p = -a; break; case "top-left": case "bottom-left": case "left": p = a }return [p, f] }(n, e[0], e[1]) : function (r, a) { let u = 0, p = 0; a < 0 && (a = 0); const f = a / Math.SQRT2; switch (r) { case "top-right": case "top-left": p = f - 7; break; case "bottom-right": case "bottom-left": p = 7 - f; break; case "bottom": p = 7 - a; break; case "top": p = a - 7 }switch (r) { case "top-right": case "bottom-right": u = -f; break; case "top-left": case "bottom-left": u = f; break; case "left": u = a; break; case "right": u = -a }return [u, p] }(n, e[0]) } function Ox(n, e, r) { var a; const u = n.layout, p = (a = u.get("text-variable-anchor-offset")) === null || a === void 0 ? void 0 : a.evaluate(e, {}, r); if (p) { const _ = p.values, x = []; for (let S = 0; S < _.length; S += 2) { const M = x[S] = _[S], C = _[S + 1].map(k => k * on); M.startsWith("top") ? C[1] -= 7 : M.startsWith("bottom") && (C[1] += 7), x[S + 1] = C } return new Dn(x) } const f = u.get("text-variable-anchor"); if (f) { let _; _ = n._unevaluatedLayout.getValue("text-radial-offset") !== void 0 ? [u.get("text-radial-offset").evaluate(e, {}, r) * on, Xg] : u.get("text-offset").evaluate(e, {}, r).map(S => S * on); const x = []; for (const S of f) x.push(S, Bx(S, _)); return new Dn(x) } return null } function Yg(n) { switch (n) { case "right": case "top-right": case "bottom-right": return "right"; case "left": case "top-left": case "bottom-left": return "left" }return "center" } function dE(n, e, r, a, u, p, f, _, x, S, M, C) { let k = p.textMaxSize.evaluate(e, {}); k === void 0 && (k = f); const D = n.layers[0].layout, L = D.get("icon-offset").evaluate(e, {}, M), F = jx(r.horizontal), N = f / 24, G = n.tilePixelRatio * N, ee = n.tilePixelRatio * k / 24, q = n.tilePixelRatio * _, H = n.tilePixelRatio * D.get("symbol-spacing"), ne = D.get("text-padding") * n.tilePixelRatio, ae = function (ut, gt, ot, xt = 1) { const Vt = ut.get("icon-padding").evaluate(gt, {}, ot), Ft = Vt && Vt.values; return [Ft[0] * xt, Ft[1] * xt, Ft[2] * xt, Ft[3] * xt] }(D, e, M, n.tilePixelRatio), Ie = D.get("text-max-angle") / 180 * Math.PI, Ue = D.get("text-rotation-alignment") !== "viewport" && D.get("symbol-placement") !== "point", je = D.get("icon-rotation-alignment") === "map" && D.get("symbol-placement") !== "point", Ze = D.get("symbol-placement"), nt = H / 2, He = D.get("icon-text-fit"); let Ve; a && He !== "none" && (n.allowVerticalPlacement && r.vertical && (Ve = kv(a, r.vertical, He, D.get("icon-text-fit-padding"), L, N)), F && (a = kv(a, F, He, D.get("icon-text-fit-padding"), L, N))); const Fe = M ? C.line.getGranularityForZoomLevel(M.z) : 1, dt = (ut, gt) => { gt.x < 0 || gt.x >= Se || gt.y < 0 || gt.y >= Se || function (ot, xt, Vt, Ft, xr, Tn, Yr, wr, mr, Xt, kr, Nr, hr, ei, Sn, ti, $i, un, Sr, Kr, Dr, cn, ho, os, jh) { const oa = ot.addToLineVertexArray(xt, Vt); let wl, Zu, Wu, Hu, $x = 0, qx = 0, Zx = 0, Wx = 0, i_ = -1, s_ = -1; const po = {}; let Hx = Or(""); if (ot.allowVerticalPlacement && Ft.vertical) { const Fn = wr.layout.get("text-rotate").evaluate(Dr, {}, os) + 90; Wu = new cf(mr, xt, Xt, kr, Nr, Ft.vertical, hr, ei, Sn, Fn), Yr && (Hu = new cf(mr, xt, Xt, kr, Nr, Yr, $i, un, Sn, Fn)) } if (xr) { const Fn = wr.layout.get("icon-rotate").evaluate(Dr, {}), ki = wr.layout.get("icon-text-fit") !== "none", bl = Lx(xr, Fn, ho, ki), ls = Yr ? Lx(Yr, Fn, ho, ki) : void 0; Zu = new cf(mr, xt, Xt, kr, Nr, xr, $i, un, !1, Fn), $x = 4 * bl.length; const Tl = ot.iconSizeData; let zs = null; Tl.kind === "source" ? (zs = [uo * wr.layout.get("icon-size").evaluate(Dr, {})], zs[0] > ra && qt(`${ot.layerIds[0]}: Value for "icon-size" is >= 255. Reduce your "icon-size".`)) : Tl.kind === "composite" && (zs = [uo * cn.compositeIconSizes[0].evaluate(Dr, {}, os), uo * cn.compositeIconSizes[1].evaluate(Dr, {}, os)], (zs[0] > ra || zs[1] > ra) && qt(`${ot.layerIds[0]}: Value for "icon-size" is >= 255. Reduce your "icon-size".`)), ot.addSymbols(ot.icon, bl, zs, Kr, Sr, Dr, b.az.none, xt, oa.lineStartIndex, oa.lineLength, -1, os), i_ = ot.icon.placedSymbolArray.length - 1, ls && (qx = 4 * ls.length, ot.addSymbols(ot.icon, ls, zs, Kr, Sr, Dr, b.az.vertical, xt, oa.lineStartIndex, oa.lineLength, -1, os), s_ = ot.icon.placedSymbolArray.length - 1) } const Xx = Object.keys(Ft.horizontal); for (const Fn of Xx) { const ki = Ft.horizontal[Fn]; if (!wl) { Hx = Or(ki.text); const ls = wr.layout.get("text-rotate").evaluate(Dr, {}, os); wl = new cf(mr, xt, Xt, kr, Nr, ki, hr, ei, Sn, ls) } const bl = ki.positionedLines.length === 1; if (Zx += Nx(ot, xt, ki, Tn, wr, Sn, Dr, ti, oa, Ft.vertical ? b.az.horizontal : b.az.horizontalOnly, bl ? Xx : [Fn], po, i_, cn, os), bl) break } Ft.vertical && (Wx += Nx(ot, xt, Ft.vertical, Tn, wr, Sn, Dr, ti, oa, b.az.vertical, ["vertical"], po, s_, cn, os)); const mE = wl ? wl.boxStartIndex : ot.collisionBoxArray.length, gE = wl ? wl.boxEndIndex : ot.collisionBoxArray.length, _E = Wu ? Wu.boxStartIndex : ot.collisionBoxArray.length, yE = Wu ? Wu.boxEndIndex : ot.collisionBoxArray.length, vE = Zu ? Zu.boxStartIndex : ot.collisionBoxArray.length, xE = Zu ? Zu.boxEndIndex : ot.collisionBoxArray.length, wE = Hu ? Hu.boxStartIndex : ot.collisionBoxArray.length, bE = Hu ? Hu.boxEndIndex : ot.collisionBoxArray.length; let as = -1; const df = (Fn, ki) => Fn && Fn.circleDiameter ? Math.max(Fn.circleDiameter, ki) : ki; as = df(wl, as), as = df(Wu, as), as = df(Zu, as), as = df(Hu, as); const Yx = as > -1 ? 1 : 0; Yx && (as *= jh / on), ot.glyphOffsetArray.length >= Nu.MAX_GLYPHS && qt("Too many glyphs being rendered in a tile. See https://github.com/mapbox/mapbox-gl-js/issues/2907"), Dr.sortKey !== void 0 && ot.addToSortKeyRanges(ot.symbolInstances.length, Dr.sortKey); const TE = Ox(wr, Dr, os), [SE, EE] = function (Fn, ki) { const bl = Fn.length, ls = ki == null ? void 0 : ki.values; if ((ls == null ? void 0 : ls.length) > 0) for (let Tl = 0; Tl < ls.length; Tl += 2) { const zs = ls[Tl + 1]; Fn.emplaceBack(b.aP[ls[Tl]], zs[0], zs[1]) } return [bl, Fn.length] }(ot.textAnchorOffsets, TE); ot.symbolInstances.emplaceBack(xt.x, xt.y, po.right >= 0 ? po.right : -1, po.center >= 0 ? po.center : -1, po.left >= 0 ? po.left : -1, po.vertical || -1, i_, s_, Hx, mE, gE, _E, yE, vE, xE, wE, bE, Xt, Zx, Wx, $x, qx, Yx, 0, hr, as, SE, EE) }(n, gt, ut, r, a, u, Ve, n.layers[0], n.collisionBoxArray, e.index, e.sourceLayerIndex, n.index, G, [ne, ne, ne, ne], Ue, x, q, ae, je, L, e, p, S, M, f) }; if (Ze === "line") for (const ut of Mx(e.geometry, 0, 0, Se, Se)) { const gt = _l(ut, Fe), ot = lE(gt, H, Ie, r.vertical || F, a, 24, ee, n.overscaling, Se); for (const xt of ot) F && pE(n, F.text, nt, xt) || dt(gt, xt) } else if (Ze === "line-center") { for (const ut of e.geometry) if (ut.length > 1) { const gt = _l(ut, Fe), ot = aE(gt, Ie, r.vertical || F, a, 24, ee); ot && dt(gt, ot) } } else if (e.type === "Polygon") for (const ut of Jl(e.geometry, 0)) { const gt = cE(ut, 16); dt(_l(ut[0], Fe, !0), new sa(gt.x, gt.y, 0)) } else if (e.type === "LineString") for (const ut of e.geometry) { const gt = _l(ut, Fe); dt(gt, new sa(gt[0].x, gt[0].y, 0)) } else if (e.type === "Point") for (const ut of e.geometry) for (const gt of ut) dt([gt], new sa(gt.x, gt.y, 0)) } function Nx(n, e, r, a, u, p, f, _, x, S, M, C, k, D, L) { const F = function (ee, q, H, ne, ae, Ie, Ue, je) { const Ze = ne.layout.get("text-rotate").evaluate(Ie, {}) * Math.PI / 180, nt = []; for (const He of q.positionedLines) for (const Ve of He.positionedGlyphs) { if (!Ve.rect) continue; const Fe = Ve.rect || {}; let dt = 4, ut = !0, gt = 1, ot = 0; const xt = (ae || je) && Ve.vertical, Vt = Ve.metrics.advance * Ve.scale / 2; if (je && q.verticalizable && (ot = He.lineOffset / 2 - (Ve.imageName ? -(on - Ve.metrics.width * Ve.scale) / 2 : (Ve.scale - 1) * on)), Ve.imageName) { const un = Ue[Ve.imageName]; ut = un.sdf, gt = un.pixelRatio, dt = 1 / gt } const Ft = ae ? [Ve.x + Vt, Ve.y] : [0, 0]; let xr = ae ? [0, 0] : [Ve.x + Vt + H[0], Ve.y + H[1] - ot], Tn = [0, 0]; xt && (Tn = xr, xr = [0, 0]); const Yr = Ve.metrics.isDoubleResolution ? 2 : 1, wr = (Ve.metrics.left - dt) * Ve.scale - Vt + xr[0], mr = (-Ve.metrics.top - dt) * Ve.scale + xr[1], Xt = wr + Fe.w / Yr * Ve.scale / gt, kr = mr + Fe.h / Yr * Ve.scale / gt, Nr = new B(wr, mr), hr = new B(Xt, mr), ei = new B(wr, kr), Sn = new B(Xt, kr); if (xt) { const un = new B(-Vt, Vt - -17), Sr = -Math.PI / 2, Kr = 12 - Vt, Dr = new B(22 - Kr, -(Ve.imageName ? Kr : 0)), cn = new B(...Tn); Nr._rotateAround(Sr, un)._add(Dr)._add(cn), hr._rotateAround(Sr, un)._add(Dr)._add(cn), ei._rotateAround(Sr, un)._add(Dr)._add(cn), Sn._rotateAround(Sr, un)._add(Dr)._add(cn) } if (Ze) { const un = Math.sin(Ze), Sr = Math.cos(Ze), Kr = [Sr, -un, un, Sr]; Nr._matMult(Kr), hr._matMult(Kr), ei._matMult(Kr), Sn._matMult(Kr) } const ti = new B(0, 0), $i = new B(0, 0); nt.push({ tl: Nr, tr: hr, bl: ei, br: Sn, tex: Fe, writingMode: q.writingMode, glyphOffset: Ft, sectionIndex: Ve.sectionIndex, isSDF: ut, pixelOffsetTL: ti, pixelOffsetBR: $i, minFontScaleX: 0, minFontScaleY: 0 }) } return nt }(0, r, _, u, p, f, a, n.allowVerticalPlacement), N = n.textSizeData; let G = null; N.kind === "source" ? (G = [uo * u.layout.get("text-size").evaluate(f, {})], G[0] > ra && qt(`${n.layerIds[0]}: Value for "text-size" is >= 255. Reduce your "text-size".`)) : N.kind === "composite" && (G = [uo * D.compositeTextSizes[0].evaluate(f, {}, L), uo * D.compositeTextSizes[1].evaluate(f, {}, L)], (G[0] > ra || G[1] > ra) && qt(`${n.layerIds[0]}: Value for "text-size" is >= 255. Reduce your "text-size".`)), n.addSymbols(n.text, F, G, _, p, f, S, e, x.lineStartIndex, x.lineLength, k, L); for (const ee of M) C[ee] = n.text.placedSymbolArray.length - 1; return 4 * F.length } function jx(n) { for (const e in n) return n[e]; return null } function pE(n, e, r, a) { const u = n.compareText; if (e in u) { const p = u[e]; for (let f = p.length - 1; f >= 0; f--)if (a.dist(p[f]) < r) return !0 } else u[e] = []; return u[e].push(a), !1 } const Vx = [Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array]; class Kg { static from(e) { if (!(e instanceof ArrayBuffer)) throw new Error("Data must be an instance of ArrayBuffer."); const [r, a] = new Uint8Array(e, 0, 2); if (r !== 219) throw new Error("Data does not appear to be in a KDBush format."); const u = a >> 4; if (u !== 1) throw new Error(`Got v${u} data when expected v1.`); const p = Vx[15 & a]; if (!p) throw new Error("Unrecognized array type."); const [f] = new Uint16Array(e, 2, 1), [_] = new Uint32Array(e, 4, 1); return new Kg(_, f, p, e) } constructor(e, r = 64, a = Float64Array, u) { if (isNaN(e) || e < 0) throw new Error(`Unpexpected numItems value: ${e}.`); this.numItems = +e, this.nodeSize = Math.min(Math.max(+r, 2), 65535), this.ArrayType = a, this.IndexArrayType = e < 65536 ? Uint16Array : Uint32Array; const p = Vx.indexOf(this.ArrayType), f = 2 * e * this.ArrayType.BYTES_PER_ELEMENT, _ = e * this.IndexArrayType.BYTES_PER_ELEMENT, x = (8 - _ % 8) % 8; if (p < 0) throw new Error(`Unexpected typed array class: ${a}.`); u && u instanceof ArrayBuffer ? (this.data = u, this.ids = new this.IndexArrayType(this.data, 8, e), this.coords = new this.ArrayType(this.data, 8 + _ + x, 2 * e), this._pos = 2 * e, this._finished = !0) : (this.data = new ArrayBuffer(8 + f + _ + x), this.ids = new this.IndexArrayType(this.data, 8, e), this.coords = new this.ArrayType(this.data, 8 + _ + x, 2 * e), this._pos = 0, this._finished = !1, new Uint8Array(this.data, 0, 2).set([219, 16 + p]), new Uint16Array(this.data, 2, 1)[0] = r, new Uint32Array(this.data, 4, 1)[0] = e) } add(e, r) { const a = this._pos >> 1; return this.ids[a] = a, this.coords[this._pos++] = e, this.coords[this._pos++] = r, a } finish() { const e = this._pos >> 1; if (e !== this.numItems) throw new Error(`Added ${e} items when expected ${this.numItems}.`); return Qg(this.ids, this.coords, this.nodeSize, 0, this.numItems - 1, 0), this._finished = !0, this } range(e, r, a, u) { if (!this._finished) throw new Error("Data not yet indexed - call index.finish()."); const { ids: p, coords: f, nodeSize: _ } = this, x = [0, p.length - 1, 0], S = []; for (; x.length;) { const M = x.pop() || 0, C = x.pop() || 0, k = x.pop() || 0; if (C - k <= _) { for (let N = k; N <= C; N++) { const G = f[2 * N], ee = f[2 * N + 1]; G >= e && G <= a && ee >= r && ee <= u && S.push(p[N]) } continue } const D = k + C >> 1, L = f[2 * D], F = f[2 * D + 1]; L >= e && L <= a && F >= r && F <= u && S.push(p[D]), (M === 0 ? e <= L : r <= F) && (x.push(k), x.push(D - 1), x.push(1 - M)), (M === 0 ? a >= L : u >= F) && (x.push(D + 1), x.push(C), x.push(1 - M)) } return S } within(e, r, a) { if (!this._finished) throw new Error("Data not yet indexed - call index.finish()."); const { ids: u, coords: p, nodeSize: f } = this, _ = [0, u.length - 1, 0], x = [], S = a * a; for (; _.length;) { const M = _.pop() || 0, C = _.pop() || 0, k = _.pop() || 0; if (C - k <= f) { for (let N = k; N <= C; N++)Gx(p[2 * N], p[2 * N + 1], e, r) <= S && x.push(u[N]); continue } const D = k + C >> 1, L = p[2 * D], F = p[2 * D + 1]; Gx(L, F, e, r) <= S && x.push(u[D]), (M === 0 ? e - a <= L : r - a <= F) && (_.push(k), _.push(D - 1), _.push(1 - M)), (M === 0 ? e + a >= L : r + a >= F) && (_.push(D + 1), _.push(C), _.push(1 - M)) } return x } } function Qg(n, e, r, a, u, p) { if (u - a <= r) return; const f = a + u >> 1; Ux(n, e, f, a, u, p), Qg(n, e, r, a, f - 1, 1 - p), Qg(n, e, r, f + 1, u, 1 - p) } function Ux(n, e, r, a, u, p) { for (; u > a;) { if (u - a > 600) { const S = u - a + 1, M = r - a + 1, C = Math.log(S), k = .5 * Math.exp(2 * C / 3), D = .5 * Math.sqrt(C * k * (S - k) / S) * (M - S / 2 < 0 ? -1 : 1); Ux(n, e, r, Math.max(a, Math.floor(r - M * k / S + D)), Math.min(u, Math.floor(r + (S - M) * k / S + D)), p) } const f = e[2 * r + p]; let _ = a, x = u; for (Oh(n, e, a, r), e[2 * u + p] > f && Oh(n, e, a, u); _ < x;) { for (Oh(n, e, _, x), _++, x--; e[2 * _ + p] < f;)_++; for (; e[2 * x + p] > f;)x-- } e[2 * a + p] === f ? Oh(n, e, a, x) : (x++, Oh(n, e, x, u)), x <= r && (a = x + 1), r <= x && (u = x - 1) } } function Oh(n, e, r, a) { Jg(n, r, a), Jg(e, 2 * r, 2 * a), Jg(e, 2 * r + 1, 2 * a + 1) } function Jg(n, e, r) { const a = n[e]; n[e] = n[r], n[r] = a } function Gx(n, e, r, a) { const u = n - r, p = e - a; return u * u + p * p } var e_; b.cH = void 0, (e_ = b.cH || (b.cH = {})).create = "create", e_.load = "load", e_.fullLoad = "fullLoad"; let hf = null, Nh = []; const t_ = 1e3 / 60, r_ = "loadTime", n_ = "fullLoadTime", fE = { mark(n) { performance.mark(n) }, frame(n) { const e = n; hf != null && Nh.push(e - hf), hf = e }, clearMetrics() { hf = null, Nh = [], performance.clearMeasures(r_), performance.clearMeasures(n_); for (const n in b.cH) performance.clearMarks(b.cH[n]) }, getPerformanceMetrics() { performance.measure(r_, b.cH.create, b.cH.load), performance.measure(n_, b.cH.create, b.cH.fullLoad); const n = performance.getEntriesByName(r_)[0].duration, e = performance.getEntriesByName(n_)[0].duration, r = Nh.length, a = 1 / (Nh.reduce((p, f) => p + f, 0) / r / 1e3), u = Nh.filter(p => p > t_).reduce((p, f) => p + (f - t_) / t_, 0); return { loadTime: n, fullLoadTime: e, fps: a, percentDroppedFrames: u / (r + u) * 100, totalFrames: r } } }; b.$ = ye, b.A = ve, b.B = Yo, b.C = nn, b.D = vt, b.E = Wt, b.F = function ([n, e, r]) { return e += 90, e *= Math.PI / 180, r *= Math.PI / 180, { x: n * Math.cos(e) * Math.sin(r), y: n * Math.sin(e) * Math.sin(r), z: n * Math.cos(r) } }, b.G = _r, b.H = rr, b.I = Tg, b.J = Ip, b.K = function (n) { if (Pr == null) { const e = n.navigator ? n.navigator.userAgent : null; Pr = !!n.safari || !(!e || !(/\b(iPad|iPhone|iPod)\b/.test(e) || e.match("Safari") && !e.match("Chrome"))) } return Pr }, b.L = class { constructor(n, e) { this.target = n, this.mapId = e, this.resolveRejects = {}, this.tasks = {}, this.taskQueue = [], this.abortControllers = {}, this.messageHandlers = {}, this.invoker = new CS(() => this.process()), this.subscription = Mo(this.target, "message", r => this.receive(r), !1), this.globalScope = Ni(self) ? n : window } registerMessageHandler(n, e) { this.messageHandlers[n] = e } unregisterMessageHandler(n) { delete this.messageHandlers[n] } sendAsync(n, e) { return new Promise((r, a) => { const u = Math.round(1e18 * Math.random()).toString(36).substring(0, 10), p = e ? Mo(e.signal, "abort", () => { p == null || p.unsubscribe(), delete this.resolveRejects[u]; const x = { id: u, type: "<cancel>", origin: location.origin, targetMapId: n.targetMapId, sourceMapId: this.mapId }; this.target.postMessage(x) }, AS) : null; this.resolveRejects[u] = { resolve: x => { p == null || p.unsubscribe(), r(x) }, reject: x => { p == null || p.unsubscribe(), a(x) } }; const f = [], _ = Object.assign(Object.assign({}, n), { id: u, sourceMapId: this.mapId, origin: location.origin, data: nl(n.data, f) }); this.target.postMessage(_, { transfer: f }) }) } receive(n) { const e = n.data, r = e.id; if (!(e.origin !== "file://" && location.origin !== "file://" && e.origin !== "resource://android" && location.origin !== "resource://android" && e.origin !== location.origin || e.targetMapId && this.mapId !== e.targetMapId)) { if (e.type === "<cancel>") { delete this.tasks[r]; const a = this.abortControllers[r]; return delete this.abortControllers[r], void (a && a.abort()) } if (Ni(self) || e.mustQueue) return this.tasks[r] = e, this.taskQueue.push(r), void this.invoker.trigger(); this.processTask(r, e) } } process() { if (this.taskQueue.length === 0) return; const n = this.taskQueue.shift(), e = this.tasks[n]; delete this.tasks[n], this.taskQueue.length > 0 && this.invoker.trigger(), e && this.processTask(n, e) } processTask(n, e) { return c(this, void 0, void 0, function* () { if (e.type === "<response>") { const u = this.resolveRejects[n]; return delete this.resolveRejects[n], u ? void (e.error ? u.reject(il(e.error)) : u.resolve(il(e.data))) : void 0 } if (!this.messageHandlers[e.type]) return void this.completeTask(n, new Error(`Could not find a registered handler for ${e.type}, map ID: ${this.mapId}, available handlers: ${Object.keys(this.messageHandlers).join(", ")}`)); const r = il(e.data), a = new AbortController; this.abortControllers[n] = a; try { const u = yield this.messageHandlers[e.type](e.sourceMapId, r, a); this.completeTask(n, null, u) } catch (u) { this.completeTask(n, u) } }) } completeTask(n, e, r) { const a = []; delete this.abortControllers[n]; const u = { id: n, type: "<response>", sourceMapId: this.mapId, origin: location.origin, error: e ? nl(e) : null, data: nl(r, a) }; this.target.postMessage(u, { transfer: a }) } remove() { this.invoker.remove(), this.subscription.unsubscribe() } }, b.M = Ee, b.N = function () { var n = new ve(16); return ve != Float32Array && (n[1] = 0, n[2] = 0, n[3] = 0, n[4] = 0, n[6] = 0, n[7] = 0, n[8] = 0, n[9] = 0, n[11] = 0, n[12] = 0, n[13] = 0, n[14] = 0), n[0] = 1, n[5] = 1, n[10] = 1, n[15] = 1, n }, b.O = function (n, e, r) { var a, u, p, f, _, x, S, M, C, k, D, L, F = r[0], N = r[1], G = r[2]; return e === n ? (n[12] = e[0] * F + e[4] * N + e[8] * G + e[12], n[13] = e[1] * F + e[5] * N + e[9] * G + e[13], n[14] = e[2] * F + e[6] * N + e[10] * G + e[14], n[15] = e[3] * F + e[7] * N + e[11] * G + e[15]) : (u = e[1], p = e[2], f = e[3], _ = e[4], x = e[5], S = e[6], M = e[7], C = e[8], k = e[9], D = e[10], L = e[11], n[0] = a = e[0], n[1] = u, n[2] = p, n[3] = f, n[4] = _, n[5] = x, n[6] = S, n[7] = M, n[8] = C, n[9] = k, n[10] = D, n[11] = L, n[12] = a * F + _ * N + C * G + e[12], n[13] = u * F + x * N + k * G + e[13], n[14] = p * F + S * N + D * G + e[14], n[15] = f * F + M * N + L * G + e[15]), n }, b.P = B, b.Q = function (n, e, r) { var a = r[0], u = r[1], p = r[2]; return n[0] = e[0] * a, n[1] = e[1] * a, n[2] = e[2] * a, n[3] = e[3] * a, n[4] = e[4] * u, n[5] = e[5] * u, n[6] = e[6] * u, n[7] = e[7] * u, n[8] = e[8] * p, n[9] = e[9] * p, n[10] = e[10] * p, n[11] = e[11] * p, n[12] = e[12], n[13] = e[13], n[14] = e[14], n[15] = e[15], n }, b.R = Jn, b.S = function (n, e, r) { var a = e[0], u = e[1], p = e[2], f = e[3], _ = e[4], x = e[5], S = e[6], M = e[7], C = e[8], k = e[9], D = e[10], L = e[11], F = e[12], N = e[13], G = e[14], ee = e[15], q = r[0], H = r[1], ne = r[2], ae = r[3]; return n[0] = q * a + H * _ + ne * C + ae * F, n[1] = q * u + H * x + ne * k + ae * N, n[2] = q * p + H * S + ne * D + ae * G, n[3] = q * f + H * M + ne * L + ae * ee, n[4] = (q = r[4]) * a + (H = r[5]) * _ + (ne = r[6]) * C + (ae = r[7]) * F, n[5] = q * u + H * x + ne * k + ae * N, n[6] = q * p + H * S + ne * D + ae * G, n[7] = q * f + H * M + ne * L + ae * ee, n[8] = (q = r[8]) * a + (H = r[9]) * _ + (ne = r[10]) * C + (ae = r[11]) * F, n[9] = q * u + H * x + ne * k + ae * N, n[10] = q * p + H * S + ne * D + ae * G, n[11] = q * f + H * M + ne * L + ae * ee, n[12] = (q = r[12]) * a + (H = r[13]) * _ + (ne = r[14]) * C + (ae = r[15]) * F, n[13] = q * u + H * x + ne * k + ae * N, n[14] = q * p + H * S + ne * D + ae * G, n[15] = q * f + H * M + ne * L + ae * ee, n }, b.T = fg, b.U = function (n, e) { const r = {}; for (let a = 0; a < e.length; a++) { const u = e[a]; u in n && (r[u] = n[u]) } return r }, b.V = na, b.W = Yt, b.X = jv, b.Y = Nv, b.Z = ue, b._ = c, b.a = W, b.a$ = ie, b.a0 = be, b.a1 = Po, b.a2 = Ci, b.a3 = Uv, b.a4 = Qp, b.a5 = Se, b.a6 = function (n, e, r) { if (!n) return e || {}; if (!e) return n || {}; const a = Zv(n), u = Zv(e); (function (f, _) { _.removeAll && (f.add.clear(), f.update.clear(), f.remove.clear(), _.remove.clear()); for (const x of _.remove) f.add.delete(x), f.update.delete(x); for (const [x, S] of _.update) { const M = f.update.get(x); M && (_.update.set(x, kS(M, S)), f.update.delete(x)) } })(a, u); const p = {}; if ((a.removeAll || u.removeAll) && (p.removeAll = !0), p.remove = new Set([...a.remove, ...u.remove]), p.add = new Map([...a.add, ...u.add]), p.update = new Map([...a.update, ...u.update]), p.remove.size && p.add.size) for (const f of p.add.keys()) p.remove.delete(f); return function (f) { const _ = {}; return f.removeAll && (_.removeAll = f.removeAll), f.remove && (_.remove = Array.from(f.remove)), f.add && (_.add = Array.from(f.add.values())), f.update && (_.update = Array.from(f.update.values())), _ }(p) }, b.a7 = function (n, e) { const r = new Map; if (n == null || n.type == null) return r; if (n.type === "Feature") { const a = Dg(n, e); return a == null ? void 0 : (r.set(a, n), r) } if (n.type === "FeatureCollection") { const a = new Set; for (const u of n.features) { const p = Dg(u, e); if (p == null || a.has(p)) return; a.add(p), r.set(p, u) } return r } }, b.a8 = function (n, e, r) { var a, u; const p = []; if (e.removeAll) n.clear(); else if (e.remove) for (const f of e.remove) { const _ = n.get(f); _ && (p.push(_.geometry), n.delete(f)) } if (e.add) for (const f of e.add) { const _ = Dg(f, r); if (_ == null) continue; const x = n.get(_); x && p.push(x.geometry), p.push(f.geometry), n.set(_, f) } if (e.update) for (const f of e.update) { const _ = n.get(f.id); if (!_) continue; const x = !!f.newGeometry, S = f.removeAllProperties || ((a = f.removeProperties) === null || a === void 0 ? void 0 : a.length) > 0 || ((u = f.addOrUpdateProperties) === null || u === void 0 ? void 0 : u.length) > 0; if (!x && !S) continue; p.push(_.geometry); const M = Object.assign({}, _); if (n.set(f.id, M), x && (p.push(f.newGeometry), M.geometry = f.newGeometry), S) { if (M.properties = f.removeAllProperties ? {} : Object.assign({}, M.properties || {}), f.removeProperties) for (const C of f.removeProperties) delete M.properties[C]; if (f.addOrUpdateProperties) for (const { key: C, value: k } of f.addOrUpdateProperties) M.properties[C] = k } } return p }, b.a9 = Rh, b.aA = function (n, { uSize: e, uSizeT: r }, { lowerSize: a, upperSize: u }) { return n.kind === "source" ? a / uo : n.kind === "composite" ? _r.number(a / uo, u / uo, r) : e }, b.aB = function (n, e) { var r = e[0], a = e[1], u = e[2], p = e[3], f = e[4], _ = e[5], x = e[6], S = e[7], M = e[8], C = e[9], k = e[10], D = e[11], L = e[12], F = e[13], N = e[14], G = e[15], ee = r * _ - a * f, q = r * x - u * f, H = r * S - p * f, ne = a * x - u * _, ae = a * S - p * _, Ie = u * S - p * x, Ue = M * F - C * L, je = M * N - k * L, Ze = M * G - D * L, nt = C * N - k * F, He = C * G - D * F, Ve = k * G - D * N, Fe = ee * Ve - q * He + H * nt + ne * Ze - ae * je + Ie * Ue; return Fe ? (n[0] = (_ * Ve - x * He + S * nt) * (Fe = 1 / Fe), n[1] = (u * He - a * Ve - p * nt) * Fe, n[2] = (F * Ie - N * ae + G * ne) * Fe, n[3] = (k * ae - C * Ie - D * ne) * Fe, n[4] = (x * Ze - f * Ve - S * je) * Fe, n[5] = (r * Ve - u * Ze + p * je) * Fe, n[6] = (N * H - L * Ie - G * q) * Fe, n[7] = (M * Ie - k * H + D * q) * Fe, n[8] = (f * He - _ * Ze + S * Ue) * Fe, n[9] = (a * Ze - r * He - p * Ue) * Fe, n[10] = (L * ae - F * H + G * ee) * Fe, n[11] = (C * H - M * ae - D * ee) * Fe, n[12] = (_ * je - f * nt - x * Ue) * Fe, n[13] = (r * nt - a * je + u * Ue) * Fe, n[14] = (F * q - L * ne - N * ee) * Fe, n[15] = (M * ne - C * q + k * ee) * Fe, n) : null }, b.aC = Le, b.aD = function (n) { var e = n[0], r = n[1]; return Math.sqrt(e * e + r * r) }, b.aE = function (n) { return n[0] = 0, n[1] = 0, n }, b.aF = function (n, e, r) { return n[0] = e[0] * r, n[1] = e[1] * r, n }, b.aG = Pg, b.aH = Ne, b.aI = function (n, e, r, a) { const u = e.y - n.y, p = e.x - n.x, f = a.y - r.y, _ = a.x - r.x, x = f * p - _ * u; if (x === 0) return null; const S = (_ * (n.y - r.y) - f * (n.x - r.x)) / x; return new B(n.x + S * p, n.y + S * u) }, b.aJ = Mx, b.aK = ku, b.aL = function (n) { let e = 1 / 0, r = 1 / 0, a = -1 / 0, u = -1 / 0; for (const p of n) e = Math.min(e, p.x), r = Math.min(r, p.y), a = Math.max(a, p.x), u = Math.max(u, p.y); return [e, r, a, u] }, b.aM = on, b.aN = et, b.aO = function (n, e, r, a, u = !1) { if (!r[0] && !r[1]) return [0, 0]; const p = u ? a === "map" ? -n.bearingInRadians : 0 : a === "viewport" ? n.bearingInRadians : 0; if (p) { const f = Math.sin(p), _ = Math.cos(p); r = [r[0] * _ - r[1] * f, r[0] * f + r[1] * _] } return [u ? r[0] : et(e, r[0], n.zoom), u ? r[1] : et(e, r[1], n.zoom)] }, b.aQ = Eg, b.aR = Yg, b.aS = Sg, b.aT = Kg, b.aU = Br, b.aV = Zp, b.aW = X, b.aX = it, b.aY = Re, b.aZ = jn, b.a_ = Gv, b.aa = yl, b.ab = 25, b.ac = kg, b.ad = n => { const e = window.document.createElement("video"); return e.muted = !0, new Promise(r => { e.onloadstart = () => { r(e) }; for (const a of n) { const u = window.document.createElement("source"); qe(a) || (e.crossOrigin = "Anonymous"), u.src = a, e.appendChild(u) } }) }, b.ae = Qe, b.af = function () { return vi++ }, b.ag = d, b.ah = Nu, b.ai = Bh, b.aj = Ha, b.ak = Ds, b.al = Hv, b.am = function (n) { const e = {}; if (n.replace(/(?:^|(?:\s*\,\s*))([^\x00-\x20\(\)<>@\,;\:\\"\/\[\]\?\=\{\}\x7F]+)(?:\=(?:([^\x00-\x20\(\)<>@\,;\:\\"\/\[\]\?\=\{\}\x7F]+)|(?:\"((?:[^"\\]|\\.)*)\")))?/g, (r, a, u, p) => { const f = u || p; return e[a] = !f || f.toLowerCase(), "" }), e["max-age"]) { const r = parseInt(e["max-age"], 10); isNaN(r) ? delete e["max-age"] : e["max-age"] = r } return e }, b.an = Ct, b.ao = 85.051129, b.ap = Io, b.aq = function (n) { return Math.pow(2, n) }, b.ar = ft, b.as = Vv, b.at = function (n) { return Math.log(n) / Math.LN2 }, b.au = function (n) { var e = n[0], r = n[1]; return e * e + r * r }, b.av = function (n) { if (!n.length) return new Set; const e = Math.max(...n.map(x => x.canonical.z)); let r = 1 / 0, a = -1 / 0, u = 1 / 0, p = -1 / 0; const f = []; for (const x of n) { const { x: S, y: M, z: C } = x.canonical, k = Math.pow(2, e - C), D = S * k, L = M * k; f.push({ id: x, x: D, y: L }), D < r && (r = D), D > a && (a = D), L < u && (u = L), L > p && (p = L) } const _ = new Set; for (const x of f) x.x !== r && x.x !== a && x.y !== u && x.y !== p || _.add(x.id); return _ }, b.aw = function (n, e) { const r = Math.abs(2 * n.wrap) - +(n.wrap < 0), a = Math.abs(2 * e.wrap) - +(e.wrap < 0); return n.overscaledZ - e.overscaledZ || a - r || e.canonical.y - n.canonical.y || e.canonical.x - n.canonical.x }, b.ax = class { constructor(n, e) { this.max = n, this.onRemove = e, this.reset() } reset() { for (const n in this.data) for (const e of this.data[n]) e.timeout && clearTimeout(e.timeout), this.onRemove(e.value); return this.data = {}, this.order = [], this } add(n, e, r) { const a = n.wrapped().key; this.data[a] === void 0 && (this.data[a] = []); const u = { value: e, timeout: void 0 }; if (r !== void 0 && (u.timeout = setTimeout(() => { this.remove(n, u) }, r)), this.data[a].push(u), this.order.push(a), this.order.length > this.max) { const p = this._getAndRemoveByKey(this.order[0]); p && this.onRemove(p) } return this } has(n) { return n.wrapped().key in this.data } getAndRemove(n) { return this.has(n) ? this._getAndRemoveByKey(n.wrapped().key) : null } _getAndRemoveByKey(n) { const e = this.data[n].shift(); return e.timeout && clearTimeout(e.timeout), this.data[n].length === 0 && delete this.data[n], this.order.splice(this.order.indexOf(n), 1), e.value } getByKey(n) { const e = this.data[n]; return e ? e[0].value : null } get(n) { return this.has(n) ? this.data[n.wrapped().key][0].value : null } remove(n, e) { if (!this.has(n)) return this; const r = n.wrapped().key, a = e === void 0 ? 0 : this.data[r].indexOf(e), u = this.data[r][a]; return this.data[r].splice(a, 1), u.timeout && clearTimeout(u.timeout), this.data[r].length === 0 && delete this.data[r], this.onRemove(u.value), this.order.splice(this.order.indexOf(r), 1), this } setMaxSize(n) { for (this.max = n; this.order.length > this.max;) { const e = this._getAndRemoveByKey(this.order[0]); e && this.onRemove(e) } return this } filter(n) { const e = []; for (const r in this.data) for (const a of this.data[r]) n(a.value) || e.push(a); for (const r of e) this.remove(r.value.tileID, r) } }, b.ay = function (n, e) { let r = 0, a = 0; if (n.kind === "constant") a = n.layoutSize; else if (n.kind !== "source") { const { interpolationType: u, minZoom: p, maxZoom: f } = n, _ = u ? Ct(Rn.interpolationFactor(u, e, p, f), 0, 1) : 0; n.kind === "camera" ? a = _r.number(n.minSize, n.maxSize, _) : r = _ } return { uSizeT: r, uSize: a } }, b.b = ys, b.b$ = ao, b.b0 = re, b.b1 = function (n) { var e = new ve(3); return e[0] = n[0], e[1] = n[1], e[2] = n[2], e }, b.b2 = function (n, e, r) { return n[0] = e[0] - r[0], n[1] = e[1] - r[1], n[2] = e[2] - r[2], n }, b.b3 = function (n, e) { var r = e[0], a = e[1], u = e[2], p = r * r + a * a + u * u; return p > 0 && (p = 1 / Math.sqrt(p)), n[0] = e[0] * p, n[1] = e[1] * p, n[2] = e[2] * p, n }, b.b4 = Ce, b.b5 = function (n, e) { return n[0] * e[0] + n[1] * e[1] + n[2] * e[2] }, b.b6 = function (n, e, r) { return n[0] = e[0] * r[0], n[1] = e[1] * r[1], n[2] = e[2] * r[2], n[3] = e[3] * r[3], n }, b.b7 = ct, b.b8 = function (n, e, r) { const a = e[0] * r[0] + e[1] * r[1] + e[2] * r[2]; return a === 0 ? null : (-(n[0] * r[0] + n[1] * r[1] + n[2] * r[2]) - r[3]) / a }, b.b9 = Te, b.bA = function (n, e, r, a) { return n[0] = e[0] + r[0] * a, n[1] = e[1] + r[1] * a, n[2] = e[2] + r[2] * a, n }, b.bB = Me, b.bC = function (n, e, r) { var a = r[0], u = r[1], p = r[2], f = r[3], _ = e[0], x = e[1], S = e[2], M = u * S - p * x, C = p * _ - a * S, k = a * x - u * _; return n[0] = _ + f * (M += M) + u * (k += k) - p * (C += C), n[1] = x + f * C + p * M - a * k, n[2] = S + f * k + a * C - u * M, n }, b.bD = function (n, e, r) { const a = function (x) { var S = x[3], M = x[4], C = x[5], k = x[6], D = x[7], L = x[8]; return x[0] * (L * M - C * D) + x[1] * (-L * S + C * k) + x[2] * (D * S - M * k) }([n[0], n[1], n[2], e[0], e[1], e[2], r[0], r[1], r[2]]); if (a === 0) return null; const u = Ce([], [e[0], e[1], e[2]], [r[0], r[1], r[2]]), p = Ce([], [r[0], r[1], r[2]], [n[0], n[1], n[2]]), f = Ce([], [n[0], n[1], n[2]], [e[0], e[1], e[2]]), _ = ie([], u, -n[3]); return re(_, _, ie([], p, -e[3])), re(_, _, ie([], f, -r[3])), ie(_, _, 1 / a), _ }, b.bE = Ag, b.bF = function () { return new Float64Array(4) }, b.bG = function (n, e, r, a) { var u = [], p = []; return u[0] = e[0] - r[0], u[1] = e[1] - r[1], u[2] = e[2] - r[2], p[0] = u[0] * Math.cos(a) - u[1] * Math.sin(a), p[1] = u[0] * Math.sin(a) + u[1] * Math.cos(a), p[2] = u[2], n[0] = p[0] + r[0], n[1] = p[1] + r[1], n[2] = p[2] + r[2], n }, b.bH = function (n, e, r, a) { var u = [], p = []; return u[0] = e[0] - r[0], u[1] = e[1] - r[1], u[2] = e[2] - r[2], p[0] = u[0], p[1] = u[1] * Math.cos(a) - u[2] * Math.sin(a), p[2] = u[1] * Math.sin(a) + u[2] * Math.cos(a), n[0] = p[0] + r[0], n[1] = p[1] + r[1], n[2] = p[2] + r[2], n }, b.bI = function (n, e, r, a) { var u = [], p = []; return u[0] = e[0] - r[0], u[1] = e[1] - r[1], u[2] = e[2] - r[2], p[0] = u[2] * Math.sin(a) + u[0] * Math.cos(a), p[1] = u[1], p[2] = u[2] * Math.cos(a) - u[0] * Math.sin(a), n[0] = p[0] + r[0], n[1] = p[1] + r[1], n[2] = p[2] + r[2], n }, b.bJ = function (n, e, r) { var a = Math.sin(r), u = Math.cos(r), p = e[0], f = e[1], _ = e[2], x = e[3], S = e[8], M = e[9], C = e[10], k = e[11]; return e !== n && (n[4] = e[4], n[5] = e[5], n[6] = e[6], n[7] = e[7], n[12] = e[12], n[13] = e[13], n[14] = e[14], n[15] = e[15]), n[0] = p * u - S * a, n[1] = f * u - M * a, n[2] = _ * u - C * a, n[3] = x * u - k * a, n[8] = p * a + S * u, n[9] = f * a + M * u, n[10] = _ * a + C * u, n[11] = x * a + k * u, n }, b.bK = function (n, e) { const r = lt(n, 360), a = lt(e, 360), u = a - r, p = a > r ? u - 360 : u + 360; return Math.abs(u) < Math.abs(p) ? u : p }, b.bL = function (n) { return n[0] = 0, n[1] = 0, n[2] = 0, n }, b.bM = function (n, e, r, a) { const u = Math.sqrt(n * n + e * e), p = Math.sqrt(r * r + a * a); n /= u, e /= u, r /= p, a /= p; const f = Math.acos(n * r + e * a); return -e * r + n * a > 0 ? f : -f }, b.bN = function (n, e) { const r = lt(n, 2 * Math.PI), a = lt(e, 2 * Math.PI); return Math.min(Math.abs(r - a), Math.abs(r - a + 2 * Math.PI), Math.abs(r - a - 2 * Math.PI)) }, b.bO = function () { const n = {}, e = De.$version; for (const r in De.$root) { const a = De.$root[r]; if (a.required) { let u = null; u = r === "version" ? e : a.type === "array" ? [] : {}, u != null && (n[r] = u) } } return n }, b.bP = Be, b.bQ = ah, b.bR = function n(e, r) { if (Array.isArray(e)) { if (!Array.isArray(r) || e.length !== r.length) return !1; for (let a = 0; a < e.length; a++)if (!n(e[a], r[a])) return !1; return !0 } if (typeof e == "object" && e !== null && r !== null) { if (typeof r != "object" || Object.keys(e).length !== Object.keys(r).length) return !1; for (const a in e) if (!n(e[a], r[a])) return !1; return !0 } return e === r }, b.bS = function (n) { n = n.slice(); const e = Object.create(null); for (let r = 0; r < n.length; r++)e[n[r].id] = n[r]; for (let r = 0; r < n.length; r++)"ref" in n[r] && (n[r] = pn(n[r], e[n[r].ref])); return n }, b.bT = function (n, e) { if (n.type === "custom") return new IS(n, e); switch (n.type) { case "background": return new MS(n, e); case "circle": return new hT(n, e); case "color-relief": return new _T(n, e); case "fill": return new DT(n, e); case "fill-extrusion": return new $T(n, e); case "heatmap": return new pT(n, e); case "hillshade": return new mT(n, e); case "line": return new KT(n, e); case "raster": return new sg(n, e); case "symbol": return new Kp(n, e) } }, b.bU = n => n.type === "raster", b.bV = dn, b.bW = function (n, e) { if (!n) return [{ command: "setStyle", args: [e] }]; let r = []; try { if (!Mt(n.version, e.version)) return [{ command: "setStyle", args: [e] }]; Mt(n.center, e.center) || r.push({ command: "setCenter", args: [e.center] }), Mt(n.state, e.state) || r.push({ command: "setGlobalState", args: [e.state] }), Mt(n.centerAltitude, e.centerAltitude) || r.push({ command: "setCenterAltitude", args: [e.centerAltitude] }), Mt(n.zoom, e.zoom) || r.push({ command: "setZoom", args: [e.zoom] }), Mt(n.bearing, e.bearing) || r.push({ command: "setBearing", args: [e.bearing] }), Mt(n.pitch, e.pitch) || r.push({ command: "setPitch", args: [e.pitch] }), Mt(n.roll, e.roll) || r.push({ command: "setRoll", args: [e.roll] }), Mt(n.sprite, e.sprite) || r.push({ command: "setSprite", args: [e.sprite] }), Mt(n.glyphs, e.glyphs) || r.push({ command: "setGlyphs", args: [e.glyphs] }), Mt(n.transition, e.transition) || r.push({ command: "setTransition", args: [e.transition] }), Mt(n.light, e.light) || r.push({ command: "setLight", args: [e.light] }), Mt(n.terrain, e.terrain) || r.push({ command: "setTerrain", args: [e.terrain] }), Mt(n.sky, e.sky) || r.push({ command: "setSky", args: [e.sky] }), Mt(n.projection, e.projection) || r.push({ command: "setProjection", args: [e.projection] }); const a = {}, u = []; (function (f, _, x, S) { let M; for (M in _ = _ || {}, f = f || {}) Object.prototype.hasOwnProperty.call(f, M) && (Object.prototype.hasOwnProperty.call(_, M) || pr(M, x, S)); for (M in _) Object.prototype.hasOwnProperty.call(_, M) && (Object.prototype.hasOwnProperty.call(f, M) ? Mt(f[M], _[M]) || (f[M].type === "geojson" && _[M].type === "geojson" && ir(f, _, M) ? Jt(x, { command: "setGeoJSONSourceData", args: [M, _[M].data] }) : Mr(M, _, x, S)) : fn(M, _, x)) })(n.sources, e.sources, u, a); const p = []; n.layers && n.layers.forEach(f => { "source" in f && a[f.source] ? r.push({ command: "removeLayer", args: [f.id] }) : p.push(f) }), r = r.concat(u), function (f, _, x) { _ = _ || []; const S = (f = f || []).map(Ia), M = _.map(Ia), C = f.reduce(Ca, {}), k = _.reduce(Ca, {}), D = S.slice(), L = Object.create(null); let F, N, G, ee, q; for (let H = 0, ne = 0; H < S.length; H++)F = S[H], Object.prototype.hasOwnProperty.call(k, F) ? ne++ : (Jt(x, { command: "removeLayer", args: [F] }), D.splice(D.indexOf(F, ne), 1)); for (let H = 0, ne = 0; H < M.length; H++)F = M[M.length - 1 - H], D[D.length - 1 - H] !== F && (Object.prototype.hasOwnProperty.call(C, F) ? (Jt(x, { command: "removeLayer", args: [F] }), D.splice(D.lastIndexOf(F, D.length - ne), 1)) : ne++, ee = D[D.length - H], Jt(x, { command: "addLayer", args: [k[F], ee] }), D.splice(D.length - H, 0, F), L[F] = !0); for (let H = 0; H < M.length; H++)if (F = M[H], N = C[F], G = k[F], !L[F] && !Mt(N, G)) if (Mt(N.source, G.source) && Mt(N["source-layer"], G["source-layer"]) && Mt(N.type, G.type)) { for (q in Hr(N.layout, G.layout, x, F, null, "setLayoutProperty"), Hr(N.paint, G.paint, x, F, null, "setPaintProperty"), Mt(N.filter, G.filter) || Jt(x, { command: "setFilter", args: [F, G.filter] }), Mt(N.minzoom, G.minzoom) && Mt(N.maxzoom, G.maxzoom) || Jt(x, { command: "setLayerZoomRange", args: [F, G.minzoom, G.maxzoom] }), N) Object.prototype.hasOwnProperty.call(N, q) && q !== "layout" && q !== "paint" && q !== "filter" && q !== "metadata" && q !== "minzoom" && q !== "maxzoom" && (q.indexOf("paint.") === 0 ? Hr(N[q], G[q], x, F, q.slice(6), "setPaintProperty") : Mt(N[q], G[q]) || Jt(x, { command: "setLayerProperty", args: [F, q, G[q]] })); for (q in G) Object.prototype.hasOwnProperty.call(G, q) && !Object.prototype.hasOwnProperty.call(N, q) && q !== "layout" && q !== "paint" && q !== "filter" && q !== "metadata" && q !== "minzoom" && q !== "maxzoom" && (q.indexOf("paint.") === 0 ? Hr(N[q], G[q], x, F, q.slice(6), "setPaintProperty") : Mt(N[q], G[q]) || Jt(x, { command: "setLayerProperty", args: [F, q, G[q]] })) } else Jt(x, { command: "removeLayer", args: [F] }), ee = D[D.lastIndexOf(F) + 1], Jt(x, { command: "addLayer", args: [G, ee] }) }(p, e.layers, r) } catch (a) { console.warn("Unable to compute style diff:", a), r = [{ command: "setStyle", args: [e] }] } return r }, b.bX = function (n) { const e = [], r = n.id; return r === void 0 && e.push({ message: `layers.${r}: missing required property "id"` }), n.render === void 0 && e.push({ message: `layers.${r}: missing required method "render"` }), n.renderingMode && n.renderingMode !== "2d" && n.renderingMode !== "3d" && e.push({ message: `layers.${r}: property "renderingMode" must be either "2d" or "3d"` }), e }, b.bY = In, b.bZ = vn, b.b_ = class extends Gn { constructor(n, e) { super(n, e), this.current = 0 } set(n) { this.current !== n && (this.current = n, this.gl.uniform1i(this.location, n)) } }, b.ba = function (n, e, r) { return n[0] = e[0] * r, n[1] = e[1] * r, n[2] = e[2] * r, n[3] = e[3] * r, n }, b.bb = function (n, e) { return n[0] * e[0] + n[1] * e[1] + n[2] * e[2] + n[3] }, b.bc = qv, b.bd = ju, b.be = function (n, e, r, a, u) { var p = 1 / Math.tan(e / 2); if (n[0] = p / r, n[1] = 0, n[2] = 0, n[3] = 0, n[4] = 0, n[5] = p, n[6] = 0, n[7] = 0, n[8] = 0, n[9] = 0, n[11] = -1, n[12] = 0, n[13] = 0, n[15] = 0, u != null && u !== 1 / 0) { var f = 1 / (a - u); n[10] = (u + a) * f, n[14] = 2 * u * a * f } else n[10] = -1, n[14] = -2 * a; return n }, b.bf = function (n) { var e = new ve(16); return e[0] = n[0], e[1] = n[1], e[2] = n[2], e[3] = n[3], e[4] = n[4], e[5] = n[5], e[6] = n[6], e[7] = n[7], e[8] = n[8], e[9] = n[9], e[10] = n[10], e[11] = n[11], e[12] = n[12], e[13] = n[13], e[14] = n[14], e[15] = n[15], e }, b.bg = function (n, e, r) { var a = Math.sin(r), u = Math.cos(r), p = e[0], f = e[1], _ = e[2], x = e[3], S = e[4], M = e[5], C = e[6], k = e[7]; return e !== n && (n[8] = e[8], n[9] = e[9], n[10] = e[10], n[11] = e[11], n[12] = e[12], n[13] = e[13], n[14] = e[14], n[15] = e[15]), n[0] = p * u + S * a, n[1] = f * u + M * a, n[2] = _ * u + C * a, n[3] = x * u + k * a, n[4] = S * u - p * a, n[5] = M * u - f * a, n[6] = C * u - _ * a, n[7] = k * u - x * a, n }, b.bh = function (n, e, r) { var a = Math.sin(r), u = Math.cos(r), p = e[4], f = e[5], _ = e[6], x = e[7], S = e[8], M = e[9], C = e[10], k = e[11]; return e !== n && (n[0] = e[0], n[1] = e[1], n[2] = e[2], n[3] = e[3], n[12] = e[12], n[13] = e[13], n[14] = e[14], n[15] = e[15]), n[4] = p * u + S * a, n[5] = f * u + M * a, n[6] = _ * u + C * a, n[7] = x * u + k * a, n[8] = S * u - p * a, n[9] = M * u - f * a, n[10] = C * u - _ * a, n[11] = k * u - x * a, n }, b.bi = function () { const n = new Float32Array(16); return ft(n), n }, b.bj = function () { const n = new Float64Array(16); return ft(n), n }, b.bk = function () { return new Float64Array(16) }, b.bl = function (n, e, r) { const a = new Float64Array(4); return Me(a, n, e - 90, r), a }, b.bm = function (n, e, r, a) { var u, p, f, _, x, S = e[0], M = e[1], C = e[2], k = e[3], D = r[0], L = r[1], F = r[2], N = r[3]; return (p = S * D + M * L + C * F + k * N) < 0 && (p = -p, D = -D, L = -L, F = -F, N = -N), 1 - p > K ? (u = Math.acos(p), f = Math.sin(u), _ = Math.sin((1 - a) * u) / f, x = Math.sin(a * u) / f) : (_ = 1 - a, x = a), n[0] = _ * S + x * D, n[1] = _ * M + x * L, n[2] = _ * C + x * F, n[3] = _ * k + x * N, n }, b.bn = function (n) { const e = new Float64Array(9); (function (p, f) { var _ = f[0], x = f[1], S = f[2], M = f[3], C = _ + _, k = x + x, D = S + S, L = _ * C, F = x * C, N = x * k, G = S * C, ee = S * k, q = S * D, H = M * C, ne = M * k, ae = M * D; p[0] = 1 - N - q, p[3] = F - ae, p[6] = G + ne, p[1] = F + ae, p[4] = 1 - L - q, p[7] = ee - H, p[2] = G - ne, p[5] = ee + H, p[8] = 1 - L - N })(e, n); const r = jn(-Math.asin(Ct(e[2], -1, 1))); let a, u; return Math.hypot(e[5], e[8]) < .001 ? (a = 0, u = -jn(Math.atan2(e[3], e[4]))) : (a = jn(e[5] === 0 && e[8] === 0 ? 0 : Math.atan2(e[5], e[8])), u = jn(e[1] === 0 && e[0] === 0 ? 0 : Math.atan2(e[1], e[0]))), { roll: a, pitch: r + 90, bearing: u } }, b.bo = function (n, e) { return n.roll == e.roll && n.pitch == e.pitch && n.bearing == e.bearing }, b.bp = Rt, b.bq = oo, b.br = Fu, b.bs = Ih, b.bt = Lu, b.bu = Tt, b.bv = Zt, b.bw = zn, b.bx = function (n, e, r, a, u) { return Tt(a, u, Ct((n - e) / (r - e), 0, 1)) }, b.by = lt, b.bz = function () { return new Float64Array(3) }, b.c = he, b.c$ = function (n, e, r, a, u) { return c(this, void 0, void 0, function* () { if (be()) try { return yield Po(n, e, r, a, u) } catch { } return function (p, f, _, x, S) { const M = p.width, C = p.height; vs && xi || (vs = new OffscreenCanvas(M, C), xi = vs.getContext("2d", { willReadFrequently: !0 })), vs.width = M, vs.height = C, xi.drawImage(p, 0, 0, M, C); const k = xi.getImageData(f, _, x, S); return xi.clearRect(0, 0, M, C), k.data }(n, e, r, a, u) }) }, b.c0 = class extends Gn { constructor(n, e) { super(n, e), this.current = hi } set(n) { if (n[12] !== this.current[12] || n[0] !== this.current[0]) return this.current = n, void this.gl.uniformMatrix4fv(this.location, !1, n); for (let e = 1; e < 16; e++)if (n[e] !== this.current[e]) { this.current = n, this.gl.uniformMatrix4fv(this.location, !1, n); break } } }, b.c1 = ml, b.c2 = class extends Gn { constructor(n, e) { super(n, e), this.current = [0, 0, 0] } set(n) { n[0] === this.current[0] && n[1] === this.current[1] && n[2] === this.current[2] || (this.current = n, this.gl.uniform3f(this.location, n[0], n[1], n[2])) } }, b.c3 = class extends Gn { constructor(n, e) { super(n, e), this.current = [0, 0] } set(n) { n[0] === this.current[0] && n[1] === this.current[1] || (this.current = n, this.gl.uniform2f(this.location, n[0], n[1])) } }, b.c4 = Ke, b.c5 = function (n, e) { var r = Math.sin(e), a = Math.cos(e); return n[0] = a, n[1] = r, n[2] = 0, n[3] = -r, n[4] = a, n[5] = 0, n[6] = 0, n[7] = 0, n[8] = 1, n }, b.c6 = function (n, e, r) { var a = e[0], u = e[1], p = e[2]; return n[0] = a * r[0] + u * r[3] + p * r[6], n[1] = a * r[1] + u * r[4] + p * r[7], n[2] = a * r[2] + u * r[5] + p * r[8], n }, b.c7 = function (n, e, r, a, u, p, f) { var _ = 1 / (e - r), x = 1 / (a - u), S = 1 / (p - f); return n[0] = -2 * _, n[1] = 0, n[2] = 0, n[3] = 0, n[4] = 0, n[5] = -2 * x, n[6] = 0, n[7] = 0, n[8] = 0, n[9] = 0, n[10] = 2 * S, n[11] = 0, n[12] = (e + r) * _, n[13] = (u + a) * x, n[14] = (f + p) * S, n[15] = 1, n }, b.c8 = class extends Gn { constructor(n, e) { super(n, e), this.current = new Array } set(n) { if (n != this.current) { this.current = n; const e = new Float32Array(4 * n.length); for (let r = 0; r < n.length; r++)e[4 * r] = n[r].r, e[4 * r + 1] = n[r].g, e[4 * r + 2] = n[r].b, e[4 * r + 3] = n[r].a; this.gl.uniform4fv(this.location, e) } } }, b.c9 = class extends Gn { constructor(n, e) { super(n, e), this.current = new Array } set(n) { if (n != this.current) { this.current = n; const e = new Float32Array(n); this.gl.uniform1fv(this.location, e) } } }, b.cA = function (n, e) { return Pe[e] && "touches" in n }, b.cB = function (n) { return Pe[n] || V[n] }, b.cC = function (n, e, r) { var a = e[0], u = e[1]; return n[0] = r[0] * a + r[4] * u + r[12], n[1] = r[1] * a + r[5] * u + r[13], n }, b.cD = function (n, e) { const { x: r, y: a } = Rh.fromLngLat(e); return !(n < 0 || n > 25 || a < 0 || a >= 1 || r < 0 || r >= 1) }, b.cE = function (n, e) { return n[0] = e[0], n[1] = 0, n[2] = 0, n[3] = 0, n[4] = 0, n[5] = e[1], n[6] = 0, n[7] = 0, n[8] = 0, n[9] = 0, n[10] = e[2], n[11] = 0, n[12] = 0, n[13] = 0, n[14] = 0, n[15] = 1, n }, b.cF = class extends Su { }, b.cG = fE, b.cI = pe, b.cJ = function (n, e) { he.REGISTERED_PROTOCOLS[n] = e }, b.cK = function (n) { delete he.REGISTERED_PROTOCOLS[n] }, b.cL = function (n, e) { const r = {}; for (let u = 0; u < n.length; u++) { const p = e && e[n[u].id] || _p(n[u]); e && (e[n[u].id] = p); let f = r[p]; f || (f = r[p] = []), f.push(n[u]) } const a = []; for (const u in r) a.push(r[u]); return a }, b.cM = pt, b.cN = Wv, b.cO = Ex, b.cP = Iv, b.cQ = function (n) { n.bucket.createArrays(), n.bucket.tilePixelRatio = Se / (512 * n.bucket.overscaling), n.bucket.compareText = {}, n.bucket.iconsNeedLinear = !1; const e = n.bucket.layers[0], r = e.layout, a = e._unevaluatedLayout._values, u = { layoutIconSize: a["icon-size"].possiblyEvaluate(new rr(n.bucket.zoom + 1), n.canonical), layoutTextSize: a["text-size"].possiblyEvaluate(new rr(n.bucket.zoom + 1), n.canonical), textMaxSize: a["text-size"].possiblyEvaluate(new rr(18)) }; if (n.bucket.textSizeData.kind === "composite") { const { minZoom: S, maxZoom: M } = n.bucket.textSizeData; u.compositeTextSizes = [a["text-size"].possiblyEvaluate(new rr(S), n.canonical), a["text-size"].possiblyEvaluate(new rr(M), n.canonical)] } if (n.bucket.iconSizeData.kind === "composite") { const { minZoom: S, maxZoom: M } = n.bucket.iconSizeData; u.compositeIconSizes = [a["icon-size"].possiblyEvaluate(new rr(S), n.canonical), a["icon-size"].possiblyEvaluate(new rr(M), n.canonical)] } const p = r.get("text-line-height") * on, f = r.get("text-rotation-alignment") !== "viewport" && r.get("symbol-placement") !== "point", _ = r.get("text-keep-upright"), x = r.get("text-size"); for (const S of n.bucket.features) { const M = r.get("text-font").evaluate(S, {}, n.canonical).join(","), C = x.evaluate(S, {}, n.canonical), k = u.layoutTextSize.evaluate(S, {}, n.canonical), D = u.layoutIconSize.evaluate(S, {}, n.canonical), L = { horizontal: {}, vertical: void 0 }, F = S.text; let N, G = [0, 0]; if (F) { const H = F.toString(), ne = r.get("text-letter-spacing").evaluate(S, {}, n.canonical) * on, ae = ng(H) ? ne : 0, Ie = r.get("text-anchor").evaluate(S, {}, n.canonical), Ue = Ox(e, S, n.canonical); if (!Ue) { const He = r.get("text-radial-offset").evaluate(S, {}, n.canonical); G = He ? Bx(Ie, [He * on, Xg]) : r.get("text-offset").evaluate(S, {}, n.canonical).map(Ve => Ve * on) } let je = f ? "center" : r.get("text-justify").evaluate(S, {}, n.canonical); const Ze = r.get("symbol-placement") === "point" ? r.get("text-max-width").evaluate(S, {}, n.canonical) * on : 1 / 0, nt = () => { n.bucket.allowVerticalPlacement && Jo(H) && (L.vertical = Xp(F, n.glyphMap, n.glyphPositions, n.imagePositions, M, Ze, p, Ie, "left", ae, G, b.az.vertical, !0, k, C)) }; if (!f && Ue) { const He = new Set; if (je === "auto") for (let Fe = 0; Fe < Ue.values.length; Fe += 2)He.add(Yg(Ue.values[Fe])); else He.add(je); let Ve = !1; for (const Fe of He) if (!L.horizontal[Fe]) if (Ve) L.horizontal[Fe] = L.horizontal[0]; else { const dt = Xp(F, n.glyphMap, n.glyphPositions, n.imagePositions, M, Ze, p, "center", Fe, ae, G, b.az.horizontal, !1, k, C); dt && (L.horizontal[Fe] = dt, Ve = dt.positionedLines.length === 1) } nt() } else { je === "auto" && (je = Yg(Ie)); const He = Xp(F, n.glyphMap, n.glyphPositions, n.imagePositions, M, Ze, p, Ie, je, ae, G, b.az.horizontal, !1, k, C); He && (L.horizontal[je] = He), nt(), Jo(H) && f && _ && (L.vertical = Xp(F, n.glyphMap, n.glyphPositions, n.imagePositions, M, Ze, p, Ie, je, ae, G, b.az.vertical, !1, k, C)) } } let ee = !1; if (S.icon && S.icon.name) { const H = n.imageMap[S.icon.name]; H && (N = TS(n.imagePositions[S.icon.name], r.get("icon-offset").evaluate(S, {}, n.canonical), r.get("icon-anchor").evaluate(S, {}, n.canonical)), ee = !!H.sdf, n.bucket.sdfIcons === void 0 ? n.bucket.sdfIcons = ee : n.bucket.sdfIcons !== ee && qt("Style sheet warning: Cannot mix SDF and non-SDF icons in one buffer"), (H.pixelRatio !== n.bucket.pixelRatio || r.get("icon-rotate").constantOr(1) !== 0) && (n.bucket.iconsNeedLinear = !0)) } const q = jx(L.horizontal) || L.vertical; n.bucket.iconsInText = !!q && q.iconsInText, (q || N) && dE(n.bucket, S, L, N, n.imageMap, u, k, D, G, ee, n.canonical, n.subdivisionGranularity) } n.showCollisionBoxes && n.bucket.generateCollisionDebugBuffers() }, b.cR = yg, b.cS = xg, b.cT = wg, b.cU = function (n) { const e = new Hp; return function (r, a) { for (const u in r.layers) a.writeMessage(3, QS, r.layers[u]) }(n, e), e.finish() }, b.cV = function (n, e, r, a, u, p) { let f = Ix(n, e, r, u, 0); return f = Ix(f, e, a, p, 1), f }, b.cW = class { constructor(n) { this.maxEntries = n, this.map = new Map } get(n) { const e = this.map.get(n); return e !== void 0 && (this.map.delete(n), this.map.set(n, e)), e } set(n, e) { if (this.map.has(n)) this.map.delete(n); else if (this.map.size >= this.maxEntries) { const r = this.map.keys().next().value; this.map.delete(r) } this.map.set(n, e) } clear() { this.map.clear() } }, b.cX = cv, b.cY = Hp, b.cZ = Tx, b.c_ = class { constructor(n) { this._marks = { start: [n.url, "start"].join("#"), end: [n.url, "end"].join("#"), measure: n.url.toString() }, performance.mark(this._marks.start) } finish() { performance.mark(this._marks.end); let n = performance.getEntriesByName(this._marks.measure); return n.length === 0 && (performance.measure(this._marks.measure, this._marks.start, this._marks.end), n = performance.getEntriesByName(this._marks.measure), performance.clearMarks(this._marks.start), performance.clearMarks(this._marks.end), performance.clearMeasures(this._marks.measure)), n } }, b.ca = class extends io { }, b.cb = tS, b.cc = class extends fl { }, b.cd = pg, b.ce = function (n) { return n <= 1 ? 1 : Math.pow(2, Math.ceil(Math.log(n) / Math.LN2)) }, b.cf = X0, b.cg = function (n, e, r) { var a = e[0], u = e[1], p = e[2], f = r[3] * a + r[7] * u + r[11] * p + r[15]; return n[0] = (r[0] * a + r[4] * u + r[8] * p + r[12]) / (f = f || 1), n[1] = (r[1] * a + r[5] * u + r[9] * p + r[13]) / f, n[2] = (r[2] * a + r[6] * u + r[10] * p + r[14]) / f, n }, b.ch = class extends fh { }, b.ci = class extends t { }, b.cj = function (n, e) { return n[0] === e[0] && n[1] === e[1] && n[2] === e[2] && n[3] === e[3] && n[4] === e[4] && n[5] === e[5] && n[6] === e[6] && n[7] === e[7] && n[8] === e[8] && n[9] === e[9] && n[10] === e[10] && n[11] === e[11] && n[12] === e[12] && n[13] === e[13] && n[14] === e[14] && n[15] === e[15] }, b.ck = function (n, e) { var r = n[0], a = n[1], u = n[2], p = n[3], f = n[4], _ = n[5], x = n[6], S = n[7], M = n[8], C = n[9], k = n[10], D = n[11], L = n[12], F = n[13], N = n[14], G = n[15], ee = e[0], q = e[1], H = e[2], ne = e[3], ae = e[4], Ie = e[5], Ue = e[6], je = e[7], Ze = e[8], nt = e[9], He = e[10], Ve = e[11], Fe = e[12], dt = e[13], ut = e[14], gt = e[15]; return Math.abs(r - ee) <= K * Math.max(1, Math.abs(r), Math.abs(ee)) && Math.abs(a - q) <= K * Math.max(1, Math.abs(a), Math.abs(q)) && Math.abs(u - H) <= K * Math.max(1, Math.abs(u), Math.abs(H)) && Math.abs(p - ne) <= K * Math.max(1, Math.abs(p), Math.abs(ne)) && Math.abs(f - ae) <= K * Math.max(1, Math.abs(f), Math.abs(ae)) && Math.abs(_ - Ie) <= K * Math.max(1, Math.abs(_), Math.abs(Ie)) && Math.abs(x - Ue) <= K * Math.max(1, Math.abs(x), Math.abs(Ue)) && Math.abs(S - je) <= K * Math.max(1, Math.abs(S), Math.abs(je)) && Math.abs(M - Ze) <= K * Math.max(1, Math.abs(M), Math.abs(Ze)) && Math.abs(C - nt) <= K * Math.max(1, Math.abs(C), Math.abs(nt)) && Math.abs(k - He) <= K * Math.max(1, Math.abs(k), Math.abs(He)) && Math.abs(D - Ve) <= K * Math.max(1, Math.abs(D), Math.abs(Ve)) && Math.abs(L - Fe) <= K * Math.max(1, Math.abs(L), Math.abs(Fe)) && Math.abs(F - dt) <= K * Math.max(1, Math.abs(F), Math.abs(dt)) && Math.abs(N - ut) <= K * Math.max(1, Math.abs(N), Math.abs(ut)) && Math.abs(G - gt) <= K * Math.max(1, Math.abs(G), Math.abs(gt)) }, b.cl = function (n, e) { return n[0] = e[0], n[1] = e[1], n[2] = e[2], n[3] = e[3], n[4] = e[4], n[5] = e[5], n[6] = e[6], n[7] = e[7], n[8] = e[8], n[9] = e[9], n[10] = e[10], n[11] = e[11], n[12] = e[12], n[13] = e[13], n[14] = e[14], n[15] = e[15], n }, b.cm = n => n.type === "symbol", b.cn = n => n.type === "circle", b.co = n => n.type === "heatmap", b.cp = n => n.type === "line", b.cq = n => n.type === "fill", b.cr = n => n.type === "fill-extrusion", b.cs = n => n.type === "hillshade", b.ct = n => n.type === "color-relief", b.cu = n => n.type === "background", b.cv = n => n.type === "custom", b.cw = Ut, b.cx = function (n, e, r) { const a = de(e.x - r.x, e.y - r.y), u = de(n.x - r.x, n.y - r.y), p = Math.atan2(a[0] * u[1] - a[1] * u[0], function (f, _) { return f[0] * _[0] + f[1] * _[1] }(a, u)); return jn(p) }, b.cy = St, b.cz = function (n, e) { return V[e] && (n instanceof MouseEvent || n instanceof WheelEvent) }, b.d = qe, b.d0 = Q0, b.d1 = $, b.d2 = class { constructor(n, e) { this.layers = { [Bh]: this }, this.name = Bh, this.version = e ? e.version : 1, this.extent = e ? e.extent : 4096, this.length = n.length, this.features = n } feature(n) { return new KS(this.features[n], this.extent) } }, b.d3 = Wa, b.d4 = Is, b.e = Wr, b.f = n => c(void 0, void 0, void 0, function* () { if (n.byteLength === 0) return createImageBitmap(new ImageData(1, 1)); const e = new Blob([new Uint8Array(n)], { type: "image/png" }); try { return createImageBitmap(e) } catch (r) { throw new Error(`Could not load image because of ${r.message}. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported.`) } }), b.g = Ae, b.h = n => new Promise((e, r) => { const a = new Image; a.onload = () => { e(a), URL.revokeObjectURL(a.src), a.onload = null, window.requestAnimationFrame(() => { a.src = Us }) }, a.onerror = () => r(new Error("Could not load image. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported.")); const u = new Blob([new Uint8Array(n)], { type: "image/png" }); a.src = n.byteLength ? URL.createObjectURL(u) : Us }), b.i = Ni, b.j = (n, e) => Xe(Wr(n, { type: "json" }), e), b.k = tr, b.l = Pt, b.m = Xe, b.n = (n, e) => Xe(Wr(n, { type: "arrayBuffer" }), e), b.o = function (n) { return new Hp(n).readFields(mS, []) }, b.p = Mv, b.q = function (n) { return /[\u02EA\u02EB\u1100-\u11FF\u2E80-\u2FDF\u3000-\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u4DBF\u4E00-\uA48C\uA490-\uA4C6\uA960-\uA97C\uAC00-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFE10-\uFE1F\uFE30-\uFE4F\uFF00-\uFFEF]|\uD81B[\uDFE0-\uDFFF]|[\uD81C-\uD822\uD840-\uD868\uD86A-\uD86D\uD86F-\uD872\uD874-\uD879\uD880-\uD883\uD885-\uD88C][\uDC00-\uDFFF]|\uD823[\uDC00-\uDCD5\uDCFF-\uDD1E\uDD80-\uDDF2]|\uD82B[\uDFF0-\uDFFF]|\uD82C[\uDC00-\uDEFB]|\uD83C[\uDE00-\uDEFF]|\uD869[\uDC00-\uDEDF\uDF00-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEAD\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0\uDFF0-\uDFFF]|\uD87B[\uDC00-\uDE5D]|\uD87E[\uDC00-\uDE1D]|\uD884[\uDC00-\uDF4A\uDF50-\uDFFF]|\uD88D[\uDC00-\uDC79]/gim.test(String.fromCodePoint(n)) }, b.r = Th, b.s = Mo, b.t = Ln, b.u = De, b.v = tl, b.w = qt, b.x = dh, b.y = rl, b.z = ol
        }), w("worker", ["./shared"], function (b) { class c { constructor(V, j) { this.keyCache = {}, V && this.replace(V, j) } replace(V, j) { this._layerConfigs = {}, this._layers = {}, this.update(V, [], j) } update(V, j, W) { for (const he of V) { this._layerConfigs[he.id] = he; const Ae = this._layers[he.id] = b.bT(he, W); Ae._featureFilter = b.aj(Ae.filter, W), this.keyCache[he.id] && delete this.keyCache[he.id] } for (const he of j) delete this.keyCache[he], delete this._layerConfigs[he], delete this._layers[he]; this.familiesBySource = {}; const ue = b.cL(Object.values(this._layerConfigs), this.keyCache); for (const he of ue) { const Ae = he.map(ht => this._layers[ht.id]), Ee = Ae[0]; if (Ee.isHidden()) continue; const pe = Ee.source || ""; let Be = this.familiesBySource[pe]; Be || (Be = this.familiesBySource[pe] = {}); const Xe = Ee.sourceLayer || b.ai; let qe = Be[Xe]; qe || (qe = Be[Xe] = []), qe.push(Ae) } } } class B { constructor(V) { const j = {}, W = []; for (const Ee in V) { const pe = V[Ee], Be = j[Ee] = {}; for (const Xe in pe) { const qe = pe[+Xe]; if (!qe || qe.bitmap.width === 0 || qe.bitmap.height === 0) continue; const ht = { x: 0, y: 0, w: qe.bitmap.width + 2, h: qe.bitmap.height + 2 }; W.push(ht), Be[Xe] = { rect: ht, metrics: qe.metrics } } } const { w: ue, h: he } = b.p(W), Ae = new b.r({ width: ue || 1, height: he || 1 }); for (const Ee in V) { const pe = V[Ee]; for (const Be in pe) { const Xe = pe[+Be]; if (!Xe || Xe.bitmap.width === 0 || Xe.bitmap.height === 0) continue; const qe = j[Ee][Be].rect; b.r.copy(Xe.bitmap, Ae, { x: 0, y: 0 }, { x: qe.x + 1, y: qe.y + 1 }, Xe.bitmap) } } this.image = Ae, this.positions = j } } b.cM("GlyphAtlas", B); class $ { constructor(V) { this.tileID = new b.a2(V.tileID.overscaledZ, V.tileID.wrap, V.tileID.canonical.z, V.tileID.canonical.x, V.tileID.canonical.y), this.uid = V.uid, this.zoom = V.zoom, this.pixelRatio = V.pixelRatio, this.tileSize = V.tileSize, this.source = V.source, this.overscaling = this.tileID.overscaleFactor(), this.showCollisionBoxes = V.showCollisionBoxes, this.collectResourceTiming = !!V.collectResourceTiming, this.returnDependencies = !!V.returnDependencies, this.promoteId = V.promoteId, this.inFlightDependencies = [] } parse(V, j, W, ue, he) { return b._(this, void 0, void 0, function* () { this.status = "parsing", this.data = V, this.collisionBoxArray = new b.ag; const Ae = new b.cN(Object.keys(V.layers).sort()), Ee = new b.cO(this.tileID, this.promoteId); Ee.bucketLayerIDs = []; const pe = {}, Be = { featureIndex: Ee, iconDependencies: {}, patternDependencies: {}, glyphDependencies: {}, dashDependencies: {}, availableImages: W, subdivisionGranularity: he }, Xe = j.familiesBySource[this.source]; for (const ir in Xe) { const Hr = V.layers[ir]; if (!Hr) continue; Hr.version === 1 && b.w(`Vector tile source "${this.source}" layer "${ir}" does not use vector tile spec v2 and therefore may have some rendering errors.`); const Ia = Ae.encode(ir), Ca = []; for (let Qe = 0; Qe < Hr.length; Qe++) { const Cn = Hr.feature(Qe), An = Ee.getId(Cn, ir); Ca.push({ feature: Cn, id: An, index: Qe, sourceLayerIndex: Ia }) } for (const Qe of Xe[ir]) { const Cn = Qe[0]; Cn.source !== this.source && b.w(`layer.source = ${Cn.source} does not equal this.source = ${this.source}`), Cn.isHidden(this.zoom, !0) || (me(Qe, this.zoom, W), (pe[Cn.id] = Cn.createBucket({ index: Ee.bucketLayerIDs.length, layers: Qe, zoom: this.zoom, pixelRatio: this.pixelRatio, overscaling: this.overscaling, collisionBoxArray: this.collisionBoxArray, sourceLayerIndex: Ia, sourceID: this.source })).populate(Ca, Be, this.tileID.canonical), Ee.bucketLayerIDs.push(Qe.map(An => An.id))) } } const qe = b.bY(Be.glyphDependencies, ir => Object.keys(ir).map(Number)); this.inFlightDependencies.forEach(ir => ir == null ? void 0 : ir.abort()), this.inFlightDependencies = []; let ht = Promise.resolve({}); if (Object.keys(qe).length) { const ir = new AbortController; this.inFlightDependencies.push(ir), ht = ue.sendAsync({ type: "GG", data: { stacks: qe, source: this.source, tileID: this.tileID, type: "glyphs" } }, ir) } const yt = Object.keys(Be.iconDependencies); let Pt = Promise.resolve({}); if (yt.length) { const ir = new AbortController; this.inFlightDependencies.push(ir), Pt = ue.sendAsync({ type: "GI", data: { icons: yt, source: this.source, tileID: this.tileID, type: "icons" } }, ir) } const tr = Object.keys(Be.patternDependencies); let Wt = Promise.resolve({}); if (tr.length) { const ir = new AbortController; this.inFlightDependencies.push(ir), Wt = ue.sendAsync({ type: "GI", data: { icons: tr, source: this.source, tileID: this.tileID, type: "patterns" } }, ir) } const De = Be.dashDependencies; let nr = Promise.resolve({}); if (Object.keys(De).length) { const ir = new AbortController; this.inFlightDependencies.push(ir), nr = ue.sendAsync({ type: "GDA", data: { dashes: De } }, ir) } const [pn, Mt, Jt, fn] = yield Promise.all([ht, Pt, Wt, nr]), pr = new B(pn), Mr = new b.cP(Mt, Jt); for (const ir in pe) { const Hr = pe[ir]; Hr instanceof b.ah ? (me(Hr.layers, this.zoom, W), b.cQ({ bucket: Hr, glyphMap: pn, glyphPositions: pr.positions, imageMap: Mt, imagePositions: Mr.iconPositions, showCollisionBoxes: this.showCollisionBoxes, canonical: this.tileID.canonical, subdivisionGranularity: Be.subdivisionGranularity })) : Hr.hasDependencies && (Hr instanceof b.cR || Hr instanceof b.cS || Hr instanceof b.cT) && (me(Hr.layers, this.zoom, W), Hr.addFeatures(Be, this.tileID.canonical, Mr.patternPositions, fn)) } return this.status = "done", { buckets: Object.values(pe).filter(ir => !ir.isEmpty()), featureIndex: Ee, collisionBoxArray: this.collisionBoxArray, glyphAtlasImage: pr.image, imageAtlas: Mr, dashPositions: fn, glyphMap: this.returnDependencies ? pn : null, iconMap: this.returnDependencies ? Mt : null, glyphPositions: this.returnDependencies ? pr.positions : null } }) } } function me(Pe, V, j) { const W = new b.H(V); for (const ue of Pe) ue.recalculate(W, j) } class ge { constructor(V, j, W, ue, he) { this.type = V, this.properties = W || {}, this.extent = he, this.pointsArray = j, this.id = ue } loadGeometry() { return this.pointsArray.map(V => V.map(j => new b.P(j.x, j.y))) } } class we { constructor(V, j, W) { this.version = 2, this._myFeatures = V, this.name = j, this.length = V.length, this.extent = W } feature(V) { return this._myFeatures[V] } } class Ge { constructor() { this.layers = {} } addLayer(V) { this.layers[V.name] = V } } function Ye(Pe) { let V = b.cU(Pe); return V.byteOffset === 0 && V.byteLength === V.buffer.byteLength || (V = new Uint8Array(V)), { vectorTile: Pe, rawData: V.buffer } } function $e(Pe, V, j) { const { extent: W } = Pe, ue = Math.pow(2, j.z - V.z), he = (j.x - V.x * ue) * W, Ae = (j.y - V.y * ue) * W, Ee = []; for (let pe = 0; pe < Pe.length; pe++) { const Be = Pe.feature(pe); let Xe = Be.loadGeometry(); for (const ht of Xe) for (const yt of ht) yt.x = yt.x * ue - he, yt.y = yt.y * ue - Ae; const qe = 128; Xe = b.cV(Xe, Be.type, -qe, -qe, W + qe, W + qe), Xe.length !== 0 && Ee.push(new ge(Be.type, Xe, Be.properties, Be.id, W)) } return new we(Ee, Pe.name, W) } class ye { constructor(V, j, W) { this.actor = V, this.layerIndex = j, this.availableImages = W, this.fetching = {}, this.loading = {}, this.loaded = {}, this.overzoomedTileResultCache = new b.cW(1e3) } loadVectorTile(V, j) { return b._(this, void 0, void 0, function* () { const W = yield b.n(V.request, j); try { return { vectorTile: V.encoding !== "mlt" ? new b.cX(new b.cY(W.data)) : new b.cZ(W.data), rawData: W.data, cacheControl: W.cacheControl, expires: W.expires } } catch (ue) { const he = new Uint8Array(W.data); let Ae = `Unable to parse the tile at ${V.request.url}, `; throw Ae += he[0] === 31 && he[1] === 139 ? "please make sure the data is not gzipped and that you have configured the relevant header in the server" : `got error: ${ue.message}`, new Error(Ae) } }) } loadTile(V) { return b._(this, void 0, void 0, function* () { const { uid: j, overzoomParameters: W } = V; W && (V.request = W.overzoomRequest); const ue = !!(V && V.request && V.request.collectResourceTiming) && new b.c_(V.request), he = new $(V); this.loading[j] = he; const Ae = new AbortController; he.abort = Ae; try { const Ee = yield this.loadVectorTile(V, Ae); if (delete this.loading[j], !Ee) return null; if (W) { const ht = this._getOverzoomTile(V, Ee.vectorTile); Ee.rawData = ht.rawData, Ee.vectorTile = ht.vectorTile } const pe = Ee.rawData, Be = {}; Ee.expires && (Be.expires = Ee.expires), Ee.cacheControl && (Be.cacheControl = Ee.cacheControl); const Xe = {}; if (ue) { const ht = ue.finish(); ht && (Xe.resourceTiming = JSON.parse(JSON.stringify(ht))) } he.vectorTile = Ee.vectorTile; const qe = he.parse(Ee.vectorTile, this.layerIndex, this.availableImages, this.actor, V.subdivisionGranularity); this.loaded[j] = he, this.fetching[j] = { rawTileData: pe, cacheControl: Be, resourceTiming: Xe }; try { const ht = yield qe; return b.e({ rawTileData: pe.slice(0), encoding: V.encoding }, ht, Be, Xe) } finally { delete this.fetching[j] } } catch (Ee) { throw delete this.loading[j], he.status = "done", this.loaded[j] = he, Ee } }) } _getOverzoomTile(V, j) { const { tileID: W, source: ue, overzoomParameters: he } = V, { maxZoomTileID: Ae } = he, Ee = `${Ae.key}_${W.key}`, pe = this.overzoomedTileResultCache.get(Ee); if (pe) return pe; const Be = new Ge, Xe = this.layerIndex.familiesBySource[ue]; for (const ht in Xe) { const yt = j.layers[ht]; if (!yt) continue; const Pt = $e(yt, Ae, W.canonical); Pt.length > 0 && Be.addLayer(Pt) } const qe = Ye(Be); return this.overzoomedTileResultCache.set(Ee, qe), qe } reloadTile(V) { return b._(this, void 0, void 0, function* () { const j = V.uid; if (!this.loaded || !this.loaded[j]) throw new Error("Should not be trying to reload a tile that was never loaded or has been removed"); const W = this.loaded[j]; if (W.showCollisionBoxes = V.showCollisionBoxes, W.status === "parsing") { const ue = yield W.parse(W.vectorTile, this.layerIndex, this.availableImages, this.actor, V.subdivisionGranularity); let he; if (this.fetching[j]) { const { rawTileData: Ae, cacheControl: Ee, resourceTiming: pe } = this.fetching[j]; delete this.fetching[j], he = b.e({ rawTileData: Ae.slice(0), encoding: V.encoding }, ue, Ee, pe) } else he = ue; return he } if (W.status === "done" && W.vectorTile) return W.parse(W.vectorTile, this.layerIndex, this.availableImages, this.actor, V.subdivisionGranularity) }) } abortTile(V) { return b._(this, void 0, void 0, function* () { const j = this.loading, W = V.uid; j && j[W] && j[W].abort && (j[W].abort.abort(), delete j[W]) }) } removeTile(V) { return b._(this, void 0, void 0, function* () { this.loaded && this.loaded[V.uid] && delete this.loaded[V.uid] }) } } class be { constructor() { this.loaded = {} } loadTile(V) { return b._(this, void 0, void 0, function* () { const { uid: j, encoding: W, rawImageData: ue, redFactor: he, greenFactor: Ae, blueFactor: Ee, baseShift: pe } = V, Be = ue.width + 2, Xe = ue.height + 2, qe = b.b(ue) ? new b.R({ width: Be, height: Xe }, yield b.c$(ue, -1, -1, Be, Xe)) : ue, ht = new b.d0(j, qe, W, he, Ae, Ee, pe); return this.loaded = this.loaded || {}, this.loaded[j] = ht, ht }) } removeTile(V) { const j = this.loaded, W = V.uid; j && j[W] && delete j[W] } } var K, ve, Ke = function () { if (ve) return K; function Pe(j, W) { if (j.length !== 0) { V(j[0], W); for (var ue = 1; ue < j.length; ue++)V(j[ue], !W) } } function V(j, W) { for (var ue = 0, he = 0, Ae = 0, Ee = j.length, pe = Ee - 1; Ae < Ee; pe = Ae++) { var Be = (j[Ae][0] - j[pe][0]) * (j[pe][1] + j[Ae][1]), Xe = ue + Be; he += Math.abs(ue) >= Math.abs(Be) ? ue - Xe + Be : Be - Xe + ue, ue = Xe } ue + he >= 0 != !!W && j.reverse() } return ve = 1, K = function j(W, ue) { var he, Ae = W && W.type; if (Ae === "FeatureCollection") for (he = 0; he < W.features.length; he++)j(W.features[he], ue); else if (Ae === "GeometryCollection") for (he = 0; he < W.geometries.length; he++)j(W.geometries[he], ue); else if (Ae === "Feature") j(W.geometry, ue); else if (Ae === "Polygon") Pe(W.coordinates, ue); else if (Ae === "MultiPolygon") for (he = 0; he < W.coordinates.length; he++)Pe(W.coordinates[he], ue); return W } }(), ft = b.d1(Ke); const mt = { minZoom: 0, maxZoom: 16, minPoints: 2, radius: 40, extent: 512, nodeSize: 64, log: !1, generateId: !1, reduce: null, map: Pe => Pe }, ct = Math.fround || (Z = new Float32Array(1), Pe => (Z[0] = +Pe, Z[0])); var Z; class re { constructor(V) { this.options = Object.assign(Object.create(mt), V), this.trees = new Array(this.options.maxZoom + 1), this.stride = this.options.reduce ? 7 : 6, this.clusterProps = [] } load(V) { const { log: j, minZoom: W, maxZoom: ue } = this.options; j && console.time("total time"); const he = `prepare ${V.length} points`; j && console.time(he), this.points = V; const Ae = []; for (let pe = 0; pe < V.length; pe++) { const Be = V[pe]; if (!Be.geometry) continue; const [Xe, qe] = Be.geometry.coordinates, ht = ct(xe(Xe)), yt = ct(Te(qe)); Ae.push(ht, yt, 1 / 0, pe, -1, 1), this.options.reduce && Ae.push(0) } let Ee = this.trees[ue + 1] = this._createTree(Ae); j && console.timeEnd(he); for (let pe = ue; pe >= W; pe--) { const Be = +Date.now(); Ee = this.trees[pe] = this._createTree(this._cluster(Ee, pe)), j && console.log("z%d: %d clusters in %dms", pe, Ee.numItems, +Date.now() - Be) } return j && console.timeEnd("total time"), this } getClusters(V, j) { let W = ((V[0] + 180) % 360 + 360) % 360 - 180; const ue = Math.max(-90, Math.min(90, V[1])); let he = V[2] === 180 ? 180 : ((V[2] + 180) % 360 + 360) % 360 - 180; const Ae = Math.max(-90, Math.min(90, V[3])); if (V[2] - V[0] >= 360) W = -180, he = 180; else if (W > he) { const qe = this.getClusters([W, ue, 180, Ae], j), ht = this.getClusters([-180, ue, he, Ae], j); return qe.concat(ht) } const Ee = this.trees[this._limitZoom(j)], pe = Ee.range(xe(W), Te(Ae), xe(he), Te(ue)), Be = Ee.data, Xe = []; for (const qe of pe) { const ht = this.stride * qe; Xe.push(Be[ht + 5] > 1 ? ie(Be, ht, this.clusterProps) : this.points[Be[ht + 3]]) } return Xe } getChildren(V) { const j = this._getOriginId(V), W = this._getOriginZoom(V), ue = "No cluster with the specified id.", he = this.trees[W]; if (!he) throw new Error(ue); const Ae = he.data; if (j * this.stride >= Ae.length) throw new Error(ue); const Ee = this.options.radius / (this.options.extent * Math.pow(2, W - 1)), pe = he.within(Ae[j * this.stride], Ae[j * this.stride + 1], Ee), Be = []; for (const Xe of pe) { const qe = Xe * this.stride; Ae[qe + 4] === V && Be.push(Ae[qe + 5] > 1 ? ie(Ae, qe, this.clusterProps) : this.points[Ae[qe + 3]]) } if (Be.length === 0) throw new Error(ue); return Be } getLeaves(V, j, W) { const ue = []; return this._appendLeaves(ue, V, j = j || 10, W = W || 0, 0), ue } getTile(V, j, W) { const ue = this.trees[this._limitZoom(V)], he = Math.pow(2, V), { extent: Ae, radius: Ee } = this.options, pe = Ee / Ae, Be = (W - pe) / he, Xe = (W + 1 + pe) / he, qe = { features: [] }; return this._addTileFeatures(ue.range((j - pe) / he, Be, (j + 1 + pe) / he, Xe), ue.data, j, W, he, qe), j === 0 && this._addTileFeatures(ue.range(1 - pe / he, Be, 1, Xe), ue.data, he, W, he, qe), j === he - 1 && this._addTileFeatures(ue.range(0, Be, pe / he, Xe), ue.data, -1, W, he, qe), qe.features.length ? qe : null } getClusterExpansionZoom(V) { let j = this._getOriginZoom(V) - 1; for (; j <= this.options.maxZoom;) { const W = this.getChildren(V); if (j++, W.length !== 1) break; V = W[0].properties.cluster_id } return j } _appendLeaves(V, j, W, ue, he) { const Ae = this.getChildren(j); for (const Ee of Ae) { const pe = Ee.properties; if (pe && pe.cluster ? he + pe.point_count <= ue ? he += pe.point_count : he = this._appendLeaves(V, pe.cluster_id, W, ue, he) : he < ue ? he++ : V.push(Ee), V.length === W) break } return he } _createTree(V) { const j = new b.aT(V.length / this.stride | 0, this.options.nodeSize, Float32Array); for (let W = 0; W < V.length; W += this.stride)j.add(V[W], V[W + 1]); return j.finish(), j.data = V, j } _addTileFeatures(V, j, W, ue, he, Ae) { for (const Ee of V) { const pe = Ee * this.stride, Be = j[pe + 5] > 1; let Xe, qe, ht; if (Be) Xe = Ce(j, pe, this.clusterProps), qe = j[pe], ht = j[pe + 1]; else { const tr = this.points[j[pe + 3]]; Xe = tr.properties; const [Wt, De] = tr.geometry.coordinates; qe = xe(Wt), ht = Te(De) } const yt = { type: 1, geometry: [[Math.round(this.options.extent * (qe * he - W)), Math.round(this.options.extent * (ht * he - ue))]], tags: Xe }; let Pt; Pt = Be || this.options.generateId ? j[pe + 3] : this.points[j[pe + 3]].id, Pt !== void 0 && (yt.id = Pt), Ae.features.push(yt) } } _limitZoom(V) { return Math.max(this.options.minZoom, Math.min(Math.floor(+V), this.options.maxZoom + 1)) } _cluster(V, j) { const { radius: W, extent: ue, reduce: he, minPoints: Ae } = this.options, Ee = W / (ue * Math.pow(2, j)), pe = V.data, Be = [], Xe = this.stride; for (let qe = 0; qe < pe.length; qe += Xe) { if (pe[qe + 2] <= j) continue; pe[qe + 2] = j; const ht = pe[qe], yt = pe[qe + 1], Pt = V.within(pe[qe], pe[qe + 1], Ee), tr = pe[qe + 5]; let Wt = tr; for (const De of Pt) { const nr = De * Xe; pe[nr + 2] > j && (Wt += pe[nr + 5]) } if (Wt > tr && Wt >= Ae) { let De, nr = ht * tr, pn = yt * tr, Mt = -1; const Jt = (qe / Xe << 5) + (j + 1) + this.points.length; for (const fn of Pt) { const pr = fn * Xe; if (pe[pr + 2] <= j) continue; pe[pr + 2] = j; const Mr = pe[pr + 5]; nr += pe[pr] * Mr, pn += pe[pr + 1] * Mr, pe[pr + 4] = Jt, he && (De || (De = this._map(pe, qe, !0), Mt = this.clusterProps.length, this.clusterProps.push(De)), he(De, this._map(pe, pr))) } pe[qe + 4] = Jt, Be.push(nr / Wt, pn / Wt, 1 / 0, Jt, -1, Wt), he && Be.push(Mt) } else { for (let De = 0; De < Xe; De++)Be.push(pe[qe + De]); if (Wt > 1) for (const De of Pt) { const nr = De * Xe; if (!(pe[nr + 2] <= j)) { pe[nr + 2] = j; for (let pn = 0; pn < Xe; pn++)Be.push(pe[nr + pn]) } } } } return Be } _getOriginId(V) { return V - this.points.length >> 5 } _getOriginZoom(V) { return (V - this.points.length) % 32 } _map(V, j, W) { if (V[j + 5] > 1) { const Ae = this.clusterProps[V[j + 6]]; return W ? Object.assign({}, Ae) : Ae } const ue = this.points[V[j + 3]].properties, he = this.options.map(ue); return W && he === ue ? Object.assign({}, he) : he } } function ie(Pe, V, j) { return { type: "Feature", id: Pe[V + 3], properties: Ce(Pe, V, j), geometry: { type: "Point", coordinates: [(W = Pe[V], 360 * (W - .5)), Ne(Pe[V + 1])] } }; var W } function Ce(Pe, V, j) { const W = Pe[V + 5], ue = W >= 1e4 ? `${Math.round(W / 1e3)}k` : W >= 1e3 ? Math.round(W / 100) / 10 + "k" : W, he = Pe[V + 6], Ae = he === -1 ? {} : Object.assign({}, j[he]); return Object.assign(Ae, { cluster: !0, cluster_id: Pe[V + 3], point_count: W, point_count_abbreviated: ue }) } function xe(Pe) { return Pe / 360 + .5 } function Te(Pe) { const V = Math.sin(Pe * Math.PI / 180), j = .5 - .25 * Math.log((1 + V) / (1 - V)) / Math.PI; return j < 0 ? 0 : j > 1 ? 1 : j } function Ne(Pe) { const V = (180 - 360 * Pe) * Math.PI / 180; return 360 * Math.atan(Math.exp(V)) / Math.PI - 90 } function _e(Pe, V, j, W) { let ue = W; const he = V + (j - V >> 1); let Ae, Ee = j - V; const pe = Pe[V], Be = Pe[V + 1], Xe = Pe[j], qe = Pe[j + 1]; for (let ht = V + 3; ht < j; ht += 3) { const yt = Me(Pe[ht], Pe[ht + 1], pe, Be, Xe, qe); if (yt > ue) Ae = ht, ue = yt; else if (yt === ue) { const Pt = Math.abs(ht - he); Pt < Ee && (Ae = ht, Ee = Pt) } } ue > W && (Ae - V > 3 && _e(Pe, V, Ae, W), Pe[Ae + 2] = ue, j - Ae > 3 && _e(Pe, Ae, j, W)) } function Me(Pe, V, j, W, ue, he) { let Ae = ue - j, Ee = he - W; if (Ae !== 0 || Ee !== 0) { const pe = ((Pe - j) * Ae + (V - W) * Ee) / (Ae * Ae + Ee * Ee); pe > 1 ? (j = ue, W = he) : pe > 0 && (j += Ae * pe, W += Ee * pe) } return Ae = Pe - j, Ee = V - W, Ae * Ae + Ee * Ee } function Le(Pe, V, j, W) { const ue = { id: Pe ?? null, type: V, geometry: j, tags: W, minX: 1 / 0, minY: 1 / 0, maxX: -1 / 0, maxY: -1 / 0 }; if (V === "Point" || V === "MultiPoint" || V === "LineString") de(ue, j); else if (V === "Polygon") de(ue, j[0]); else if (V === "MultiLineString") for (const he of j) de(ue, he); else if (V === "MultiPolygon") for (const he of j) de(ue, he[0]); return ue } function de(Pe, V) { for (let j = 0; j < V.length; j += 3)Pe.minX = Math.min(Pe.minX, V[j]), Pe.minY = Math.min(Pe.minY, V[j + 1]), Pe.maxX = Math.max(Pe.maxX, V[j]), Pe.maxY = Math.max(Pe.maxY, V[j + 1]) } function Se(Pe, V, j, W) { if (!V.geometry) return; const ue = V.geometry.coordinates; if (ue && ue.length === 0) return; const he = V.geometry.type, Ae = Math.pow(j.tolerance / ((1 << j.maxZoom) * j.extent), 2); let Ee = [], pe = V.id; if (j.promoteId ? pe = V.properties[j.promoteId] : j.generateId && (pe = W || 0), he === "Point") et(ue, Ee); else if (he === "MultiPoint") for (const Be of ue) et(Be, Ee); else if (he === "LineString") lt(ue, Ee, Ae, !1); else if (he === "MultiLineString") { if (j.lineMetrics) { for (const Be of ue) Ee = [], lt(Be, Ee, Ae, !1), Pe.push(Le(pe, "LineString", Ee, V.properties)); return } Tt(ue, Ee, Ae, !1) } else if (he === "Polygon") Tt(ue, Ee, Ae, !0); else { if (he !== "MultiPolygon") { if (he === "GeometryCollection") { for (const Be of V.geometry.geometries) Se(Pe, { id: pe, geometry: Be, properties: V.properties }, j, W); return } throw new Error("Input data is not a valid GeoJSON object.") } for (const Be of ue) { const Xe = []; Tt(Be, Xe, Ae, !0), Ee.push(Xe) } } Pe.push(Le(pe, he, Ee, V.properties)) } function et(Pe, V) { V.push(Zt(Pe[0]), Ut(Pe[1]), 0) } function lt(Pe, V, j, W) { let ue, he, Ae = 0; for (let pe = 0; pe < Pe.length; pe++) { const Be = Zt(Pe[pe][0]), Xe = Ut(Pe[pe][1]); V.push(Be, Xe, 0), pe > 0 && (Ae += W ? (ue * Xe - Be * he) / 2 : Math.sqrt(Math.pow(Be - ue, 2) + Math.pow(Xe - he, 2))), ue = Be, he = Xe } const Ee = V.length - 3; V[2] = 1, _e(V, 0, Ee, j), V[Ee + 2] = 1, V.size = Math.abs(Ae), V.start = 0, V.end = V.size } function Tt(Pe, V, j, W) { for (let ue = 0; ue < Pe.length; ue++) { const he = []; lt(Pe[ue], he, j, W), V.push(he) } } function Zt(Pe) { return Pe / 360 + .5 } function Ut(Pe) { const V = Math.sin(Pe * Math.PI / 180), j = .5 - .25 * Math.log((1 + V) / (1 - V)) / Math.PI; return j < 0 ? 0 : j > 1 ? 1 : j } function St(Pe, V, j, W, ue, he, Ae, Ee) { if (W /= V, he >= (j /= V) && Ae < W) return Pe; if (Ae < j || he >= W) return null; const pe = []; for (const Be of Pe) { const Xe = Be.geometry; let qe = Be.type; const ht = ue === 0 ? Be.minX : Be.minY, yt = ue === 0 ? Be.maxX : Be.maxY; if (ht >= j && yt < W) { pe.push(Be); continue } if (yt < j || ht >= W) continue; let Pt = []; if (qe === "Point" || qe === "MultiPoint") Ct(Xe, Pt, j, W, ue); else if (qe === "LineString") Yt(Xe, Pt, j, W, ue, !1, Ee.lineMetrics); else if (qe === "MultiLineString") vi(Xe, Pt, j, W, ue, !1); else if (qe === "Polygon") vi(Xe, Pt, j, W, ue, !0); else if (qe === "MultiPolygon") for (const tr of Xe) { const Wt = []; vi(tr, Wt, j, W, ue, !0), Wt.length && Pt.push(Wt) } if (Pt.length) { if (Ee.lineMetrics && qe === "LineString") { for (const tr of Pt) pe.push(Le(Be.id, qe, tr, Be.tags)); continue } qe !== "LineString" && qe !== "MultiLineString" || (Pt.length === 1 ? (qe = "LineString", Pt = Pt[0]) : qe = "MultiLineString"), qe !== "Point" && qe !== "MultiPoint" || (qe = Pt.length === 3 ? "Point" : "MultiPoint"), pe.push(Le(Be.id, qe, Pt, Be.tags)) } } return pe.length ? pe : null } function Ct(Pe, V, j, W, ue) { for (let he = 0; he < Pe.length; he += 3) { const Ae = Pe[he + ue]; Ae >= j && Ae <= W && In(V, Pe[he], Pe[he + 1], Pe[he + 2]) } } function Yt(Pe, V, j, W, ue, he, Ae) { let Ee = Wr(Pe); const pe = ue === 0 ? vn : dn; let Be, Xe, qe = Pe.start; for (let Wt = 0; Wt < Pe.length - 3; Wt += 3) { const De = Pe[Wt], nr = Pe[Wt + 1], pn = Pe[Wt + 2], Mt = Pe[Wt + 3], Jt = Pe[Wt + 4], fn = ue === 0 ? De : nr, pr = ue === 0 ? Mt : Jt; let Mr = !1; Ae && (Be = Math.sqrt(Math.pow(De - Mt, 2) + Math.pow(nr - Jt, 2))), fn < j ? pr > j && (Xe = pe(Ee, De, nr, Mt, Jt, j), Ae && (Ee.start = qe + Be * Xe)) : fn > W ? pr < W && (Xe = pe(Ee, De, nr, Mt, Jt, W), Ae && (Ee.start = qe + Be * Xe)) : In(Ee, De, nr, pn), pr < j && fn >= j && (Xe = pe(Ee, De, nr, Mt, Jt, j), Mr = !0), pr > W && fn <= W && (Xe = pe(Ee, De, nr, Mt, Jt, W), Mr = !0), !he && Mr && (Ae && (Ee.end = qe + Be * Xe), V.push(Ee), Ee = Wr(Pe)), Ae && (qe += Be) } let ht = Pe.length - 3; const yt = Pe[ht], Pt = Pe[ht + 1], tr = ue === 0 ? yt : Pt; tr >= j && tr <= W && In(Ee, yt, Pt, Pe[ht + 2]), ht = Ee.length - 3, he && ht >= 3 && (Ee[ht] !== Ee[0] || Ee[ht + 1] !== Ee[1]) && In(Ee, Ee[0], Ee[1], Ee[2]), Ee.length && V.push(Ee) } function Wr(Pe) { const V = []; return V.size = Pe.size, V.start = Pe.start, V.end = Pe.end, V } function vi(Pe, V, j, W, ue, he) { for (const Ae of Pe) Yt(Ae, V, j, W, ue, he, !1) } function In(Pe, V, j, W) { Pe.push(V, j, W) } function vn(Pe, V, j, W, ue, he) { const Ae = (he - V) / (W - V); return In(Pe, he, j + (ue - j) * Ae, 1), Ae } function dn(Pe, V, j, W, ue, he) { const Ae = (he - j) / (ue - j); return In(Pe, V + (W - V) * Ae, he, 1), Ae } function rn(Pe, V) { const j = []; for (let W = 0; W < Pe.length; W++) { const ue = Pe[W], he = ue.type; let Ae; if (he === "Point" || he === "MultiPoint" || he === "LineString") Ae = qt(ue.geometry, V); else if (he === "MultiLineString" || he === "Polygon") { Ae = []; for (const Ee of ue.geometry) Ae.push(qt(Ee, V)) } else if (he === "MultiPolygon") { Ae = []; for (const Ee of ue.geometry) { const pe = []; for (const Be of Ee) pe.push(qt(Be, V)); Ae.push(pe) } } j.push(Le(ue.id, he, Ae, ue.tags)) } return j } function qt(Pe, V) { const j = []; j.size = Pe.size, Pe.start !== void 0 && (j.start = Pe.start, j.end = Pe.end); for (let W = 0; W < Pe.length; W += 3)j.push(Pe[W] + V, Pe[W + 1], Pe[W + 2]); return j } function Gt(Pe, V) { if (Pe.transformed) return Pe; const j = 1 << Pe.z, W = Pe.x, ue = Pe.y; for (const he of Pe.features) { const Ae = he.geometry, Ee = he.type; if (he.geometry = [], Ee === 1) for (let pe = 0; pe < Ae.length; pe += 2)he.geometry.push(Ni(Ae[pe], Ae[pe + 1], V, j, W, ue)); else for (let pe = 0; pe < Ae.length; pe++) { const Be = []; for (let Xe = 0; Xe < Ae[pe].length; Xe += 2)Be.push(Ni(Ae[pe][Xe], Ae[pe][Xe + 1], V, j, W, ue)); he.geometry.push(Be) } } return Pe.transformed = !0, Pe } function Ni(Pe, V, j, W, ue, he) { return [Math.round(j * (Pe * W - ue)), Math.round(j * (V * W - he))] } function Pr(Pe, V, j, W, ue) { const he = V === ue.maxZoom ? 0 : ue.tolerance / ((1 << V) * ue.extent), Ae = { features: [], numPoints: 0, numSimplified: 0, numFeatures: Pe.length, source: null, x: j, y: W, z: V, transformed: !1, minX: 2, minY: 1, maxX: -1, maxY: 0 }; for (const Ee of Pe) ys(Ae, Ee, he, ue); return Ae } function ys(Pe, V, j, W) { const ue = V.geometry, he = V.type, Ae = []; if (Pe.minX = Math.min(Pe.minX, V.minX), Pe.minY = Math.min(Pe.minY, V.minY), Pe.maxX = Math.max(Pe.maxX, V.maxX), Pe.maxY = Math.max(Pe.maxY, V.maxY), he === "Point" || he === "MultiPoint") for (let Ee = 0; Ee < ue.length; Ee += 3)Ae.push(ue[Ee], ue[Ee + 1]), Pe.numPoints++, Pe.numSimplified++; else if (he === "LineString") Us(Ae, ue, Pe, j, !1, !1); else if (he === "MultiLineString" || he === "Polygon") for (let Ee = 0; Ee < ue.length; Ee++)Us(Ae, ue[Ee], Pe, j, he === "Polygon", Ee === 0); else if (he === "MultiPolygon") for (let Ee = 0; Ee < ue.length; Ee++) { const pe = ue[Ee]; for (let Be = 0; Be < pe.length; Be++)Us(Ae, pe[Be], Pe, j, !0, Be === 0) } if (Ae.length) { let Ee = V.tags || null; if (he === "LineString" && W.lineMetrics) { Ee = {}; for (const Be in V.tags) Ee[Be] = V.tags[Be]; Ee.mapbox_clip_start = ue.start / ue.size, Ee.mapbox_clip_end = ue.end / ue.size } const pe = { geometry: Ae, type: he === "Polygon" || he === "MultiPolygon" ? 3 : he === "LineString" || he === "MultiLineString" ? 2 : 1, tags: Ee }; V.id !== null && (pe.id = V.id), Pe.features.push(pe) } } function Us(Pe, V, j, W, ue, he) { const Ae = W * W; if (W > 0 && V.size < (ue ? Ae : W)) return void (j.numPoints += V.length / 3); const Ee = []; for (let pe = 0; pe < V.length; pe += 3)(W === 0 || V[pe + 2] > Ae) && (j.numSimplified++, Ee.push(V[pe], V[pe + 1])), j.numPoints++; ue && function (pe, Be) { let Xe = 0; for (let qe = 0, ht = pe.length, yt = ht - 2; qe < ht; yt = qe, qe += 2)Xe += (pe[qe] - pe[yt]) * (pe[qe + 1] + pe[yt + 1]); if (Xe > 0 === Be) for (let qe = 0, ht = pe.length; qe < ht / 2; qe += 2) { const yt = pe[qe], Pt = pe[qe + 1]; pe[qe] = pe[ht - 2 - qe], pe[qe + 1] = pe[ht - 1 - qe], pe[ht - 2 - qe] = yt, pe[ht - 1 - qe] = Pt } }(Ee, he), Pe.push(Ee) } const Po = { maxZoom: 14, indexMaxZoom: 5, indexMaxPoints: 1e5, tolerance: 3, extent: 4096, buffer: 64, lineMetrics: !1, promoteId: null, generateId: !1, debug: 0 }; class vs { constructor(V, j) { const W = (j = this.options = function (he, Ae) { for (const Ee in Ae) he[Ee] = Ae[Ee]; return he }(Object.create(Po), j)).debug; if (W && console.time("preprocess data"), j.maxZoom < 0 || j.maxZoom > 24) throw new Error("maxZoom should be in the 0-24 range"); if (j.promoteId && j.generateId) throw new Error("promoteId and generateId cannot be used together."); let ue = function (he, Ae) { const Ee = []; if (he.type === "FeatureCollection") for (let pe = 0; pe < he.features.length; pe++)Se(Ee, he.features[pe], Ae, pe); else Se(Ee, he.type === "Feature" ? he : { geometry: he }, Ae); return Ee }(V, j); this.tiles = {}, this.tileCoords = [], W && (console.timeEnd("preprocess data"), console.log("index: maxZoom: %d, maxPoints: %d", j.indexMaxZoom, j.indexMaxPoints), console.time("generate tiles"), this.stats = {}, this.total = 0), ue = function (he, Ae) { const Ee = Ae.buffer / Ae.extent; let pe = he; const Be = St(he, 1, -1 - Ee, Ee, 0, -1, 2, Ae), Xe = St(he, 1, 1 - Ee, 2 + Ee, 0, -1, 2, Ae); return (Be || Xe) && (pe = St(he, 1, -Ee, 1 + Ee, 0, -1, 2, Ae) || [], Be && (pe = rn(Be, 1).concat(pe)), Xe && (pe = pe.concat(rn(Xe, -1)))), pe }(ue, j), ue.length && this.splitTile(ue, 0, 0, 0), W && (ue.length && console.log("features: %d, points: %d", this.tiles[0].numFeatures, this.tiles[0].numPoints), console.timeEnd("generate tiles"), console.log("tiles generated:", this.total, JSON.stringify(this.stats))) } splitTile(V, j, W, ue, he, Ae, Ee) { const pe = [V, j, W, ue], Be = this.options, Xe = Be.debug; for (; pe.length;) { ue = pe.pop(), W = pe.pop(), j = pe.pop(), V = pe.pop(); const qe = 1 << j, ht = xi(j, W, ue); let yt = this.tiles[ht]; if (!yt && (Xe > 1 && console.time("creation"), yt = this.tiles[ht] = Pr(V, j, W, ue, Be), this.tileCoords.push({ z: j, x: W, y: ue }), Xe)) { Xe > 1 && (console.log("tile z%d-%d-%d (features: %d, points: %d, simplified: %d)", j, W, ue, yt.numFeatures, yt.numPoints, yt.numSimplified), console.timeEnd("creation")); const Mr = `z${j}`; this.stats[Mr] = (this.stats[Mr] || 0) + 1, this.total++ } if (yt.source = V, he == null) { if (j === Be.indexMaxZoom || yt.numPoints <= Be.indexMaxPoints) continue } else { if (j === Be.maxZoom || j === he) continue; if (he != null) { const Mr = he - j; if (W !== Ae >> Mr || ue !== Ee >> Mr) continue } } if (yt.source = null, V.length === 0) continue; Xe > 1 && console.time("clipping"); const Pt = .5 * Be.buffer / Be.extent, tr = .5 - Pt, Wt = .5 + Pt, De = 1 + Pt; let nr = null, pn = null, Mt = null, Jt = null, fn = St(V, qe, W - Pt, W + Wt, 0, yt.minX, yt.maxX, Be), pr = St(V, qe, W + tr, W + De, 0, yt.minX, yt.maxX, Be); V = null, fn && (nr = St(fn, qe, ue - Pt, ue + Wt, 1, yt.minY, yt.maxY, Be), pn = St(fn, qe, ue + tr, ue + De, 1, yt.minY, yt.maxY, Be), fn = null), pr && (Mt = St(pr, qe, ue - Pt, ue + Wt, 1, yt.minY, yt.maxY, Be), Jt = St(pr, qe, ue + tr, ue + De, 1, yt.minY, yt.maxY, Be), pr = null), Xe > 1 && console.timeEnd("clipping"), pe.push(nr || [], j + 1, 2 * W, 2 * ue), pe.push(pn || [], j + 1, 2 * W, 2 * ue + 1), pe.push(Mt || [], j + 1, 2 * W + 1, 2 * ue), pe.push(Jt || [], j + 1, 2 * W + 1, 2 * ue + 1) } } getTile(V, j, W) { V = +V, j = +j, W = +W; const ue = this.options, { extent: he, debug: Ae } = ue; if (V < 0 || V > 24) return null; const Ee = 1 << V, pe = xi(V, j = j + Ee & Ee - 1, W); if (this.tiles[pe]) return Gt(this.tiles[pe], he); Ae > 1 && console.log("drilling down to z%d-%d-%d", V, j, W); let Be, Xe = V, qe = j, ht = W; for (; !Be && Xe > 0;)Xe--, qe >>= 1, ht >>= 1, Be = this.tiles[xi(Xe, qe, ht)]; return Be && Be.source ? (Ae > 1 && (console.log("found parent tile z%d-%d-%d", Xe, qe, ht), console.time("drilling down")), this.splitTile(Be.source, Xe, qe, ht, V, j, W), Ae > 1 && console.timeEnd("drilling down"), this.tiles[pe] ? Gt(this.tiles[pe], he) : null) : null } } function xi(Pe, V, j) { return 32 * ((1 << Pe) * j + V) + Pe } class Mo extends ye { constructor(V, j, W, ue = Io) { super(V, j, W), this._dataUpdateable = new Map, this._createGeoJSONIndex = ue } loadVectorTile(V, j) { return b._(this, void 0, void 0, function* () { const W = V.tileID.canonical; if (!this._geoJSONIndex) throw new Error("Unable to parse the data into a cluster or geojson"); const ue = this._geoJSONIndex.getTile(W.z, W.x, W.y); return ue ? Ye(new b.d2(ue.features, { version: 2, extent: b.a5 })) : null }) } loadData(V) { return b._(this, void 0, void 0, function* () { var j; (j = this._pendingRequest) === null || j === void 0 || j.abort(); const W = this._startPerformance(V); this._pendingRequest = new AbortController; try { (!this._pendingData || V.request || V.data || V.dataDiff) && (this._pendingData = this.loadAndProcessGeoJSON(V, this._pendingRequest)); const ue = yield this._pendingData; this._geoJSONIndex = this._createGeoJSONIndex(ue, V), this.loaded = {}; const he = {}; return V.request && (he.data = ue), this._finishPerformance(W, V, he), he } catch (ue) { if (delete this._pendingRequest, b.Z(ue)) return { abandoned: !0 }; throw ue } }) } _startPerformance(V) { var j; if (!((j = V == null ? void 0 : V.request) === null || j === void 0) && j.collectResourceTiming) return new b.c_(V.request) } _finishPerformance(V, j, W) { if (!V) return; const ue = V.finish(); ue && (W.resourceTiming = {}, W.resourceTiming[j.source] = JSON.parse(JSON.stringify(ue))) } getData() { return b._(this, void 0, void 0, function* () { return this._pendingData }) } reloadTile(V) { const j = this.loaded; return j && j[V.uid] ? super.reloadTile(V) : this.loadTile(V) } loadAndProcessGeoJSON(V, j) { return b._(this, void 0, void 0, function* () { let W; if (V.request ? W = yield this.loadGeoJSONFromUrl(V.request, V.promoteId, j) : V.data ? W = this._loadGeoJSONFromObject(V.data, V.promoteId) : V.dataDiff && (W = this._loadGeoJSONFromDiff(V.dataDiff, V.promoteId, V.source)), delete this._pendingRequest, typeof W != "object") throw new Error(`Input data given to '${V.source}' is not a valid GeoJSON object.`); return ft(W, !0), V.filter && (W = this._filterGeoJSON(W, V.filter)), W }) } loadGeoJSONFromUrl(V, j, W) { return b._(this, void 0, void 0, function* () { const ue = yield b.j(V, W); return this._dataUpdateable = b.a7(ue.data, j), ue.data }) } _loadGeoJSONFromObject(V, j) { return this._dataUpdateable = b.a7(V, j), V } _loadGeoJSONFromDiff(V, j, W) { if (!this._dataUpdateable) throw new Error(`Cannot update existing geojson data in ${W}`); b.a8(this._dataUpdateable, V, j); const ue = Array.from(this._dataUpdateable.values()); return this._toFeatureCollection(ue) } _filterGeoJSON(V, j) { const W = b.d3(j, { type: "boolean", "property-type": "data-driven", overridable: !1, transition: !1 }); if (W.result === "error") throw new Error(W.value.map(he => `${he.key}: ${he.message}`).join(", ")); const ue = V.features.filter(he => W.value.evaluate({ zoom: 0 }, he)); return this._toFeatureCollection(ue) } _toFeatureCollection(V) { return { type: "FeatureCollection", features: V } } removeSource(V) { return b._(this, void 0, void 0, function* () { this._pendingRequest && this._pendingRequest.abort() }) } getClusterExpansionZoom(V) { return this._geoJSONIndex.getClusterExpansionZoom(V.clusterId) } getClusterChildren(V) { return this._geoJSONIndex.getChildren(V.clusterId) } getClusterLeaves(V) { return this._geoJSONIndex.getLeaves(V.clusterId, V.limit, V.offset) } } function Io(Pe, V) { return V.cluster ? new re(function ({ superclusterOptions: j, clusterProperties: W }) { if (!W || !j) return j; const ue = {}, he = {}, Ae = { accumulated: null, zoom: 0 }, Ee = { properties: null }, pe = Object.keys(W); for (const Be of pe) { const [Xe, qe] = W[Be], ht = b.d3(qe), yt = b.d3(typeof Xe == "string" ? [Xe, ["accumulated"], ["get", Be]] : Xe); ue[Be] = ht.value, he[Be] = yt.value } return j.map = Be => { Ee.properties = Be; const Xe = {}; for (const qe of pe) Xe[qe] = ue[qe].evaluate(Ae, Ee); return Xe }, j.reduce = (Be, Xe) => { Ee.properties = Xe; for (const qe of pe) Ae.accumulated = Be[qe], Be[qe] = he[qe].evaluate(Ae, Ee) }, j }(V)).load(Pe.features) : function (j, W) { return new vs(j, W) }(Pe, V.geojsonVtOptions) } class jn { constructor(V) { this.self = V, this.actor = new b.L(V), this.layerIndexes = {}, this.availableImages = {}, this.workerSources = {}, this.demWorkerSources = {}, this.externalWorkerSourceTypes = {}, this.globalStates = new Map, this.self.registerWorkerSource = (j, W) => { if (this.externalWorkerSourceTypes[j]) throw new Error(`Worker source with name "${j}" already registered.`); this.externalWorkerSourceTypes[j] = W }, this.self.addProtocol = b.cJ, this.self.removeProtocol = b.cK, this.self.registerRTLTextPlugin = j => { b.d4.setMethods(j) }, this.actor.registerMessageHandler("LDT", (j, W) => this._getDEMWorkerSource(j, W.source).loadTile(W)), this.actor.registerMessageHandler("RDT", (j, W) => b._(this, void 0, void 0, function* () { this._getDEMWorkerSource(j, W.source).removeTile(W) })), this.actor.registerMessageHandler("GCEZ", (j, W) => b._(this, void 0, void 0, function* () { return this._getWorkerSource(j, W.type, W.source).getClusterExpansionZoom(W) })), this.actor.registerMessageHandler("GCC", (j, W) => b._(this, void 0, void 0, function* () { return this._getWorkerSource(j, W.type, W.source).getClusterChildren(W) })), this.actor.registerMessageHandler("GCL", (j, W) => b._(this, void 0, void 0, function* () { return this._getWorkerSource(j, W.type, W.source).getClusterLeaves(W) })), this.actor.registerMessageHandler("LD", (j, W) => this._getWorkerSource(j, W.type, W.source).loadData(W)), this.actor.registerMessageHandler("GD", (j, W) => this._getWorkerSource(j, W.type, W.source).getData()), this.actor.registerMessageHandler("LT", (j, W) => this._getWorkerSource(j, W.type, W.source).loadTile(W)), this.actor.registerMessageHandler("RT", (j, W) => this._getWorkerSource(j, W.type, W.source).reloadTile(W)), this.actor.registerMessageHandler("AT", (j, W) => this._getWorkerSource(j, W.type, W.source).abortTile(W)), this.actor.registerMessageHandler("RMT", (j, W) => this._getWorkerSource(j, W.type, W.source).removeTile(W)), this.actor.registerMessageHandler("RS", (j, W) => b._(this, void 0, void 0, function* () { if (!this.workerSources[j] || !this.workerSources[j][W.type] || !this.workerSources[j][W.type][W.source]) return; const ue = this.workerSources[j][W.type][W.source]; delete this.workerSources[j][W.type][W.source], ue.removeSource !== void 0 && ue.removeSource(W) })), this.actor.registerMessageHandler("RM", j => b._(this, void 0, void 0, function* () { delete this.layerIndexes[j], delete this.availableImages[j], delete this.workerSources[j], delete this.demWorkerSources[j], this.globalStates.delete(j) })), this.actor.registerMessageHandler("SR", (j, W) => b._(this, void 0, void 0, function* () { this.referrer = W })), this.actor.registerMessageHandler("SRPS", (j, W) => this._syncRTLPluginState(j, W)), this.actor.registerMessageHandler("IS", (j, W) => b._(this, void 0, void 0, function* () { this.self.importScripts(W) })), this.actor.registerMessageHandler("SI", (j, W) => this._setImages(j, W)), this.actor.registerMessageHandler("UL", (j, W) => b._(this, void 0, void 0, function* () { this._getLayerIndex(j).update(W.layers, W.removedIds, this._getGlobalState(j)) })), this.actor.registerMessageHandler("UGS", (j, W) => b._(this, void 0, void 0, function* () { const ue = this._getGlobalState(j); for (const he in W) ue[he] = W[he] })), this.actor.registerMessageHandler("SL", (j, W) => b._(this, void 0, void 0, function* () { this._getLayerIndex(j).replace(W, this._getGlobalState(j)) })) } _getGlobalState(V) { let j = this.globalStates.get(V); return j || (j = {}, this.globalStates.set(V, j)), j } _setImages(V, j) { return b._(this, void 0, void 0, function* () { this.availableImages[V] = j; for (const W in this.workerSources[V]) { const ue = this.workerSources[V][W]; for (const he in ue) ue[he].availableImages = j } }) } _syncRTLPluginState(V, j) { return b._(this, void 0, void 0, function* () { return yield b.d4.syncState(j, this.self.importScripts) }) } _getAvailableImages(V) { let j = this.availableImages[V]; return j || (j = []), j } _getLayerIndex(V) { let j = this.layerIndexes[V]; return j || (j = this.layerIndexes[V] = new c), j } _getWorkerSource(V, j, W) { if (this.workerSources[V] || (this.workerSources[V] = {}), this.workerSources[V][j] || (this.workerSources[V][j] = {}), !this.workerSources[V][j][W]) { const ue = { sendAsync: (he, Ae) => (he.targetMapId = V, this.actor.sendAsync(he, Ae)) }; switch (j) { case "vector": this.workerSources[V][j][W] = new ye(ue, this._getLayerIndex(V), this._getAvailableImages(V)); break; case "geojson": this.workerSources[V][j][W] = new Mo(ue, this._getLayerIndex(V), this._getAvailableImages(V)); break; default: this.workerSources[V][j][W] = new this.externalWorkerSourceTypes[j](ue, this._getLayerIndex(V), this._getAvailableImages(V)) } } return this.workerSources[V][j][W] } _getDEMWorkerSource(V, j) { return this.demWorkerSources[V] || (this.demWorkerSources[V] = {}), this.demWorkerSources[V][j] || (this.demWorkerSources[V][j] = new be), this.demWorkerSources[V][j] } } return b.i(self) && (self.worker = new jn(self)), jn }), w("index", ["exports", "./shared"], function (b, c) {
            var B = "5.15.0"; function $() { var m = new c.A(4); return c.A != Float32Array && (m[1] = 0, m[2] = 0), m[0] = 1, m[3] = 1, m } let me, ge, we; const Ge = { frame(m, t, s) { const l = requestAnimationFrame(g => { d(), t(g) }), { unsubscribe: d } = c.s(m.signal, "abort", () => { d(), cancelAnimationFrame(l), s(new c.a(m.signal.reason)) }, !1) }, frameAsync(m) { return new Promise((t, s) => { this.frame(m, t, s) }) }, getImageData(m, t = 0) { return this.getImageCanvasContext(m).getImageData(-t, -t, m.width + 2 * t, m.height + 2 * t) }, getImageCanvasContext(m) { const t = window.document.createElement("canvas"), s = t.getContext("2d", { willReadFrequently: !0 }); if (!s) throw new Error("failed to create canvas 2d context"); return t.width = m.width, t.height = m.height, s.drawImage(m, 0, 0, m.width, m.height), s }, resolveURL: m => (me || (me = document.createElement("a")), me.href = m, me.href), hardwareConcurrency: typeof navigator < "u" && navigator.hardwareConcurrency || 4, get prefersReducedMotion() { return we !== void 0 ? we : !!matchMedia && (ge == null && (ge = matchMedia("(prefers-reduced-motion: reduce)")), ge.matches) }, set prefersReducedMotion(m) { we = m } }, Ye = new class { constructor() { this._realTime = typeof performance < "u" && performance && performance.now ? performance.now.bind(performance) : Date.now.bind(Date), this._frozenAt = null } getCurrentTime() { return this._frozenAt !== null ? this._frozenAt : this._realTime() } setNow(m) { this._frozenAt = m } restoreNow() { this._frozenAt = null } isFrozen() { return this._frozenAt !== null } }; function $e() { return Ye.getCurrentTime() } class ye { static testProp(t) { if (!ye.docStyle) return t[0]; for (let s = 0; s < t.length; s++)if (t[s] in ye.docStyle) return t[s]; return t[0] } static create(t, s, l) { const d = window.document.createElement(t); return s !== void 0 && (d.className = s), l && l.appendChild(d), d } static createNS(t, s) { return window.document.createElementNS(t, s) } static disableDrag() { ye.docStyle && ye.selectProp && (ye.userSelect = ye.docStyle[ye.selectProp], ye.docStyle[ye.selectProp] = "none") } static enableDrag() { ye.docStyle && ye.selectProp && (ye.docStyle[ye.selectProp] = ye.userSelect) } static setTransform(t, s) { t.style[ye.transformProp] = s } static addEventListener(t, s, l, d = {}) { t.addEventListener(s, l, "passive" in d ? d : d.capture) } static removeEventListener(t, s, l, d = {}) { t.removeEventListener(s, l, "passive" in d ? d : d.capture) } static suppressClickInternal(t) { t.preventDefault(), t.stopPropagation(), window.removeEventListener("click", ye.suppressClickInternal, !0) } static suppressClick() { window.addEventListener("click", ye.suppressClickInternal, !0), window.setTimeout(() => { window.removeEventListener("click", ye.suppressClickInternal, !0) }, 0) } static getScale(t) { const s = t.getBoundingClientRect(); return { x: s.width / t.offsetWidth || 1, y: s.height / t.offsetHeight || 1, boundingClientRect: s } } static getPoint(t, s, l) { const d = s.boundingClientRect; return new c.P((l.clientX - d.left) / s.x - t.clientLeft, (l.clientY - d.top) / s.y - t.clientTop) } static mousePos(t, s) { const l = ye.getScale(t); return ye.getPoint(t, l, s) } static touchPos(t, s) { const l = [], d = ye.getScale(t); for (let g = 0; g < s.length; g++)l.push(ye.getPoint(t, d, s[g])); return l } static mouseButton(t) { return t.button } static remove(t) { t.parentNode && t.parentNode.removeChild(t) } static sanitize(t) { const s = new DOMParser().parseFromString(t, "text/html").body || document.createElement("body"), l = s.querySelectorAll("script"); for (const d of l) d.remove(); return ye.clean(s), s.innerHTML } static isPossiblyDangerous(t, s) { const l = s.replace(/\s+/g, "").toLowerCase(); return !(!["src", "href", "xlink:href"].includes(t) || !l.includes("javascript:") && !l.includes("data:")) || !!t.startsWith("on") || void 0 } static clean(t) { const s = t.children; for (const l of s) ye.removeAttributes(l), ye.clean(l) } static removeAttributes(t) { for (const { name: s, value: l } of t.attributes) ye.isPossiblyDangerous(s, l) && t.removeAttribute(s) } } ye.docStyle = typeof window < "u" && window.document && window.document.documentElement.style, ye.selectProp = ye.testProp(["userSelect", "MozUserSelect", "WebkitUserSelect", "msUserSelect"]), ye.transformProp = ye.testProp(["transform", "WebkitTransform"]); const be = { supported: !1, testSupport: function (m) { !Ke && ve && (ft ? mt(m) : K = m) } }; let K, ve, Ke = !1, ft = !1; function mt(m) { const t = m.createTexture(); m.bindTexture(m.TEXTURE_2D, t); try { if (m.texImage2D(m.TEXTURE_2D, 0, m.RGBA, m.RGBA, m.UNSIGNED_BYTE, ve), m.isContextLost()) return; be.supported = !0 } catch { } m.deleteTexture(t), Ke = !0 } var ct; typeof document < "u" && (ve = document.createElement("img"), ve.onload = () => { K && mt(K), K = null, ft = !0 }, ve.onerror = () => { Ke = !0, K = null }, ve.src = "data:image/webp;base64,UklGRh4AAABXRUJQVlA4TBEAAAAvAQAAAAfQ//73v/+BiOh/AAA="), function (m) { let t, s, l, d; m.resetRequestQueue = () => { t = [], s = 0, l = 0, d = {} }, m.addThrottleControl = E => { const I = l++; return d[I] = E, I }, m.removeThrottleControl = E => { delete d[E], v() }, m.getImage = (E, I, A = !0) => new Promise((R, z) => { be.supported && (E.headers || (E.headers = {}), E.headers.accept = "image/webp,*/*"), c.e(E, { type: "image" }), t.push({ abortController: I, requestParameters: E, supportImageRefresh: A, state: "queued", onError: O => { z(O) }, onSuccess: O => { R(O) } }), v() }); const g = E => c._(this, void 0, void 0, function* () { E.state = "running"; const { requestParameters: I, supportImageRefresh: A, onError: R, onSuccess: z, abortController: O } = E, U = A === !1 && !c.i(self) && !c.g(I.url) && (!I.headers || Object.keys(I.headers).reduce((Y, te) => Y && te === "accept", !0)); s++; const X = U ? T(I, O) : c.m(I, O); try { const Y = yield X; delete E.abortController, E.state = "completed", Y.data instanceof HTMLImageElement || c.b(Y.data) ? z(Y) : Y.data && z({ data: yield (Q = Y.data, typeof createImageBitmap == "function" ? c.f(Q) : c.h(Q)), cacheControl: Y.cacheControl, expires: Y.expires }) } catch (Y) { delete E.abortController, R(Y) } finally { s--, v() } var Q }), v = () => { const E = (() => { for (const I of Object.keys(d)) if (d[I]()) return !0; return !1 })() ? c.c.MAX_PARALLEL_IMAGE_REQUESTS_PER_FRAME : c.c.MAX_PARALLEL_IMAGE_REQUESTS; for (let I = s; I < E && t.length > 0; I++) { const A = t.shift(); A.abortController.signal.aborted ? I-- : g(A) } }, T = (E, I) => new Promise((A, R) => { const z = new Image, O = E.url, U = E.credentials; U && U === "include" ? z.crossOrigin = "use-credentials" : (U && U === "same-origin" || !c.d(O)) && (z.crossOrigin = "anonymous"), I.signal.addEventListener("abort", () => { z.src = "", R(new c.a(I.signal.reason)) }), z.fetchPriority = "high", z.onload = () => { z.onerror = z.onload = null, A({ data: z }) }, z.onerror = () => { z.onerror = z.onload = null, I.signal.aborted || R(new Error("Could not load image. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported.")) }, z.src = O }) }(ct || (ct = {})), ct.resetRequestQueue(); class Z { constructor(t) { this._transformRequestFn = t ?? null } transformRequest(t, s) { return this._transformRequestFn && this._transformRequestFn(t, s) || { url: t } } setTransformRequest(t) { this._transformRequestFn = t } } function re(m) { const t = []; if (typeof m == "string") t.push({ id: "default", url: m }); else if (m && m.length > 0) { const s = []; for (const { id: l, url: d } of m) { const g = `${l}${d}`; s.indexOf(g) === -1 && (s.push(g), t.push({ id: l, url: d })) } } return t } function ie(m, t, s) { try { const l = new URL(m); return l.pathname += `${t}${s}`, l.toString() } catch { throw new Error(`Invalid sprite URL "${m}", must be absolute. Modify style specification directly or use TransformStyleFunction to correct the issue dynamically`) } } function Ce(m) { const { userImage: t } = m; return !!(t && t.render && t.render()) && (m.data.replace(new Uint8Array(t.data.buffer)), !0) } class xe extends c.E { constructor() { super(), this.images = {}, this.updatedImages = {}, this.callbackDispatchedThisFrame = {}, this.loaded = !1, this.requestors = [], this.patterns = {}, this.atlasImage = new c.R({ width: 1, height: 1 }), this.dirty = !0 } destroy() { this.atlasTexture && (this.atlasTexture.destroy(), this.atlasTexture = null); for (const t of Object.keys(this.images)) this.removeImage(t); this.patterns = {}, this.atlasImage = new c.R({ width: 1, height: 1 }), this.dirty = !0 } isLoaded() { return this.loaded } setLoaded(t) { if (this.loaded !== t && (this.loaded = t, t)) { for (const { ids: s, promiseResolve: l } of this.requestors) l(this._getImagesForIds(s)); this.requestors = [] } } getImage(t) { const s = this.images[t]; if (s && !s.data && s.spriteData) { const l = s.spriteData; s.data = new c.R({ width: l.width, height: l.height }, l.context.getImageData(l.x, l.y, l.width, l.height).data), s.spriteData = null } return s } addImage(t, s) { if (this.images[t]) throw new Error(`Image id ${t} already exist, use updateImage instead`); this._validate(t, s) && (this.images[t] = s) } _validate(t, s) { let l = !0; const d = s.data || s.spriteData; return this._validateStretch(s.stretchX, d && d.width) || (this.fire(new c.k(new Error(`Image "${t}" has invalid "stretchX" value`))), l = !1), this._validateStretch(s.stretchY, d && d.height) || (this.fire(new c.k(new Error(`Image "${t}" has invalid "stretchY" value`))), l = !1), this._validateContent(s.content, s) || (this.fire(new c.k(new Error(`Image "${t}" has invalid "content" value`))), l = !1), l } _validateStretch(t, s) { if (!t) return !0; let l = 0; for (const d of t) { if (d[0] < l || d[1] < d[0] || s < d[1]) return !1; l = d[1] } return !0 } _validateContent(t, s) { if (!t) return !0; if (t.length !== 4) return !1; const l = s.spriteData, d = l && l.width || s.data.width, g = l && l.height || s.data.height; return !(t[0] < 0 || d < t[0] || t[1] < 0 || g < t[1] || t[2] < 0 || d < t[2] || t[3] < 0 || g < t[3] || t[2] < t[0] || t[3] < t[1]) } updateImage(t, s, l = !0) { const d = this.getImage(t); if (l && (d.data.width !== s.data.width || d.data.height !== s.data.height)) throw new Error(`size mismatch between old image (${d.data.width}x${d.data.height}) and new image (${s.data.width}x${s.data.height}).`); s.version = d.version + 1, this.images[t] = s, this.updatedImages[t] = !0 } removeImage(t) { const s = this.images[t]; delete this.images[t], delete this.patterns[t], s.userImage && s.userImage.onRemove && s.userImage.onRemove() } listImages() { return Object.keys(this.images) } getImages(t) { return new Promise((s, l) => { let d = !0; if (!this.isLoaded()) for (const g of t) this.images[g] || (d = !1); this.isLoaded() || d ? s(this._getImagesForIds(t)) : this.requestors.push({ ids: t, promiseResolve: s }) }) } _getImagesForIds(t) { const s = {}; for (const l of t) { let d = this.getImage(l); d || (this.fire(new c.l("styleimagemissing", { id: l })), d = this.getImage(l)), d ? s[l] = { data: d.data.clone(), pixelRatio: d.pixelRatio, sdf: d.sdf, version: d.version, stretchX: d.stretchX, stretchY: d.stretchY, content: d.content, textFitWidth: d.textFitWidth, textFitHeight: d.textFitHeight, hasRenderCallback: !!(d.userImage && d.userImage.render) } : c.w(`Image "${l}" could not be loaded. Please make sure you have added the image with map.addImage() or a "sprite" property in your style. You can provide missing images by listening for the "styleimagemissing" map event.`) } return s } getPixelSize() { const { width: t, height: s } = this.atlasImage; return { width: t, height: s } } getPattern(t) { const s = this.patterns[t], l = this.getImage(t); if (!l) return null; if (s && s.position.version === l.version) return s.position; if (s) s.position.version = l.version; else { const d = { w: l.data.width + 2, h: l.data.height + 2, x: 0, y: 0 }, g = new c.I(d, l); this.patterns[t] = { bin: d, position: g } } return this._updatePatternAtlas(), this.patterns[t].position } bind(t) { const s = t.gl; this.atlasTexture ? this.dirty && (this.atlasTexture.update(this.atlasImage), this.dirty = !1) : this.atlasTexture = new c.T(t, this.atlasImage, s.RGBA), this.atlasTexture.bind(s.LINEAR, s.CLAMP_TO_EDGE) } _updatePatternAtlas() { const t = []; for (const g in this.patterns) t.push(this.patterns[g].bin); const { w: s, h: l } = c.p(t), d = this.atlasImage; d.resize({ width: s || 1, height: l || 1 }); for (const g in this.patterns) { const { bin: v } = this.patterns[g], T = v.x + 1, E = v.y + 1, I = this.getImage(g).data, A = I.width, R = I.height; c.R.copy(I, d, { x: 0, y: 0 }, { x: T, y: E }, { width: A, height: R }), c.R.copy(I, d, { x: 0, y: R - 1 }, { x: T, y: E - 1 }, { width: A, height: 1 }), c.R.copy(I, d, { x: 0, y: 0 }, { x: T, y: E + R }, { width: A, height: 1 }), c.R.copy(I, d, { x: A - 1, y: 0 }, { x: T - 1, y: E }, { width: 1, height: R }), c.R.copy(I, d, { x: 0, y: 0 }, { x: T + A, y: E }, { width: 1, height: R }) } this.dirty = !0 } beginFrame() { this.callbackDispatchedThisFrame = {} } dispatchRenderCallbacks(t) { for (const s of t) { if (this.callbackDispatchedThisFrame[s]) continue; this.callbackDispatchedThisFrame[s] = !0; const l = this.getImage(s); l || c.w(`Image with ID: "${s}" was not found`), Ce(l) && this.updateImage(s, l) } } cloneImages() { const t = {}; for (const s in this.images) { const l = this.images[s]; t[s] = Object.assign(Object.assign({}, l), { data: l.data ? l.data.clone() : null }) } return t } } const Te = 1e20; function Ne(m, t, s, l, d, g, v, T, E) { for (let I = t; I < t + l; I++)_e(m, s * g + I, g, d, v, T, E); for (let I = s; I < s + d; I++)_e(m, I * g + t, 1, l, v, T, E) } function _e(m, t, s, l, d, g, v) { g[0] = 0, v[0] = -Te, v[1] = Te, d[0] = m[t]; for (let T = 1, E = 0, I = 0; T < l; T++) { d[T] = m[t + T * s]; const A = T * T; do { const R = g[E]; I = (d[T] - d[R] + A - R * R) / (T - R) / 2 } while (I <= v[E] && --E > -1); E++, g[E] = T, v[E] = I, v[E + 1] = Te } for (let T = 0, E = 0; T < l; T++) { for (; v[E + 1] < T;)E++; const I = g[E], A = T - I; m[t + T * s] = d[I] + A * A } } const Me = c.v.layout_symbol["text-font"].default.join(","); class Le { constructor(t, s, l) { this.requestManager = t, this.localIdeographFontFamily = s, this.entries = {}, this.lang = l } setURL(t) { this.url = t } getGlyphs(t) { return c._(this, void 0, void 0, function* () { const s = []; for (const g in t) for (const v of t[g]) s.push(this._getAndCacheGlyphsPromise(g, v)); const l = yield Promise.all(s), d = {}; for (const { stack: g, id: v, glyph: T } of l) d[g] || (d[g] = {}), d[g][v] = T && { id: T.id, bitmap: T.bitmap.clone(), metrics: T.metrics }; return d }) } _getAndCacheGlyphsPromise(t, s) { return c._(this, void 0, void 0, function* () { let l = this.entries[t]; l || (l = this.entries[t] = { glyphs: {}, requests: {}, ranges: {} }); let d = l.glyphs[s]; return d !== void 0 ? { stack: t, id: s, glyph: d } : !this.url || this._charUsesLocalIdeographFontFamily(s) ? (d = l.glyphs[s] = this._drawGlyph(l, t, s), { stack: t, id: s, glyph: d }) : yield this._downloadAndCacheRangePromise(t, s) }) } _downloadAndCacheRangePromise(t, s) { return c._(this, void 0, void 0, function* () { const l = this.entries[t], d = Math.floor(s / 256); if (l.ranges[d]) return { stack: t, id: s, glyph: null }; if (!l.requests[d]) { const g = Le.loadGlyphRange(t, d, this.url, this.requestManager); l.requests[d] = g } try { const g = yield l.requests[d]; for (const v in g) l.glyphs[+v] = g[+v]; return l.ranges[d] = !0, { stack: t, id: s, glyph: g[s] || null } } catch (g) { const v = l.glyphs[s] = this._drawGlyph(l, t, s); return this._warnOnMissingGlyphRange(v, d, s, g), { stack: t, id: s, glyph: v } } }) } _warnOnMissingGlyphRange(t, s, l, d) { const g = 256 * s, v = g + 255, T = l.toString(16).padStart(4, "0").toUpperCase(); c.w(`Unable to load glyph range ${s}, ${g}-${v}. Rendering codepoint U+${T} locally instead. ${d}`) } _charUsesLocalIdeographFontFamily(t) { return !!this.localIdeographFontFamily && c.q(t) } _drawGlyph(t, s, l) { const d = s === Me && this.localIdeographFontFamily !== "" && this._charUsesLocalIdeographFontFamily(l), g = d ? "ideographTinySDF" : "tinySDF"; t[g] || (t[g] = this._createTinySDF(d ? this.localIdeographFontFamily : s)); const v = t[g].draw(String.fromCodePoint(l)); return { id: l, bitmap: new c.r({ width: v.width || 60, height: v.height || 60 }, v.data), metrics: { width: v.glyphWidth / 2 || 24, height: v.glyphHeight / 2 || 24, left: v.glyphLeft / 2 + .5 || 0, top: v.glyphTop / 2 - 27.5 || -8, advance: v.glyphAdvance / 2 || 24, isDoubleResolution: !0 } } } _createTinySDF(t) { const s = t ? t.split(",") : []; s.push("sans-serif"); const l = s.map(d => /[-\w]+/.test(d) ? d : `'${CSS.escape(d)}'`).join(","); return new Le.TinySDF({ fontSize: 48, buffer: 6, radius: 16, cutoff: .25, fontFamily: l, fontWeight: this._fontWeight(s[0]), fontStyle: this._fontStyle(s[0]), lang: this.lang }) } _fontStyle(t) { return /italic/i.test(t) ? "italic" : /oblique/i.test(t) ? "oblique" : "normal" } _fontWeight(t) { const s = { thin: 100, hairline: 100, "extra light": 200, "ultra light": 200, light: 300, normal: 400, regular: 400, medium: 500, semibold: 600, demibold: 600, bold: 700, "extra bold": 800, "ultra bold": 800, black: 900, heavy: 900, "extra black": 950, "ultra black": 950 }; let l; for (const [d, g] of Object.entries(s)) new RegExp(`\\b${d}\\b`, "i").test(t) && (l = `${g}`); return l } destroy() { for (const t in this.entries) { const s = this.entries[t]; s.tinySDF && (s.tinySDF = null), s.ideographTinySDF && (s.ideographTinySDF = null), s.glyphs = {}, s.requests = {}, s.ranges = {} } this.entries = {} } } Le.loadGlyphRange = function (m, t, s, l) { return c._(this, void 0, void 0, function* () { const d = 256 * t, g = d + 255, v = l.transformRequest(s.replace("{fontstack}", m).replace("{range}", `${d}-${g}`), "Glyphs"), T = yield c.n(v, new AbortController); if (!T || !T.data) throw new Error(`Could not load glyph range. range: ${t}, ${d}-${g}`); const E = {}; for (const I of c.o(T.data)) E[I.id] = I; return E }) }, Le.TinySDF = class { constructor({ fontSize: m = 24, buffer: t = 3, radius: s = 8, cutoff: l = .25, fontFamily: d = "sans-serif", fontWeight: g = "normal", fontStyle: v = "normal", lang: T = null } = {}) { this.buffer = t, this.cutoff = l, this.radius = s, this.lang = T; const E = this.size = m + 4 * t, I = this._createCanvas(E), A = this.ctx = I.getContext("2d", { willReadFrequently: !0 }); A.font = `${v} ${g} ${m}px ${d}`, A.textBaseline = "alphabetic", A.textAlign = "left", A.fillStyle = "black", this.gridOuter = new Float64Array(E * E), this.gridInner = new Float64Array(E * E), this.f = new Float64Array(E), this.z = new Float64Array(E + 1), this.v = new Uint16Array(E) } _createCanvas(m) { const t = document.createElement("canvas"); return t.width = t.height = m, t } draw(m) { const { width: t, actualBoundingBoxAscent: s, actualBoundingBoxDescent: l, actualBoundingBoxLeft: d, actualBoundingBoxRight: g } = this.ctx.measureText(m), v = Math.ceil(s), T = Math.max(0, Math.min(this.size - this.buffer, Math.ceil(g - d))), E = Math.min(this.size - this.buffer, v + Math.ceil(l)), I = T + 2 * this.buffer, A = E + 2 * this.buffer, R = Math.max(I * A, 0), z = new Uint8ClampedArray(R), O = { data: z, width: I, height: A, glyphWidth: T, glyphHeight: E, glyphTop: v, glyphLeft: 0, glyphAdvance: t }; if (T === 0 || E === 0) return O; const { ctx: U, buffer: X, gridInner: Q, gridOuter: Y } = this; this.lang && (U.lang = this.lang), U.clearRect(X, X, T, E), U.fillText(m, X, X + v); const te = U.getImageData(X, X, T, E); Y.fill(Te, 0, R), Q.fill(0, 0, R); for (let le = 0; le < E; le++)for (let J = 0; J < T; J++) { const oe = te.data[4 * (le * T + J) + 3] / 255; if (oe === 0) continue; const ce = (le + X) * I + J + X; if (oe === 1) Y[ce] = 0, Q[ce] = Te; else { const se = .5 - oe; Y[ce] = se > 0 ? se * se : 0, Q[ce] = se < 0 ? se * se : 0 } } Ne(Y, 0, 0, I, A, I, this.f, this.v, this.z), Ne(Q, X, X, T, E, I, this.f, this.v, this.z); for (let le = 0; le < R; le++) { const J = Math.sqrt(Y[le]) - Math.sqrt(Q[le]); z[le] = Math.round(255 - 255 * (J / this.radius + this.cutoff)) } return O } }; class de { constructor() { this.specification = c.u.light.position } possiblyEvaluate(t, s) { return c.F(t.expression.evaluate(s)) } interpolate(t, s, l) { return { x: c.G.number(t.x, s.x, l), y: c.G.number(t.y, s.y, l), z: c.G.number(t.z, s.z, l) } } } let Se; class et extends c.E { constructor(t) { super(), Se = Se || new c.t({ anchor: new c.D(c.u.light.anchor), position: new de, color: new c.D(c.u.light.color), intensity: new c.D(c.u.light.intensity) }), this._transitionable = new c.x(Se, void 0), this.setLight(t), this._transitioning = this._transitionable.untransitioned() } getLight() { return this._transitionable.serialize() } setLight(t, s = {}) { if (!this._validate(c.y, t, s)) for (const l in t) { const d = t[l]; l.endsWith(c.z) ? this._transitionable.setTransition(l.slice(0, -c.z.length), d) : this._transitionable.setValue(l, d) } } updateTransitions(t) { this._transitioning = this._transitionable.transitioned(t, this._transitioning) } hasTransition() { return this._transitioning.hasTransition() } recalculate(t) { this.properties = this._transitioning.possiblyEvaluate(t) } _validate(t, s, l) { return (!l || l.validate !== !1) && c.B(this, t.call(c.C, { value: s, style: { glyphs: !0, sprite: !0 }, styleSpec: c.u })) } } const lt = new c.t({ "sky-color": new c.D(c.u.sky["sky-color"]), "horizon-color": new c.D(c.u.sky["horizon-color"]), "fog-color": new c.D(c.u.sky["fog-color"]), "fog-ground-blend": new c.D(c.u.sky["fog-ground-blend"]), "horizon-fog-blend": new c.D(c.u.sky["horizon-fog-blend"]), "sky-horizon-blend": new c.D(c.u.sky["sky-horizon-blend"]), "atmosphere-blend": new c.D(c.u.sky["atmosphere-blend"]) }); class Tt extends c.E { constructor(t) { super(), this._transitionable = new c.x(lt, void 0), this.setSky(t), this._transitioning = this._transitionable.untransitioned(), this.recalculate(new c.H(0)) } setSky(t, s = {}) { if (!this._validate(c.J, t, s)) { t || (t = { "sky-color": "transparent", "horizon-color": "transparent", "fog-color": "transparent", "fog-ground-blend": 1, "atmosphere-blend": 0 }); for (const l in t) { const d = t[l]; l.endsWith(c.z) ? this._transitionable.setTransition(l.slice(0, -c.z.length), d) : this._transitionable.setValue(l, d) } } } getSky() { return this._transitionable.serialize() } updateTransitions(t) { this._transitioning = this._transitionable.transitioned(t, this._transitioning) } hasTransition() { return this._transitioning.hasTransition() } recalculate(t) { this.properties = this._transitioning.possiblyEvaluate(t) } _validate(t, s, l = {}) { return (l == null ? void 0 : l.validate) !== !1 && c.B(this, t.call(c.C, c.e({ value: s, style: { glyphs: !0, sprite: !0 }, styleSpec: c.u }))) } calculateFogBlendOpacity(t) { return t < 60 ? 0 : t < 70 ? (t - 60) / 10 : 1 } } class Zt { constructor(t, s) { this.width = t, this.height = s, this.nextRow = 0, this.data = new Uint8Array(this.width * this.height), this.dashEntry = {} } getDash(t, s) { const l = t.join(",") + String(s); return this.dashEntry[l] || (this.dashEntry[l] = this.addDash(t, s)), this.dashEntry[l] } getDashRanges(t, s, l) { const d = []; let g = t.length % 2 == 1 ? -t[t.length - 1] * l : 0, v = t[0] * l, T = !0; d.push({ left: g, right: v, isDash: T, zeroLength: t[0] === 0 }); let E = t[0]; for (let I = 1; I < t.length; I++) { T = !T; const A = t[I]; g = E * l, E += A, v = E * l, d.push({ left: g, right: v, isDash: T, zeroLength: A === 0 }) } return d } addRoundDash(t, s, l) { const d = s / 2; for (let g = -l; g <= l; g++) { const v = this.width * (this.nextRow + l + g); let T = 0, E = t[T]; for (let I = 0; I < this.width; I++) { I / E.right > 1 && (E = t[++T]); const A = Math.abs(I - E.left), R = Math.abs(I - E.right), z = Math.min(A, R); let O; const U = g / l * (d + 1); if (E.isDash) { const X = d - Math.abs(U); O = Math.sqrt(z * z + X * X) } else O = d - Math.sqrt(z * z + U * U); this.data[v + I] = Math.max(0, Math.min(255, O + 128)) } } } addRegularDash(t) { for (let T = t.length - 1; T >= 0; --T) { const E = t[T], I = t[T + 1]; E.zeroLength ? t.splice(T, 1) : I && I.isDash === E.isDash && (I.left = E.left, t.splice(T, 1)) } const s = t[0], l = t[t.length - 1]; s.isDash === l.isDash && (s.left = l.left - this.width, l.right = s.right + this.width); const d = this.width * this.nextRow; let g = 0, v = t[g]; for (let T = 0; T < this.width; T++) { T / v.right > 1 && (v = t[++g]); const E = Math.abs(T - v.left), I = Math.abs(T - v.right), A = Math.min(E, I); this.data[d + T] = Math.max(0, Math.min(255, (v.isDash ? A : -A) + 128)) } } addDash(t, s) { const l = s ? 7 : 0, d = 2 * l + 1; if (this.nextRow + d > this.height) return c.w("LineAtlas out of space"), null; let g = 0; for (let T = 0; T < t.length; T++)g += t[T]; if (g !== 0) { const T = this.width / g, E = this.getDashRanges(t, this.width, T); s ? this.addRoundDash(E, T, l) : this.addRegularDash(E) } const v = { y: this.nextRow + l, height: 2 * l, width: g }; return this.nextRow += d, this.dirty = !0, v } bind(t) { const s = t.gl; this.texture ? (s.bindTexture(s.TEXTURE_2D, this.texture), this.dirty && (this.dirty = !1, s.texSubImage2D(s.TEXTURE_2D, 0, 0, 0, this.width, this.height, s.ALPHA, s.UNSIGNED_BYTE, this.data))) : (this.texture = s.createTexture(), s.bindTexture(s.TEXTURE_2D, this.texture), s.texParameteri(s.TEXTURE_2D, s.TEXTURE_WRAP_S, s.REPEAT), s.texParameteri(s.TEXTURE_2D, s.TEXTURE_WRAP_T, s.REPEAT), s.texParameteri(s.TEXTURE_2D, s.TEXTURE_MIN_FILTER, s.LINEAR), s.texParameteri(s.TEXTURE_2D, s.TEXTURE_MAG_FILTER, s.LINEAR), s.texImage2D(s.TEXTURE_2D, 0, s.ALPHA, this.width, this.height, 0, s.ALPHA, s.UNSIGNED_BYTE, this.data)) } } const Ut = "maplibre_preloaded_worker_pool"; class St { constructor() { this.active = {} } acquire(t) { if (!this.workers) for (this.workers = []; this.workers.length < St.workerCount;)this.workers.push(new Worker(c.c.WORKER_URL)); return this.active[t] = !0, this.workers.slice() } release(t) { delete this.active[t], this.numActive() === 0 && (this.workers.forEach(s => { s.terminate() }), this.workers = null) } isPreloaded() { return !!this.active[Ut] } numActive() { return Object.keys(this.active).length } } const Ct = Math.floor(Ge.hardwareConcurrency / 2); let Yt, Wr; function vi() { return Yt || (Yt = new St), Yt } St.workerCount = c.K(globalThis) ? Math.max(Math.min(Ct, 3), 1) : 1; class In { constructor(t, s) { this.workerPool = t, this.actors = [], this.currentActor = 0, this.id = s; const l = this.workerPool.acquire(s); for (let d = 0; d < l.length; d++) { const g = new c.L(l[d], s); g.name = `Worker ${d}`, this.actors.push(g) } if (!this.actors.length) throw new Error("No actors found") } broadcast(t, s) { const l = []; for (const d of this.actors) l.push(d.sendAsync({ type: t, data: s })); return Promise.all(l) } getActor() { return this.currentActor = (this.currentActor + 1) % this.actors.length, this.actors[this.currentActor] } remove(t = !0) { this.actors.forEach(s => { s.remove() }), this.actors = [], t && this.workerPool.release(this.id) } registerMessageHandler(t, s) { for (const l of this.actors) l.registerMessageHandler(t, s) } unregisterMessageHandler(t) { for (const s of this.actors) s.unregisterMessageHandler(t) } } function vn() { return Wr || (Wr = new In(vi(), c.M), Wr.registerMessageHandler("GR", (m, t, s) => c.m(t, s))), Wr } function dn(m, t) { const s = c.N(); return c.O(s, s, [1, 1, 0]), c.Q(s, s, [.5 * m.width, .5 * m.height, 1]), m.calculatePosMatrix ? c.S(s, s, m.calculatePosMatrix(t.toUnwrapped())) : s } function rn(m, t, s, l, d, g, v) { var T; const E = function (z, O, U) { if (z) for (const X of z) { const Q = O[X]; if (Q && Q.source === U && Q.type === "fill-extrusion") return !0 } else for (const X in O) { const Q = O[X]; if (Q.source === U && Q.type === "fill-extrusion") return !0 } return !1 }((T = d == null ? void 0 : d.layers) !== null && T !== void 0 ? T : null, t, m.id), I = g.maxPitchScaleFactor(), A = m.tilesIn(l, I, E); A.sort(qt); const R = []; for (const z of A) R.push({ wrappedTileID: z.tileID.wrapped().key, queryResults: z.tile.queryRenderedFeatures(t, s, m.getState(), z.queryGeometry, z.cameraQueryGeometry, z.scale, d, g, I, dn(g, z.tileID), v ? (O, U) => v(z.tileID, O, U) : void 0) }); return function (z, O) { for (const U in z) for (const X of z[U]) Gt(X, O); return z }(function (z) { const O = {}, U = {}; for (const X of z) { const Q = X.queryResults, Y = X.wrappedTileID, te = U[Y] = U[Y] || {}; for (const le in Q) { const J = Q[le], oe = te[le] = te[le] || {}, ce = O[le] = O[le] || []; for (const se of J) oe[se.featureIndex] || (oe[se.featureIndex] = !0, ce.push(se)) } } return O }(R), m) } function qt(m, t) { const s = m.tileID, l = t.tileID; return s.overscaledZ - l.overscaledZ || s.canonical.y - l.canonical.y || s.wrap - l.wrap || s.canonical.x - l.canonical.x } function Gt(m, t) { const s = m.feature, l = t.getFeatureState(s.layer["source-layer"], s.id); s.source = s.layer.source, s.layer["source-layer"] && (s.sourceLayer = s.layer["source-layer"]), s.state = l } function Ni(m, t, s) { return c._(this, void 0, void 0, function* () { let l = m; if (m.url ? l = (yield c.j(t.transformRequest(m.url, "Source"), s)).data : yield Ge.frameAsync(s), !l) return null; const d = c.U(c.e(l, m), ["tiles", "minzoom", "maxzoom", "attribution", "bounds", "scheme", "tileSize", "encoding"]); return "vector_layers" in l && l.vector_layers && (d.vectorLayerIds = l.vector_layers.map(g => g.id)), d }) } class Pr { constructor(t, s) { t && (s ? this.setSouthWest(t).setNorthEast(s) : Array.isArray(t) && (t.length === 4 ? this.setSouthWest([t[0], t[1]]).setNorthEast([t[2], t[3]]) : this.setSouthWest(t[0]).setNorthEast(t[1]))) } setNorthEast(t) { return this._ne = t instanceof c.V ? new c.V(t.lng, t.lat) : c.V.convert(t), this } setSouthWest(t) { return this._sw = t instanceof c.V ? new c.V(t.lng, t.lat) : c.V.convert(t), this } extend(t) { const s = this._sw, l = this._ne; let d, g; if (t instanceof c.V) d = t, g = t; else { if (!(t instanceof Pr)) return Array.isArray(t) ? t.length === 4 || t.every(Array.isArray) ? this.extend(Pr.convert(t)) : this.extend(c.V.convert(t)) : t && ("lng" in t || "lon" in t) && "lat" in t ? this.extend(c.V.convert(t)) : this; if (d = t._sw, g = t._ne, !d || !g) return this } return s || l ? (s.lng = Math.min(d.lng, s.lng), s.lat = Math.min(d.lat, s.lat), l.lng = Math.max(g.lng, l.lng), l.lat = Math.max(g.lat, l.lat)) : (this._sw = new c.V(d.lng, d.lat), this._ne = new c.V(g.lng, g.lat)), this } getCenter() { return new c.V((this._sw.lng + this._ne.lng) / 2, (this._sw.lat + this._ne.lat) / 2) } getSouthWest() { return this._sw } getNorthEast() { return this._ne } getNorthWest() { return new c.V(this.getWest(), this.getNorth()) } getSouthEast() { return new c.V(this.getEast(), this.getSouth()) } getWest() { return this._sw.lng } getSouth() { return this._sw.lat } getEast() { return this._ne.lng } getNorth() { return this._ne.lat } toArray() { return [this._sw.toArray(), this._ne.toArray()] } toString() { return `LngLatBounds(${this._sw.toString()}, ${this._ne.toString()})` } isEmpty() { return !(this._sw && this._ne) } contains(t) { const { lng: s, lat: l } = c.V.convert(t); let d = this._sw.lng <= s && s <= this._ne.lng; return this._sw.lng > this._ne.lng && (d = this._sw.lng >= s && s >= this._ne.lng), this._sw.lat <= l && l <= this._ne.lat && d } intersects(t) { if (!((t = Pr.convert(t)).getNorth() >= this.getSouth() && t.getSouth() <= this.getNorth())) return !1; const s = Math.abs(this.getEast() - this.getWest()), l = Math.abs(t.getEast() - t.getWest()); if (s >= 360 || l >= 360) return !0; const d = c.W(this.getWest(), -180, 180), g = c.W(this.getEast(), -180, 180), v = c.W(t.getWest(), -180, 180), T = c.W(t.getEast(), -180, 180), E = d >= g, I = v >= T; return !(!E || !I) || (E ? T >= d || v <= g : I ? g >= v || d <= T : v <= g && T >= d) } static convert(t) { return t instanceof Pr ? t : t && new Pr(t) } static fromLngLat(t, s = 0) { const l = 360 * s / 40075017, d = l / Math.cos(Math.PI / 180 * t.lat); return new Pr(new c.V(t.lng - d, t.lat - l), new c.V(t.lng + d, t.lat + l)) } adjustAntiMeridian() { const t = new c.V(this._sw.lng, this._sw.lat), s = new c.V(this._ne.lng, this._ne.lat); return new Pr(t, t.lng > s.lng ? new c.V(s.lng + 360, s.lat) : s) } } class ys { constructor(t, s, l) { this.bounds = Pr.convert(this.validateBounds(t)), this.minzoom = s || 0, this.maxzoom = l || 24 } validateBounds(t) { return Array.isArray(t) && t.length === 4 ? [Math.max(-180, t[0]), Math.max(-90, t[1]), Math.min(180, t[2]), Math.min(90, t[3])] : [-180, -90, 180, 90] } contains(t) { const s = Math.pow(2, t.z), l = Math.floor(c.Y(this.bounds.getWest()) * s), d = Math.floor(c.X(this.bounds.getNorth()) * s), g = Math.ceil(c.Y(this.bounds.getEast()) * s), v = Math.ceil(c.X(this.bounds.getSouth()) * s); return t.x >= l && t.x < g && t.y >= d && t.y < v } } class Us extends c.E { constructor(t, s, l, d) { if (super(), this.id = t, this.dispatcher = l, this.type = "vector", this.minzoom = 0, this.maxzoom = 22, this.scheme = "xyz", this.tileSize = 512, this.reparseOverscaled = !0, this.isTileClipped = !0, this._loaded = !1, c.e(this, c.U(s, ["url", "scheme", "tileSize", "promoteId", "encoding"])), this._options = c.e({ type: "vector" }, s), this._collectResourceTiming = s.collectResourceTiming, this.tileSize !== 512) throw new Error("vector tile sources must have a tileSize of 512"); this.setEventedParent(d) } load() { return c._(this, void 0, void 0, function* () { this._loaded = !1, this.fire(new c.l("dataloading", { dataType: "source" })), this._tileJSONRequest = new AbortController; try { const t = yield Ni(this._options, this.map._requestManager, this._tileJSONRequest); this._tileJSONRequest = null, this._loaded = !0, this.map.style.tileManagers[this.id].clearTiles(), t && (c.e(this, t), t.bounds && (this.tileBounds = new ys(t.bounds, this.minzoom, this.maxzoom)), this.fire(new c.l("data", { dataType: "source", sourceDataType: "metadata" })), this.fire(new c.l("data", { dataType: "source", sourceDataType: "content" }))) } catch (t) { this._tileJSONRequest = null, this._loaded = !0, c.Z(t) || this.fire(new c.k(t)) } }) } loaded() { return this._loaded } hasTile(t) { return !this.tileBounds || this.tileBounds.contains(t.canonical) } onAdd(t) { this.map = t, this.load() } setSourceProperty(t) { this._tileJSONRequest && this._tileJSONRequest.abort(), t(), this.load() } setTiles(t) { return this.setSourceProperty(() => { this._options.tiles = t }), this } setUrl(t) { return this.setSourceProperty(() => { this.url = t, this._options.url = t }), this } onRemove() { this._tileJSONRequest && (this._tileJSONRequest.abort(), this._tileJSONRequest = null) } serialize() { return c.e({}, this._options) } loadTile(t) { return c._(this, void 0, void 0, function* () { const s = t.tileID.canonical.url(this.tiles, this.map.getPixelRatio(), this.scheme), l = { request: this.map._requestManager.transformRequest(s, "Tile"), uid: t.uid, tileID: t.tileID, zoom: t.tileID.overscaledZ, tileSize: this.tileSize * t.tileID.overscaleFactor(), type: this.type, source: this.id, pixelRatio: this.map.getPixelRatio(), showCollisionBoxes: this.map.showCollisionBoxes, promoteId: this.promoteId, subdivisionGranularity: this.map.style.projection.subdivisionGranularity, encoding: this.encoding, overzoomParameters: this._getOverzoomParameters(t) }; l.request.collectResourceTiming = this._collectResourceTiming; let d = "RT"; if (t.actor && t.state !== "expired") { if (t.state === "loading") return new Promise((g, v) => { t.reloadPromise = { resolve: g, reject: v } }) } else t.actor = this.dispatcher.getActor(), d = "LT"; t.abortController = new AbortController; try { const g = yield t.actor.sendAsync({ type: d, data: l }, t.abortController); if (delete t.abortController, t.aborted) return; this._afterTileLoadWorkerResponse(t, g) } catch (g) { if (delete t.abortController, t.aborted) return; if (g && g.status !== 404) throw g; this._afterTileLoadWorkerResponse(t, null) } }) } _getOverzoomParameters(t) { if (t.tileID.canonical.z <= this.maxzoom || this.map._zoomLevelsToOverscale === void 0) return; const s = t.tileID.scaledTo(this.maxzoom).canonical, l = s.url(this.tiles, this.map.getPixelRatio(), this.scheme); return { maxZoomTileID: s, overzoomRequest: this.map._requestManager.transformRequest(l, "Tile") } } _afterTileLoadWorkerResponse(t, s) { if (s && s.resourceTiming && (t.resourceTiming = s.resourceTiming), s && this.map._refreshExpiredTiles && t.setExpiryData(s), t.loadVectorData(s, this.map.painter), t.reloadPromise) { const l = t.reloadPromise; t.reloadPromise = null, this.loadTile(t).then(l.resolve).catch(l.reject) } } abortTile(t) { return c._(this, void 0, void 0, function* () { t.abortController && (t.abortController.abort(), delete t.abortController), t.actor && (yield t.actor.sendAsync({ type: "AT", data: { uid: t.uid, type: this.type, source: this.id } })) }) } unloadTile(t) { return c._(this, void 0, void 0, function* () { t.unloadVectorData(), t.actor && (yield t.actor.sendAsync({ type: "RMT", data: { uid: t.uid, type: this.type, source: this.id } })) }) } hasTransition() { return !1 } } class Po extends c.E { constructor(t, s, l, d) { super(), this.id = t, this.dispatcher = l, this.setEventedParent(d), this.type = "raster", this.minzoom = 0, this.maxzoom = 22, this.roundZoom = !0, this.scheme = "xyz", this.tileSize = 512, this._loaded = !1, this._options = c.e({ type: "raster" }, s), c.e(this, c.U(s, ["url", "scheme", "tileSize"])) } load() { return c._(this, arguments, void 0, function* (t = !1) { this._loaded = !1, this.fire(new c.l("dataloading", { dataType: "source" })), this._tileJSONRequest = new AbortController; try { const s = yield Ni(this._options, this.map._requestManager, this._tileJSONRequest); this._tileJSONRequest = null, this._loaded = !0, s && (c.e(this, s), s.bounds && (this.tileBounds = new ys(s.bounds, this.minzoom, this.maxzoom)), this.fire(new c.l("data", { dataType: "source", sourceDataType: "metadata" })), this.fire(new c.l("data", { dataType: "source", sourceDataType: "content", sourceDataChanged: t }))) } catch (s) { this._tileJSONRequest = null, this._loaded = !0, c.Z(s) || this.fire(new c.k(s)) } }) } loaded() { return this._loaded } onAdd(t) { this.map = t, this.load() } onRemove() { this._tileJSONRequest && (this._tileJSONRequest.abort(), this._tileJSONRequest = null) } setSourceProperty(t) { this._tileJSONRequest && (this._tileJSONRequest.abort(), this._tileJSONRequest = null), t(), this.load(!0) } setTiles(t) { return this.setSourceProperty(() => { this._options.tiles = t }), this } setUrl(t) { return this.setSourceProperty(() => { this.url = t, this._options.url = t }), this } serialize() { return c.e({}, this._options) } hasTile(t) { return !this.tileBounds || this.tileBounds.contains(t.canonical) } loadTile(t) { return c._(this, void 0, void 0, function* () { const s = t.tileID.canonical.url(this.tiles, this.map.getPixelRatio(), this.scheme); t.abortController = new AbortController; try { const l = yield ct.getImage(this.map._requestManager.transformRequest(s, "Tile"), t.abortController, this.map._refreshExpiredTiles); if (delete t.abortController, t.aborted) return void (t.state = "unloaded"); if (l && l.data) { this.map._refreshExpiredTiles && (l.cacheControl || l.expires) && t.setExpiryData({ cacheControl: l.cacheControl, expires: l.expires }); const d = this.map.painter.context, g = d.gl, v = l.data; t.texture = this.map.painter.getTileTexture(v.width), t.texture ? t.texture.update(v, { useMipmap: !0 }) : (t.texture = new c.T(d, v, g.RGBA, { useMipmap: !0 }), t.texture.bind(g.LINEAR, g.CLAMP_TO_EDGE, g.LINEAR_MIPMAP_NEAREST)), t.state = "loaded" } } catch (l) { if (delete t.abortController, t.aborted) t.state = "unloaded"; else if (l) throw t.state = "errored", l } }) } abortTile(t) { return c._(this, void 0, void 0, function* () { t.abortController && (t.abortController.abort(), delete t.abortController) }) } unloadTile(t) { return c._(this, void 0, void 0, function* () { t.texture && this.map.painter.saveTileTexture(t.texture) }) } hasTransition() { return !1 } } class vs extends Po { constructor(t, s, l, d) { super(t, s, l, d), this.type = "raster-dem", this.maxzoom = 22, this._options = c.e({ type: "raster-dem" }, s), this.encoding = s.encoding || "mapbox", this.redFactor = s.redFactor, this.greenFactor = s.greenFactor, this.blueFactor = s.blueFactor, this.baseShift = s.baseShift } loadTile(t) { return c._(this, void 0, void 0, function* () { const s = t.tileID.canonical.url(this.tiles, this.map.getPixelRatio(), this.scheme), l = this.map._requestManager.transformRequest(s, "Tile"); t.neighboringTiles = this._getNeighboringTiles(t.tileID), t.abortController = new AbortController; try { const d = yield ct.getImage(l, t.abortController, this.map._refreshExpiredTiles); if (delete t.abortController, t.aborted) return void (t.state = "unloaded"); if (d && d.data) { const g = d.data; this.map._refreshExpiredTiles && (d.cacheControl || d.expires) && t.setExpiryData({ cacheControl: d.cacheControl, expires: d.expires }); const v = c.b(g) && c.$() ? g : yield this.readImageNow(g), T = { type: this.type, uid: t.uid, source: this.id, rawImageData: v, encoding: this.encoding, redFactor: this.redFactor, greenFactor: this.greenFactor, blueFactor: this.blueFactor, baseShift: this.baseShift }; if (!t.actor || t.state === "expired") { t.actor = this.dispatcher.getActor(); const E = yield t.actor.sendAsync({ type: "LDT", data: T }); t.dem = E, t.needsHillshadePrepare = !0, t.needsTerrainPrepare = !0, t.state = "loaded" } } } catch (d) { if (delete t.abortController, t.aborted) t.state = "unloaded"; else if (d) throw t.state = "errored", d } }) } readImageNow(t) { return c._(this, void 0, void 0, function* () { if (typeof VideoFrame < "u" && c.a0()) { const s = t.width + 2, l = t.height + 2; try { return new c.R({ width: s, height: l }, yield c.a1(t, -1, -1, s, l)) } catch { } } return Ge.getImageData(t, 1) }) } _getNeighboringTiles(t) { const s = t.canonical, l = Math.pow(2, s.z), d = (s.x - 1 + l) % l, g = s.x === 0 ? t.wrap - 1 : t.wrap, v = (s.x + 1 + l) % l, T = s.x + 1 === l ? t.wrap + 1 : t.wrap, E = {}; return E[new c.a2(t.overscaledZ, g, s.z, d, s.y).key] = { backfilled: !1 }, E[new c.a2(t.overscaledZ, T, s.z, v, s.y).key] = { backfilled: !1 }, s.y > 0 && (E[new c.a2(t.overscaledZ, g, s.z, d, s.y - 1).key] = { backfilled: !1 }, E[new c.a2(t.overscaledZ, t.wrap, s.z, s.x, s.y - 1).key] = { backfilled: !1 }, E[new c.a2(t.overscaledZ, T, s.z, v, s.y - 1).key] = { backfilled: !1 }), s.y + 1 < l && (E[new c.a2(t.overscaledZ, g, s.z, d, s.y + 1).key] = { backfilled: !1 }, E[new c.a2(t.overscaledZ, t.wrap, s.z, s.x, s.y + 1).key] = { backfilled: !1 }, E[new c.a2(t.overscaledZ, T, s.z, v, s.y + 1).key] = { backfilled: !1 }), E } unloadTile(t) { return c._(this, void 0, void 0, function* () { t.demTexture && this.map.painter.saveTileTexture(t.demTexture), t.fbo && (t.fbo.destroy(), delete t.fbo), t.dem && delete t.dem, delete t.neighboringTiles, t.state = "unloaded", t.actor && (yield t.actor.sendAsync({ type: "RDT", data: { type: this.type, uid: t.uid, source: this.id } })) }) } } function xi(m) { return m.type === "GeometryCollection" ? m.geometries.map(t => t.coordinates).flat(1 / 0) : m.coordinates.flat(1 / 0) } function Mo(m) { const t = new Pr; let s; switch (m.type) { case "FeatureCollection": s = m.features.map(l => xi(l.geometry)).flat(1 / 0); break; case "Feature": s = xi(m.geometry); break; default: s = xi(m) }if (s.length == 0) return t; for (let l = 0; l < s.length - 1; l += 2)t.extend([s[l], s[l + 1]]); return t } class Io extends c.E { constructor(t, s, l, d) { super(), this.id = t, this.type = "geojson", this.minzoom = 0, this.maxzoom = 18, this.tileSize = 512, this.isTileClipped = !0, this.reparseOverscaled = !0, this._removed = !1, this._isUpdatingWorker = !1, this._pendingWorkerUpdate = { data: s.data }, this.actor = l.getActor(), this.setEventedParent(d), this._data = typeof s.data == "string" ? { url: s.data } : { geojson: s.data }, this._options = c.e({}, s), this._collectResourceTiming = s.collectResourceTiming, s.maxzoom !== void 0 && (this.maxzoom = s.maxzoom), s.type && (this.type = s.type), s.attribution && (this.attribution = s.attribution), this.promoteId = s.promoteId, s.clusterMaxZoom !== void 0 && this.maxzoom <= s.clusterMaxZoom && c.w(`The maxzoom value "${this.maxzoom}" is expected to be greater than the clusterMaxZoom value "${s.clusterMaxZoom}".`), this.workerOptions = c.e({ source: this.id, cluster: s.cluster || !1, geojsonVtOptions: { buffer: this._pixelsToTileUnits(s.buffer !== void 0 ? s.buffer : 128), tolerance: this._pixelsToTileUnits(s.tolerance !== void 0 ? s.tolerance : .375), extent: c.a5, maxZoom: this.maxzoom, lineMetrics: s.lineMetrics || !1, generateId: s.generateId || !1 }, superclusterOptions: { maxZoom: this._getClusterMaxZoom(s.clusterMaxZoom), minPoints: Math.max(2, s.clusterMinPoints || 2), extent: c.a5, radius: this._pixelsToTileUnits(s.clusterRadius || 50), log: !1, generateId: s.generateId || !1 }, clusterProperties: s.clusterProperties, filter: s.filter }, s.workerOptions), typeof this.promoteId == "string" && (this.workerOptions.promoteId = this.promoteId) } _hasPendingWorkerUpdate() { return this._pendingWorkerUpdate.data !== void 0 || this._pendingWorkerUpdate.diff !== void 0 || this._pendingWorkerUpdate.optionsChanged } _pixelsToTileUnits(t) { return t * (c.a5 / this.tileSize) } _getClusterMaxZoom(t) { const s = t ? Math.round(t) : this.maxzoom - 1; return Number.isInteger(t) || t === void 0 || c.w(`Integer expected for option 'clusterMaxZoom': provided value "${t}" rounded to "${s}"`), s } load() { return c._(this, void 0, void 0, function* () { yield this._updateWorkerData() }) } onAdd(t) { this.map = t, this.load() } setData(t, s) { this._data = typeof t == "string" ? { url: t } : { geojson: t }, this._pendingWorkerUpdate = { data: t }; const l = this._updateWorkerData(); return s ? l : this } updateData(t, s) { this._pendingWorkerUpdate.diff = c.a6(this._pendingWorkerUpdate.diff, t); const l = this._updateWorkerData(); return s ? l : this } getData() { return c._(this, void 0, void 0, function* () { const t = c.e({ type: this.type }, this.workerOptions); return this.actor.sendAsync({ type: "GD", data: t }) }) } getBounds() { return c._(this, void 0, void 0, function* () { return Mo(yield this.getData()) }) } setClusterOptions(t) { return this.workerOptions.cluster = t.cluster, t.clusterRadius !== void 0 && (this.workerOptions.superclusterOptions.radius = this._pixelsToTileUnits(t.clusterRadius)), t.clusterMaxZoom !== void 0 && (this.workerOptions.superclusterOptions.maxZoom = this._getClusterMaxZoom(t.clusterMaxZoom)), this._pendingWorkerUpdate.optionsChanged = !0, this._updateWorkerData(), this } getClusterExpansionZoom(t) { return this.actor.sendAsync({ type: "GCEZ", data: { type: this.type, clusterId: t, source: this.id } }) } getClusterChildren(t) { return this.actor.sendAsync({ type: "GCC", data: { type: this.type, clusterId: t, source: this.id } }) } getClusterLeaves(t, s, l) { return this.actor.sendAsync({ type: "GCL", data: { type: this.type, source: this.id, clusterId: t, limit: s, offset: l } }) } _updateWorkerData() { return c._(this, void 0, void 0, function* () { if (this._isUpdatingWorker) return; if (!this._hasPendingWorkerUpdate()) return void c.w(`No pending worker updates for GeoJSONSource ${this.id}.`); const { data: t, diff: s } = this._pendingWorkerUpdate, l = c.e({ type: this.type }, this.workerOptions); t !== void 0 ? (typeof t == "string" ? (l.request = this.map._requestManager.transformRequest(Ge.resolveURL(t), "Source"), l.request.collectResourceTiming = this._collectResourceTiming) : l.data = t, this._pendingWorkerUpdate.data = void 0) : s && (l.dataDiff = s, this._pendingWorkerUpdate.diff = void 0), this._pendingWorkerUpdate.optionsChanged = void 0, this._isUpdatingWorker = !0, this.fire(new c.l("dataloading", { dataType: "source" })); try { const d = yield this.actor.sendAsync({ type: "LD", data: l }); if (this._isUpdatingWorker = !1, this._removed || d.abandoned) return void this.fire(new c.l("dataabort", { dataType: "source" })); d.data && (this._data = { geojson: d.data }); const g = this._applyDiffToSource(s), v = this._getShouldReloadTileOptions(g); let T = null; d.resourceTiming && d.resourceTiming[this.id] && (T = d.resourceTiming[this.id].slice(0)); const E = { dataType: "source" }; this._collectResourceTiming && T && T.length > 0 && c.e(E, { resourceTiming: T }), this.fire(new c.l("data", Object.assign(Object.assign({}, E), { sourceDataType: "metadata" }))), this.fire(new c.l("data", Object.assign(Object.assign({}, E), { sourceDataType: "content", shouldReloadTileOptions: v }))) } catch (d) { if (this._isUpdatingWorker = !1, this._removed) return void this.fire(new c.l("dataabort", { dataType: "source" })); this.fire(new c.k(d)) } finally { this._hasPendingWorkerUpdate() && this._updateWorkerData() } }) } _applyDiffToSource(t) { if (!t) return; const s = typeof this.promoteId == "string" ? this.promoteId : void 0; if (!this._data.url && !this._data.updateable) { const d = c.a7(this._data.geojson, s); if (!d) throw new Error(`GeoJSONSource "${this.id}": GeoJSON data is not compatible with updateData`); this._data = { updateable: d } } if (!this._data.updateable) return; const l = c.a8(this._data.updateable, t, s); return t.removeAll || this._options.cluster ? void 0 : l } _getShouldReloadTileOptions(t) { if (t) return { affectedBounds: t.filter(Boolean).map(s => Mo(s)) } } shouldReloadTile(t, { affectedBounds: s }) { if (t.state === "loading") return !0; if (t.state === "unloaded") return !1; const { buffer: l, extent: d } = this.workerOptions.geojsonVtOptions, g = function ({ x: v, y: T, z: E }, I = 0) { const A = c.a3((v - I) / Math.pow(2, E)), R = c.a4((T + 1 + I) / Math.pow(2, E)), z = c.a3((v + 1 + I) / Math.pow(2, E)), O = c.a4((T - I) / Math.pow(2, E)); return new Pr([A, R], [z, O]) }(t.tileID.canonical, l / d); for (const v of s) if (g.intersects(v)) return !0; return !1 } loaded() { return !this._isUpdatingWorker && !this._hasPendingWorkerUpdate() } loadTile(t) { return c._(this, void 0, void 0, function* () { const s = t.actor ? "RT" : "LT"; t.actor = this.actor; const l = { type: this.type, uid: t.uid, tileID: t.tileID, zoom: t.tileID.overscaledZ, maxZoom: this.maxzoom, tileSize: this.tileSize, source: this.id, pixelRatio: this.map.getPixelRatio(), showCollisionBoxes: this.map.showCollisionBoxes, promoteId: this.promoteId, subdivisionGranularity: this.map.style.projection.subdivisionGranularity }; t.abortController = new AbortController; const d = yield this.actor.sendAsync({ type: s, data: l }, t.abortController); delete t.abortController, t.unloadVectorData(), t.aborted || t.loadVectorData(d, this.map.painter, s === "RT") }) } abortTile(t) { return c._(this, void 0, void 0, function* () { t.abortController && (t.abortController.abort(), delete t.abortController), t.aborted = !0 }) } unloadTile(t) { return c._(this, void 0, void 0, function* () { t.unloadVectorData(), yield this.actor.sendAsync({ type: "RMT", data: { uid: t.uid, type: this.type, source: this.id } }) }) } onRemove() { this._removed = !0, this.actor.sendAsync({ type: "RS", data: { type: this.type, source: this.id } }) } serialize() { return c.e({}, this._options, { type: this.type, data: this._data.updateable ? { type: "FeatureCollection", features: Array.from(this._data.updateable.values()) } : this._data.url || this._data.geojson }) } hasTransition() { return !1 } } class jn extends c.E { constructor(t, s, l, d) { super(), this.flippedWindingOrder = !1, this.id = t, this.dispatcher = l, this.coordinates = s.coordinates, this.type = "image", this.minzoom = 0, this.maxzoom = 22, this.tileSize = 512, this.tiles = {}, this._loaded = !1, this.setEventedParent(d), this.options = s } load(t) { return c._(this, void 0, void 0, function* () { this._loaded = !1, this.fire(new c.l("dataloading", { dataType: "source" })), this.url = this.options.url, this._request = new AbortController; try { const s = yield ct.getImage(this.map._requestManager.transformRequest(this.url, "Image"), this._request); this._request = null, this._loaded = !0, s && s.data && (this.image = s.data, t && (this.coordinates = t), this._finishLoading()) } catch (s) { this._request = null, this._loaded = !0, c.Z(s) || this.fire(new c.k(s)) } }) } loaded() { return this._loaded } updateImage(t) { return t.url ? (this._request && (this._request.abort(), this._request = null), this.options.url = t.url, this.load(t.coordinates).finally(() => { this.texture = null }), this) : this } _finishLoading() { this.map && (this.setCoordinates(this.coordinates), this.fire(new c.l("data", { dataType: "source", sourceDataType: "metadata" }))) } onAdd(t) { this.map = t, this.load() } onRemove() { this._request && (this._request.abort(), this._request = null) } setCoordinates(t) { this.coordinates = t; const s = t.map(c.a9.fromLngLat); var l; return this.tileID = function (d) { const g = c.aa.fromPoints(d), v = g.width(), T = g.height(), E = Math.max(v, T), I = Math.max(0, Math.floor(-Math.log(E) / Math.LN2)), A = Math.pow(2, I); return new c.ac(I, Math.floor((g.minX + g.maxX) / 2 * A), Math.floor((g.minY + g.maxY) / 2 * A)) }(s), this.terrainTileRanges = this._getOverlappingTileRanges(s), this.minzoom = this.maxzoom = this.tileID.z, this.tileCoords = s.map(d => this.tileID.getTilePoint(d)._round()), this.flippedWindingOrder = ((l = this.tileCoords)[1].x - l[0].x) * (l[2].y - l[0].y) - (l[1].y - l[0].y) * (l[2].x - l[0].x) < 0, this.fire(new c.l("data", { dataType: "source", sourceDataType: "content" })), this } prepare() { if (Object.keys(this.tiles).length === 0 || !this.image) return; const t = this.map.painter.context, s = t.gl; this.texture || (this.texture = new c.T(t, this.image, s.RGBA), this.texture.bind(s.LINEAR, s.CLAMP_TO_EDGE)); let l = !1; for (const d in this.tiles) { const g = this.tiles[d]; g.state !== "loaded" && (g.state = "loaded", g.texture = this.texture, l = !0) } l && this.fire(new c.l("data", { dataType: "source", sourceDataType: "idle", sourceId: this.id })) } loadTile(t) { return c._(this, void 0, void 0, function* () { this.tileID && this.tileID.equals(t.tileID.canonical) ? (this.tiles[String(t.tileID.wrap)] = t, t.buckets = {}) : t.state = "errored" }) } serialize() { return { type: "image", url: this.options.url, coordinates: this.coordinates } } hasTransition() { return !1 } _getOverlappingTileRanges(t) { const { minX: s, minY: l, maxX: d, maxY: g } = c.aa.fromPoints(t), v = {}; for (let T = 0; T <= c.ab; T++) { const E = Math.pow(2, T), I = Math.floor(s * E), A = Math.floor(l * E), R = Math.floor(d * E), z = Math.floor(g * E); v[T] = { minTileX: I, minTileY: A, maxTileX: R, maxTileY: z } } return v } } class Pe extends jn { constructor(t, s, l, d) { super(t, s, l, d), this.roundZoom = !0, this.type = "video", this.options = s } load() { return c._(this, void 0, void 0, function* () { this._loaded = !1; const t = this.options; this.urls = []; for (const s of t.urls) this.urls.push(this.map._requestManager.transformRequest(s, "Source").url); try { const s = yield c.ad(this.urls); if (this._loaded = !0, !s) return; this.video = s, this.video.loop = !0, this.video.addEventListener("playing", () => { this.map.triggerRepaint() }), this.map && this.video.play(), this._finishLoading() } catch (s) { this.fire(new c.k(s)) } }) } pause() { this.video && this.video.pause() } play() { this.video && this.video.play() } seek(t) { if (this.video) { const s = this.video.seekable; t < s.start(0) || t > s.end(0) ? this.fire(new c.k(new c.ae(`sources.${this.id}`, null, `Playback for this video can be set only between the ${s.start(0)} and ${s.end(0)}-second mark.`))) : this.video.currentTime = t } } getVideo() { return this.video } onAdd(t) { this.map || (this.map = t, this.load(), this.video && (this.video.play(), this.setCoordinates(this.coordinates))) } prepare() { if (Object.keys(this.tiles).length === 0 || this.video.readyState < 2) return; const t = this.map.painter.context, s = t.gl; this.texture ? this.video.paused || (this.texture.bind(s.LINEAR, s.CLAMP_TO_EDGE), s.texSubImage2D(s.TEXTURE_2D, 0, 0, 0, s.RGBA, s.UNSIGNED_BYTE, this.video)) : (this.texture = new c.T(t, this.video, s.RGBA), this.texture.bind(s.LINEAR, s.CLAMP_TO_EDGE)); let l = !1; for (const d in this.tiles) { const g = this.tiles[d]; g.state !== "loaded" && (g.state = "loaded", g.texture = this.texture, l = !0) } l && this.fire(new c.l("data", { dataType: "source", sourceDataType: "idle", sourceId: this.id })) } serialize() { return { type: "video", urls: this.urls, coordinates: this.coordinates } } hasTransition() { return this.video && !this.video.paused } } class V extends jn { constructor(t, s, l, d) { super(t, s, l, d), s.coordinates ? Array.isArray(s.coordinates) && s.coordinates.length === 4 && !s.coordinates.some(g => !Array.isArray(g) || g.length !== 2 || g.some(v => typeof v != "number")) || this.fire(new c.k(new c.ae(`sources.${t}`, null, '"coordinates" property must be an array of 4 longitude/latitude array pairs'))) : this.fire(new c.k(new c.ae(`sources.${t}`, null, 'missing required property "coordinates"'))), s.animate && typeof s.animate != "boolean" && this.fire(new c.k(new c.ae(`sources.${t}`, null, 'optional "animate" property must be a boolean value'))), s.canvas ? typeof s.canvas == "string" || s.canvas instanceof HTMLCanvasElement || this.fire(new c.k(new c.ae(`sources.${t}`, null, '"canvas" must be either a string representing the ID of the canvas element from which to read, or an HTMLCanvasElement instance'))) : this.fire(new c.k(new c.ae(`sources.${t}`, null, 'missing required property "canvas"'))), this.options = s, this.animate = s.animate === void 0 || s.animate } load() { return c._(this, void 0, void 0, function* () { this._loaded = !0, this.canvas || (this.canvas = this.options.canvas instanceof HTMLCanvasElement ? this.options.canvas : document.getElementById(this.options.canvas)), this.width = this.canvas.width, this.height = this.canvas.height, this._hasInvalidDimensions() ? this.fire(new c.k(new Error("Canvas dimensions cannot be less than or equal to zero."))) : (this.play = function () { this._playing = !0, this.map.triggerRepaint() }, this.pause = function () { this._playing && (this.prepare(), this._playing = !1) }, this._finishLoading()) }) } getCanvas() { return this.canvas } onAdd(t) { this.map = t, this.load(), this.canvas && this.animate && this.play() } onRemove() { this.pause() } prepare() { let t = !1; if (this.canvas.width !== this.width && (this.width = this.canvas.width, t = !0), this.canvas.height !== this.height && (this.height = this.canvas.height, t = !0), this._hasInvalidDimensions() || Object.keys(this.tiles).length === 0) return; const s = this.map.painter.context, l = s.gl; this.texture ? (t || this._playing) && this.texture.update(this.canvas, { premultiply: !0 }) : (this.texture = new c.T(s, this.canvas, l.RGBA, { premultiply: !0 }), this.texture.bind(l.LINEAR, l.CLAMP_TO_EDGE)); let d = !1; for (const g in this.tiles) { const v = this.tiles[g]; v.state !== "loaded" && (v.state = "loaded", v.texture = this.texture, d = !0) } d && this.fire(new c.l("data", { dataType: "source", sourceDataType: "idle", sourceId: this.id })) } serialize() { return { type: "canvas", animate: this.animate, canvas: this.options.canvas, coordinates: this.coordinates } } hasTransition() { return this._playing } _hasInvalidDimensions() { for (const t of [this.canvas.width, this.canvas.height]) if (isNaN(t) || t <= 0) return !0; return !1 } } const j = {}, W = m => { switch (m) { case "geojson": return Io; case "image": return jn; case "raster": return Po; case "raster-dem": return vs; case "vector": return Us; case "video": return Pe; case "canvas": return V }return j[m] }, ue = "RTLPluginLoaded"; class he extends c.E { constructor() { super(...arguments), this.status = "unavailable", this.url = null, this.dispatcher = vn() } _syncState(t) { return this.status = t, this.dispatcher.broadcast("SRPS", { pluginStatus: t, pluginURL: this.url }).catch(s => { throw this.status = "error", s }) } getRTLTextPluginStatus() { return this.status } clearRTLTextPlugin() { this.status = "unavailable", this.url = null } setRTLTextPlugin(t) { return c._(this, arguments, void 0, function* (s, l = !1) { if (this.url) throw new Error("setRTLTextPlugin cannot be called multiple times."); if (this.url = Ge.resolveURL(s), !this.url) throw new Error(`requested url ${s} is invalid`); if (this.status === "unavailable") { if (!l) return this._requestImport(); this.status = "deferred", this._syncState(this.status) } else if (this.status === "requested") return this._requestImport() }) } _requestImport() { return c._(this, void 0, void 0, function* () { yield this._syncState("loading"), this.status = "loaded", this.fire(new c.l(ue)) }) } lazyLoad() { this.status === "unavailable" ? this.status = "requested" : this.status === "deferred" && this._requestImport() } } let Ae = null; function Ee() { return Ae || (Ae = new he), Ae } var pe, Be; (function (m) { m[m.Base = 0] = "Base", m[m.Parent = 1] = "Parent" })(pe || (pe = {})), function (m) { m[m.Departing = 0] = "Departing", m[m.Incoming = 1] = "Incoming" }(Be || (Be = {})); class Xe { constructor(t, s) { this.timeAdded = 0, this.fadeEndTime = 0, this.fadeOpacity = 1, this.tileID = t, this.uid = c.af(), this.uses = 0, this.tileSize = s, this.buckets = {}, this.expirationTime = null, this.queryPadding = 0, this.hasSymbolBuckets = !1, this.hasRTLText = !1, this.dependencies = {}, this.rtt = [], this.rttCoords = {}, this.expiredRequestCount = 0, this.state = "loading" } isRenderable(t) { return this.hasData() && (!this.fadeEndTime || this.fadeOpacity > 0) && (t || !this.holdingForSymbolFade()) } setCrossFadeLogic({ fadingRole: t, fadingDirection: s, fadingParentID: l, fadeEndTime: d }) { this.resetFadeLogic(), this.fadingRole = t, this.fadingDirection = s, this.fadingParentID = l, this.fadeEndTime = d } setSelfFadeLogic(t) { this.resetFadeLogic(), this.selfFading = !0, this.fadeEndTime = t } resetFadeLogic() { this.fadingRole = null, this.fadingDirection = null, this.fadingParentID = null, this.selfFading = !1, this.timeAdded = $e(), this.fadeEndTime = 0, this.fadeOpacity = 1 } wasRequested() { return this.state === "errored" || this.state === "loaded" || this.state === "reloading" } clearTextures(t) { this.demTexture && t.saveTileTexture(this.demTexture), this.demTexture = null } loadVectorData(t, s, l) { if (this.hasData() && this.unloadVectorData(), this.state = "loaded", t) { t.featureIndex && (this.latestFeatureIndex = t.featureIndex, t.rawTileData ? (this.latestRawTileData = t.rawTileData, this.latestFeatureIndex.rawTileData = t.rawTileData, this.latestFeatureIndex.encoding = t.encoding) : this.latestRawTileData && (this.latestFeatureIndex.rawTileData = this.latestRawTileData, this.latestFeatureIndex.encoding = this.latestEncoding)), this.collisionBoxArray = t.collisionBoxArray, this.buckets = function (d, g) { const v = {}; if (!g) return v; for (const T of d) { const E = T.layerIds.map(I => g.getLayer(I)).filter(Boolean); if (E.length !== 0) { T.layers = E, T.stateDependentLayerIds && (T.stateDependentLayers = T.stateDependentLayerIds.map(I => E.filter(A => A.id === I)[0])); for (const I of E) v[I.id] = T } } return v }(t.buckets, s == null ? void 0 : s.style), this.hasSymbolBuckets = !1; for (const d in this.buckets) { const g = this.buckets[d]; if (g instanceof c.ah) { if (this.hasSymbolBuckets = !0, !l) break; g.justReloaded = !0 } } if (this.hasRTLText = !1, this.hasSymbolBuckets) for (const d in this.buckets) { const g = this.buckets[d]; if (g instanceof c.ah && g.hasRTLText) { this.hasRTLText = !0, Ee().lazyLoad(); break } } this.queryPadding = 0; for (const d in this.buckets) { const g = this.buckets[d]; this.queryPadding = Math.max(this.queryPadding, s.style.getLayer(d).queryRadius(g)) } t.imageAtlas && (this.imageAtlas = t.imageAtlas), t.glyphAtlasImage && (this.glyphAtlasImage = t.glyphAtlasImage), this.dashPositions = t.dashPositions } else this.collisionBoxArray = new c.ag } unloadVectorData() { for (const t in this.buckets) this.buckets[t].destroy(); this.buckets = {}, this.imageAtlasTexture && this.imageAtlasTexture.destroy(), this.imageAtlas && (this.imageAtlas = null), this.glyphAtlasTexture && this.glyphAtlasTexture.destroy(), this.dashPositions && (this.dashPositions = null), this.latestFeatureIndex = null, this.state = "unloaded" } getBucket(t) { return this.buckets[t.id] } upload(t) { for (const l in this.buckets) { const d = this.buckets[l]; d.uploadPending() && d.upload(t) } const s = t.gl; this.imageAtlas && !this.imageAtlas.uploaded && (this.imageAtlasTexture = new c.T(t, this.imageAtlas.image, s.RGBA), this.imageAtlas.uploaded = !0), this.glyphAtlasImage && (this.glyphAtlasTexture = new c.T(t, this.glyphAtlasImage, s.ALPHA), this.glyphAtlasImage = null) } prepare(t) { this.imageAtlas && this.imageAtlas.patchUpdatedImages(t, this.imageAtlasTexture) } queryRenderedFeatures(t, s, l, d, g, v, T, E, I, A, R) { return this.latestFeatureIndex && this.latestFeatureIndex.rawTileData ? this.latestFeatureIndex.query({ queryGeometry: d, cameraQueryGeometry: g, scale: v, tileSize: this.tileSize, pixelPosMatrix: A, transform: E, params: T, queryPadding: this.queryPadding * I, getElevation: R }, t, s, l) : {} } querySourceFeatures(t, s) { const l = this.latestFeatureIndex; if (!l || !l.rawTileData) return; const d = l.loadVTLayers(), g = s && s.sourceLayer ? s.sourceLayer : "", v = d[c.ai] || d[g]; if (!v) return; const T = c.aj(s == null ? void 0 : s.filter, s == null ? void 0 : s.globalState), { z: E, x: I, y: A } = this.tileID.canonical, R = { z: E, x: I, y: A }; for (let z = 0; z < v.length; z++) { const O = v.feature(z); if (T.needGeometry) { const Q = c.ak(O, !0); if (!T.filter(new c.H(this.tileID.overscaledZ), Q, this.tileID.canonical)) continue } else if (!T.filter(new c.H(this.tileID.overscaledZ), O)) continue; const U = l.getId(O, g), X = new c.al(O, E, I, A, U); X.tile = R, t.push(X) } } hasData() { return this.state === "loaded" || this.state === "reloading" || this.state === "expired" } patternsLoaded() { return this.imageAtlas && !!Object.keys(this.imageAtlas.patternPositions).length } setExpiryData(t) { const s = this.expirationTime; if (t.cacheControl) { const l = c.am(t.cacheControl); l["max-age"] && (this.expirationTime = Date.now() + 1e3 * l["max-age"]) } else t.expires && (this.expirationTime = new Date(t.expires).getTime()); if (this.expirationTime) { const l = Date.now(); let d = !1; if (this.expirationTime > l) d = !1; else if (s) if (this.expirationTime < s) d = !0; else { const g = this.expirationTime - s; g ? this.expirationTime = l + Math.max(g, 3e4) : d = !0 } else d = !0; d ? (this.expiredRequestCount++, this.state = "expired") : this.expiredRequestCount = 0 } } getExpiryTimeout() { if (this.expirationTime) return this.expiredRequestCount ? 1e3 * (1 << Math.min(this.expiredRequestCount - 1, 31)) : Math.min(this.expirationTime - new Date().getTime(), Math.pow(2, 31) - 1) } setFeatureState(t, s) { if (!this.latestFeatureIndex || !this.latestFeatureIndex.rawTileData || Object.keys(t).length === 0) return; const l = this.latestFeatureIndex.loadVTLayers(); for (const d in this.buckets) { if (!s.style.hasLayer(d)) continue; const g = this.buckets[d], v = g.layers[0].sourceLayer || c.ai, T = l[v], E = t[v]; if (!T || !E || Object.keys(E).length === 0) continue; g.update(E, T, this.imageAtlas && this.imageAtlas.patternPositions || {}, this.dashPositions || {}); const I = s && s.style && s.style.getLayer(d); I && (this.queryPadding = Math.max(this.queryPadding, I.queryRadius(g))) } } holdingForSymbolFade() { return this.symbolFadeHoldUntil !== void 0 } symbolFadeFinished() { return !this.symbolFadeHoldUntil || this.symbolFadeHoldUntil < $e() } clearSymbolFadeHold() { this.symbolFadeHoldUntil = void 0 } setSymbolHoldDuration(t) { this.symbolFadeHoldUntil = $e() + t } setDependencies(t, s) { const l = {}; for (const d of s) l[d] = !0; this.dependencies[t] = l } hasDependency(t, s) { for (const l of t) { const d = this.dependencies[l]; if (d) { for (const g of s) if (d[g]) return !0 } } return !1 } } class qe { constructor() { this.state = {}, this.stateChanges = {}, this.deletedStates = {} } updateState(t, s, l) { const d = String(s); if (this.stateChanges[t] = this.stateChanges[t] || {}, this.stateChanges[t][d] = this.stateChanges[t][d] || {}, c.e(this.stateChanges[t][d], l), this.deletedStates[t] === null) { this.deletedStates[t] = {}; for (const g in this.state[t]) g !== d && (this.deletedStates[t][g] = null) } else if (this.deletedStates[t] && this.deletedStates[t][d] === null) { this.deletedStates[t][d] = {}; for (const g in this.state[t][d]) l[g] || (this.deletedStates[t][d][g] = null) } else for (const g in l) this.deletedStates[t] && this.deletedStates[t][d] && this.deletedStates[t][d][g] === null && delete this.deletedStates[t][d][g] } removeFeatureState(t, s, l) { if (this.deletedStates[t] === null) return; const d = String(s); if (this.deletedStates[t] = this.deletedStates[t] || {}, l && s !== void 0) this.deletedStates[t][d] !== null && (this.deletedStates[t][d] = this.deletedStates[t][d] || {}, this.deletedStates[t][d][l] = null); else if (s !== void 0) if (this.stateChanges[t] && this.stateChanges[t][d]) for (l in this.deletedStates[t][d] = {}, this.stateChanges[t][d]) this.deletedStates[t][d][l] = null; else this.deletedStates[t][d] = null; else this.deletedStates[t] = null } getState(t, s) { const l = String(s), d = c.e({}, (this.state[t] || {})[l], (this.stateChanges[t] || {})[l]); if (this.deletedStates[t] === null) return {}; if (this.deletedStates[t]) { const g = this.deletedStates[t][s]; if (g === null) return {}; for (const v in g) delete d[v] } return d } initializeTileState(t, s) { t.setFeatureState(this.state, s) } coalesceChanges(t, s) { const l = {}; for (const d in this.stateChanges) { this.state[d] = this.state[d] || {}; const g = {}; for (const v in this.stateChanges[d]) this.state[d][v] || (this.state[d][v] = {}), c.e(this.state[d][v], this.stateChanges[d][v]), g[v] = this.state[d][v]; l[d] = g } for (const d in this.deletedStates) { this.state[d] = this.state[d] || {}; const g = {}; if (this.deletedStates[d] === null) for (const v in this.state[d]) g[v] = {}, this.state[d][v] = {}; else for (const v in this.deletedStates[d]) { if (this.deletedStates[d][v] === null) this.state[d][v] = {}; else for (const T of Object.keys(this.deletedStates[d][v])) delete this.state[d][v][T]; g[v] = this.state[d][v] } l[d] = l[d] || {}, c.e(l[d], g) } this.stateChanges = {}, this.deletedStates = {}, Object.keys(l).length !== 0 && t.setFeatureState(l, s) } } const ht = 89.25; function yt(m, t) { const s = c.an(t.lat, -c.ao, c.ao); return new c.P(c.Y(t.lng) * m, c.X(s) * m) } function Pt(m, t) { return new c.a9(t.x / m, t.y / m).toLngLat() } function tr(m) { return m.cameraToCenterDistance * Math.min(.85 * Math.tan(c.ap(90 - m.pitch)), Math.tan(c.ap(ht - m.pitch))) } function Wt(m, t) { const s = m.canonical, l = t / c.aq(s.z), d = s.x + Math.pow(2, s.z) * m.wrap, g = c.ar(new Float64Array(16)); return c.O(g, g, [d * l, s.y * l, 0]), c.Q(g, g, [l / c.a5, l / c.a5, 1]), g } function De(m, t, s, l, d) { const g = c.a9.fromLngLat(m, t), v = d * c.as(1, m.lat), { x: T, y: E, z: I } = nr(s, l); return new c.a9(g.x + v * -T, g.y + v * -E, g.z + v * -I) } function nr(m, t) { const s = c.ap(m), l = c.ap(t), d = Math.cos(-s), g = Math.sin(s); return { x: g * Math.sin(l), y: -g * Math.cos(l), z: d } } function pn(m, t, s) { const l = t.intersectsFrustum(m); if (!s || l === 0) return l; const d = t.intersectsPlane(s); return d === 0 ? 0 : l === 2 && d === 2 ? 2 : 1 } function Mt(m, t, s) { let l = 0; const d = (s - t) / 10; for (let g = 0; g < 10; g++)l += d * Math.pow(Math.cos(t + (g + .5) / 10 * (s - t)), m); return l } function Jt(m, t) { return function (s, l, d, g, v) { const T = 2 * ((m - 1) / c.at(Math.cos(c.ap(ht - v)) / Math.cos(c.ap(ht))) - 1), E = Math.acos(d / g), I = 2 * Mt(T - 1, 0, c.ap(v / 2)), A = Math.min(c.ap(ht), E + c.ap(v / 2)), R = Mt(T - 1, Math.min(A, E - c.ap(v / 2)), A), z = Math.atan(l / d), O = Math.hypot(l, d); let U = s; return U += c.at(g / O / Math.max(.5, Math.cos(c.ap(v / 2)))), U += T * c.at(Math.cos(z)) / 2, U -= c.at(Math.max(1, R / I / t)) / 2, U } } const fn = Jt(9.314, 3); function pr(m, t) { const s = (t.roundZoom ? Math.round : Math.floor)(m.zoom + c.at(m.tileSize / t.tileSize)); return Math.max(0, s) } function Mr(m, t) { const s = m.getCameraFrustum(), l = m.getClippingPlane(), d = m.screenPointToMercatorCoordinate(m.getCameraPoint()), g = c.a9.fromLngLat(m.center, m.elevation); d.z = g.z + Math.cos(m.pitchInRadians) * m.cameraToCenterDistance / m.worldSize; const v = m.getCoveringTilesDetailsProvider(), T = v.allowVariableZoom(m, t), E = pr(m, t), I = t.minzoom || 0, A = t.maxzoom !== void 0 ? t.maxzoom : m.maxZoom, R = Math.min(Math.max(0, E), A), z = Math.pow(2, R), O = [z * d.x, z * d.y, 0], U = [z * g.x, z * g.y, 0], X = Math.hypot(g.x - d.x, g.y - d.y), Q = Math.abs(g.z - d.z), Y = Math.hypot(X, Q), te = oe => ({ zoom: 0, x: 0, y: 0, wrap: oe, fullyVisible: !1 }), le = [], J = []; if (m.renderWorldCopies && v.allowWorldCopies()) for (let oe = 1; oe <= 3; oe++)le.push(te(-oe)), le.push(te(oe)); for (le.push(te(0)); le.length > 0;) { const oe = le.pop(), ce = oe.x, se = oe.y; let fe = oe.fullyVisible; const Oe = { x: ce, y: se, z: oe.zoom }, ke = v.getTileBoundingVolume(Oe, oe.wrap, m.elevation, t); if (!fe) { const tt = pn(s, ke, l); if (tt === 0) continue; fe = tt === 2 } const ze = v.distanceToTile2d(d.x, d.y, Oe, ke); let Re = E; T && (Re = (t.calculateTileZoom || fn)(m.zoom + c.at(m.tileSize / t.tileSize), ze, Q, Y, m.fov)), Re = (t.roundZoom ? Math.round : Math.floor)(Re), Re = Math.max(0, Re); const Je = Math.min(Re, A); if (oe.wrap = v.getWrap(g, Oe, oe.wrap), oe.zoom >= Je) { if (oe.zoom < I) continue; const tt = R - oe.zoom, We = O[0] - .5 - (ce << tt), it = O[1] - .5 - (se << tt), It = t.reparseOverscaled ? Math.max(oe.zoom, Re) : oe.zoom; J.push({ tileID: new c.a2(oe.zoom === A ? It : oe.zoom, oe.wrap, oe.zoom, ce, se), distanceSq: c.au([U[0] - .5 - ce, U[1] - .5 - se]), tileDistanceToCamera: Math.sqrt(We * We + it * it) }) } else for (let tt = 0; tt < 4; tt++)le.push({ zoom: oe.zoom + 1, x: (ce << 1) + tt % 2, y: (se << 1) + (tt >> 1), wrap: oe.wrap, fullyVisible: fe }) } return J.sort((oe, ce) => oe.distanceSq - ce.distanceSq).map(oe => oe.tileID) } const ir = c.aa.fromPoints([new c.P(0, 0), new c.P(c.a5, c.a5)]); function Hr(m) { return m === "raster" || m === "image" || m === "video" } function Ia(m, t, s, l, d, g, v) { if (!t.hasData()) return !1; const { tileID: T, fadingRole: E, fadingDirection: I, fadingParentID: A } = t; if (E === pe.Base && I === Be.Incoming && A) return s[A.key] = A, !0; const R = Math.max(T.overscaledZ - d, g); for (let z = T.overscaledZ - 1; z >= R; z--) { const O = T.scaledTo(z), U = m.getLoadedTile(O); if (U) return t.setCrossFadeLogic({ fadingRole: pe.Base, fadingDirection: Be.Incoming, fadingParentID: U.tileID, fadeEndTime: l + v }), U.setCrossFadeLogic({ fadingRole: pe.Parent, fadingDirection: Be.Departing, fadeEndTime: l + v }), s[O.key] = O, !0 } return !1 } function Ca(m, t, s, l, d, g) { if (!t.hasData()) return !1; const v = t.tileID.children(d); let T = Qe(m, t, v, s, l, d, g); if (T) return !0; for (const E of v) Qe(m, t, E.children(d), s, l, d, g) && (T = !0); return T } function Qe(m, t, s, l, d, g, v) { if (s[0].overscaledZ >= g) return !1; let T = !1; for (const E of s) { const I = m.getLoadedTile(E); if (!I) continue; const { fadingRole: A, fadingDirection: R, fadingParentID: z } = I; A === pe.Base && R === Be.Departing && z || (I.setCrossFadeLogic({ fadingRole: pe.Base, fadingDirection: Be.Departing, fadingParentID: t.tileID, fadeEndTime: d + v }), t.setCrossFadeLogic({ fadingRole: pe.Parent, fadingDirection: Be.Incoming, fadeEndTime: d + v })), l[E.key] = E, T = !0 } return T } function Cn(m, t, s, l) { const d = m.tileID; return !!m.selfFading || !m.hasData() && !!t.has(d) && (m.setSelfFadeLogic(s + l), !0) } function An(m, t) { var s; m.needsHillshadePrepare = !0, m.needsTerrainPrepare = !0; let l = t.tileID.canonical.x - m.tileID.canonical.x; const d = t.tileID.canonical.y - m.tileID.canonical.y, g = Math.pow(2, m.tileID.canonical.z), v = t.tileID.key; l === 0 && d === 0 || Math.abs(d) > 1 || (Math.abs(l) > 1 && (Math.abs(l + g) === 1 ? l += g : Math.abs(l - g) === 1 && (l -= g)), t.dem && m.dem && (m.dem.backfillBorder(t.dem, l, d), !((s = m.neighboringTiles) === null || s === void 0) && s[v] && (m.neighboringTiles[v].backfilled = !0))) } class Ul { constructor() { this._tiles = {} } handleWrapJump(t) { const s = {}; for (const l in this._tiles) { const d = this._tiles[l]; d.tileID = d.tileID.unwrapTo(d.tileID.wrap + t), s[d.tileID.key] = d } this._tiles = s } setFeatureState(t, s) { for (const l in this._tiles) this._tiles[l].setFeatureState(t, s) } getAllTiles() { return Object.values(this._tiles) } getAllIds(t = !1) { return t ? Object.values(this._tiles).map(s => s.tileID).sort(c.aw).map(s => s.key) : Object.keys(this._tiles) } getTileById(t) { return this._tiles[t] } setTile(t, s) { this._tiles[t] = s } deleteTileById(t) { delete this._tiles[t] } getLoadedTile(t) { const s = this.getTileById(t.key); return s != null && s.hasData() ? s : null } isIdRenderable(t, s = !1) { var l; return (l = this.getTileById(t)) === null || l === void 0 ? void 0 : l.isRenderable(s) } getRenderableIds(t = 0, s) { const l = []; for (const d of this.getAllIds()) this.isIdRenderable(d, s) && l.push(this.getTileById(d)); return s ? l.sort((d, g) => { const v = d.tileID, T = g.tileID, E = new c.P(v.canonical.x, v.canonical.y)._rotate(-t), I = new c.P(T.canonical.x, T.canonical.y)._rotate(-t); return v.overscaledZ - T.overscaledZ || I.y - E.y || I.x - E.x }).map(d => d.tileID.key) : l.map(d => d.tileID).sort(c.aw).map(d => d.key) } } class oi extends c.E { constructor(t, s, l) { super(), this.id = t, this.dispatcher = l, this.on("data", d => this._dataHandler(d)), this.on("dataloading", () => { this._sourceErrored = !1 }), this.on("error", () => { this._sourceErrored = this._source.loaded() }), this._source = ((d, g, v, T) => { const E = new (W(g.type))(d, g, v, T); if (E.id !== d) throw new Error(`Expected Source id to be ${d} instead of ${E.id}`); return E })(t, s, l, this), this._inViewTiles = new Ul, this._outOfViewCache = new c.ax(0, d => this._unloadTile(d)), this._timers = {}, this._maxTileCacheSize = null, this._maxTileCacheZoomLevels = null, this._rasterFadeDuration = 0, this._maxFadingAncestorLevels = 5, this._state = new qe, this._didEmitContent = !1, this._updated = !1 } onAdd(t) { this.map = t, this._maxTileCacheSize = t ? t._maxTileCacheSize : null, this._maxTileCacheZoomLevels = t ? t._maxTileCacheZoomLevels : null, this._source && this._source.onAdd && this._source.onAdd(t) } onRemove(t) { for (const s of this._inViewTiles.getAllTiles()) s.unloadVectorData(); this.clearTiles(), this._source && this._source.onRemove && this._source.onRemove(t), this._inViewTiles = new Ul } loaded() { if (this._sourceErrored) return !0; if (!this._sourceLoaded || !this._source.loaded()) return !1; if (!(this.used === void 0 && this.usedForTerrain === void 0 || this.used || this.usedForTerrain)) return !0; if (!this._updated) return !1; for (const t of this._inViewTiles.getAllTiles()) if (t.state !== "loaded" && t.state !== "errored") return !1; return !0 } getSource() { return this._source } getState() { return this._state } pause() { this._paused = !0 } resume() { if (!this._paused) return; const t = this._shouldReloadOnResume; this._paused = !1, this._shouldReloadOnResume = !1, t && this.reload(), this.transform && this.update(this.transform, this.terrain) } _loadTile(t, s, l) { return c._(this, void 0, void 0, function* () { try { yield this._source.loadTile(t), this._tileLoaded(t, s, l) } catch (d) { t.state = "errored", d.status !== 404 ? this._source.fire(new c.k(d, { tile: t })) : this.update(this.transform, this.terrain) } }) } _unloadTile(t) { this._source.unloadTile && this._source.unloadTile(t) } _abortTile(t) { this._source.abortTile && this._source.abortTile(t), this._source.fire(new c.l("dataabort", { tile: t, coord: t.tileID, dataType: "source" })) } serialize() { return this._source.serialize() } prepare(t) { this._source.prepare && this._source.prepare(), this._state.coalesceChanges(this._inViewTiles, this.map ? this.map.painter : null); for (const s of this._inViewTiles.getAllTiles()) s.upload(t), s.prepare(this.map.style.imageManager) } getIds() { return this._inViewTiles.getAllIds(!0) } getRenderableIds(t) { var s; return this._inViewTiles.getRenderableIds((s = this.transform) === null || s === void 0 ? void 0 : s.bearingInRadians, t) } hasRenderableParent(t) { const s = t.overscaledZ - 1; if (s >= this._source.minzoom) { const l = this.getLoadedTile(t.scaledTo(s)); if (l) return this._inViewTiles.isIdRenderable(l.tileID.key) } return !1 } reload(t, s = void 0) { if (this._paused) this._shouldReloadOnResume = !0; else { this._outOfViewCache.reset(); for (const l of this._inViewTiles.getAllIds()) { const d = this._inViewTiles.getTileById(l); s && !this._source.shouldReloadTile(d, s) || (t ? this._reloadTile(l, "expired") : d.state !== "errored" && this._reloadTile(l, "reloading")) } } } _reloadTile(t, s) { return c._(this, void 0, void 0, function* () { const l = this._inViewTiles.getTileById(t); l && (l.state !== "loading" && (l.state = s), yield this._loadTile(l, t, s)) }) } _tileLoaded(t, s, l) { t.timeAdded = $e(), t.selfFading && (t.fadeEndTime = t.timeAdded + this._rasterFadeDuration), l === "expired" && (t.refreshedUponExpiration = !0), this._setTileReloadTimer(s, t), this.getSource().type === "raster-dem" && t.dem && function (d, g) { var v, T; const E = g.getRenderableIds(); for (const I of E) { if (!d.neighboringTiles || !d.neighboringTiles[I]) continue; const A = g.getTileById(I); d.neighboringTiles[I].backfilled || An(d, A), !((T = (v = A.neighboringTiles) === null || v === void 0 ? void 0 : v[d.tileID.key]) === null || T === void 0) && T.backfilled || An(A, d) } }(t, this._inViewTiles), this._state.initializeTileState(t, this.map ? this.map.painter : null), t.aborted || this._source.fire(new c.l("data", { dataType: "source", tile: t, coord: t.tileID })) } getTile(t) { return this.getTileByID(t.key) } getTileByID(t) { return this._inViewTiles.getTileById(t) } _retainLoadedChildren(t, s) { const l = this._getLoadedDescendents(s), d = new Set; for (const g of s) { const v = l[g.key]; if (!(v != null && v.length)) { d.add(g); continue } const T = g.overscaledZ + oi.maxOverzooming, E = v.filter(R => R.tileID.overscaledZ <= T); if (!E.length) { d.add(g); continue } const I = Math.min(...E.map(R => R.tileID.overscaledZ)), A = E.filter(R => R.tileID.overscaledZ === I).map(R => R.tileID); for (const R of A) t[R.key] = R; this._areDescendentsComplete(A, I, g.overscaledZ) || d.add(g) } return d } _getLoadedDescendents(t) { var s; const l = {}; for (const d of this._inViewTiles.getAllTiles().filter(g => g.hasData())) for (const g of t) d.tileID.isChildOf(g) && (l[s = g.key] || (l[s] = [])).push(d); return l } _areDescendentsComplete(t, s, l) { return t.length === 1 && t[0].isOverscaled() ? t[0].overscaledZ === s : Math.pow(4, s - l) === t.length } getLoadedTile(t) { return this._inViewTiles.getLoadedTile(t) } updateCacheSize(t) { const s = Math.ceil(t.width / this._source.tileSize) + 1, l = Math.ceil(t.height / this._source.tileSize) + 1, d = Math.floor(s * l * (this._maxTileCacheZoomLevels === null ? c.c.MAX_TILE_CACHE_ZOOM_LEVELS : this._maxTileCacheZoomLevels)), g = typeof this._maxTileCacheSize == "number" ? Math.min(this._maxTileCacheSize, d) : d; this._outOfViewCache.setMaxSize(g) } handleWrapJump(t) { const s = Math.round((t - (this._prevLng === void 0 ? t : this._prevLng)) / 360); this._prevLng = t, s && (this._inViewTiles.handleWrapJump(s), this._resetTileReloadTimers()) } update(t, s) { if (!this._sourceLoaded || this._paused) return; let l; this.transform = t, this.terrain = s, this.updateCacheSize(t), this.handleWrapJump(this.transform.center.lng), this.used || this.usedForTerrain ? this._source.tileID ? l = t.getVisibleUnwrappedCoordinates(this._source.tileID).map(E => new c.a2(E.canonical.z, E.wrap, E.canonical.z, E.canonical.x, E.canonical.y)) : (l = Mr(t, { tileSize: this.usedForTerrain ? this.tileSize : this._source.tileSize, minzoom: this._source.minzoom, maxzoom: this._source.type === "vector" && this.map._zoomLevelsToOverscale !== void 0 ? t.maxZoom - this.map._zoomLevelsToOverscale : this._source.maxzoom, roundZoom: !this.usedForTerrain && this._source.roundZoom, reparseOverscaled: this._source.reparseOverscaled, terrain: s, calculateTileZoom: this._source.calculateTileZoom }), this._source.hasTile && (l = l.filter(E => this._source.hasTile(E)))) : l = [], this.usedForTerrain && (l = this._addTerrainIdealTiles(l)); const d = l.length === 0 && !this._updated && this._didEmitContent; this._updated = !0, d && this.fire(new c.l("data", { sourceDataType: "idle", dataType: "source", sourceId: this.id })); const g = pr(t, this._source), v = this._updateRetainedTiles(l, g), T = Hr(this._source.type); T && this._rasterFadeDuration > 0 && !s && function (E, I, A, R, z, O, U) { const X = $e(), Q = c.av(I); for (const Y of I) { const te = E.getTileById(Y.key); te.fadingDirection !== Be.Departing && te.fadeOpacity !== 0 || te.resetFadeLogic(), Ia(E, te, A, X, R, z, U) || Ca(E, te, A, X, O, U) || Cn(te, Q, X, U) || te.resetFadeLogic() } }(this._inViewTiles, l, v, this._maxFadingAncestorLevels, this._source.minzoom, this._source.maxzoom, this._rasterFadeDuration), T ? this._cleanUpRasterTiles(v) : this._cleanUpVectorTiles(v) } _cleanUpRasterTiles(t) { for (const s of this._inViewTiles.getAllIds()) t[s] || this._removeTile(s) } _cleanUpVectorTiles(t) { for (const s of this._inViewTiles.getAllIds()) { const l = this._inViewTiles.getTileById(s); t[s] ? l.clearSymbolFadeHold() : l.hasSymbolBuckets ? l.holdingForSymbolFade() ? l.symbolFadeFinished() && this._removeTile(s) : l.setSymbolHoldDuration(this.map._fadeDuration) : this._removeTile(s) } } _addTerrainIdealTiles(t) { const s = []; for (const l of t) if (l.canonical.z > this._source.minzoom) { const d = l.scaledTo(l.canonical.z - 1); s.push(d); const g = l.scaledTo(Math.max(this._source.minzoom, Math.min(l.canonical.z, 5))); s.push(g) } return t.concat(s) } releaseSymbolFadeTiles() { for (const t of this._inViewTiles.getAllIds()) this._inViewTiles.getTileById(t).holdingForSymbolFade() && this._removeTile(t) } _updateRetainedTiles(t, s) { var l; const d = new Set; for (const I of t) this._addTile(I).hasData() || d.add(I); const g = t.reduce((I, A) => (I[A.key] = A, I), {}), v = this._retainLoadedChildren(g, d), T = {}, E = Math.max(s - oi.maxUnderzooming, this._source.minzoom); for (const I of v) { let A = this._inViewTiles.getTileById(I.key), R = A == null ? void 0 : A.wasRequested(); for (let z = I.overscaledZ - 1; z >= E; --z) { const O = I.scaledTo(z); if (T[O.key]) break; if (T[O.key] = !0, A = this.getTile(O), !A && R && (A = this._addTile(O)), A) { const U = A.hasData(); if ((U || !(!((l = this.map) === null || l === void 0) && l.cancelPendingTileRequestsWhileZooming) || R) && (g[O.key] = O), R = A.wasRequested(), U) break } } } return g } _addTile(t) { let s = this._inViewTiles.getTileById(t.key); if (s) return s; s = this._outOfViewCache.getAndRemove(t), s && (s.resetFadeLogic(), this._setTileReloadTimer(t.key, s), s.tileID = t, this._state.initializeTileState(s, this.map ? this.map.painter : null)); const l = s; return s || (s = new Xe(t, this._source.tileSize * t.overscaleFactor()), this._loadTile(s, t.key, s.state)), s.uses++, this._inViewTiles.setTile(t.key, s), l || this._source.fire(new c.l("dataloading", { tile: s, coord: s.tileID, dataType: "source" })), s } _setTileReloadTimer(t, s) { this._clearTileReloadTimer(t); const l = s.getExpiryTimeout(); l && (this._timers[t] = setTimeout(() => { this._reloadTile(t, "expired"), delete this._timers[t] }, l)) } _clearTileReloadTimer(t) { const s = this._timers[t]; s && (clearTimeout(s), delete this._timers[t]) } _resetTileReloadTimers() { for (const t in this._timers) clearTimeout(this._timers[t]), delete this._timers[t]; for (const t of this._inViewTiles.getAllIds()) { const s = this._inViewTiles.getTileById(t); this._setTileReloadTimer(t, s) } } refreshTiles(t) { for (const s of this._inViewTiles.getAllIds()) { const l = this._inViewTiles.getTileById(s); (this._inViewTiles.isIdRenderable(s) || l.state == "errored") && t.some(d => d.equals(l.tileID.canonical)) && this._reloadTile(s, "expired") } } _removeTile(t) { const s = this._inViewTiles.getTileById(t); s && (s.uses--, this._inViewTiles.deleteTileById(t), this._clearTileReloadTimer(t), s.uses > 0 || (s.hasData() && s.state !== "reloading" ? this._outOfViewCache.add(s.tileID, s, s.getExpiryTimeout()) : (s.aborted = !0, this._abortTile(s), this._unloadTile(s)))) } _dataHandler(t) { t.dataType === "source" && (t.sourceDataType !== "metadata" ? t.sourceDataType === "content" && this._sourceLoaded && !this._paused && (this.reload(t.sourceDataChanged, t.shouldReloadTileOptions), this.transform && this.update(this.transform, this.terrain), this._didEmitContent = !0) : this._sourceLoaded = !0) } clearTiles() { this._shouldReloadOnResume = !1, this._paused = !1; for (const t of this._inViewTiles.getAllIds()) this._removeTile(t); this._outOfViewCache.reset() } tilesIn(t, s, l) { const d = [], g = this.transform; if (!g) return d; const v = g.getCoveringTilesDetailsProvider().allowWorldCopies(), T = l ? g.getCameraQueryGeometry(t) : t, E = O => g.screenPointToMercatorCoordinate(O, this.terrain), I = this.transformBbox(t, E, !v), A = this.transformBbox(T, E, !v), R = this.getIds(), z = c.aa.fromPoints(A); for (let O = 0; O < R.length; O++) { const U = this._inViewTiles.getTileById(R[O]); if (U.holdingForSymbolFade()) continue; const X = v ? [U.tileID] : [U.tileID.unwrapTo(-1), U.tileID.unwrapTo(0)], Q = Math.pow(2, g.zoom - U.tileID.overscaledZ), Y = s * U.queryPadding * c.a5 / U.tileSize / Q; for (const te of X) { const le = z.map(J => te.getTilePoint(new c.a9(J.x, J.y))); if (le.expandBy(Y), le.intersects(ir)) { const J = I.map(ce => te.getTilePoint(ce)), oe = A.map(ce => te.getTilePoint(ce)); d.push({ tile: U, tileID: v ? te : te.unwrapTo(0), queryGeometry: J, cameraQueryGeometry: oe, scale: Q }) } } } return d } transformBbox(t, s, l) { let d = t.map(s); if (l) { const g = c.aa.fromPoints(t); g.shrinkBy(.001 * Math.min(g.width(), g.height())); const v = g.map(s); c.aa.fromPoints(d).covers(v) || (d = d.map(T => T.x > .5 ? new c.a9(T.x - 1, T.y, T.z) : T)) } return d } getVisibleCoordinates(t) { const s = this.getRenderableIds(t).map(l => this._inViewTiles.getTileById(l).tileID); return this.transform && this.transform.populateCache(s), s } hasTransition() { return !!this._source.hasTransition() || !(!Hr(this._source.type) || !function (t, s) { if (s <= 0) return !1; const l = $e(); for (const d of t.getAllTiles()) if (d.fadeEndTime >= l) return !0; return !1 }(this._inViewTiles, this._rasterFadeDuration)) } setRasterFadeDuration(t) { this._rasterFadeDuration = t } setFeatureState(t, s, l) { this._state.updateState(t = t || c.ai, s, l) } removeFeatureState(t, s, l) { this._state.removeFeatureState(t = t || c.ai, s, l) } getFeatureState(t, s) { return this._state.getState(t = t || c.ai, s) } setDependencies(t, s, l) { const d = this._inViewTiles.getTileById(t); d && d.setDependencies(s, l) } reloadTilesForDependencies(t, s) { for (const l of this._inViewTiles.getAllIds()) this._inViewTiles.getTileById(l).hasDependency(t, s) && this._reloadTile(l, "reloading"); this._outOfViewCache.filter(l => !l.hasDependency(t, s)) } areTilesLoaded() { for (const t of this._inViewTiles.getAllTiles()) if (t.state !== "loaded" && t.state !== "errored") return !1; return !0 } } oi.maxUnderzooming = 10, oi.maxOverzooming = 3; class at { constructor(t, s) { this.reset(t, s) } reset(t, s) { this.points = t || [], this._distances = [0]; for (let l = 1; l < this.points.length; l++)this._distances[l] = this._distances[l - 1] + this.points[l].dist(this.points[l - 1]); this.length = this._distances[this._distances.length - 1], this.padding = Math.min(s || 0, .5 * this.length), this.paddedLength = this.length - 2 * this.padding } lerp(t) { if (this.points.length === 1) return this.points[0]; t = c.an(t, 0, 1); let s = 1, l = this._distances[s]; const d = t * this.paddedLength + this.padding; for (; l < d && s < this._distances.length;)l = this._distances[++s]; const g = s - 1, v = this._distances[g], T = l - v, E = T > 0 ? (d - v) / T : 0; return this.points[g].mult(1 - E).add(this.points[s].mult(E)) } } function Dt(m, t) { let s = !0; return m === "always" || m !== "never" && t !== "never" || (s = !1), s } class zt { constructor(t, s, l) { const d = this.boxCells = [], g = this.circleCells = []; this.xCellCount = Math.ceil(t / l), this.yCellCount = Math.ceil(s / l); for (let v = 0; v < this.xCellCount * this.yCellCount; v++)d.push([]), g.push([]); this.circleKeys = [], this.boxKeys = [], this.bboxes = [], this.circles = [], this.width = t, this.height = s, this.xScale = this.xCellCount / t, this.yScale = this.yCellCount / s, this.boxUid = 0, this.circleUid = 0 } keysLength() { return this.boxKeys.length + this.circleKeys.length } insert(t, s, l, d, g) { this._forEachCell(s, l, d, g, this._insertBoxCell, this.boxUid++), this.boxKeys.push(t), this.bboxes.push(s), this.bboxes.push(l), this.bboxes.push(d), this.bboxes.push(g) } insertCircle(t, s, l, d) { this._forEachCell(s - d, l - d, s + d, l + d, this._insertCircleCell, this.circleUid++), this.circleKeys.push(t), this.circles.push(s), this.circles.push(l), this.circles.push(d) } _insertBoxCell(t, s, l, d, g, v) { this.boxCells[g].push(v) } _insertCircleCell(t, s, l, d, g, v) { this.circleCells[g].push(v) } _query(t, s, l, d, g, v, T) { if (l < 0 || t > this.width || d < 0 || s > this.height) return []; const E = []; if (t <= 0 && s <= 0 && this.width <= l && this.height <= d) { if (g) return [{ key: null, x1: t, y1: s, x2: l, y2: d }]; for (let I = 0; I < this.boxKeys.length; I++)E.push({ key: this.boxKeys[I], x1: this.bboxes[4 * I], y1: this.bboxes[4 * I + 1], x2: this.bboxes[4 * I + 2], y2: this.bboxes[4 * I + 3] }); for (let I = 0; I < this.circleKeys.length; I++) { const A = this.circles[3 * I], R = this.circles[3 * I + 1], z = this.circles[3 * I + 2]; E.push({ key: this.circleKeys[I], x1: A - z, y1: R - z, x2: A + z, y2: R + z }) } } else this._forEachCell(t, s, l, d, this._queryCell, E, { hitTest: g, overlapMode: v, seenUids: { box: {}, circle: {} } }, T); return E } query(t, s, l, d) { return this._query(t, s, l, d, !1, null) } hitTest(t, s, l, d, g, v) { return this._query(t, s, l, d, !0, g, v).length > 0 } hitTestCircle(t, s, l, d, g) { const v = t - l, T = t + l, E = s - l, I = s + l; if (T < 0 || v > this.width || I < 0 || E > this.height) return !1; const A = []; return this._forEachCell(v, E, T, I, this._queryCellCircle, A, { hitTest: !0, overlapMode: d, circle: { x: t, y: s, radius: l }, seenUids: { box: {}, circle: {} } }, g), A.length > 0 } _queryCell(t, s, l, d, g, v, T, E) { const { seenUids: I, hitTest: A, overlapMode: R } = T, z = this.boxCells[g]; if (z !== null) { const U = this.bboxes; for (const X of z) if (!I.box[X]) { I.box[X] = !0; const Q = 4 * X, Y = this.boxKeys[X]; if (t <= U[Q + 2] && s <= U[Q + 3] && l >= U[Q + 0] && d >= U[Q + 1] && (!E || E(Y)) && (!A || !Dt(R, Y.overlapMode)) && (v.push({ key: Y, x1: U[Q], y1: U[Q + 1], x2: U[Q + 2], y2: U[Q + 3] }), A)) return !0 } } const O = this.circleCells[g]; if (O !== null) { const U = this.circles; for (const X of O) if (!I.circle[X]) { I.circle[X] = !0; const Q = 3 * X, Y = this.circleKeys[X]; if (this._circleAndRectCollide(U[Q], U[Q + 1], U[Q + 2], t, s, l, d) && (!E || E(Y)) && (!A || !Dt(R, Y.overlapMode))) { const te = U[Q], le = U[Q + 1], J = U[Q + 2]; if (v.push({ key: Y, x1: te - J, y1: le - J, x2: te + J, y2: le + J }), A) return !0 } } } return !1 } _queryCellCircle(t, s, l, d, g, v, T, E) { const { circle: I, seenUids: A, overlapMode: R } = T, z = this.boxCells[g]; if (z !== null) { const U = this.bboxes; for (const X of z) if (!A.box[X]) { A.box[X] = !0; const Q = 4 * X, Y = this.boxKeys[X]; if (this._circleAndRectCollide(I.x, I.y, I.radius, U[Q + 0], U[Q + 1], U[Q + 2], U[Q + 3]) && (!E || E(Y)) && !Dt(R, Y.overlapMode)) return v.push(!0), !0 } } const O = this.circleCells[g]; if (O !== null) { const U = this.circles; for (const X of O) if (!A.circle[X]) { A.circle[X] = !0; const Q = 3 * X, Y = this.circleKeys[X]; if (this._circlesCollide(U[Q], U[Q + 1], U[Q + 2], I.x, I.y, I.radius) && (!E || E(Y)) && !Dt(R, Y.overlapMode)) return v.push(!0), !0 } } } _forEachCell(t, s, l, d, g, v, T, E) { const I = this._convertToXCellCoord(t), A = this._convertToYCellCoord(s), R = this._convertToXCellCoord(l), z = this._convertToYCellCoord(d); for (let O = I; O <= R; O++)for (let U = A; U <= z; U++)if (g.call(this, t, s, l, d, this.xCellCount * U + O, v, T, E)) return } _convertToXCellCoord(t) { return Math.max(0, Math.min(this.xCellCount - 1, Math.floor(t * this.xScale))) } _convertToYCellCoord(t) { return Math.max(0, Math.min(this.yCellCount - 1, Math.floor(t * this.yScale))) } _circlesCollide(t, s, l, d, g, v) { const T = d - t, E = g - s, I = l + v; return I * I > T * T + E * E } _circleAndRectCollide(t, s, l, d, g, v, T) { const E = (v - d) / 2, I = Math.abs(t - (d + E)); if (I > E + l) return !1; const A = (T - g) / 2, R = Math.abs(s - (g + A)); if (R > A + l) return !1; if (I <= E || R <= A) return !0; const z = I - E, O = R - A; return z * z + O * O <= l * l } } function Yn(m, t, s) { const l = c.N(); if (!m) { const { vecSouth: R, vecEast: z } = es(t), O = $(); O[0] = z[0], O[1] = z[1], O[2] = R[0], O[3] = R[1], d = O, (A = (v = (g = O)[0]) * (I = g[3]) - (E = g[2]) * (T = g[1])) && (d[0] = I * (A = 1 / A), d[1] = -T * A, d[2] = -E * A, d[3] = v * A), l[0] = O[0], l[1] = O[1], l[4] = O[2], l[5] = O[3] } var d, g, v, T, E, I, A; return c.Q(l, l, [1 / s, 1 / s, 1]), l } function Gl(m, t, s, l) { if (m) { const d = c.N(); if (!t) { const { vecSouth: g, vecEast: v } = es(s); d[0] = v[0], d[1] = v[1], d[4] = g[0], d[5] = g[1] } return c.Q(d, d, [l, l, 1]), d } return s.pixelsToClipSpaceMatrix } function es(m) { const t = Math.cos(m.rollInRadians), s = Math.sin(m.rollInRadians), l = Math.cos(m.pitchInRadians), d = Math.cos(m.bearingInRadians), g = Math.sin(m.bearingInRadians), v = c.aC(); v[0] = -d * l * s - g * t, v[1] = -g * l * s + d * t; const T = c.aD(v); T < 1e-9 ? c.aE(v) : c.aF(v, v, 1 / T); const E = c.aC(); E[0] = d * l * t - g * s, E[1] = g * l * t + d * s; const I = c.aD(E); return I < 1e-9 ? c.aE(E) : c.aF(E, E, 1 / I), { vecEast: E, vecSouth: v } } function At(m, t, s, l) { let d; l ? (d = [m, t, l(m, t), 1], c.aH(d, d, s)) : (d = [m, t, 0, 1], Zl(d, d, s)); const g = d[3]; return { point: new c.P(d[0] / g, d[1] / g), signedDistanceFromCamera: g, isOccluded: !1 } } function Aa(m, t) { return .5 + m / t * .5 } function ka(m, t) { return m.x >= -t[0] && m.x <= t[0] && m.y >= -t[1] && m.y <= t[1] } function $l(m, t, s, l, d, g, v, T, E, I, A, R, z) { const O = s ? m.textSizeData : m.iconSizeData, U = c.ay(O, t.transform.zoom), X = [256 / t.width * 2 + 1, 256 / t.height * 2 + 1], Q = s ? m.text.dynamicLayoutVertexArray : m.icon.dynamicLayoutVertexArray; Q.clear(); const Y = m.lineVertexArray, te = s ? m.text.placedSymbolArray : m.icon.placedSymbolArray, le = t.transform.width / t.transform.height; let J = !1; for (let oe = 0; oe < te.length; oe++) { const ce = te.get(oe); if (ce.hidden || ce.writingMode === c.az.vertical && !J) { $s(ce.numGlyphs, Q); continue } J = !1; const se = new c.P(ce.anchorX, ce.anchorY), fe = { getElevation: z, pitchedLabelPlaneMatrix: l, lineVertexArray: Y, pitchWithMap: g, projectionCache: { projections: {}, offsets: {}, cachedAnchorPoint: void 0, anyProjectionOccluded: !1 }, transform: t.transform, tileAnchorPoint: se, unwrappedTileID: E, width: I, height: A, translation: R }, Oe = ko(ce.anchorX, ce.anchorY, fe); if (!ka(Oe.point, X)) { $s(ce.numGlyphs, Q); continue } const ke = Aa(t.transform.cameraToCenterDistance, Oe.signedDistanceFromCamera), ze = c.aA(O, U, ce), Re = g ? ze * t.transform.getPitchedTextCorrection(ce.anchorX, ce.anchorY, E) / ke : ze * ke, Je = Ao({ projectionContext: fe, pitchedLabelPlaneMatrixInverse: d, symbol: ce, fontSize: Re, flip: !1, keepUpright: v, glyphOffsetArray: m.glyphOffsetArray, dynamicLayoutVertexArray: Q, aspectRatio: le, rotateToLine: T }); J = Je.useVertical, (Je.notEnoughRoom || J || Je.needsFlipping && Ao({ projectionContext: fe, pitchedLabelPlaneMatrixInverse: d, symbol: ce, fontSize: Re, flip: !0, keepUpright: v, glyphOffsetArray: m.glyphOffsetArray, dynamicLayoutVertexArray: Q, aspectRatio: le, rotateToLine: T }).notEnoughRoom) && $s(ce.numGlyphs, Q) } s ? m.text.dynamicLayoutVertexBuffer.updateData(Q) : m.icon.dynamicLayoutVertexBuffer.updateData(Q) } function Co(m, t, s, l, d, g, v, T) { const E = g.glyphStartIndex + g.numGlyphs, I = g.lineStartIndex, A = g.lineStartIndex + g.lineLength, R = t.getoffsetX(g.glyphStartIndex), z = t.getoffsetX(E - 1), O = wi(m * R, s, l, d, g.segment, I, A, T, v); if (!O) return null; const U = wi(m * z, s, l, d, g.segment, I, A, T, v); return U ? T.projectionCache.anyProjectionOccluded ? null : { first: O, last: U } : null } function Da(m, t, s, l) { return m === c.az.horizontal && Math.abs(s.y - t.y) > Math.abs(s.x - t.x) * l ? { useVertical: !0 } : (m === c.az.vertical ? t.y < s.y : t.x > s.x) ? { needsFlipping: !0 } : null } function Ao(m) { const { projectionContext: t, pitchedLabelPlaneMatrixInverse: s, symbol: l, fontSize: d, flip: g, keepUpright: v, glyphOffsetArray: T, dynamicLayoutVertexArray: E, aspectRatio: I, rotateToLine: A } = m, R = d / 24, z = l.lineOffsetX * R, O = l.lineOffsetY * R; let U; if (l.numGlyphs > 1) { const X = l.glyphStartIndex + l.numGlyphs, Q = l.lineStartIndex, Y = l.lineStartIndex + l.lineLength, te = Co(R, T, z, O, g, l, A, t); if (!te) return { notEnoughRoom: !0 }; const le = ql(te.first.point.x, te.first.point.y, t, s), J = ql(te.last.point.x, te.last.point.y, t, s); if (v && !g) { const oe = Da(l.writingMode, le, J, I); if (oe) return oe } U = [te.first]; for (let oe = l.glyphStartIndex + 1; oe < X - 1; oe++) { const ce = wi(R * T.getoffsetX(oe), z, O, g, l.segment, Q, Y, t, A); if (!ce) return { notEnoughRoom: !0 }; U.push(ce) } U.push(te.last) } else { if (v && !g) { const Q = er(t.tileAnchorPoint.x, t.tileAnchorPoint.y, t).point, Y = l.lineStartIndex + l.segment + 1, te = new c.P(t.lineVertexArray.getx(Y), t.lineVertexArray.gety(Y)), le = er(te.x, te.y, t), J = le.signedDistanceFromCamera > 0 ? le.point : za(t.tileAnchorPoint, te, Q, 1, t), oe = ql(Q.x, Q.y, t, s), ce = ql(J.x, J.y, t, s), se = Da(l.writingMode, oe, ce, I); if (se) return se } const X = wi(R * T.getoffsetX(l.glyphStartIndex), z, O, g, l.segment, l.lineStartIndex, l.lineStartIndex + l.lineLength, t, A); if (!X || t.projectionCache.anyProjectionOccluded) return { notEnoughRoom: !0 }; U = [X] } for (const X of U) c.aG(E, X.point, X.angle); return {} } function za(m, t, s, l, d) { const g = m.add(m.sub(t)._unit()), v = er(g.x, g.y, d).point, T = s.sub(v); return s.add(T._mult(l / T.mag())) } function kn(m, t, s) { const l = t.projectionCache; if (l.projections[m]) return l.projections[m]; const d = new c.P(t.lineVertexArray.getx(m), t.lineVertexArray.gety(m)), g = er(d.x, d.y, t); if (g.signedDistanceFromCamera > 0) return l.projections[m] = g.point, l.anyProjectionOccluded = l.anyProjectionOccluded || g.isOccluded, g.point; const v = m - s.direction; return za(s.distanceFromAnchor === 0 ? t.tileAnchorPoint : new c.P(t.lineVertexArray.getx(v), t.lineVertexArray.gety(v)), d, s.previousVertex, s.absOffsetX - s.distanceFromAnchor + 1, t) } function er(m, t, s) { const l = m + s.translation[0], d = t + s.translation[1]; let g; return s.pitchWithMap ? (g = At(l, d, s.pitchedLabelPlaneMatrix, s.getElevation), g.isOccluded = !1) : (g = s.transform.projectTileCoordinates(l, d, s.unwrappedTileID, s.getElevation), g.point.x = (.5 * g.point.x + .5) * s.width, g.point.y = (.5 * -g.point.y + .5) * s.height), g } function ql(m, t, s, l) { if (s.pitchWithMap) { const d = [m, t, 0, 1]; return c.aH(d, d, l), s.transform.projectTileCoordinates(d[0] / d[3], d[1] / d[3], s.unwrappedTileID, s.getElevation).point } return { x: m / s.width * 2 - 1, y: 1 - t / s.height * 2 } } function ko(m, t, s) { return s.transform.projectTileCoordinates(m, t, s.unwrappedTileID, s.getElevation) } function Ra(m, t, s) { return m._unit()._perp()._mult(t * s) } function Gs(m, t, s, l, d, g, v, T, E) { if (T.projectionCache.offsets[m]) return T.projectionCache.offsets[m]; const I = s.add(t); if (m + E.direction < l || m + E.direction >= d) return T.projectionCache.offsets[m] = I, I; const A = kn(m + E.direction, T, E), R = Ra(A.sub(s), v, E.direction), z = s.add(R), O = A.add(R); return T.projectionCache.offsets[m] = c.aI(g, I, z, O) || I, T.projectionCache.offsets[m] } function wi(m, t, s, l, d, g, v, T, E) { const I = l ? m - t : m + t; let A = I > 0 ? 1 : -1, R = 0; l && (A *= -1, R = Math.PI), A < 0 && (R += Math.PI); let z, O = A > 0 ? g + d : g + d + 1; T.projectionCache.cachedAnchorPoint ? z = T.projectionCache.cachedAnchorPoint : (z = er(T.tileAnchorPoint.x, T.tileAnchorPoint.y, T).point, T.projectionCache.cachedAnchorPoint = z); let U, X, Q = z, Y = z, te = 0, le = 0; const J = Math.abs(I), oe = []; let ce; for (; te + le <= J;) { if (O += A, O < g || O >= v) return null; te += le, Y = Q, X = U; const Oe = { absOffsetX: J, direction: A, distanceFromAnchor: te, previousVertex: Y }; if (Q = kn(O, T, Oe), s === 0) oe.push(Y), ce = Q.sub(Y); else { let ke; const ze = Q.sub(Y); ke = ze.mag() === 0 ? Ra(kn(O + A, T, Oe).sub(Q), s, A) : Ra(ze, s, A), X || (X = Y.add(ke)), U = Gs(O, ke, Q, g, v, X, s, T, Oe), oe.push(X), ce = U.sub(X) } le = ce.mag() } const se = ce._mult((J - te) / le)._add(X || Y), fe = R + Math.atan2(Q.y - Y.y, Q.x - Y.x); return oe.push(se), { point: se, angle: E ? fe : 0, path: oe } } const Bd = new Float32Array([-1 / 0, -1 / 0, 0, -1 / 0, -1 / 0, 0, -1 / 0, -1 / 0, 0, -1 / 0, -1 / 0, 0]); function $s(m, t) { for (let s = 0; s < m; s++) { const l = t.length; t.resize(l + 4), t.float32.set(Bd, 3 * l) } } function Zl(m, t, s) { const l = t[0], d = t[1]; return m[0] = s[0] * l + s[4] * d + s[12], m[1] = s[1] * l + s[5] * d + s[13], m[3] = s[3] * l + s[7] * d + s[15], m } const Ir = 100; class Od { constructor(t, s = new zt(t.width + 200, t.height + 200, 25), l = new zt(t.width + 200, t.height + 200, 25)) { this.transform = t, this.grid = s, this.ignoredGrid = l, this.pitchFactor = Math.cos(t.pitch * Math.PI / 180) * t.cameraToCenterDistance, this.screenRightBoundary = t.width + Ir, this.screenBottomBoundary = t.height + Ir, this.gridRightBoundary = t.width + 200, this.gridBottomBoundary = t.height + 200, this.perspectiveRatioCutoff = .6 } placeCollisionBox(t, s, l, d, g, v, T, E, I, A, R, z) { const O = this.projectAndGetPerspectiveRatio(t.anchorPointX + E[0], t.anchorPointY + E[1], g, A, z), U = l * O.perspectiveRatio; let X; if (v || T) X = this._projectCollisionBox(t, U, d, g, v, T, E, O, A, R, z); else { const ce = O.x + (R ? R.x * U : 0), se = O.y + (R ? R.y * U : 0); X = { allPointsOccluded: !1, box: [ce + t.x1 * U, se + t.y1 * U, ce + t.x2 * U, se + t.y2 * U] } } const [Q, Y, te, le] = X.box, J = v ? X.allPointsOccluded : O.isOccluded; let oe = J; return oe || (oe = O.perspectiveRatio < this.perspectiveRatioCutoff), oe || (oe = !this.isInsideGrid(Q, Y, te, le)), oe || s !== "always" && this.grid.hitTest(Q, Y, te, le, s, I) ? { box: [Q, Y, te, le], placeable: !1, offscreen: !1, occluded: J } : { box: [Q, Y, te, le], placeable: !0, offscreen: this.isOffscreen(Q, Y, te, le), occluded: J } } placeCollisionCircles(t, s, l, d, g, v, T, E, I, A, R, z, O, U) { const X = [], Q = new c.P(s.anchorX, s.anchorY), Y = this.getPerspectiveRatio(Q.x, Q.y, v, U), te = (I ? g * this.transform.getPitchedTextCorrection(s.anchorX, s.anchorY, v) / Y : g * Y) / c.aM, le = { getElevation: U, pitchedLabelPlaneMatrix: T, lineVertexArray: l, pitchWithMap: I, projectionCache: { projections: {}, offsets: {}, cachedAnchorPoint: void 0, anyProjectionOccluded: !1 }, transform: this.transform, tileAnchorPoint: Q, unwrappedTileID: v, width: this.transform.width, height: this.transform.height, translation: O }, J = Co(te, d, s.lineOffsetX * te, s.lineOffsetY * te, !1, s, !1, le); let oe = !1, ce = !1, se = !0; if (J) { const fe = .5 * R * Y + z, Oe = new c.P(-100, -100), ke = new c.P(this.screenRightBoundary, this.screenBottomBoundary), ze = new at, Re = J.first, Je = J.last; let tt = []; for (let It = Re.path.length - 1; It >= 1; It--)tt.push(Re.path[It]); for (let It = 1; It < Je.path.length; It++)tt.push(Je.path[It]); const We = 2.5 * fe; if (I) { const It = this.projectPathToScreenSpace(tt, le); tt = It.some(Kt => Kt.signedDistanceFromCamera <= 0) ? [] : It.map(Kt => Kt.point) } let it = []; if (tt.length > 0) { const It = tt[0].clone(), Kt = tt[0].clone(); for (let fr = 1; fr < tt.length; fr++)It.x = Math.min(It.x, tt[fr].x), It.y = Math.min(It.y, tt[fr].y), Kt.x = Math.max(Kt.x, tt[fr].x), Kt.y = Math.max(Kt.y, tt[fr].y); it = It.x >= Oe.x && Kt.x <= ke.x && It.y >= Oe.y && Kt.y <= ke.y ? [tt] : Kt.x < Oe.x || It.x > ke.x || Kt.y < Oe.y || It.y > ke.y ? [] : c.aJ([tt], Oe.x, Oe.y, ke.x, ke.y) } for (const It of it) { ze.reset(It, .25 * fe); let Kt = 0; Kt = ze.length <= .5 * fe ? 1 : Math.ceil(ze.paddedLength / We) + 1; for (let fr = 0; fr < Kt; fr++) { const ar = fr / Math.max(Kt - 1, 1), yr = ze.lerp(ar), lr = yr.x + Ir, Ar = yr.y + Ir; X.push(lr, Ar, fe, 0); const vr = lr - fe, sn = Ar - fe, Vr = lr + fe, Or = Ar + fe; if (se = se && this.isOffscreen(vr, sn, Vr, Or), ce = ce || this.isInsideGrid(vr, sn, Vr, Or), t !== "always" && this.grid.hitTestCircle(lr, Ar, fe, t, A) && (oe = !0, !E)) return { circles: [], offscreen: !1, collisionDetected: oe } } } } return { circles: !E && oe || !ce || Y < this.perspectiveRatioCutoff ? [] : X, offscreen: se, collisionDetected: oe } } projectPathToScreenSpace(t, s) { const l = function (d, g) { const v = c.N(); return c.aB(v, g.pitchedLabelPlaneMatrix), d.map(T => { const E = At(T.x, T.y, v, g.getElevation), I = g.transform.projectTileCoordinates(E.point.x, E.point.y, g.unwrappedTileID, g.getElevation); return I.point.x = (.5 * I.point.x + .5) * g.width, I.point.y = (.5 * -I.point.y + .5) * g.height, I }) }(t, s); return function (d) { let g = 0, v = 0, T = 0, E = 0; for (let I = 0; I < d.length; I++)d[I].isOccluded ? (T = I + 1, E = 0) : (E++, E > v && (v = E, g = T)); return d.slice(g, g + v) }(l) } queryRenderedSymbols(t) { if (t.length === 0 || this.grid.keysLength() === 0 && this.ignoredGrid.keysLength() === 0) return {}; const s = [], l = new c.aa; for (const R of t) { const z = new c.P(R.x + Ir, R.y + Ir); l.extend(z), s.push(z) } const { minX: d, minY: g, maxX: v, maxY: T } = l, E = this.grid.query(d, g, v, T).concat(this.ignoredGrid.query(d, g, v, T)), I = {}, A = {}; for (const R of E) { const z = R.key; if (I[z.bucketInstanceId] === void 0 && (I[z.bucketInstanceId] = {}), I[z.bucketInstanceId][z.featureIndex]) continue; const O = [new c.P(R.x1, R.y1), new c.P(R.x2, R.y1), new c.P(R.x2, R.y2), new c.P(R.x1, R.y2)]; c.aK(s, O) && (I[z.bucketInstanceId][z.featureIndex] = !0, A[z.bucketInstanceId] === void 0 && (A[z.bucketInstanceId] = []), A[z.bucketInstanceId].push(z.featureIndex)) } return A } insertCollisionBox(t, s, l, d, g, v) { (l ? this.ignoredGrid : this.grid).insert({ bucketInstanceId: d, featureIndex: g, collisionGroupID: v, overlapMode: s }, t[0], t[1], t[2], t[3]) } insertCollisionCircles(t, s, l, d, g, v) { const T = l ? this.ignoredGrid : this.grid, E = { bucketInstanceId: d, featureIndex: g, collisionGroupID: v, overlapMode: s }; for (let I = 0; I < t.length; I += 4)T.insertCircle(E, t[I], t[I + 1], t[I + 2]) } projectAndGetPerspectiveRatio(t, s, l, d, g) { if (g) { let v; d ? (v = [t, s, d(t, s), 1], c.aH(v, v, g)) : (v = [t, s, 0, 1], Zl(v, v, g)); const T = v[3]; return { x: (v[0] / T + 1) / 2 * this.transform.width + Ir, y: (-v[1] / T + 1) / 2 * this.transform.height + Ir, perspectiveRatio: .5 + this.transform.cameraToCenterDistance / T * .5, isOccluded: !1, signedDistanceFromCamera: T } } { const v = this.transform.projectTileCoordinates(t, s, l, d); return { x: (v.point.x + 1) / 2 * this.transform.width + Ir, y: (1 - v.point.y) / 2 * this.transform.height + Ir, perspectiveRatio: .5 + this.transform.cameraToCenterDistance / v.signedDistanceFromCamera * .5, isOccluded: v.isOccluded, signedDistanceFromCamera: v.signedDistanceFromCamera } } } getPerspectiveRatio(t, s, l, d) { const g = this.transform.projectTileCoordinates(t, s, l, d); return .5 + this.transform.cameraToCenterDistance / g.signedDistanceFromCamera * .5 } isOffscreen(t, s, l, d) { return l < Ir || t >= this.screenRightBoundary || d < Ir || s > this.screenBottomBoundary } isInsideGrid(t, s, l, d) { return l >= 0 && t < this.gridRightBoundary && d >= 0 && s < this.gridBottomBoundary } getViewportMatrix() { const t = c.ar([]); return c.O(t, t, [-100, -100, 0]), t } _projectCollisionBox(t, s, l, d, g, v, T, E, I, A, R) { let z = 1, O = 0, U = 0, X = 1; const Q = t.anchorPointX + T[0], Y = t.anchorPointY + T[1]; if (v && !g) { const tt = this.projectAndGetPerspectiveRatio(Q + 1, Y, d, I, R), We = tt.x - E.x, it = Math.atan((tt.y - E.y) / We) + (We < 0 ? Math.PI : 0), It = Math.sin(it), Kt = Math.cos(it); z = Kt, O = It, U = -It, X = Kt } else if (!v && g) { const tt = es(this.transform); z = tt.vecEast[0], O = tt.vecEast[1], U = tt.vecSouth[0], X = tt.vecSouth[1] } let te = E.x, le = E.y, J = s; g && (te = Q, le = Y, J = Math.pow(2, -(this.transform.zoom - l.overscaledZ)), J *= this.transform.getPitchedTextCorrection(Q, Y, d), A || (J *= c.an(.5 + E.signedDistanceFromCamera / this.transform.cameraToCenterDistance * .5, 0, 4))), A && (te += z * A.x * J + U * A.y * J, le += O * A.x * J + X * A.y * J); const oe = t.x1 * J, ce = t.x2 * J, se = (oe + ce) / 2, fe = t.y1 * J, Oe = t.y2 * J, ke = (fe + Oe) / 2, ze = [{ offsetX: oe, offsetY: fe }, { offsetX: se, offsetY: fe }, { offsetX: ce, offsetY: fe }, { offsetX: ce, offsetY: ke }, { offsetX: ce, offsetY: Oe }, { offsetX: se, offsetY: Oe }, { offsetX: oe, offsetY: Oe }, { offsetX: oe, offsetY: ke }]; let Re = []; for (const { offsetX: tt, offsetY: We } of ze) Re.push(new c.P(te + z * tt + U * We, le + O * tt + X * We)); let Je = !1; if (g) { const tt = Re.map(We => this.projectAndGetPerspectiveRatio(We.x, We.y, d, I, R)); Je = tt.some(We => !We.isOccluded), Re = tt.map(We => new c.P(We.x, We.y)) } else Je = !0; return { box: c.aL(Re), allPointsOccluded: !Je } } } class Nd { constructor(t, s, l, d) { this.opacity = t ? Math.max(0, Math.min(1, t.opacity + (t.placed ? s : -s))) : d && l ? 1 : 0, this.placed = l } isHidden() { return this.opacity === 0 && !this.placed } } class La { constructor(t, s, l, d, g) { this.text = new Nd(t ? t.text : null, s, l, g), this.icon = new Nd(t ? t.icon : null, s, d, g) } isHidden() { return this.text.isHidden() && this.icon.isHidden() } } class jd { constructor(t, s, l) { this.text = t, this.icon = s, this.skipFade = l } } class Vd { constructor(t, s, l, d, g) { this.bucketInstanceId = t, this.featureIndex = s, this.sourceLayerIndex = l, this.bucketIndex = d, this.tileID = g } } class Ud { constructor(t) { this.crossSourceCollisions = t, this.maxGroupID = 0, this.collisionGroups = {} } get(t) { if (this.crossSourceCollisions) return { ID: 0, predicate: null }; if (!this.collisionGroups[t]) { const s = ++this.maxGroupID; this.collisionGroups[t] = { ID: s, predicate: l => l.collisionGroupID === s } } return this.collisionGroups[t] } } function Wl(m, t, s, l, d) { const { horizontalAlign: g, verticalAlign: v } = c.aS(m); return new c.P(-(g - .5) * t + l[0] * d, -(v - .5) * s + l[1] * d) } class Pc { constructor(t, s, l, d, g) { this.transform = t.clone(), this.terrain = s, this.collisionIndex = new Od(this.transform), this.placements = {}, this.opacities = {}, this.variableOffsets = {}, this.stale = !1, this.commitTime = 0, this.fadeDuration = l, this.retainedQueryData = {}, this.collisionGroups = new Ud(d), this.collisionCircleArrays = {}, this.collisionBoxArrays = new Map, this.prevPlacement = g, g && (g.prevPlacement = void 0), this.placedOrientations = {} } _getTerrainElevationFunc(t) { const s = this.terrain; return s ? (l, d) => s.getElevation(t, l, d) : null } getBucketParts(t, s, l, d) { const g = l.getBucket(s), v = l.latestFeatureIndex; if (!g || !v || s.id !== g.layerIds[0]) return; const T = l.collisionBoxArray, E = g.layers[0].layout, I = g.layers[0].paint, A = Math.pow(2, this.transform.zoom - l.tileID.overscaledZ), R = l.tileSize / c.a5, z = l.tileID.toUnwrapped(), O = E.get("text-rotation-alignment") === "map", U = c.aN(l, 1, this.transform.zoom), X = c.aO(this.collisionIndex.transform, l, I.get("text-translate"), I.get("text-translate-anchor")), Q = c.aO(this.collisionIndex.transform, l, I.get("icon-translate"), I.get("icon-translate-anchor")), Y = Yn(O, this.transform, U); this.retainedQueryData[g.bucketInstanceId] = new Vd(g.bucketInstanceId, v, g.sourceLayerIndex, g.index, l.tileID); const te = { bucket: g, layout: E, translationText: X, translationIcon: Q, unwrappedTileID: z, pitchedLabelPlaneMatrix: Y, scale: A, textPixelRatio: R, holdingForFade: l.holdingForSymbolFade(), collisionBoxArray: T, partiallyEvaluatedTextSize: c.ay(g.textSizeData, this.transform.zoom), collisionGroup: this.collisionGroups.get(g.sourceID) }; if (d) for (const le of g.sortKeyRanges) { const { sortKey: J, symbolInstanceStart: oe, symbolInstanceEnd: ce } = le; t.push({ sortKey: J, symbolInstanceStart: oe, symbolInstanceEnd: ce, parameters: te }) } else t.push({ symbolInstanceStart: 0, symbolInstanceEnd: g.symbolInstances.length, parameters: te }) } attemptAnchorPlacement(t, s, l, d, g, v, T, E, I, A, R, z, O, U, X, Q, Y, te, le, J) { const oe = c.aP[t.textAnchor], ce = [t.textOffset0, t.textOffset1], se = Wl(oe, l, d, ce, g), fe = this.collisionIndex.placeCollisionBox(s, z, E, I, A, T, v, Q, R.predicate, le, se, J); if ((!te || this.collisionIndex.placeCollisionBox(te, z, E, I, A, T, v, Y, R.predicate, le, se, J).placeable) && fe.placeable) { let Oe; if (this.prevPlacement && this.prevPlacement.variableOffsets[O.crossTileID] && this.prevPlacement.placements[O.crossTileID] && this.prevPlacement.placements[O.crossTileID].text && (Oe = this.prevPlacement.variableOffsets[O.crossTileID].anchor), O.crossTileID === 0) throw new Error("symbolInstance.crossTileID can't be 0"); return this.variableOffsets[O.crossTileID] = { textOffset: ce, width: l, height: d, anchor: oe, textBoxScale: g, prevAnchor: Oe }, this.markUsedJustification(U, oe, O, X), U.allowVerticalPlacement && (this.markUsedOrientation(U, X, O), this.placedOrientations[O.crossTileID] = X), { shift: se, placedGlyphBoxes: fe } } } placeLayerBucketPart(t, s, l) { const { bucket: d, layout: g, translationText: v, translationIcon: T, unwrappedTileID: E, pitchedLabelPlaneMatrix: I, textPixelRatio: A, holdingForFade: R, collisionBoxArray: z, partiallyEvaluatedTextSize: O, collisionGroup: U } = t.parameters, X = g.get("text-optional"), Q = g.get("icon-optional"), Y = c.aQ(g, "text-overlap", "text-allow-overlap"), te = Y === "always", le = c.aQ(g, "icon-overlap", "icon-allow-overlap"), J = le === "always", oe = g.get("text-rotation-alignment") === "map", ce = g.get("text-pitch-alignment") === "map", se = g.get("icon-text-fit") !== "none", fe = g.get("symbol-z-order") === "viewport-y", Oe = te && (J || !d.hasIconData() || Q), ke = J && (te || !d.hasTextData() || X); !d.collisionArrays && z && d.deserializeCollisionBoxes(z); const ze = this.retainedQueryData[d.bucketInstanceId].tileID, Re = this._getTerrainElevationFunc(ze), Je = this.transform.getFastPathSimpleProjectionMatrix(ze), tt = (We, it, It) => { var Kt, fr; if (s[We.crossTileID]) return; if (R) return void (this.placements[We.crossTileID] = new jd(!1, !1, !1)); let ar = !1, yr = !1, lr = !0, Ar = null, vr = { box: null, placeable: !1, offscreen: null, occluded: !1 }, sn = { placeable: !1 }, Vr = null, Or = null, mn = null, Cs = 0, ns = 0, Ui = 0; it.textFeatureIndex ? Cs = it.textFeatureIndex : We.useRuntimeCollisionCircles && (Cs = We.featureIndex), it.verticalTextFeatureIndex && (ns = it.verticalTextFeatureIndex); const Gn = it.textBox; if (Gn) { const hi = cr => { let ur = c.az.horizontal; if (d.allowVerticalPlacement && !cr && this.prevPlacement) { const Jr = this.prevPlacement.placedOrientations[We.crossTileID]; Jr && (this.placedOrientations[We.crossTileID] = Jr, ur = Jr, this.markUsedOrientation(d, ur, We)) } return ur }, Gi = (cr, ur) => { if (d.allowVerticalPlacement && We.numVerticalGlyphVertices > 0 && it.verticalTextBox) { for (const Jr of d.writingModes) if (Jr === c.az.vertical ? (vr = ur(), sn = vr) : vr = cr(), vr && vr.placeable) break } else vr = cr() }, Mi = We.textAnchorOffsetStartIndex, Ii = We.textAnchorOffsetEndIndex; if (Ii === Mi) { const cr = (ur, Jr) => { const en = this.collisionIndex.placeCollisionBox(ur, Y, A, ze, E, ce, oe, v, U.predicate, Re, void 0, Je); return en && en.placeable && (this.markUsedOrientation(d, Jr, We), this.placedOrientations[We.crossTileID] = Jr), en }; Gi(() => cr(Gn, c.az.horizontal), () => { const ur = it.verticalTextBox; return d.allowVerticalPlacement && We.numVerticalGlyphVertices > 0 && ur ? cr(ur, c.az.vertical) : { box: null, offscreen: null } }), hi(vr && vr.placeable) } else { let cr = c.aP[(fr = (Kt = this.prevPlacement) === null || Kt === void 0 ? void 0 : Kt.variableOffsets[We.crossTileID]) === null || fr === void 0 ? void 0 : fr.anchor]; const ur = (en, Bp, Op) => { const lo = en.x2 - en.x1, ag = en.y2 - en.y1, Np = We.textBoxScale, xh = se && le === "never" ? Bp : null; let As = null, ks = Y === "never" ? 1 : 2, Ds = "never"; cr && ks++; for (let wh = 0; wh < ks; wh++) { for (let bh = Mi; bh < Ii; bh++) { const Au = d.textAnchorOffsets.get(bh); if (cr && Au.textAnchor !== cr) continue; const ku = this.attemptAnchorPlacement(Au, en, lo, ag, Np, oe, ce, A, ze, E, U, Ds, We, d, Op, v, T, xh, Re); if (ku && (As = ku.placedGlyphBoxes, As && As.placeable)) return ar = !0, Ar = ku.shift, As } cr ? cr = null : Ds = Y } return l && !As && (As = { box: this.collisionIndex.placeCollisionBox(Gn, "always", A, ze, E, ce, oe, v, U.predicate, Re, void 0, Je).box, offscreen: !1, placeable: !1, occluded: !1 }), As }; Gi(() => ur(Gn, it.iconBox, c.az.horizontal), () => { const en = it.verticalTextBox; return d.allowVerticalPlacement && (!vr || !vr.placeable) && We.numVerticalGlyphVertices > 0 && en ? ur(en, it.verticalIconBox, c.az.vertical) : { box: null, occluded: !0, offscreen: null } }), vr && (ar = vr.placeable, lr = vr.offscreen); const Jr = hi(vr && vr.placeable); if (!ar && this.prevPlacement) { const en = this.prevPlacement.variableOffsets[We.crossTileID]; en && (this.variableOffsets[We.crossTileID] = en, this.markUsedJustification(d, en.anchor, We, Jr)) } } } if (Vr = vr, ar = Vr && Vr.placeable, lr = Vr && Vr.offscreen, We.useRuntimeCollisionCircles && We.centerJustifiedTextSymbolIndex >= 0) { const hi = d.text.placedSymbolArray.get(We.centerJustifiedTextSymbolIndex), Gi = c.aA(d.textSizeData, O, hi), Mi = g.get("text-padding"); Or = this.collisionIndex.placeCollisionCircles(Y, hi, d.lineVertexArray, d.glyphOffsetArray, Gi, E, I, l, ce, U.predicate, We.collisionCircleDiameter, Mi, v, Re), Or.circles.length && Or.collisionDetected && !l && c.w("Collisions detected, but collision boxes are not shown"), ar = te || Or.circles.length > 0 && !Or.collisionDetected, lr = lr && Or.offscreen } if (it.iconFeatureIndex && (Ui = it.iconFeatureIndex), it.iconBox) { const hi = Gi => this.collisionIndex.placeCollisionBox(Gi, le, A, ze, E, ce, oe, T, U.predicate, Re, se && Ar ? Ar : void 0, Je); sn && sn.placeable && it.verticalIconBox ? (mn = hi(it.verticalIconBox), yr = mn.placeable) : (mn = hi(it.iconBox), yr = mn.placeable), lr = lr && mn.offscreen } const oo = X || We.numHorizontalGlyphVertices === 0 && We.numVerticalGlyphVertices === 0, ml = Q || We.numIconVertices === 0; oo || ml ? ml ? oo || (yr = yr && ar) : ar = yr && ar : yr = ar = yr && ar; const ao = yr && mn.placeable; if (ar && Vr.placeable && this.collisionIndex.insertCollisionBox(Vr.box, Y, g.get("text-ignore-placement"), d.bucketInstanceId, sn && sn.placeable && ns ? ns : Cs, U.ID), ao && this.collisionIndex.insertCollisionBox(mn.box, le, g.get("icon-ignore-placement"), d.bucketInstanceId, Ui, U.ID), Or && ar && this.collisionIndex.insertCollisionCircles(Or.circles, Y, g.get("text-ignore-placement"), d.bucketInstanceId, Cs, U.ID), l && this.storeCollisionData(d.bucketInstanceId, It, it, Vr, mn, Or), We.crossTileID === 0) throw new Error("symbolInstance.crossTileID can't be 0"); if (d.bucketInstanceId === 0) throw new Error("bucket.bucketInstanceId can't be 0"); this.placements[We.crossTileID] = new jd((ar || Oe) && !(Vr != null && Vr.occluded), (yr || ke) && !(mn != null && mn.occluded), lr || d.justReloaded), s[We.crossTileID] = !0 }; if (fe) { if (t.symbolInstanceStart !== 0) throw new Error("bucket.bucketInstanceId should be 0"); const We = d.getSortedSymbolIndexes(-this.transform.bearingInRadians); for (let it = We.length - 1; it >= 0; --it) { const It = We[it]; tt(d.symbolInstances.get(It), d.collisionArrays[It], It) } } else for (let We = t.symbolInstanceStart; We < t.symbolInstanceEnd; We++)tt(d.symbolInstances.get(We), d.collisionArrays[We], We); d.justReloaded = !1 } storeCollisionData(t, s, l, d, g, v) { if (l.textBox || l.iconBox) { let T, E; this.collisionBoxArrays.has(t) ? T = this.collisionBoxArrays.get(t) : (T = new Map, this.collisionBoxArrays.set(t, T)), T.has(s) ? E = T.get(s) : (E = { text: null, icon: null }, T.set(s, E)), l.textBox && (E.text = d.box), l.iconBox && (E.icon = g.box) } if (v) { let T = this.collisionCircleArrays[t]; T === void 0 && (T = this.collisionCircleArrays[t] = []); for (let E = 0; E < v.circles.length; E += 4)T.push(v.circles[E + 0] - Ir), T.push(v.circles[E + 1] - Ir), T.push(v.circles[E + 2]), T.push(v.collisionDetected ? 1 : 0) } } markUsedJustification(t, s, l, d) { let g; g = d === c.az.vertical ? l.verticalPlacedTextSymbolIndex : { left: l.leftJustifiedTextSymbolIndex, center: l.centerJustifiedTextSymbolIndex, right: l.rightJustifiedTextSymbolIndex }[c.aR(s)]; const v = [l.leftJustifiedTextSymbolIndex, l.centerJustifiedTextSymbolIndex, l.rightJustifiedTextSymbolIndex, l.verticalPlacedTextSymbolIndex]; for (const T of v) T >= 0 && (t.text.placedSymbolArray.get(T).crossTileID = g >= 0 && T !== g ? 0 : l.crossTileID) } markUsedOrientation(t, s, l) { const d = s === c.az.horizontal || s === c.az.horizontalOnly ? s : 0, g = s === c.az.vertical ? s : 0, v = [l.leftJustifiedTextSymbolIndex, l.centerJustifiedTextSymbolIndex, l.rightJustifiedTextSymbolIndex]; for (const T of v) t.text.placedSymbolArray.get(T).placedOrientation = d; l.verticalPlacedTextSymbolIndex && (t.text.placedSymbolArray.get(l.verticalPlacedTextSymbolIndex).placedOrientation = g) } commit(t) { this.commitTime = t, this.zoomAtLastRecencyCheck = this.transform.zoom; const s = this.prevPlacement; let l = !1; this.prevZoomAdjustment = s ? s.zoomAdjustment(this.transform.zoom) : 0; const d = s ? s.symbolFadeChange(t) : 1, g = s ? s.opacities : {}, v = s ? s.variableOffsets : {}, T = s ? s.placedOrientations : {}; for (const E in this.placements) { const I = this.placements[E], A = g[E]; A ? (this.opacities[E] = new La(A, d, I.text, I.icon), l = l || I.text !== A.text.placed || I.icon !== A.icon.placed) : (this.opacities[E] = new La(null, d, I.text, I.icon, I.skipFade), l = l || I.text || I.icon) } for (const E in g) { const I = g[E]; if (!this.opacities[E]) { const A = new La(I, d, !1, !1); A.isHidden() || (this.opacities[E] = A, l = l || I.text.placed || I.icon.placed) } } for (const E in v) this.variableOffsets[E] || !this.opacities[E] || this.opacities[E].isHidden() || (this.variableOffsets[E] = v[E]); for (const E in T) this.placedOrientations[E] || !this.opacities[E] || this.opacities[E].isHidden() || (this.placedOrientations[E] = T[E]); if (s && s.lastPlacementChangeTime === void 0) throw new Error("Last placement time for previous placement is not defined"); l ? this.lastPlacementChangeTime = t : typeof this.lastPlacementChangeTime != "number" && (this.lastPlacementChangeTime = s ? s.lastPlacementChangeTime : t) } updateLayerOpacities(t, s) { const l = {}; for (const d of s) { const g = d.getBucket(t); g && d.latestFeatureIndex && t.id === g.layerIds[0] && this.updateBucketOpacities(g, d.tileID, l, d.collisionBoxArray) } } updateBucketOpacities(t, s, l, d) { t.hasTextData() && (t.text.opacityVertexArray.clear(), t.text.hasVisibleVertices = !1), t.hasIconData() && (t.icon.opacityVertexArray.clear(), t.icon.hasVisibleVertices = !1), t.hasIconCollisionBoxData() && t.iconCollisionBox.collisionVertexArray.clear(), t.hasTextCollisionBoxData() && t.textCollisionBox.collisionVertexArray.clear(); const g = t.layers[0], v = g.layout, T = new La(null, 0, !1, !1, !0), E = v.get("text-allow-overlap"), I = v.get("icon-allow-overlap"), A = g._unevaluatedLayout.hasValue("text-variable-anchor") || g._unevaluatedLayout.hasValue("text-variable-anchor-offset"), R = v.get("text-rotation-alignment") === "map", z = v.get("text-pitch-alignment") === "map", O = v.get("icon-text-fit") !== "none", U = new La(null, 0, E && (I || !t.hasIconData() || v.get("icon-optional")), I && (E || !t.hasTextData() || v.get("text-optional")), !0); !t.collisionArrays && d && (t.hasIconCollisionBoxData() || t.hasTextCollisionBoxData()) && t.deserializeCollisionBoxes(d); const X = (Y, te, le) => { for (let J = 0; J < te / 4; J++)Y.opacityVertexArray.emplaceBack(le); Y.hasVisibleVertices = Y.hasVisibleVertices || le !== Ba }, Q = this.collisionBoxArrays.get(t.bucketInstanceId); for (let Y = 0; Y < t.symbolInstances.length; Y++) { const te = t.symbolInstances.get(Y), { numHorizontalGlyphVertices: le, numVerticalGlyphVertices: J, crossTileID: oe } = te; let ce = this.opacities[oe]; l[oe] ? ce = T : ce || (ce = U, this.opacities[oe] = ce), l[oe] = !0; const se = te.numIconVertices > 0, fe = this.placedOrientations[te.crossTileID], Oe = fe === c.az.vertical, ke = fe === c.az.horizontal || fe === c.az.horizontalOnly; if (le > 0 || J > 0) { const Re = Ac(ce.text); X(t.text, le, Oe ? Ba : Re), X(t.text, J, ke ? Ba : Re); const Je = ce.text.isHidden();[te.rightJustifiedTextSymbolIndex, te.centerJustifiedTextSymbolIndex, te.leftJustifiedTextSymbolIndex].forEach(it => { it >= 0 && (t.text.placedSymbolArray.get(it).hidden = Je || Oe ? 1 : 0) }), te.verticalPlacedTextSymbolIndex >= 0 && (t.text.placedSymbolArray.get(te.verticalPlacedTextSymbolIndex).hidden = Je || ke ? 1 : 0); const tt = this.variableOffsets[te.crossTileID]; tt && this.markUsedJustification(t, tt.anchor, te, fe); const We = this.placedOrientations[te.crossTileID]; We && (this.markUsedJustification(t, "left", te, We), this.markUsedOrientation(t, We, te)) } if (se) { const Re = Ac(ce.icon), Je = !(O && te.verticalPlacedIconSymbolIndex && Oe); te.placedIconSymbolIndex >= 0 && (X(t.icon, te.numIconVertices, Je ? Re : Ba), t.icon.placedSymbolArray.get(te.placedIconSymbolIndex).hidden = ce.icon.isHidden()), te.verticalPlacedIconSymbolIndex >= 0 && (X(t.icon, te.numVerticalIconVertices, Je ? Ba : Re), t.icon.placedSymbolArray.get(te.verticalPlacedIconSymbolIndex).hidden = ce.icon.isHidden()) } const ze = Q && Q.has(Y) ? Q.get(Y) : { text: null, icon: null }; if (t.hasIconCollisionBoxData() || t.hasTextCollisionBoxData()) { const Re = t.collisionArrays[Y]; if (Re) { let Je = new c.P(0, 0); if (Re.textBox || Re.verticalTextBox) { let tt = !0; if (A) { const We = this.variableOffsets[oe]; We ? (Je = Wl(We.anchor, We.width, We.height, We.textOffset, We.textBoxScale), R && Je._rotate(z ? -this.transform.bearingInRadians : this.transform.bearingInRadians)) : tt = !1 } if (Re.textBox || Re.verticalTextBox) { let We; Re.textBox && (We = Oe), Re.verticalTextBox && (We = ke), Mc(t.textCollisionBox.collisionVertexArray, ce.text.placed, !tt || We, ze.text, Je.x, Je.y) } } if (Re.iconBox || Re.verticalIconBox) { const tt = !!(!ke && Re.verticalIconBox); let We; Re.iconBox && (We = tt), Re.verticalIconBox && (We = !tt), Mc(t.iconCollisionBox.collisionVertexArray, ce.icon.placed, We, ze.icon, O ? Je.x : 0, O ? Je.y : 0) } } } } if (t.sortFeatures(-this.transform.bearingInRadians), this.retainedQueryData[t.bucketInstanceId] && (this.retainedQueryData[t.bucketInstanceId].featureSortOrder = t.featureSortOrder), t.hasTextData() && t.text.opacityVertexBuffer && t.text.opacityVertexBuffer.updateData(t.text.opacityVertexArray), t.hasIconData() && t.icon.opacityVertexBuffer && t.icon.opacityVertexBuffer.updateData(t.icon.opacityVertexArray), t.hasIconCollisionBoxData() && t.iconCollisionBox.collisionVertexBuffer && t.iconCollisionBox.collisionVertexBuffer.updateData(t.iconCollisionBox.collisionVertexArray), t.hasTextCollisionBoxData() && t.textCollisionBox.collisionVertexBuffer && t.textCollisionBox.collisionVertexBuffer.updateData(t.textCollisionBox.collisionVertexArray), t.text.opacityVertexArray.length !== t.text.layoutVertexArray.length / 4) throw new Error(`bucket.text.opacityVertexArray.length (= ${t.text.opacityVertexArray.length}) !== bucket.text.layoutVertexArray.length (= ${t.text.layoutVertexArray.length}) / 4`); if (t.icon.opacityVertexArray.length !== t.icon.layoutVertexArray.length / 4) throw new Error(`bucket.icon.opacityVertexArray.length (= ${t.icon.opacityVertexArray.length}) !== bucket.icon.layoutVertexArray.length (= ${t.icon.layoutVertexArray.length}) / 4`); t.bucketInstanceId in this.collisionCircleArrays && (t.collisionCircleArray = this.collisionCircleArrays[t.bucketInstanceId], delete this.collisionCircleArrays[t.bucketInstanceId]) } symbolFadeChange(t) { return this.fadeDuration === 0 ? 1 : (t - this.commitTime) / this.fadeDuration + this.prevZoomAdjustment } zoomAdjustment(t) { return Math.max(0, (this.transform.zoom - t) / 1.5) } hasTransitions(t) { return this.stale || t - this.lastPlacementChangeTime < this.fadeDuration } stillRecent(t, s) { const l = this.zoomAtLastRecencyCheck === s ? 1 - this.zoomAdjustment(s) : 1; return this.zoomAtLastRecencyCheck = s, this.commitTime + this.fadeDuration * l > t } setStale() { this.stale = !0 } } function Mc(m, t, s, l, d, g) { l && l.length !== 0 || (l = [0, 0, 0, 0]); const v = l[0] - Ir, T = l[1] - Ir, E = l[2] - Ir, I = l[3] - Ir; m.emplaceBack(t ? 1 : 0, s ? 1 : 0, d || 0, g || 0, v, T), m.emplaceBack(t ? 1 : 0, s ? 1 : 0, d || 0, g || 0, E, T), m.emplaceBack(t ? 1 : 0, s ? 1 : 0, d || 0, g || 0, E, I), m.emplaceBack(t ? 1 : 0, s ? 1 : 0, d || 0, g || 0, v, I) } const Ic = Math.pow(2, 25), Cc = Math.pow(2, 24), Fm = Math.pow(2, 17), Fa = Math.pow(2, 16), Hl = Math.pow(2, 9), Gd = Math.pow(2, 8), Do = Math.pow(2, 1); function Ac(m) { if (m.opacity === 0 && !m.placed) return 0; if (m.opacity === 1 && m.placed) return 4294967295; const t = m.placed ? 1 : 0, s = Math.floor(127 * m.opacity); return s * Ic + t * Cc + s * Fm + t * Fa + s * Hl + t * Gd + s * Do + t } const Ba = 0; class xs { constructor(t) { this._sortAcrossTiles = t.layout.get("symbol-z-order") !== "viewport-y" && !t.layout.get("symbol-sort-key").isConstant(), this._currentTileIndex = 0, this._currentPartIndex = 0, this._seenCrossTileIDs = {}, this._bucketParts = [] } continuePlacement(t, s, l, d, g) { const v = this._bucketParts; for (; this._currentTileIndex < t.length;)if (s.getBucketParts(v, d, t[this._currentTileIndex], this._sortAcrossTiles), this._currentTileIndex++, g()) return !0; for (this._sortAcrossTiles && (this._sortAcrossTiles = !1, v.sort((T, E) => T.sortKey - E.sortKey)); this._currentPartIndex < v.length;)if (s.placeLayerBucketPart(v[this._currentPartIndex], this._seenCrossTileIDs, l), this._currentPartIndex++, g()) return !0; return !1 } } class zo { constructor(t, s, l, d, g, v, T, E) { this.placement = new Pc(t, s, v, T, E), this._currentPlacementIndex = l.length - 1, this._forceFullPlacement = d, this._showCollisionBoxes = g, this._done = !1 } isDone() { return this._done } continuePlacement(t, s, l) { const d = $e(), g = () => !this._forceFullPlacement && $e() - d > 2; for (; this._currentPlacementIndex >= 0;) { const v = s[t[this._currentPlacementIndex]], T = this.placement.collisionIndex.transform.zoom; if (v.type === "symbol" && (!v.minzoom || v.minzoom <= T) && (!v.maxzoom || v.maxzoom > T)) { if (this._inProgressLayer || (this._inProgressLayer = new xs(v)), this._inProgressLayer.continuePlacement(l[v.source], this.placement, this._showCollisionBoxes, v, g)) return; delete this._inProgressLayer } this._currentPlacementIndex-- } this._done = !0 } commit(t) { return this.placement.commit(t), this.placement } } const Rt = 512 / c.a5 / 2; class kc { constructor(t, s, l) { this.tileID = t, this.bucketInstanceId = l, this._symbolsByKey = {}; const d = new Map; for (let g = 0; g < s.length; g++) { const v = s.get(g), T = v.key, E = d.get(T); E ? E.push(v) : d.set(T, [v]) } for (const [g, v] of d) { const T = { positions: v.map(E => ({ x: Math.floor(E.anchorX * Rt), y: Math.floor(E.anchorY * Rt) })), crossTileIDs: v.map(E => E.crossTileID) }; if (T.positions.length > 128) { const E = new c.aT(T.positions.length, 16, Uint16Array); for (const { x: I, y: A } of T.positions) E.add(I, A); E.finish(), delete T.positions, T.index = E } this._symbolsByKey[g] = T } } getScaledCoordinates(t, s) { const { x: l, y: d, z: g } = this.tileID.canonical, { x: v, y: T, z: E } = s.canonical, I = Rt / Math.pow(2, E - g), A = (T * c.a5 + t.anchorY) * I, R = d * c.a5 * Rt; return { x: Math.floor((v * c.a5 + t.anchorX) * I - l * c.a5 * Rt), y: Math.floor(A - R) } } findMatches(t, s, l) { const d = this.tileID.canonical.z < s.canonical.z ? 1 : Math.pow(2, this.tileID.canonical.z - s.canonical.z); for (let g = 0; g < t.length; g++) { const v = t.get(g); if (v.crossTileID) continue; const T = this._symbolsByKey[v.key]; if (!T) continue; const E = this.getScaledCoordinates(v, s); if (T.index) { const I = T.index.range(E.x - d, E.y - d, E.x + d, E.y + d).sort(); for (const A of I) { const R = T.crossTileIDs[A]; if (!l[R]) { l[R] = !0, v.crossTileID = R; break } } } else if (T.positions) for (let I = 0; I < T.positions.length; I++) { const A = T.positions[I], R = T.crossTileIDs[I]; if (Math.abs(A.x - E.x) <= d && Math.abs(A.y - E.y) <= d && !l[R]) { l[R] = !0, v.crossTileID = R; break } } } } getCrossTileIDsLists() { return Object.values(this._symbolsByKey).map(({ crossTileIDs: t }) => t) } } class Bm { constructor() { this.maxCrossTileID = 0 } generate() { return ++this.maxCrossTileID } } class Dc { constructor() { this.indexes = {}, this.usedCrossTileIDs = {}, this.lng = 0 } handleWrapJump(t) { const s = Math.round((t - this.lng) / 360); if (s !== 0) for (const l in this.indexes) { const d = this.indexes[l], g = {}; for (const v in d) { const T = d[v]; T.tileID = T.tileID.unwrapTo(T.tileID.wrap + s), g[T.tileID.key] = T } this.indexes[l] = g } this.lng = t } addBucket(t, s, l) { if (this.indexes[t.overscaledZ] && this.indexes[t.overscaledZ][t.key]) { if (this.indexes[t.overscaledZ][t.key].bucketInstanceId === s.bucketInstanceId) return !1; this.removeBucketCrossTileIDs(t.overscaledZ, this.indexes[t.overscaledZ][t.key]) } for (let g = 0; g < s.symbolInstances.length; g++)s.symbolInstances.get(g).crossTileID = 0; this.usedCrossTileIDs[t.overscaledZ] || (this.usedCrossTileIDs[t.overscaledZ] = {}); const d = this.usedCrossTileIDs[t.overscaledZ]; for (const g in this.indexes) { const v = this.indexes[g]; if (Number(g) > t.overscaledZ) for (const T in v) { const E = v[T]; E.tileID.isChildOf(t) && E.findMatches(s.symbolInstances, t, d) } else { const T = v[t.scaledTo(Number(g)).key]; T && T.findMatches(s.symbolInstances, t, d) } } for (let g = 0; g < s.symbolInstances.length; g++) { const v = s.symbolInstances.get(g); v.crossTileID || (v.crossTileID = l.generate(), d[v.crossTileID] = !0) } return this.indexes[t.overscaledZ] === void 0 && (this.indexes[t.overscaledZ] = {}), this.indexes[t.overscaledZ][t.key] = new kc(t, s.symbolInstances, s.bucketInstanceId), !0 } removeBucketCrossTileIDs(t, s) { for (const l of s.getCrossTileIDsLists()) for (const d of l) delete this.usedCrossTileIDs[t][d] } removeStaleBuckets(t) { let s = !1; for (const l in this.indexes) { const d = this.indexes[l]; for (const g in d) t[d[g].bucketInstanceId] || (this.removeBucketCrossTileIDs(l, d[g]), delete d[g], s = !0) } return s } } class Vn { constructor() { this.layerIndexes = {}, this.crossTileIDs = new Bm, this.maxBucketInstanceId = 0, this.bucketsInCurrentPlacement = {} } addLayer(t, s, l) { let d = this.layerIndexes[t.id]; d === void 0 && (d = this.layerIndexes[t.id] = new Dc); let g = !1; const v = {}; d.handleWrapJump(l); for (const T of s) { const E = T.getBucket(t); E && t.id === E.layerIds[0] && (E.bucketInstanceId || (E.bucketInstanceId = ++this.maxBucketInstanceId), d.addBucket(T.tileID, E, this.crossTileIDs) && (g = !0), v[E.bucketInstanceId] = !0) } return d.removeStaleBuckets(v) && (g = !0), g } pruneUnusedLayers(t) { const s = {}; t.forEach(l => { s[l] = !0 }); for (const l in this.layerIndexes) s[l] || delete this.layerIndexes[l] } } var xn = "void main() {fragColor=vec4(1.0);}"; const br = {
                prelude: Et(`#ifdef GL_ES
precision mediump float;
#else
#if !defined(lowp)
#define lowp
#endif
#if !defined(mediump)
#define mediump
#endif
#if !defined(highp)
#define highp
#endif
#endif
out highp vec4 fragColor;`, `#ifdef GL_ES
precision highp float;
#else
#if !defined(lowp)
#define lowp
#endif
#if !defined(mediump)
#define mediump
#endif
#if !defined(highp)
#define highp
#endif
#endif
vec2 unpack_float(const float packedValue) {int packedIntValue=int(packedValue);int v0=packedIntValue/256;return vec2(v0,packedIntValue-v0*256);}vec2 unpack_opacity(const float packedOpacity) {int intOpacity=int(packedOpacity)/2;return vec2(float(intOpacity)/127.0,mod(packedOpacity,2.0));}vec4 decode_color(const vec2 encodedColor) {return vec4(unpack_float(encodedColor[0])/255.0,unpack_float(encodedColor[1])/255.0
);}float unpack_mix_vec2(const vec2 packedValue,const float t) {return mix(packedValue[0],packedValue[1],t);}vec4 unpack_mix_color(const vec4 packedColors,const float t) {vec4 minColor=decode_color(vec2(packedColors[0],packedColors[1]));vec4 maxColor=decode_color(vec2(packedColors[2],packedColors[3]));return mix(minColor,maxColor,t);}vec2 get_pattern_pos(const vec2 pixel_coord_upper,const vec2 pixel_coord_lower,const vec2 pattern_size,const float tile_units_to_pixels,const vec2 pos) {vec2 offset=mod(mod(mod(pixel_coord_upper,pattern_size)*256.0,pattern_size)*256.0+pixel_coord_lower,pattern_size);return (tile_units_to_pixels*pos+offset)/pattern_size;}mat3 rotationMatrixFromAxisAngle(vec3 u,float angle) {float c=cos(angle);float s=sin(angle);float c2=1.0-c;return mat3(u.x*u.x*c2+      c,u.x*u.y*c2-u.z*s,u.x*u.z*c2+u.y*s,u.y*u.x*c2+u.z*s,u.y*u.y*c2+    c,u.y*u.z*c2-u.x*s,u.z*u.x*c2-u.y*s,u.z*u.y*c2+u.x*s,u.z*u.z*c2+    c
);}
#ifdef TERRAIN3D
uniform sampler2D u_terrain;uniform float u_terrain_dim;uniform mat4 u_terrain_matrix;uniform vec4 u_terrain_unpack;uniform float u_terrain_exaggeration;uniform highp sampler2D u_depth;
#endif
const highp vec4 bitSh=vec4(256.*256.*256.,256.*256.,256.,1.);const highp vec4 bitShifts=vec4(1.)/bitSh;highp float unpack(highp vec4 color) {return dot(color,bitShifts);}highp float depthOpacity(vec3 frag) {
#ifdef TERRAIN3D
highp float d=unpack(texture(u_depth,frag.xy*0.5+0.5))+0.0001-frag.z;return 1.0-max(0.0,min(1.0,-d*500.0));
#else
return 1.0;
#endif
}float calculate_visibility(vec4 pos) {
#ifdef TERRAIN3D
vec3 frag=pos.xyz/pos.w;highp float d=depthOpacity(frag);if (d > 0.95) return 1.0;return (d+depthOpacity(frag+vec3(0.0,0.01,0.0)))/2.0;
#else
return 1.0;
#endif
}float ele(vec2 pos) {
#ifdef TERRAIN3D
vec4 rgb=(texture(u_terrain,pos)*255.0)*u_terrain_unpack;return rgb.r+rgb.g+rgb.b-u_terrain_unpack.a;
#else
return 0.0;
#endif
}float get_elevation(vec2 pos) {
#ifdef TERRAIN3D
#ifdef GLOBE
if ((pos.y <-32767.5) || (pos.y > 32766.5)) {return 0.0;}
#endif
vec2 coord=(u_terrain_matrix*vec4(pos,0.0,1.0)).xy*u_terrain_dim+1.0;vec2 f=fract(coord);vec2 c=(floor(coord)+0.5)/(u_terrain_dim+2.0);float d=1.0/(u_terrain_dim+2.0);float tl=ele(c);float tr=ele(c+vec2(d,0.0));float bl=ele(c+vec2(0.0,d));float br=ele(c+vec2(d,d));float elevation=mix(mix(tl,tr,f.x),mix(bl,br,f.x),f.y);return elevation*u_terrain_exaggeration;
#else
return 0.0;
#endif
}const float PI=3.141592653589793;uniform mat4 u_projection_matrix;`), projectionMercator: Et("", "float projectLineThickness(float tileY) {return 1.0;}float projectCircleRadius(float tileY) {return 1.0;}vec4 projectTile(vec2 p) {vec4 result=u_projection_matrix*vec4(p,0.0,1.0);return result;}vec4 projectTile(vec2 p,vec2 rawPos) {vec4 result=u_projection_matrix*vec4(p,0.0,1.0);if (rawPos.y <-32767.5 || rawPos.y > 32766.5) {result.z=-10000000.0;}return result;}vec4 projectTileWithElevation(vec2 posInTile,float elevation) {return u_projection_matrix*vec4(posInTile,elevation,1.0);}vec4 projectTileFor3D(vec2 posInTile,float elevation) {return projectTileWithElevation(posInTile,elevation);}"), projectionGlobe: Et("", `#define GLOBE_RADIUS 6371008.8
uniform highp vec4 u_projection_tile_mercator_coords;uniform highp vec4 u_projection_clipping_plane;uniform highp float u_projection_transition;uniform mat4 u_projection_fallback_matrix;vec3 globeRotateVector(vec3 vec,vec2 angles) {vec3 axisRight=vec3(vec.z,0.0,-vec.x);vec3 axisUp=cross(axisRight,vec);axisRight=normalize(axisRight);axisUp=normalize(axisUp);vec2 t=tan(angles);return normalize(vec+axisRight*t.x+axisUp*t.y);}mat3 globeGetRotationMatrix(vec3 spherePos) {vec3 axisRight=vec3(spherePos.z,0.0,-spherePos.x);vec3 axisDown=cross(axisRight,spherePos);axisRight=normalize(axisRight);axisDown=normalize(axisDown);return mat3(axisRight,axisDown,spherePos
);}float circumferenceRatioAtTileY(float tileY) {float mercator_pos_y=u_projection_tile_mercator_coords.y+u_projection_tile_mercator_coords.w*tileY;float spherical_y=2.0*atan(exp(PI-(mercator_pos_y*PI*2.0)))-PI*0.5;return cos(spherical_y);}float projectLineThickness(float tileY) {float thickness=1.0/circumferenceRatioAtTileY(tileY); 
if (u_projection_transition < 0.999) {return mix(1.0,thickness,u_projection_transition);} else {return thickness;}}vec3 projectToSphere(vec2 translatedPos,vec2 rawPos) {vec2 mercator_pos=u_projection_tile_mercator_coords.xy+u_projection_tile_mercator_coords.zw*translatedPos;vec2 spherical;spherical.x=mercator_pos.x*PI*2.0+PI;spherical.y=2.0*atan(exp(PI-(mercator_pos.y*PI*2.0)))-PI*0.5;float len=cos(spherical.y);vec3 pos=vec3(sin(spherical.x)*len,sin(spherical.y),cos(spherical.x)*len
);if (rawPos.y <-32767.5) {pos=vec3(0.0,1.0,0.0);}if (rawPos.y > 32766.5) {pos=vec3(0.0,-1.0,0.0);}return pos;}vec3 projectToSphere(vec2 posInTile) {return projectToSphere(posInTile,vec2(0.0,0.0));}float globeComputeClippingZ(vec3 spherePos) {return (1.0-(dot(spherePos,u_projection_clipping_plane.xyz)+u_projection_clipping_plane.w));}vec4 interpolateProjection(vec2 posInTile,vec3 spherePos,float elevation) {vec3 elevatedPos=spherePos*(1.0+elevation/GLOBE_RADIUS);vec4 globePosition=u_projection_matrix*vec4(elevatedPos,1.0);globePosition.z=globeComputeClippingZ(elevatedPos)*globePosition.w;if (u_projection_transition > 0.999) {return globePosition;}vec4 flatPosition=u_projection_fallback_matrix*vec4(posInTile,elevation,1.0);const float z_globeness_threshold=0.2;vec4 result=globePosition;result.z=mix(0.0,globePosition.z,clamp((u_projection_transition-z_globeness_threshold)/(1.0-z_globeness_threshold),0.0,1.0));result.xyw=mix(flatPosition.xyw,globePosition.xyw,u_projection_transition);if ((posInTile.y <-32767.5) || (posInTile.y > 32766.5)) {result=globePosition;const float poles_hidden_anim_percentage=0.02;result.z=mix(globePosition.z,100.0,pow(max((1.0-u_projection_transition)/poles_hidden_anim_percentage,0.0),8.0));}return result;}vec4 interpolateProjectionFor3D(vec2 posInTile,vec3 spherePos,float elevation) {vec3 elevatedPos=spherePos*(1.0+elevation/GLOBE_RADIUS);vec4 globePosition=u_projection_matrix*vec4(elevatedPos,1.0);if (u_projection_transition > 0.999) {return globePosition;}vec4 fallbackPosition=u_projection_fallback_matrix*vec4(posInTile,elevation,1.0);return mix(fallbackPosition,globePosition,u_projection_transition);}vec4 projectTile(vec2 posInTile) {return interpolateProjection(posInTile,projectToSphere(posInTile),0.0);}vec4 projectTile(vec2 posInTile,vec2 rawPos) {return interpolateProjection(posInTile,projectToSphere(posInTile,rawPos),0.0);}vec4 projectTileWithElevation(vec2 posInTile,float elevation) {return interpolateProjection(posInTile,projectToSphere(posInTile),elevation);}vec4 projectTileFor3D(vec2 posInTile,float elevation) {vec3 spherePos=projectToSphere(posInTile,posInTile);return interpolateProjectionFor3D(posInTile,spherePos,elevation);}`), background: Et(`uniform vec4 u_color;uniform float u_opacity;void main() {fragColor=u_color*u_opacity;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, "in vec2 a_pos;void main() {gl_Position=projectTile(a_pos);}"), backgroundPattern: Et(`uniform vec2 u_pattern_tl_a;uniform vec2 u_pattern_br_a;uniform vec2 u_pattern_tl_b;uniform vec2 u_pattern_br_b;uniform vec2 u_texsize;uniform float u_mix;uniform float u_opacity;uniform sampler2D u_image;in vec2 v_pos_a;in vec2 v_pos_b;void main() {vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(u_pattern_tl_a/u_texsize,u_pattern_br_a/u_texsize,imagecoord);vec4 color1=texture(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(u_pattern_tl_b/u_texsize,u_pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture(u_image,pos2);fragColor=mix(color1,color2,u_mix)*u_opacity;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, "uniform vec2 u_pattern_size_a;uniform vec2 u_pattern_size_b;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_scale_a;uniform float u_scale_b;uniform float u_tile_units_to_pixels;in vec2 a_pos;out vec2 v_pos_a;out vec2 v_pos_b;void main() {gl_Position=projectTile(a_pos);v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,u_scale_a*u_pattern_size_a,u_tile_units_to_pixels,a_pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,u_scale_b*u_pattern_size_b,u_tile_units_to_pixels,a_pos);}"), circle: Et(`in vec3 v_data;in float v_visibility;
#pragma mapbox: define highp vec4 color
#pragma mapbox: define mediump float radius
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define highp vec4 stroke_color
#pragma mapbox: define mediump float stroke_width
#pragma mapbox: define lowp float stroke_opacity
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize mediump float radius
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize highp vec4 stroke_color
#pragma mapbox: initialize mediump float stroke_width
#pragma mapbox: initialize lowp float stroke_opacity
vec2 extrude=v_data.xy;float extrude_length=length(extrude);float antialiased_blur=v_data.z;float opacity_t=smoothstep(0.0,antialiased_blur,extrude_length-1.0);float color_t=stroke_width < 0.01 ? 0.0 : smoothstep(antialiased_blur,0.0,extrude_length-radius/(radius+stroke_width));fragColor=v_visibility*opacity_t*mix(color*opacity,stroke_color*stroke_opacity,color_t);const float epsilon=0.5/255.0;if (fragColor.r < epsilon && fragColor.g < epsilon && fragColor.b < epsilon && fragColor.a < epsilon) {discard;}
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `uniform bool u_scale_with_map;uniform bool u_pitch_with_map;uniform vec2 u_extrude_scale;uniform highp float u_globe_extrude_scale;uniform lowp float u_device_pixel_ratio;uniform highp float u_camera_to_center_distance;uniform vec2 u_translate;in vec2 a_pos;out vec3 v_data;out float v_visibility;
#pragma mapbox: define highp vec4 color
#pragma mapbox: define mediump float radius
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define highp vec4 stroke_color
#pragma mapbox: define mediump float stroke_width
#pragma mapbox: define lowp float stroke_opacity
void main(void) {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize mediump float radius
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize highp vec4 stroke_color
#pragma mapbox: initialize mediump float stroke_width
#pragma mapbox: initialize lowp float stroke_opacity
vec2 pos_raw=a_pos+32768.0;vec2 extrude=vec2(mod(pos_raw,8.0)/7.0*2.0-1.0);vec2 circle_center=floor(pos_raw/8.0)+u_translate;float ele=get_elevation(circle_center);v_visibility=calculate_visibility(projectTileWithElevation(circle_center,ele));if (u_pitch_with_map) {
#ifdef GLOBE
vec3 center_vector=projectToSphere(circle_center);
#endif
float angle_scale=u_globe_extrude_scale;vec2 corner_position=circle_center;if (u_scale_with_map) {angle_scale*=(radius+stroke_width);corner_position+=extrude*u_extrude_scale*(radius+stroke_width);} else {
#ifdef GLOBE
vec4 projected_center=interpolateProjection(circle_center,center_vector,ele);
#else
vec4 projected_center=projectTileWithElevation(circle_center,ele);
#endif
corner_position+=extrude*u_extrude_scale*(radius+stroke_width)*(projected_center.w/u_camera_to_center_distance);angle_scale*=(radius+stroke_width)*(projected_center.w/u_camera_to_center_distance);}
#ifdef GLOBE
vec2 angles=extrude*angle_scale;vec3 corner_vector=globeRotateVector(center_vector,angles);gl_Position=interpolateProjection(corner_position,corner_vector,ele);
#else
gl_Position=projectTileWithElevation(corner_position,ele);
#endif
} else {gl_Position=projectTileWithElevation(circle_center,ele);if (gl_Position.z/gl_Position.w > 1.0) {gl_Position.xy=vec2(10000.0);}if (u_scale_with_map) {gl_Position.xy+=extrude*(radius+stroke_width)*u_extrude_scale*u_camera_to_center_distance;} else {gl_Position.xy+=extrude*(radius+stroke_width)*u_extrude_scale*gl_Position.w;}}float antialiasblur=-max(1.0/u_device_pixel_ratio/(radius+stroke_width),blur);v_data=vec3(extrude.x,extrude.y,antialiasblur);}`), clippingMask: Et(xn, "in vec2 a_pos;void main() {gl_Position=projectTile(a_pos);}"), heatmap: Et(`uniform highp float u_intensity;in vec2 v_extrude;
#pragma mapbox: define highp float weight
#define GAUSS_COEF 0.3989422804014327
void main() {
#pragma mapbox: initialize highp float weight
float d=-0.5*3.0*3.0*dot(v_extrude,v_extrude);float val=weight*u_intensity*GAUSS_COEF*exp(d);fragColor=vec4(val,1.0,1.0,1.0);
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `uniform float u_extrude_scale;uniform float u_opacity;uniform float u_intensity;uniform highp float u_globe_extrude_scale;in vec2 a_pos;out vec2 v_extrude;
#pragma mapbox: define highp float weight
#pragma mapbox: define mediump float radius
const highp float ZERO=1.0/255.0/16.0;
#define GAUSS_COEF 0.3989422804014327
void main(void) {
#pragma mapbox: initialize highp float weight
#pragma mapbox: initialize mediump float radius
vec2 pos_raw=a_pos+32768.0;vec2 unscaled_extrude=vec2(mod(pos_raw,8.0)/7.0*2.0-1.0);float S=sqrt(-2.0*log(ZERO/weight/u_intensity/GAUSS_COEF))/3.0;v_extrude=S*unscaled_extrude;vec2 extrude=v_extrude*radius*u_extrude_scale;vec2 circle_center=floor(pos_raw/8.0);
#ifdef GLOBE
vec2 angles=v_extrude*radius*u_globe_extrude_scale;vec3 center_vector=projectToSphere(circle_center);vec3 corner_vector=globeRotateVector(center_vector,angles);gl_Position=interpolateProjection(circle_center+extrude,corner_vector,0.0);
#else
gl_Position=projectTileFor3D(circle_center+extrude,get_elevation(circle_center));
#endif
}`), heatmapTexture: Et(`uniform sampler2D u_image;uniform sampler2D u_color_ramp;uniform float u_opacity;in vec2 v_pos;void main() {float t=texture(u_image,v_pos).r;vec4 color=texture(u_color_ramp,vec2(t,0.5));fragColor=color*u_opacity;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(0.0);
#endif
}`, "uniform mat4 u_matrix;uniform vec2 u_world;in vec2 a_pos;out vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos*u_world,0,1);v_pos.x=a_pos.x;v_pos.y=1.0-a_pos.y;}"), collisionBox: Et("in float v_placed;in float v_notUsed;void main() {float alpha=0.5;fragColor=vec4(1.0,0.0,0.0,1.0)*alpha;if (v_placed > 0.5) {fragColor=vec4(0.0,0.0,1.0,0.5)*alpha;}if (v_notUsed > 0.5) {fragColor*=.1;}}", "in vec2 a_anchor_pos;in vec2 a_placed;in vec2 a_box_real;uniform vec2 u_pixel_extrude_scale;out float v_placed;out float v_notUsed;void main() {gl_Position=projectTileWithElevation(a_anchor_pos,get_elevation(a_anchor_pos));gl_Position.xy=((a_box_real+0.5)*u_pixel_extrude_scale*2.0-1.0)*vec2(1.0,-1.0)*gl_Position.w;if (gl_Position.z/gl_Position.w < 1.1) {gl_Position.z=0.5;}v_placed=a_placed.x;v_notUsed=a_placed.y;}"), collisionCircle: Et("in float v_radius;in vec2 v_extrude;in float v_collision;void main() {float alpha=0.5;float stroke_radius=0.9;float distance_to_center=length(v_extrude);float distance_to_edge=abs(distance_to_center-v_radius);float opacity_t=smoothstep(-stroke_radius,0.0,-distance_to_edge);vec4 color=mix(vec4(0.0,0.0,1.0,0.5),vec4(1.0,0.0,0.0,1.0),v_collision);fragColor=color*alpha*opacity_t;}", "in vec2 a_pos;in float a_radius;in vec2 a_flags;uniform vec2 u_viewport_size;out float v_radius;out vec2 v_extrude;out float v_collision;void main() {float radius=a_radius;float collision=a_flags.x;float vertexIdx=a_flags.y;vec2 quadVertexOffset=vec2(mix(-1.0,1.0,float(vertexIdx >=2.0)),mix(-1.0,1.0,float(vertexIdx >=1.0 && vertexIdx <=2.0)));vec2 quadVertexExtent=quadVertexOffset*radius;float padding_factor=1.2;v_radius=radius;v_extrude=quadVertexExtent*padding_factor;v_collision=collision;gl_Position=vec4((a_pos/u_viewport_size*2.0-1.0)*vec2(1.0,-1.0),0.0,1.0)+vec4(quadVertexExtent*padding_factor/u_viewport_size*2.0,0.0,0.0);}"), colorRelief: Et(`#ifdef GL_ES
precision highp float;
#endif
uniform sampler2D u_image;uniform vec4 u_unpack;uniform sampler2D u_elevation_stops;uniform sampler2D u_color_stops;uniform int u_color_ramp_size;uniform float u_opacity;in vec2 v_pos;float getElevation(vec2 coord) {vec4 data=texture(u_image,coord)*255.0;data.a=-1.0;return dot(data,u_unpack);}float getElevationStop(int stop) {float x=(float(stop)+0.5)/float(u_color_ramp_size);vec4 data=texture(u_elevation_stops,vec2(x,0))*255.0;data.a=-1.0;return dot(data,u_unpack);}void main() {float el=getElevation(v_pos);int r=(u_color_ramp_size-1);int l=0;float el_l=getElevationStop(l);float el_r=getElevationStop(r);while(r-l > 1){int m=(r+l)/2;float el_m=getElevationStop(m);if(el < el_m){r=m;el_r=el_m;}else
{l=m;el_l=el_m;}}float x=(float(l)+(el-el_l)/(el_r-el_l)+0.5)/float(u_color_ramp_size);fragColor=u_opacity*texture(u_color_stops,vec2(x,0));
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, "uniform vec2 u_dimension;in vec2 a_pos;out vec2 v_pos;void main() {gl_Position=projectTile(a_pos,a_pos);highp vec2 epsilon=1.0/u_dimension;float scale=(u_dimension.x-2.0)/u_dimension.x;v_pos=(a_pos/8192.0)*scale+epsilon;if (a_pos.y <-32767.5) {v_pos.y=0.0;}if (a_pos.y > 32766.5) {v_pos.y=1.0;}}"), debug: Et("uniform highp vec4 u_color;uniform sampler2D u_overlay;in vec2 v_uv;void main() {vec4 overlay_color=texture(u_overlay,v_uv);fragColor=mix(u_color,overlay_color,overlay_color.a);}", "in vec2 a_pos;out vec2 v_uv;uniform float u_overlay_scale;void main() {v_uv=a_pos/8192.0;gl_Position=projectTileWithElevation(a_pos*u_overlay_scale,get_elevation(a_pos));}"), depth: Et(xn, `in vec2 a_pos;void main() {
#ifdef GLOBE
gl_Position=projectTileFor3D(a_pos,0.0);
#else
gl_Position=u_projection_matrix*vec4(a_pos,0.0,1.0);
#endif
}`), fill: Et(`#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float opacity
fragColor=color*opacity;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `uniform vec2 u_fill_translate;in vec2 a_pos;
#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float opacity
gl_Position=projectTile(a_pos+u_fill_translate,a_pos);}`), fillOutline: Et(`in vec2 v_pos;
#ifdef GLOBE
in float v_depth;
#endif
#pragma mapbox: define highp vec4 outline_color
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize highp vec4 outline_color
#pragma mapbox: initialize lowp float opacity
float dist=length(v_pos-gl_FragCoord.xy);float alpha=1.0-smoothstep(0.0,1.0,dist);fragColor=outline_color*(alpha*opacity);
#ifdef GLOBE
if (v_depth > 1.0) {discard;}
#endif
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `uniform vec2 u_world;uniform vec2 u_fill_translate;in vec2 a_pos;out vec2 v_pos;
#ifdef GLOBE
out float v_depth;
#endif
#pragma mapbox: define highp vec4 outline_color
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize highp vec4 outline_color
#pragma mapbox: initialize lowp float opacity
gl_Position=projectTile(a_pos+u_fill_translate,a_pos);v_pos=(gl_Position.xy/gl_Position.w+1.0)/2.0*u_world;
#ifdef GLOBE
v_depth=gl_Position.z/gl_Position.w;
#endif
}`), fillOutlinePattern: Et(`uniform vec2 u_texsize;uniform sampler2D u_image;uniform float u_fade;in vec2 v_pos_a;in vec2 v_pos_b;in vec2 v_pos;
#ifdef GLOBE
in float v_depth;
#endif
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
void main() {
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(pattern_tl_a/u_texsize,pattern_br_a/u_texsize,imagecoord);vec4 color1=texture(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(pattern_tl_b/u_texsize,pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture(u_image,pos2);float dist=length(v_pos-gl_FragCoord.xy);float alpha=1.0-smoothstep(0.0,1.0,dist);fragColor=mix(color1,color2,u_fade)*alpha*opacity;
#ifdef GLOBE
if (v_depth > 1.0) {discard;}
#endif
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `uniform vec2 u_world;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform vec3 u_scale;uniform vec2 u_fill_translate;in vec2 a_pos;out vec2 v_pos_a;out vec2 v_pos_b;out vec2 v_pos;
#ifdef GLOBE
out float v_depth;
#endif
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
void main() {
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;gl_Position=projectTile(a_pos+u_fill_translate,a_pos);vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,fromScale*display_size_a,tileRatio,a_pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,toScale*display_size_b,tileRatio,a_pos);v_pos=(gl_Position.xy/gl_Position.w+1.0)/2.0*u_world;
#ifdef GLOBE
v_depth=gl_Position.z/gl_Position.w;
#endif
}`), fillPattern: Et(`#ifdef GL_ES
precision highp float;
#endif
uniform vec2 u_texsize;uniform float u_fade;uniform sampler2D u_image;in vec2 v_pos_a;in vec2 v_pos_b;
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
void main() {
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(pattern_tl_a/u_texsize,pattern_br_a/u_texsize,imagecoord);vec4 color1=texture(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(pattern_tl_b/u_texsize,pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture(u_image,pos2);fragColor=mix(color1,color2,u_fade)*opacity;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform vec3 u_scale;uniform vec2 u_fill_translate;in vec2 a_pos;out vec2 v_pos_a;out vec2 v_pos_b;
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
void main() {
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileZoomRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;gl_Position=projectTile(a_pos+u_fill_translate,a_pos);v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,fromScale*display_size_a,tileZoomRatio,a_pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,toScale*display_size_b,tileZoomRatio,a_pos);}`), fillExtrusion: Et(`in vec4 v_color;void main() {fragColor=v_color;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `uniform vec3 u_lightcolor;uniform lowp vec3 u_lightpos;uniform lowp vec3 u_lightpos_globe;uniform lowp float u_lightintensity;uniform float u_vertical_gradient;uniform lowp float u_opacity;uniform vec2 u_fill_translate;in vec2 a_pos;in vec4 a_normal_ed;
#ifdef TERRAIN3D
in vec2 a_centroid;
#endif
out vec4 v_color;
#pragma mapbox: define highp float base
#pragma mapbox: define highp float height
#pragma mapbox: define highp vec4 color
void main() {
#pragma mapbox: initialize highp float base
#pragma mapbox: initialize highp float height
#pragma mapbox: initialize highp vec4 color
vec3 normal=a_normal_ed.xyz;
#ifdef TERRAIN3D
float height_terrain3d_offset=get_elevation(a_centroid);float base_terrain3d_offset=height_terrain3d_offset-(base > 0.0 ? 0.0 : 10.0);
#else
float height_terrain3d_offset=0.0;float base_terrain3d_offset=0.0;
#endif
base=max(0.0,base)+base_terrain3d_offset;height=max(0.0,height)+height_terrain3d_offset;float t=mod(normal.x,2.0);float elevation=t > 0.0 ? height : base;vec2 posInTile=a_pos+u_fill_translate;
#ifdef GLOBE
vec3 spherePos=projectToSphere(posInTile,a_pos);gl_Position=interpolateProjectionFor3D(posInTile,spherePos,elevation);
#else
gl_Position=u_projection_matrix*vec4(posInTile,elevation,1.0);
#endif
float colorvalue=color.r*0.2126+color.g*0.7152+color.b*0.0722;v_color=vec4(0.0,0.0,0.0,1.0);vec4 ambientlight=vec4(0.03,0.03,0.03,1.0);color+=ambientlight;vec3 normalForLighting=normal/16384.0;float directional=clamp(dot(normalForLighting,u_lightpos),0.0,1.0);
#ifdef GLOBE
mat3 rotMatrix=globeGetRotationMatrix(spherePos);normalForLighting=rotMatrix*normalForLighting;directional=mix(directional,clamp(dot(normalForLighting,u_lightpos_globe),0.0,1.0),u_projection_transition);
#endif
directional=mix((1.0-u_lightintensity),max((1.0-colorvalue+u_lightintensity),1.0),directional);if (normal.y !=0.0) {directional*=((1.0-u_vertical_gradient)+(u_vertical_gradient*clamp((t+base)*pow(height/150.0,0.5),mix(0.7,0.98,1.0-u_lightintensity),1.0)));}v_color.r+=clamp(color.r*directional*u_lightcolor.r,mix(0.0,0.3,1.0-u_lightcolor.r),1.0);v_color.g+=clamp(color.g*directional*u_lightcolor.g,mix(0.0,0.3,1.0-u_lightcolor.g),1.0);v_color.b+=clamp(color.b*directional*u_lightcolor.b,mix(0.0,0.3,1.0-u_lightcolor.b),1.0);v_color*=u_opacity;}`), fillExtrusionPattern: Et(`uniform vec2 u_texsize;uniform float u_fade;uniform sampler2D u_image;in vec2 v_pos_a;in vec2 v_pos_b;in vec4 v_lighting;
#pragma mapbox: define lowp float base
#pragma mapbox: define lowp float height
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
void main() {
#pragma mapbox: initialize lowp float base
#pragma mapbox: initialize lowp float height
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(pattern_tl_a/u_texsize,pattern_br_a/u_texsize,imagecoord);vec4 color1=texture(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(pattern_tl_b/u_texsize,pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture(u_image,pos2);vec4 mixedColor=mix(color1,color2,u_fade);fragColor=mixedColor*v_lighting;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_height_factor;uniform vec3 u_scale;uniform float u_vertical_gradient;uniform lowp float u_opacity;uniform vec2 u_fill_translate;uniform vec3 u_lightcolor;uniform lowp vec3 u_lightpos;uniform lowp vec3 u_lightpos_globe;uniform lowp float u_lightintensity;in vec2 a_pos;in vec4 a_normal_ed;
#ifdef TERRAIN3D
in vec2 a_centroid;
#endif
#ifdef GLOBE
out vec3 v_sphere_pos;
#endif
out vec2 v_pos_a;out vec2 v_pos_b;out vec4 v_lighting;
#pragma mapbox: define lowp float base
#pragma mapbox: define lowp float height
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
void main() {
#pragma mapbox: initialize lowp float base
#pragma mapbox: initialize lowp float height
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;vec3 normal=a_normal_ed.xyz;float edgedistance=a_normal_ed.w;vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;
#ifdef TERRAIN3D
float height_terrain3d_offset=get_elevation(a_centroid);float base_terrain3d_offset=height_terrain3d_offset-(base > 0.0 ? 0.0 : 10.0);
#else
float height_terrain3d_offset=0.0;float base_terrain3d_offset=0.0;
#endif
base=max(0.0,base)+base_terrain3d_offset;height=max(0.0,height)+height_terrain3d_offset;float t=mod(normal.x,2.0);float elevation=t > 0.0 ? height : base;vec2 posInTile=a_pos+u_fill_translate;
#ifdef GLOBE
vec3 spherePos=projectToSphere(posInTile,a_pos);vec3 elevatedPos=spherePos*(1.0+elevation/GLOBE_RADIUS);v_sphere_pos=elevatedPos;gl_Position=interpolateProjectionFor3D(posInTile,spherePos,elevation);
#else
gl_Position=u_projection_matrix*vec4(posInTile,elevation,1.0);
#endif
vec2 pos=normal.x==1.0 && normal.y==0.0 && normal.z==16384.0
? a_pos
: vec2(edgedistance,elevation*u_height_factor);v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,fromScale*display_size_a,tileRatio,pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,toScale*display_size_b,tileRatio,pos);v_lighting=vec4(0.0,0.0,0.0,1.0);float directional=clamp(dot(normal/16383.0,u_lightpos),0.0,1.0);directional=mix((1.0-u_lightintensity),max((0.5+u_lightintensity),1.0),directional);if (normal.y !=0.0) {directional*=((1.0-u_vertical_gradient)+(u_vertical_gradient*clamp((t+base)*pow(height/150.0,0.5),mix(0.7,0.98,1.0-u_lightintensity),1.0)));}v_lighting.rgb+=clamp(directional*u_lightcolor,mix(vec3(0.0),vec3(0.3),1.0-u_lightcolor),vec3(1.0));v_lighting*=u_opacity;}`), hillshadePrepare: Et(`#ifdef GL_ES
precision highp float;
#endif
uniform sampler2D u_image;in vec2 v_pos;uniform vec2 u_dimension;uniform float u_zoom;uniform vec4 u_unpack;float getElevation(vec2 coord,float bias) {vec4 data=texture(u_image,coord)*255.0;data.a=-1.0;return dot(data,u_unpack);}void main() {vec2 epsilon=1.0/u_dimension;float tileSize=u_dimension.x-2.0;float a=getElevation(v_pos+vec2(-epsilon.x,-epsilon.y),0.0);float b=getElevation(v_pos+vec2(0,-epsilon.y),0.0);float c=getElevation(v_pos+vec2(epsilon.x,-epsilon.y),0.0);float d=getElevation(v_pos+vec2(-epsilon.x,0),0.0);float e=getElevation(v_pos,0.0);float f=getElevation(v_pos+vec2(epsilon.x,0),0.0);float g=getElevation(v_pos+vec2(-epsilon.x,epsilon.y),0.0);float h=getElevation(v_pos+vec2(0,epsilon.y),0.0);float i=getElevation(v_pos+vec2(epsilon.x,epsilon.y),0.0);float exaggerationFactor=u_zoom < 2.0 ? 0.4 : u_zoom < 4.5 ? 0.35 : 0.3;float exaggeration=u_zoom < 15.0 ? (u_zoom-15.0)*exaggerationFactor : 0.0;vec2 deriv=vec2((c+f+f+i)-(a+d+d+g),(g+h+h+i)-(a+b+b+c))*tileSize/pow(2.0,exaggeration+(28.2562-u_zoom));fragColor=clamp(vec4(deriv.x/8.0+0.5,deriv.y/8.0+0.5,1.0,1.0),0.0,1.0);
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, "uniform mat4 u_matrix;uniform vec2 u_dimension;in vec2 a_pos;in vec2 a_texture_pos;out vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);highp vec2 epsilon=1.0/u_dimension;float scale=(u_dimension.x-2.0)/u_dimension.x;v_pos=(a_texture_pos/8192.0)*scale+epsilon;}"), hillshade: Et(`uniform sampler2D u_image;in vec2 v_pos;uniform vec2 u_latrange;uniform float u_exaggeration;uniform vec4 u_accent;uniform int u_method;uniform float u_altitudes[NUM_ILLUMINATION_SOURCES];uniform float u_azimuths[NUM_ILLUMINATION_SOURCES];uniform vec4 u_shadows[NUM_ILLUMINATION_SOURCES];uniform vec4 u_highlights[NUM_ILLUMINATION_SOURCES];
#define PI 3.141592653589793
#define STANDARD 0
#define COMBINED 1
#define IGOR 2
#define MULTIDIRECTIONAL 3
#define BASIC 4
float get_aspect(vec2 deriv){return deriv.x !=0.0 ? atan(deriv.y,-deriv.x) : PI/2.0*(deriv.y > 0.0 ? 1.0 :-1.0);}void igor_hillshade(vec2 deriv){deriv=deriv*u_exaggeration*2.0;float aspect=get_aspect(deriv);float azimuth=u_azimuths[0]+PI;float slope_stength=atan(length(deriv))*2.0/PI;float aspect_strength=1.0-abs(mod((aspect+azimuth)/PI+0.5,2.0)-1.0);float shadow_strength=slope_stength*aspect_strength;float highlight_strength=slope_stength*(1.0-aspect_strength);fragColor=u_shadows[0]*shadow_strength+u_highlights[0]*highlight_strength;}void standard_hillshade(vec2 deriv){float azimuth=u_azimuths[0]+PI;float slope=atan(0.625*length(deriv));float aspect=get_aspect(deriv);float intensity=u_exaggeration;float base=1.875-intensity*1.75;float maxValue=0.5*PI;float scaledSlope=intensity !=0.5 ? ((pow(base,slope)-1.0)/(pow(base,maxValue)-1.0))*maxValue : slope;float accent=cos(scaledSlope);vec4 accent_color=(1.0-accent)*u_accent*clamp(intensity*2.0,0.0,1.0);float shade=abs(mod((aspect+azimuth)/PI+0.5,2.0)-1.0);vec4 shade_color=mix(u_shadows[0],u_highlights[0],shade)*sin(scaledSlope)*clamp(intensity*2.0,0.0,1.0);fragColor=accent_color*(1.0-shade_color.a)+shade_color;}void basic_hillshade(vec2 deriv){deriv=deriv*u_exaggeration*2.0;float azimuth=u_azimuths[0]+PI;float cos_az=cos(azimuth);float sin_az=sin(azimuth);float cos_alt=cos(u_altitudes[0]);float sin_alt=sin(u_altitudes[0]);float cang=(sin_alt-(deriv.y*cos_az*cos_alt-deriv.x*sin_az*cos_alt))/sqrt(1.0+dot(deriv,deriv));float shade=clamp(cang,0.0,1.0);if(shade > 0.5){fragColor=u_highlights[0]*(2.0*shade-1.0);}else
{fragColor=u_shadows[0]*(1.0-2.0*shade);}}void multidirectional_hillshade(vec2 deriv){deriv=deriv*u_exaggeration*2.0;fragColor=vec4(0,0,0,0);for(int i=0; i < NUM_ILLUMINATION_SOURCES; i++){float cos_alt=cos(u_altitudes[i]);float sin_alt=sin(u_altitudes[i]);float cos_az=-cos(u_azimuths[i]);float sin_az=-sin(u_azimuths[i]);float cang=(sin_alt-(deriv.y*cos_az*cos_alt-deriv.x*sin_az*cos_alt))/sqrt(1.0+dot(deriv,deriv));float shade=clamp(cang,0.0,1.0);if(shade > 0.5){fragColor+=u_highlights[i]*(2.0*shade-1.0)/float(NUM_ILLUMINATION_SOURCES);}else
{fragColor+=u_shadows[i]*(1.0-2.0*shade)/float(NUM_ILLUMINATION_SOURCES);}}}void combined_hillshade(vec2 deriv){deriv=deriv*u_exaggeration*2.0;float azimuth=u_azimuths[0]+PI;float cos_az=cos(azimuth);float sin_az=sin(azimuth);float cos_alt=cos(u_altitudes[0]);float sin_alt=sin(u_altitudes[0]);float cang=acos((sin_alt-(deriv.y*cos_az*cos_alt-deriv.x*sin_az*cos_alt))/sqrt(1.0+dot(deriv,deriv)));cang=clamp(cang,0.0,PI/2.0);float shade=cang*atan(length(deriv))*4.0/PI/PI;float highlight=(PI/2.0-cang)*atan(length(deriv))*4.0/PI/PI;fragColor=u_shadows[0]*shade+u_highlights[0]*highlight;}void main() {vec4 pixel=texture(u_image,v_pos);float scaleFactor=cos(radians((u_latrange[0]-u_latrange[1])*(1.0-v_pos.y)+u_latrange[1]));vec2 deriv=((pixel.rg*8.0)-4.0)/scaleFactor;if (u_method==BASIC) {basic_hillshade(deriv);} else if (u_method==COMBINED) {combined_hillshade(deriv);} else if (u_method==IGOR) {igor_hillshade(deriv);} else if (u_method==MULTIDIRECTIONAL) {multidirectional_hillshade(deriv);} else if (u_method==STANDARD) {standard_hillshade(deriv);} else {standard_hillshade(deriv);}
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, "uniform mat4 u_matrix;in vec2 a_pos;out vec2 v_pos;void main() {gl_Position=projectTile(a_pos,a_pos);v_pos=a_pos/8192.0;if (a_pos.y <-32767.5) {v_pos.y=0.0;}if (a_pos.y > 32766.5) {v_pos.y=1.0;}}"), line: Et(`uniform lowp float u_device_pixel_ratio;in vec2 v_width2;in vec2 v_normal;in float v_gamma_scale;
#ifdef GLOBE
in float v_depth;
#endif
#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
float dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);fragColor=color*(alpha*opacity);
#ifdef GLOBE
if (v_depth > 1.0) {discard;}
#endif
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `
#define scale 0.015873016
in vec2 a_pos_normal;in vec4 a_data;uniform vec2 u_translation;uniform mediump float u_ratio;uniform vec2 u_units_to_pixels;uniform lowp float u_device_pixel_ratio;out vec2 v_normal;out vec2 v_width2;out float v_gamma_scale;out highp float v_linesofar;
#ifdef GLOBE
out float v_depth;
#endif
#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define mediump float gapwidth
#pragma mapbox: define lowp float offset
#pragma mapbox: define mediump float width
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump float gapwidth
#pragma mapbox: initialize lowp float offset
#pragma mapbox: initialize mediump float width
float ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;v_linesofar=(floor(a_data.z/4.0)+a_data.w*64.0)*2.0;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);float adjustedThickness=projectLineThickness(pos.y);vec4 projected_no_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation);vec4 projected_with_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation+dist/u_ratio*adjustedThickness);gl_Position=projected_with_extrude;
#ifdef GLOBE
v_depth=gl_Position.z/gl_Position.w;
#endif
#ifdef TERRAIN3D
v_gamma_scale=1.0;
#else
float extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length((projected_with_extrude.xy-projected_no_extrude.xy)/projected_with_extrude.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;
#endif
v_width2=vec2(outset,inset);}`), lineGradient: Et(`uniform lowp float u_device_pixel_ratio;uniform sampler2D u_image;in vec2 v_width2;in vec2 v_normal;in float v_gamma_scale;in highp vec2 v_uv;
#ifdef GLOBE
in float v_depth;
#endif
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
float dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);vec4 color=texture(u_image,v_uv);fragColor=color*(alpha*opacity);
#ifdef GLOBE
if (v_depth > 1.0) {discard;}
#endif
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `
#define scale 0.015873016
in vec2 a_pos_normal;in vec4 a_data;in float a_uv_x;in float a_split_index;uniform vec2 u_translation;uniform mediump float u_ratio;uniform lowp float u_device_pixel_ratio;uniform vec2 u_units_to_pixels;uniform float u_image_height;out vec2 v_normal;out vec2 v_width2;out float v_gamma_scale;out highp vec2 v_uv;
#ifdef GLOBE
out float v_depth;
#endif
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define mediump float gapwidth
#pragma mapbox: define lowp float offset
#pragma mapbox: define mediump float width
void main() {
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump float gapwidth
#pragma mapbox: initialize lowp float offset
#pragma mapbox: initialize mediump float width
float ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;highp float texel_height=1.0/u_image_height;highp float half_texel_height=0.5*texel_height;v_uv=vec2(a_uv_x,a_split_index*texel_height-half_texel_height);vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);float adjustedThickness=projectLineThickness(pos.y);vec4 projected_no_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation);vec4 projected_with_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation+dist/u_ratio*adjustedThickness);gl_Position=projected_with_extrude;
#ifdef GLOBE
v_depth=gl_Position.z/gl_Position.w;
#endif
#ifdef TERRAIN3D
v_gamma_scale=1.0;
#else
float extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length((projected_with_extrude.xy-projected_no_extrude.xy)/projected_with_extrude.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;
#endif
v_width2=vec2(outset,inset);}`), linePattern: Et(`#ifdef GL_ES
precision highp float;
#endif
uniform lowp float u_device_pixel_ratio;uniform vec2 u_texsize;uniform float u_fade;uniform mediump vec3 u_scale;uniform sampler2D u_image;in vec2 v_normal;in vec2 v_width2;in float v_linesofar;in float v_gamma_scale;in float v_width;
#ifdef GLOBE
in float v_depth;
#endif
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileZoomRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;vec2 pattern_size_a=vec2(display_size_a.x*fromScale/tileZoomRatio,display_size_a.y);vec2 pattern_size_b=vec2(display_size_b.x*toScale/tileZoomRatio,display_size_b.y);float aspect_a=display_size_a.y/v_width;float aspect_b=display_size_b.y/v_width;float dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);float x_a=mod(v_linesofar/pattern_size_a.x*aspect_a,1.0);float x_b=mod(v_linesofar/pattern_size_b.x*aspect_b,1.0);float y=0.5*v_normal.y+0.5;vec2 texel_size=1.0/u_texsize;vec2 pos_a=mix(pattern_tl_a*texel_size-texel_size,pattern_br_a*texel_size+texel_size,vec2(x_a,y));vec2 pos_b=mix(pattern_tl_b*texel_size-texel_size,pattern_br_b*texel_size+texel_size,vec2(x_b,y));vec4 color=mix(texture(u_image,pos_a),texture(u_image,pos_b),u_fade);fragColor=color*alpha*opacity;
#ifdef GLOBE
if (v_depth > 1.0) {discard;}
#endif
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `
#define scale 0.015873016
#define LINE_DISTANCE_SCALE 2.0
in vec2 a_pos_normal;in vec4 a_data;uniform vec2 u_translation;uniform vec2 u_units_to_pixels;uniform mediump float u_ratio;uniform lowp float u_device_pixel_ratio;out vec2 v_normal;out vec2 v_width2;out float v_linesofar;out float v_gamma_scale;out float v_width;
#ifdef GLOBE
out float v_depth;
#endif
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp float offset
#pragma mapbox: define mediump float gapwidth
#pragma mapbox: define mediump float width
#pragma mapbox: define lowp float floorwidth
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
void main() {
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize lowp float offset
#pragma mapbox: initialize mediump float gapwidth
#pragma mapbox: initialize mediump float width
#pragma mapbox: initialize lowp float floorwidth
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
float ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;float a_linesofar=(floor(a_data.z/4.0)+a_data.w*64.0)*LINE_DISTANCE_SCALE;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);float adjustedThickness=projectLineThickness(pos.y);vec4 projected_no_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation);vec4 projected_with_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation+dist/u_ratio*adjustedThickness);gl_Position=projected_with_extrude;
#ifdef GLOBE
v_depth=gl_Position.z/gl_Position.w;
#endif
#ifdef TERRAIN3D
v_gamma_scale=1.0;
#else
float extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length((projected_with_extrude.xy-projected_no_extrude.xy)/projected_with_extrude.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;
#endif
v_linesofar=a_linesofar;v_width2=vec2(outset,inset);v_width=floorwidth;}`), lineSDF: Et(`uniform lowp float u_device_pixel_ratio;uniform lowp float u_lineatlas_width;uniform sampler2D u_image;uniform float u_mix;in vec2 v_normal;in vec2 v_width2;in vec2 v_tex_a;in vec2 v_tex_b;in float v_gamma_scale;
#ifdef GLOBE
in float v_depth;
#endif
#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define mediump float width
#pragma mapbox: define lowp float floorwidth
#pragma mapbox: define mediump vec4 dasharray_from
#pragma mapbox: define mediump vec4 dasharray_to
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump float width
#pragma mapbox: initialize lowp float floorwidth
#pragma mapbox: initialize mediump vec4 dasharray_from
#pragma mapbox: initialize mediump vec4 dasharray_to
float dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);float sdfdist_a=texture(u_image,v_tex_a).a;float sdfdist_b=texture(u_image,v_tex_b).a;float sdfdist=mix(sdfdist_a,sdfdist_b,u_mix);float sdfgamma=(u_lineatlas_width/256.0/u_device_pixel_ratio)/min(dasharray_from.w,dasharray_to.w);alpha*=smoothstep(0.5-sdfgamma/floorwidth,0.5+sdfgamma/floorwidth,sdfdist);fragColor=color*(alpha*opacity);
#ifdef GLOBE
if (v_depth > 1.0) {discard;}
#endif
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `
#define scale 0.015873016
#define LINE_DISTANCE_SCALE 2.0
in vec2 a_pos_normal;in vec4 a_data;uniform vec2 u_translation;uniform mediump float u_ratio;uniform lowp float u_device_pixel_ratio;uniform vec2 u_units_to_pixels;uniform float u_tileratio;uniform float u_crossfade_from;uniform float u_crossfade_to;uniform float u_lineatlas_height;out vec2 v_normal;out vec2 v_width2;out vec2 v_tex_a;out vec2 v_tex_b;out float v_gamma_scale;
#ifdef GLOBE
out float v_depth;
#endif
#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define mediump float gapwidth
#pragma mapbox: define lowp float offset
#pragma mapbox: define mediump float width
#pragma mapbox: define lowp float floorwidth
#pragma mapbox: define mediump vec4 dasharray_from
#pragma mapbox: define mediump vec4 dasharray_to
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump float gapwidth
#pragma mapbox: initialize lowp float offset
#pragma mapbox: initialize mediump float width
#pragma mapbox: initialize lowp float floorwidth
#pragma mapbox: initialize mediump vec4 dasharray_from
#pragma mapbox: initialize mediump vec4 dasharray_to
float ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;float a_linesofar=(floor(a_data.z/4.0)+a_data.w*64.0)*LINE_DISTANCE_SCALE;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);float adjustedThickness=projectLineThickness(pos.y);vec4 projected_no_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation);vec4 projected_with_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation+dist/u_ratio*adjustedThickness);gl_Position=projected_with_extrude;
#ifdef GLOBE
v_depth=gl_Position.z/gl_Position.w;
#endif
#ifdef TERRAIN3D
v_gamma_scale=1.0;
#else
float extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length((projected_with_extrude.xy-projected_no_extrude.xy)/projected_with_extrude.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;
#endif
float u_patternscale_a_x=u_tileratio/dasharray_from.w/u_crossfade_from;float u_patternscale_a_y=-dasharray_from.z/2.0/u_lineatlas_height;float u_patternscale_b_x=u_tileratio/dasharray_to.w/u_crossfade_to;float u_patternscale_b_y=-dasharray_to.z/2.0/u_lineatlas_height;v_tex_a=vec2(a_linesofar*u_patternscale_a_x/floorwidth,normal.y*u_patternscale_a_y+(float(dasharray_from.y)+0.5)/u_lineatlas_height);v_tex_b=vec2(a_linesofar*u_patternscale_b_x/floorwidth,normal.y*u_patternscale_b_y+(float(dasharray_to.y)+0.5)/u_lineatlas_height);v_width2=vec2(outset,inset);}`), lineGradientSDF: Et(`uniform lowp float u_device_pixel_ratio;uniform sampler2D u_image;uniform sampler2D u_image_dash;uniform float u_mix;uniform lowp float u_lineatlas_width;in vec2 v_normal;in vec2 v_width2;in vec2 v_tex_a;in vec2 v_tex_b;in float v_gamma_scale;in highp vec2 v_uv;
#ifdef GLOBE
in float v_depth;
#endif
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define mediump float width
#pragma mapbox: define lowp float floorwidth
#pragma mapbox: define mediump vec4 dasharray_from
#pragma mapbox: define mediump vec4 dasharray_to
void main() {
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump float width
#pragma mapbox: initialize lowp float floorwidth
#pragma mapbox: initialize mediump vec4 dasharray_from
#pragma mapbox: initialize mediump vec4 dasharray_to
float dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);vec4 color=texture(u_image,v_uv);float sdfdist_a=texture(u_image_dash,v_tex_a).a;float sdfdist_b=texture(u_image_dash,v_tex_b).a;float sdfdist=mix(sdfdist_a,sdfdist_b,u_mix);float sdfgamma=(u_lineatlas_width/256.0)/min(dasharray_from.w,dasharray_to.w);float dash_alpha=smoothstep(0.5-sdfgamma/floorwidth,0.5+sdfgamma/floorwidth,sdfdist);fragColor=color*(alpha*dash_alpha*opacity);
#ifdef GLOBE
if (v_depth > 1.0) {discard;}
#endif
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `
#define scale 0.015873016
#define LINE_DISTANCE_SCALE 2.0
in vec2 a_pos_normal;in vec4 a_data;in float a_uv_x;in float a_split_index;uniform vec2 u_translation;uniform mediump float u_ratio;uniform lowp float u_device_pixel_ratio;uniform vec2 u_units_to_pixels;uniform float u_image_height;uniform float u_tileratio;uniform float u_crossfade_from;uniform float u_crossfade_to;uniform float u_lineatlas_height;out vec2 v_normal;out vec2 v_width2;out float v_gamma_scale;out highp vec2 v_uv;out vec2 v_tex_a;out vec2 v_tex_b;
#ifdef GLOBE
out float v_depth;
#endif
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define mediump float gapwidth
#pragma mapbox: define lowp float offset
#pragma mapbox: define mediump float width
#pragma mapbox: define lowp float floorwidth
#pragma mapbox: define mediump vec4 dasharray_from
#pragma mapbox: define mediump vec4 dasharray_to
void main() {
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump float gapwidth
#pragma mapbox: initialize lowp float offset
#pragma mapbox: initialize mediump float width
#pragma mapbox: initialize lowp float floorwidth
#pragma mapbox: initialize mediump vec4 dasharray_from
#pragma mapbox: initialize mediump vec4 dasharray_to
float ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;float a_linesofar=(floor(a_data.z/4.0)+a_data.w*64.0)*LINE_DISTANCE_SCALE;float texel_height=1.0/u_image_height;float half_texel_height=0.5*texel_height;v_uv=vec2(a_uv_x,a_split_index*texel_height-half_texel_height);vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);float adjustedThickness=projectLineThickness(pos.y);vec4 projected_no_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation);vec4 projected_with_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation+dist/u_ratio*adjustedThickness);gl_Position=projected_with_extrude;
#ifdef GLOBE
v_depth=gl_Position.z/gl_Position.w;
#endif
#ifdef TERRAIN3D
v_gamma_scale=1.0;
#else
float extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length((projected_with_extrude.xy-projected_no_extrude.xy)/projected_with_extrude.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;
#endif
float u_patternscale_a_x=u_tileratio/dasharray_from.w/u_crossfade_from;float u_patternscale_a_y=-dasharray_from.z/2.0/u_lineatlas_height;float u_patternscale_b_x=u_tileratio/dasharray_to.w/u_crossfade_to;float u_patternscale_b_y=-dasharray_to.z/2.0/u_lineatlas_height;v_tex_a=vec2(a_linesofar*u_patternscale_a_x/floorwidth,normal.y*u_patternscale_a_y+(float(dasharray_from.y)+0.5)/u_lineatlas_height);v_tex_b=vec2(a_linesofar*u_patternscale_b_x/floorwidth,normal.y*u_patternscale_b_y+(float(dasharray_to.y)+0.5)/u_lineatlas_height);v_width2=vec2(outset,inset);}`), raster: Et(`uniform float u_fade_t;uniform float u_opacity;uniform sampler2D u_image0;uniform sampler2D u_image1;in vec2 v_pos0;in vec2 v_pos1;uniform float u_brightness_low;uniform float u_brightness_high;uniform float u_saturation_factor;uniform float u_contrast_factor;uniform vec3 u_spin_weights;void main() {vec4 color0=texture(u_image0,v_pos0);vec4 color1=texture(u_image1,v_pos1);if (color0.a > 0.0) {color0.rgb=color0.rgb/color0.a;}if (color1.a > 0.0) {color1.rgb=color1.rgb/color1.a;}vec4 color=mix(color0,color1,u_fade_t);color.a*=u_opacity;vec3 rgb=color.rgb;rgb=vec3(dot(rgb,u_spin_weights.xyz),dot(rgb,u_spin_weights.zxy),dot(rgb,u_spin_weights.yzx));float average=(color.r+color.g+color.b)/3.0;rgb+=(average-rgb)*u_saturation_factor;rgb=(rgb-0.5)*u_contrast_factor+0.5;vec3 u_high_vec=vec3(u_brightness_low,u_brightness_low,u_brightness_low);vec3 u_low_vec=vec3(u_brightness_high,u_brightness_high,u_brightness_high);fragColor=vec4(mix(u_high_vec,u_low_vec,rgb)*color.a,color.a);
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `uniform vec2 u_tl_parent;uniform float u_scale_parent;uniform float u_buffer_scale;uniform vec4 u_coords_top;uniform vec4 u_coords_bottom;in vec2 a_pos;out vec2 v_pos0;out vec2 v_pos1;void main() {vec2 fractionalPos=a_pos/8192.0;vec2 position=mix(mix(u_coords_top.xy,u_coords_top.zw,fractionalPos.x),mix(u_coords_bottom.xy,u_coords_bottom.zw,fractionalPos.x),fractionalPos.y);gl_Position=projectTile(position,position);v_pos0=((fractionalPos-0.5)/u_buffer_scale)+0.5;
#ifdef GLOBE
if (a_pos.y <-32767.5) {v_pos0.y=0.0;}if (a_pos.y > 32766.5) {v_pos0.y=1.0;}
#endif
v_pos1=(v_pos0*u_scale_parent)+u_tl_parent;}`), symbolIcon: Et(`uniform sampler2D u_texture;in vec2 v_tex;in float v_fade_opacity;
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize lowp float opacity
lowp float alpha=opacity*v_fade_opacity;fragColor=texture(u_texture,v_tex)*alpha;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `in vec4 a_pos_offset;in vec4 a_data;in vec4 a_pixeloffset;in vec3 a_projected_pos;in float a_fade_opacity;uniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform highp float u_camera_to_center_distance;uniform highp float u_pitch;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform float u_fade_change;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform vec2 u_texsize;uniform bool u_is_along_line;uniform bool u_is_variable_anchor;uniform vec2 u_translation;uniform float u_pitched_scale;out vec2 v_tex;out float v_fade_opacity;
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize lowp float opacity
vec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_data.xy;vec2 a_size=a_data.zw;float a_size_min=floor(a_size[0]*0.5);vec2 a_pxoffset=a_pixeloffset.xy;vec2 a_minFontScale=a_pixeloffset.zw/256.0;float ele=get_elevation(a_pos);highp float segment_angle=-a_projected_pos[2];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec2 translated_a_pos=a_pos+u_translation;vec4 projectedPoint=projectTileWithElevation(translated_a_pos,ele);highp float camera_to_anchor_distance=projectedPoint.w;highp float distance_ratio=u_pitch_with_map ?
camera_to_anchor_distance/u_camera_to_center_distance :
u_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(0.5+0.5*distance_ratio,0.0,4.0);size*=perspective_ratio;float fontScale=u_is_text ? size/24.0 : size;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetProjectedPoint=projectTileWithElevation(translated_a_pos+vec2(1,0),ele);vec2 a=projectedPoint.xy/projectedPoint.w;vec2 b=offsetProjectedPoint.xy/offsetProjectedPoint.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}highp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);vec4 projected_pos;if (u_is_along_line || u_is_variable_anchor) {projected_pos=vec4(a_projected_pos.xy,ele,1.0);} else if (u_pitch_with_map) {projected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy+u_translation,ele,1.0);} else {projected_pos=u_label_plane_matrix*projectTileWithElevation(a_projected_pos.xy+u_translation,ele);}float z=float(u_pitch_with_map)*projected_pos.z/projected_pos.w;float projectionScaling=1.0;
#ifdef GLOBE
if(u_pitch_with_map) {float anchor_pos_tile_y=(u_coord_matrix*vec4(projected_pos.xy/projected_pos.w,z,1.0)).y;projectionScaling=mix(projectionScaling,1.0/circumferenceRatioAtTileY(anchor_pos_tile_y)*u_pitched_scale,u_projection_transition);}
#endif
vec4 finalPos=u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+rotation_matrix*(a_offset/32.0*max(a_minFontScale,fontScale)+a_pxoffset/16.0)*projectionScaling,z,1.0);if(u_pitch_with_map) {finalPos=projectTileWithElevation(finalPos.xy,finalPos.z);}gl_Position=finalPos;v_tex=a_tex/u_texsize;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float visibility=calculate_visibility(projectedPoint);v_fade_opacity=max(0.0,min(visibility,fade_opacity[0]+fade_change));}`), symbolSDF: Et(`#define SDF_PX 8.0
uniform bool u_is_halo;uniform sampler2D u_texture;uniform highp float u_gamma_scale;uniform lowp float u_device_pixel_ratio;uniform bool u_is_text;in vec2 v_data0;in vec3 v_data1;
#pragma mapbox: define highp vec4 fill_color
#pragma mapbox: define highp vec4 halo_color
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp float halo_width
#pragma mapbox: define lowp float halo_blur
void main() {
#pragma mapbox: initialize highp vec4 fill_color
#pragma mapbox: initialize highp vec4 halo_color
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize lowp float halo_width
#pragma mapbox: initialize lowp float halo_blur
float EDGE_GAMMA=0.105/u_device_pixel_ratio;vec2 tex=v_data0.xy;float gamma_scale=v_data1.x;float size=v_data1.y;float fade_opacity=v_data1[2];float fontScale=u_is_text ? size/24.0 : size;lowp vec4 color=fill_color;highp float gamma=EDGE_GAMMA/(fontScale*u_gamma_scale);lowp float inner_edge=(256.0-64.0)/256.0;if (u_is_halo) {color=halo_color;gamma=(halo_blur*1.19/SDF_PX+EDGE_GAMMA)/(fontScale*u_gamma_scale);inner_edge=inner_edge+gamma*gamma_scale;}lowp float dist=texture(u_texture,tex).a;highp float gamma_scaled=gamma*gamma_scale;highp float alpha=smoothstep(inner_edge-gamma_scaled,inner_edge+gamma_scaled,dist);if (u_is_halo) {lowp float halo_edge=(6.0-halo_width/fontScale)/SDF_PX;alpha=min(smoothstep(halo_edge-gamma_scaled,halo_edge+gamma_scaled,dist),1.0-alpha);}fragColor=color*(alpha*opacity*fade_opacity);
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `in vec4 a_pos_offset;in vec4 a_data;in vec4 a_pixeloffset;in vec3 a_projected_pos;in float a_fade_opacity;uniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform bool u_is_along_line;uniform bool u_is_variable_anchor;uniform highp float u_pitch;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform highp float u_camera_to_center_distance;uniform float u_fade_change;uniform vec2 u_texsize;uniform vec2 u_translation;uniform float u_pitched_scale;out vec2 v_data0;out vec3 v_data1;
#pragma mapbox: define highp vec4 fill_color
#pragma mapbox: define highp vec4 halo_color
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp float halo_width
#pragma mapbox: define lowp float halo_blur
void main() {
#pragma mapbox: initialize highp vec4 fill_color
#pragma mapbox: initialize highp vec4 halo_color
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize lowp float halo_width
#pragma mapbox: initialize lowp float halo_blur
vec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_data.xy;vec2 a_size=a_data.zw;float a_size_min=floor(a_size[0]*0.5);vec2 a_pxoffset=a_pixeloffset.xy;float ele=get_elevation(a_pos);highp float segment_angle=-a_projected_pos[2];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec2 translated_a_pos=a_pos+u_translation;vec4 projectedPoint=projectTileWithElevation(translated_a_pos,ele);highp float camera_to_anchor_distance=projectedPoint.w;highp float distance_ratio=u_pitch_with_map ?
camera_to_anchor_distance/u_camera_to_center_distance :
u_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(0.5+0.5*distance_ratio,0.0,4.0);size*=perspective_ratio;float fontScale=u_is_text ? size/24.0 : size;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetProjectedPoint=projectTileWithElevation(translated_a_pos+vec2(1,0),ele);vec2 a=projectedPoint.xy/projectedPoint.w;vec2 b=offsetProjectedPoint.xy/offsetProjectedPoint.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}highp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);vec4 projected_pos;if (u_is_along_line || u_is_variable_anchor) {projected_pos=vec4(a_projected_pos.xy,ele,1.0);} else if (u_pitch_with_map) {projected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy+u_translation,ele,1.0);} else {projected_pos=u_label_plane_matrix*projectTileWithElevation(a_projected_pos.xy+u_translation,ele);}float z=float(u_pitch_with_map)*projected_pos.z/projected_pos.w;float projectionScaling=1.0;
#ifdef GLOBE
if(u_pitch_with_map) {float anchor_pos_tile_y=(u_coord_matrix*vec4(projected_pos.xy/projected_pos.w,z,1.0)).y;projectionScaling=mix(projectionScaling,1.0/circumferenceRatioAtTileY(anchor_pos_tile_y)*u_pitched_scale,u_projection_transition);}
#endif
vec4 finalPos=u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+rotation_matrix*(a_offset/32.0*fontScale+a_pxoffset)*projectionScaling,z,1.0);if(u_pitch_with_map) {finalPos=projectTileWithElevation(finalPos.xy,finalPos.z);}float gamma_scale=finalPos.w;gl_Position=finalPos;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float visibility=calculate_visibility(projectedPoint);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float interpolated_fade_opacity=max(0.0,min(visibility,fade_opacity[0]+fade_change));v_data0=a_tex/u_texsize;v_data1=vec3(gamma_scale,size,interpolated_fade_opacity);}`), symbolTextAndIcon: Et(`#define SDF_PX 8.0
#define SDF 1.0
#define ICON 0.0
uniform bool u_is_halo;uniform sampler2D u_texture;uniform sampler2D u_texture_icon;uniform highp float u_gamma_scale;uniform lowp float u_device_pixel_ratio;in vec4 v_data0;in vec4 v_data1;
#pragma mapbox: define highp vec4 fill_color
#pragma mapbox: define highp vec4 halo_color
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp float halo_width
#pragma mapbox: define lowp float halo_blur
void main() {
#pragma mapbox: initialize highp vec4 fill_color
#pragma mapbox: initialize highp vec4 halo_color
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize lowp float halo_width
#pragma mapbox: initialize lowp float halo_blur
float fade_opacity=v_data1[2];if (v_data1.w==ICON) {vec2 tex_icon=v_data0.zw;lowp float alpha=opacity*fade_opacity;fragColor=texture(u_texture_icon,tex_icon)*alpha;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
return;}vec2 tex=v_data0.xy;float EDGE_GAMMA=0.105/u_device_pixel_ratio;float gamma_scale=v_data1.x;float size=v_data1.y;float fontScale=size/24.0;lowp vec4 color=fill_color;highp float gamma=EDGE_GAMMA/(fontScale*u_gamma_scale);lowp float buff=(256.0-64.0)/256.0;if (u_is_halo) {color=halo_color;gamma=(halo_blur*1.19/SDF_PX+EDGE_GAMMA)/(fontScale*u_gamma_scale);buff=(6.0-halo_width/fontScale)/SDF_PX;}lowp float dist=texture(u_texture,tex).a;highp float gamma_scaled=gamma*gamma_scale;highp float alpha=smoothstep(buff-gamma_scaled,buff+gamma_scaled,dist);fragColor=color*(alpha*opacity*fade_opacity);
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `in vec4 a_pos_offset;in vec4 a_data;in vec3 a_projected_pos;in float a_fade_opacity;uniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform highp float u_pitch;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform highp float u_camera_to_center_distance;uniform float u_fade_change;uniform vec2 u_texsize;uniform vec2 u_texsize_icon;uniform bool u_is_along_line;uniform bool u_is_variable_anchor;uniform vec2 u_translation;uniform float u_pitched_scale;out vec4 v_data0;out vec4 v_data1;
#pragma mapbox: define highp vec4 fill_color
#pragma mapbox: define highp vec4 halo_color
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp float halo_width
#pragma mapbox: define lowp float halo_blur
void main() {
#pragma mapbox: initialize highp vec4 fill_color
#pragma mapbox: initialize highp vec4 halo_color
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize lowp float halo_width
#pragma mapbox: initialize lowp float halo_blur
vec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_data.xy;vec2 a_size=a_data.zw;float a_size_min=floor(a_size[0]*0.5);float is_sdf=a_size[0]-2.0*a_size_min;float ele=get_elevation(a_pos);highp float segment_angle=-a_projected_pos[2];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec2 translated_a_pos=a_pos+u_translation;vec4 projectedPoint=projectTileWithElevation(translated_a_pos,ele);highp float camera_to_anchor_distance=projectedPoint.w;highp float distance_ratio=u_pitch_with_map ?
camera_to_anchor_distance/u_camera_to_center_distance :
u_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(0.5+0.5*distance_ratio,0.0,4.0);size*=perspective_ratio;float fontScale=size/24.0;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetProjectedPoint=projectTileWithElevation(translated_a_pos+vec2(1,0),ele);vec2 a=projectedPoint.xy/projectedPoint.w;vec2 b=offsetProjectedPoint.xy/offsetProjectedPoint.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}highp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);vec4 projected_pos;if (u_is_along_line || u_is_variable_anchor) {projected_pos=vec4(a_projected_pos.xy,ele,1.0);} else if (u_pitch_with_map) {projected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy+u_translation,ele,1.0);} else {projected_pos=u_label_plane_matrix*projectTileWithElevation(a_projected_pos.xy+u_translation,ele);}float z=float(u_pitch_with_map)*projected_pos.z/projected_pos.w;float projectionScaling=1.0;
#ifdef GLOBE
if(u_pitch_with_map && !u_is_along_line) {float anchor_pos_tile_y=(u_coord_matrix*vec4(projected_pos.xy/projected_pos.w,z,1.0)).y;projectionScaling=mix(projectionScaling,1.0/circumferenceRatioAtTileY(anchor_pos_tile_y)*u_pitched_scale,u_projection_transition);}
#endif
vec4 finalPos=u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+rotation_matrix*(a_offset/32.0*fontScale)*projectionScaling,z,1.0);if(u_pitch_with_map) {finalPos=projectTileWithElevation(finalPos.xy,finalPos.z);}float gamma_scale=finalPos.w;gl_Position=finalPos;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float visibility=calculate_visibility(projectedPoint);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float interpolated_fade_opacity=max(0.0,min(visibility,fade_opacity[0]+fade_change));v_data0.xy=a_tex/u_texsize;v_data0.zw=a_tex/u_texsize_icon;v_data1=vec4(gamma_scale,size,interpolated_fade_opacity,is_sdf);}`), terrain: Et("uniform sampler2D u_texture;uniform vec4 u_fog_color;uniform vec4 u_horizon_color;uniform float u_fog_ground_blend;uniform float u_fog_ground_blend_opacity;uniform float u_horizon_fog_blend;uniform bool u_is_globe_mode;in vec2 v_texture_pos;in float v_fog_depth;const float gamma=2.2;vec4 gammaToLinear(vec4 color) {return pow(color,vec4(gamma));}vec4 linearToGamma(vec4 color) {return pow(color,vec4(1.0/gamma));}void main() {vec4 surface_color=texture(u_texture,vec2(v_texture_pos.x,1.0-v_texture_pos.y));if (!u_is_globe_mode && v_fog_depth > u_fog_ground_blend) {vec4 surface_color_linear=gammaToLinear(surface_color);float blend_color=smoothstep(0.0,1.0,max((v_fog_depth-u_horizon_fog_blend)/(1.0-u_horizon_fog_blend),0.0));vec4 fog_horizon_color_linear=mix(gammaToLinear(u_fog_color),gammaToLinear(u_horizon_color),blend_color);float factor_fog=max(v_fog_depth-u_fog_ground_blend,0.0)/(1.0-u_fog_ground_blend);fragColor=linearToGamma(mix(surface_color_linear,fog_horizon_color_linear,pow(factor_fog,2.0)*u_fog_ground_blend_opacity));} else {fragColor=surface_color;}}", "in vec3 a_pos3d;uniform mat4 u_fog_matrix;uniform float u_ele_delta;out vec2 v_texture_pos;out float v_fog_depth;void main() {float ele=get_elevation(a_pos3d.xy);float ele_delta=a_pos3d.z==1.0 ? u_ele_delta : 0.0;v_texture_pos=a_pos3d.xy/8192.0;gl_Position=projectTileFor3D(a_pos3d.xy,get_elevation(a_pos3d.xy)-ele_delta);vec4 pos=u_fog_matrix*vec4(a_pos3d.xy,ele,1.0);v_fog_depth=pos.z/pos.w*0.5+0.5;}"), terrainDepth: Et("in float v_depth;const highp vec4 bitSh=vec4(256.*256.*256.,256.*256.,256.,1.);const highp vec4 bitMsk=vec4(0.,vec3(1./256.0));highp vec4 pack(highp float value) {highp vec4 comp=fract(value*bitSh);comp-=comp.xxyz*bitMsk;return comp;}void main() {fragColor=pack(v_depth);}", "in vec3 a_pos3d;uniform float u_ele_delta;out float v_depth;void main() {float ele=get_elevation(a_pos3d.xy);float ele_delta=a_pos3d.z==1.0 ? u_ele_delta : 0.0;gl_Position=projectTileFor3D(a_pos3d.xy,ele-ele_delta);v_depth=gl_Position.z/gl_Position.w;}"), terrainCoords: Et("precision mediump float;uniform sampler2D u_texture;uniform float u_terrain_coords_id;in vec2 v_texture_pos;void main() {vec4 rgba=texture(u_texture,v_texture_pos);fragColor=vec4(rgba.r,rgba.g,rgba.b,u_terrain_coords_id);}", "in vec3 a_pos3d;uniform float u_ele_delta;out vec2 v_texture_pos;void main() {float ele=get_elevation(a_pos3d.xy);float ele_delta=a_pos3d.z==1.0 ? u_ele_delta : 0.0;v_texture_pos=a_pos3d.xy/8192.0;gl_Position=projectTileFor3D(a_pos3d.xy,ele-ele_delta);}"), projectionErrorMeasurement: Et("in vec4 v_output_error_encoded;void main() {fragColor=v_output_error_encoded;}", "in vec2 a_pos;uniform highp float u_input;uniform highp float u_output_expected;out vec4 v_output_error_encoded;void main() {float real_output=2.0*atan(exp(PI-(u_input*PI*2.0)))-PI*0.5;float error=real_output-u_output_expected;float abs_error=abs(error)*128.0;v_output_error_encoded.x=min(floor(abs_error*256.0),255.0)/255.0;abs_error-=v_output_error_encoded.x;v_output_error_encoded.y=min(floor(abs_error*65536.0),255.0)/255.0;abs_error-=v_output_error_encoded.x/255.0;v_output_error_encoded.z=min(floor(abs_error*16777216.0),255.0)/255.0;v_output_error_encoded.w=error >=0.0 ? 1.0 : 0.0;gl_Position=vec4(a_pos,0.0,1.0);}"), atmosphere: Et(`in vec3 view_direction;uniform vec3 u_sun_pos;uniform vec3 u_globe_position;uniform float u_globe_radius;uniform float u_atmosphere_blend;/**Shader use from https:*Made some change to adapt to MapLibre Globe geometry*/const float PI=3.141592653589793;const int iSteps=5;const int jSteps=3;/*radius of the planet*/const float EARTH_RADIUS=6371e3;/*radius of the atmosphere*/const float ATMOS_RADIUS=6471e3;vec2 rsi(vec3 r0,vec3 rd,float sr) {float a=dot(rd,rd);float b=2.0*dot(rd,r0);float c=dot(r0,r0)-(sr*sr);float d=(b*b)-4.0*a*c;if (d < 0.0) return vec2(1e5,-1e5);return vec2((-b-sqrt(d))/(2.0*a),(-b+sqrt(d))/(2.0*a));}vec4 atmosphere(vec3 r,vec3 r0,vec3 pSun,float iSun,float rPlanet,float rAtmos,vec3 kRlh,float kMie,float shRlh,float shMie,float g) {pSun=normalize(pSun);r=normalize(r);vec2 p=rsi(r0,r,rAtmos);if (p.x > p.y) {return vec4(0.0,0.0,0.0,1.0);}if (p.x < 0.0) {p.x=0.0;}vec3 pos=r0+r*p.x;vec2 p2=rsi(r0,r,rPlanet);if (p2.x <=p2.y && p2.x > 0.0) {p.y=min(p.y,p2.x);}float iStepSize=(p.y-p.x)/float(iSteps);float iTime=p.x+iStepSize*0.5;vec3 totalRlh=vec3(0,0,0);vec3 totalMie=vec3(0,0,0);float iOdRlh=0.0;float iOdMie=0.0;float mu=dot(r,pSun);float mumu=mu*mu;float gg=g*g;float pRlh=3.0/(16.0*PI)*(1.0+mumu);float pMie=3.0/(8.0*PI)*((1.0-gg)*(mumu+1.0))/(pow(1.0+gg-2.0*mu*g,1.5)*(2.0+gg));for (int i=0; i < iSteps; i++) {vec3 iPos=r0+r*iTime;float iHeight=length(iPos)-rPlanet;float odStepRlh=exp(-iHeight/shRlh)*iStepSize;float odStepMie=exp(-iHeight/shMie)*iStepSize;iOdRlh+=odStepRlh;iOdMie+=odStepMie;float jStepSize=rsi(iPos,pSun,rAtmos).y/float(jSteps);float jTime=jStepSize*0.5;float jOdRlh=0.0;float jOdMie=0.0;for (int j=0; j < jSteps; j++) {vec3 jPos=iPos+pSun*jTime;float jHeight=length(jPos)-rPlanet;jOdRlh+=exp(-jHeight/shRlh)*jStepSize;jOdMie+=exp(-jHeight/shMie)*jStepSize;jTime+=jStepSize;}vec3 attn=exp(-(kMie*(iOdMie+jOdMie)+kRlh*(iOdRlh+jOdRlh)));totalRlh+=odStepRlh*attn;totalMie+=odStepMie*attn;iTime+=iStepSize;}float opacity=exp(-(length(kRlh)*length(totalRlh)+kMie*length(totalMie)));vec3 color=iSun*(pRlh*kRlh*totalRlh+pMie*kMie*totalMie);return vec4(color,opacity);}void main() {vec3 scale_camera_pos=-u_globe_position*EARTH_RADIUS/u_globe_radius;vec4 color=atmosphere(normalize(view_direction),scale_camera_pos,u_sun_pos,22.0,EARTH_RADIUS,ATMOS_RADIUS,vec3(5.5e-6,13.0e-6,22.4e-6),21e-6,8e3,1.2e3,0.758
);color.rgb=1.0-exp(-1.0*color.rgb);color=pow(color,vec4(1.0/2.2));fragColor=vec4(color.rgb,1.0-color.a)*u_atmosphere_blend;}`, "in vec2 a_pos;uniform mat4 u_inv_proj_matrix;out vec3 view_direction;void main() {view_direction=(u_inv_proj_matrix*vec4(a_pos,0.0,1.0)).xyz;gl_Position=vec4(a_pos,0.0,1.0);}"), sky: Et("uniform vec4 u_sky_color;uniform vec4 u_horizon_color;uniform vec2 u_horizon;uniform vec2 u_horizon_normal;uniform float u_sky_horizon_blend;uniform float u_sky_blend;void main() {float x=gl_FragCoord.x;float y=gl_FragCoord.y;float blend=(y-u_horizon.y)*u_horizon_normal.y+(x-u_horizon.x)*u_horizon_normal.x;if (blend > 0.0) {if (blend < u_sky_horizon_blend) {fragColor=mix(u_sky_color,u_horizon_color,pow(1.0-blend/u_sky_horizon_blend,2.0));} else {fragColor=u_sky_color;}}fragColor=mix(fragColor,vec4(vec3(0.0),0.0),u_sky_blend);}", "in vec2 a_pos;void main() {gl_Position=vec4(a_pos,1.0,1.0);}")
            }; function Et(m, t) {
                const s = /#pragma mapbox: ([\w]+) ([\w]+) ([\w]+) ([\w]+)/g, l = t.match(/in ([\w]+) ([\w]+)/g), d = m.match(/uniform ([\w]+) ([\w]+)([\s]*)([\w]*)/g), g = t.match(/uniform ([\w]+) ([\w]+)([\s]*)([\w]*)/g), v = g ? g.concat(d) : d, T = {}; return {
                    fragmentSource: m = m.replace(s, (E, I, A, R, z) => (T[z] = !0, I === "define" ? `
#ifndef HAS_UNIFORM_u_${z}
in ${A} ${R} ${z};
#else
uniform ${A} ${R} u_${z};
#endif
`: `
#ifdef HAS_UNIFORM_u_${z}
    ${A} ${R} ${z} = u_${z};
#endif
`)), vertexSource: t = t.replace(s, (E, I, A, R, z) => {
                        const O = R === "float" ? "vec2" : "vec4", U = z.match(/color/) ? "color" : O; return T[z] ? I === "define" ? `
#ifndef HAS_UNIFORM_u_${z}
uniform lowp float u_${z}_t;
in ${A} ${O} a_${z};
out ${A} ${R} ${z};
#else
uniform ${A} ${R} u_${z};
#endif
`: U === "vec4" ? `
#ifndef HAS_UNIFORM_u_${z}
    ${z} = a_${z};
#else
    ${A} ${R} ${z} = u_${z};
#endif
`: `
#ifndef HAS_UNIFORM_u_${z}
    ${z} = unpack_mix_${U}(a_${z}, u_${z}_t);
#else
    ${A} ${R} ${z} = u_${z};
#endif
`: I === "define" ? `
#ifndef HAS_UNIFORM_u_${z}
uniform lowp float u_${z}_t;
in ${A} ${O} a_${z};
#else
uniform ${A} ${R} u_${z};
#endif
`: U === "vec4" ? `
#ifndef HAS_UNIFORM_u_${z}
    ${A} ${R} ${z} = a_${z};
#else
    ${A} ${R} ${z} = u_${z};
#endif
`: `
#ifndef HAS_UNIFORM_u_${z}
    ${A} ${R} ${z} = unpack_mix_${U}(a_${z}, u_${z}_t);
#else
    ${A} ${R} ${z} = u_${z};
#endif
`}), staticAttributes: l, staticUniforms: v
                }
            } class sr { constructor(t, s, l) { this.vertexBuffer = t, this.indexBuffer = s, this.segments = l } destroy() { this.vertexBuffer.destroy(), this.indexBuffer.destroy(), this.segments.destroy(), this.vertexBuffer = null, this.indexBuffer = null, this.segments = null } } var ws = c.aU([{ name: "a_pos", type: "Int16", components: 2 }]); const Dn = "#define PROJECTION_MERCATOR", Kn = "mercator"; class zn { constructor() { this._cachedMesh = null } get name() { return "mercator" } get useSubdivision() { return !1 } get shaderVariantName() { return Kn } get shaderDefine() { return Dn } get shaderPreludeCode() { return br.projectionMercator } get vertexShaderPreludeCode() { return br.projectionMercator.vertexSource } get subdivisionGranularity() { return c.aV.noSubdivision } get useGlobeControls() { return !1 } get transitionState() { return 0 } get latitudeErrorCorrectionRadians() { return 0 } destroy() { } updateGPUdependent(t) { } getMeshFromTileID(t, s, l, d, g) { if (this._cachedMesh) return this._cachedMesh; const v = new c.aW; v.emplaceBack(0, 0), v.emplaceBack(c.a5, 0), v.emplaceBack(0, c.a5), v.emplaceBack(c.a5, c.a5); const T = t.createVertexBuffer(v, ws.members), E = c.aX.simpleSegment(0, 0, 4, 2), I = new c.aY; I.emplaceBack(1, 0, 2), I.emplaceBack(1, 2, 3); const A = t.createIndexBuffer(I); return this._cachedMesh = new sr(T, A, E), this._cachedMesh } recalculate() { } hasTransition() { return !1 } setErrorQueryLatitudeDegrees(t) { } } class Ro { constructor(t = 0, s = 0, l = 0, d = 0) { if (isNaN(t) || t < 0 || isNaN(s) || s < 0 || isNaN(l) || l < 0 || isNaN(d) || d < 0) throw new Error("Invalid value for edge-insets, top, bottom, left and right must all be numbers"); this.top = t, this.bottom = s, this.left = l, this.right = d } interpolate(t, s, l) { return s.top != null && t.top != null && (this.top = c.G.number(t.top, s.top, l)), s.bottom != null && t.bottom != null && (this.bottom = c.G.number(t.bottom, s.bottom, l)), s.left != null && t.left != null && (this.left = c.G.number(t.left, s.left, l)), s.right != null && t.right != null && (this.right = c.G.number(t.right, s.right, l)), this } getCenter(t, s) { const l = c.an((this.left + t - this.right) / 2, 0, t), d = c.an((this.top + s - this.bottom) / 2, 0, s); return new c.P(l, d) } equals(t) { return this.top === t.top && this.bottom === t.bottom && this.left === t.left && this.right === t.right } clone() { return new Ro(this.top, this.bottom, this.left, this.right) } toJSON() { return { top: this.top, bottom: this.bottom, left: this.left, right: this.right } } } function bs(m, t) { if (!m.renderWorldCopies || m.lngRange) return; const s = t.lng - m.center.lng; t.lng += s > 180 ? -360 : s < -180 ? 360 : 0 } function Lr(m) { return Math.max(0, Math.floor(m)) } class qs { constructor(t, s) { var l; this.applyConstrain = (d, g) => this._constrainOverride !== null ? this._constrainOverride(d, g) : this._callbacks.defaultConstrain(d, g), this._callbacks = t, this._tileSize = 512, this._renderWorldCopies = (s == null ? void 0 : s.renderWorldCopies) === void 0 || !!(s != null && s.renderWorldCopies), this._minZoom = (s == null ? void 0 : s.minZoom) || 0, this._maxZoom = (s == null ? void 0 : s.maxZoom) || 22, this._minPitch = (s == null ? void 0 : s.minPitch) == null ? 0 : s == null ? void 0 : s.minPitch, this._maxPitch = (s == null ? void 0 : s.maxPitch) == null ? 60 : s == null ? void 0 : s.maxPitch, this._constrainOverride = (l = s == null ? void 0 : s.constrainOverride) !== null && l !== void 0 ? l : null, this.setMaxBounds(), this._width = 0, this._height = 0, this._center = new c.V(0, 0), this._elevation = 0, this._zoom = 0, this._tileZoom = Lr(this._zoom), this._scale = c.aq(this._zoom), this._bearingInRadians = 0, this._fovInRadians = .6435011087932844, this._pitchInRadians = 0, this._rollInRadians = 0, this._unmodified = !0, this._edgeInsets = new Ro, this._minElevationForCurrentTile = 0, this._autoCalculateNearFarZ = !0 } apply(t, s, l) { this._constrainOverride = t.constrainOverride, this._latRange = t.latRange, this._lngRange = t.lngRange, this._width = t.width, this._height = t.height, this._center = t.center, this._elevation = t.elevation, this._minElevationForCurrentTile = t.minElevationForCurrentTile, this._zoom = t.zoom, this._tileZoom = Lr(this._zoom), this._scale = c.aq(this._zoom), this._bearingInRadians = t.bearingInRadians, this._fovInRadians = t.fovInRadians, this._pitchInRadians = t.pitchInRadians, this._rollInRadians = t.rollInRadians, this._unmodified = t.unmodified, this._edgeInsets = new Ro(t.padding.top, t.padding.bottom, t.padding.left, t.padding.right), this._minZoom = t.minZoom, this._maxZoom = t.maxZoom, this._minPitch = t.minPitch, this._maxPitch = t.maxPitch, this._renderWorldCopies = t.renderWorldCopies, this._cameraToCenterDistance = t.cameraToCenterDistance, this._nearZ = t.nearZ, this._farZ = t.farZ, this._autoCalculateNearFarZ = !l && t.autoCalculateNearFarZ, s && this.constrainInternal(), this._calcMatrices() } get pixelsToClipSpaceMatrix() { return this._pixelsToClipSpaceMatrix } get clipSpaceToPixelsMatrix() { return this._clipSpaceToPixelsMatrix } get minElevationForCurrentTile() { return this._minElevationForCurrentTile } setMinElevationForCurrentTile(t) { this._minElevationForCurrentTile = t } get tileSize() { return this._tileSize } get tileZoom() { return this._tileZoom } get scale() { return this._scale } get width() { return this._width } get height() { return this._height } get bearingInRadians() { return this._bearingInRadians } get lngRange() { return this._lngRange } get latRange() { return this._latRange } get pixelsToGLUnits() { return this._pixelsToGLUnits } get minZoom() { return this._minZoom } setMinZoom(t) { this._minZoom !== t && (this._minZoom = t, this.setZoom(this.applyConstrain(this._center, this.zoom).zoom)) } get maxZoom() { return this._maxZoom } setMaxZoom(t) { this._maxZoom !== t && (this._maxZoom = t, this.setZoom(this.applyConstrain(this._center, this.zoom).zoom)) } get minPitch() { return this._minPitch } setMinPitch(t) { this._minPitch !== t && (this._minPitch = t, this.setPitch(Math.max(this.pitch, t))) } get maxPitch() { return this._maxPitch } setMaxPitch(t) { this._maxPitch !== t && (this._maxPitch = t, this.setPitch(Math.min(this.pitch, t))) } get renderWorldCopies() { return this._renderWorldCopies } setRenderWorldCopies(t) { t === void 0 ? t = !0 : t === null && (t = !1), this._renderWorldCopies = t } get constrainOverride() { return this._constrainOverride } setConstrainOverride(t) { t === void 0 && (t = null), this._constrainOverride !== t && (this._constrainOverride = t, this.constrainInternal(), this._calcMatrices()) } get worldSize() { return this._tileSize * this._scale } get centerOffset() { return this.centerPoint._sub(this.size._div(2)) } get size() { return new c.P(this._width, this._height) } get bearing() { return this._bearingInRadians / Math.PI * 180 } setBearing(t) { const s = c.W(t, -180, 180) * Math.PI / 180; var l, d, g, v, T, E, I, A, R; this._bearingInRadians !== s && (this._unmodified = !1, this._bearingInRadians = s, this._calcMatrices(), this._rotationMatrix = $(), l = this._rotationMatrix, g = -this._bearingInRadians, v = (d = this._rotationMatrix)[0], T = d[1], E = d[2], I = d[3], A = Math.sin(g), R = Math.cos(g), l[0] = v * R + E * A, l[1] = T * R + I * A, l[2] = v * -A + E * R, l[3] = T * -A + I * R) } get rotationMatrix() { return this._rotationMatrix } get pitchInRadians() { return this._pitchInRadians } get pitch() { return this._pitchInRadians / Math.PI * 180 } setPitch(t) { const s = c.an(t, this.minPitch, this.maxPitch) / 180 * Math.PI; this._pitchInRadians !== s && (this._unmodified = !1, this._pitchInRadians = s, this._calcMatrices()) } get rollInRadians() { return this._rollInRadians } get roll() { return this._rollInRadians / Math.PI * 180 } setRoll(t) { const s = t / 180 * Math.PI; this._rollInRadians !== s && (this._unmodified = !1, this._rollInRadians = s, this._calcMatrices()) } get fovInRadians() { return this._fovInRadians } get fov() { return c.aZ(this._fovInRadians) } setFov(t) { t = c.an(t, .1, 150), this.fov !== t && (this._unmodified = !1, this._fovInRadians = c.ap(t), this._calcMatrices()) } get zoom() { return this._zoom } setZoom(t) { const s = this.applyConstrain(this._center, t).zoom; this._zoom !== s && (this._unmodified = !1, this._zoom = s, this._tileZoom = Math.max(0, Math.floor(s)), this._scale = c.aq(s), this.constrainInternal(), this._calcMatrices()) } get center() { return this._center } setCenter(t) { t.lat === this._center.lat && t.lng === this._center.lng || (this._unmodified = !1, this._center = t, this.constrainInternal(), this._calcMatrices()) } get elevation() { return this._elevation } setElevation(t) { t !== this._elevation && (this._elevation = t, this.constrainInternal(), this._calcMatrices()) } get padding() { return this._edgeInsets.toJSON() } setPadding(t) { this._edgeInsets.equals(t) || (this._unmodified = !1, this._edgeInsets.interpolate(this._edgeInsets, t, 1), this._calcMatrices()) } get centerPoint() { return this._edgeInsets.getCenter(this._width, this._height) } get pixelsPerMeter() { return this._pixelPerMeter } get unmodified() { return this._unmodified } get cameraToCenterDistance() { return this._cameraToCenterDistance } get nearZ() { return this._nearZ } get farZ() { return this._farZ } get autoCalculateNearFarZ() { return this._autoCalculateNearFarZ } overrideNearFarZ(t, s) { this._autoCalculateNearFarZ = !1, this._nearZ = t, this._farZ = s, this._calcMatrices() } clearNearFarZOverride() { this._autoCalculateNearFarZ = !0, this._calcMatrices() } isPaddingEqual(t) { return this._edgeInsets.equals(t) } interpolatePadding(t, s, l) { this._unmodified = !1, this._edgeInsets.interpolate(t, s, l), this.constrainInternal(), this._calcMatrices() } resize(t, s, l = !0) { this._width = t, this._height = s, l && this.constrainInternal(), this._calcMatrices() } getMaxBounds() { return this._latRange && this._latRange.length === 2 && this._lngRange && this._lngRange.length === 2 ? new Pr([this._lngRange[0], this._latRange[0]], [this._lngRange[1], this._latRange[1]]) : null } setMaxBounds(t) { t ? (this._lngRange = [t.getWest(), t.getEast()], this._latRange = [t.getSouth(), t.getNorth()], this.constrainInternal()) : (this._lngRange = null, this._latRange = [-c.ao, c.ao]) } getCameraQueryGeometry(t, s) { if (s.length === 1) return [s[0], t]; { const { minX: l, minY: d, maxX: g, maxY: v } = c.aa.fromPoints(s).extend(t); return [new c.P(l, d), new c.P(g, d), new c.P(g, v), new c.P(l, v), new c.P(l, d)] } } constrainInternal() { if (!this.center || !this._width || !this._height || this._constraining) return; this._constraining = !0; const t = this._unmodified, { center: s, zoom: l } = this.applyConstrain(this.center, this.zoom); this.setCenter(s), this.setZoom(l), this._unmodified = t, this._constraining = !1 } _calcMatrices() { if (this._width && this._height) { this._pixelsToGLUnits = [2 / this._width, -2 / this._height]; let t = c.ar(new Float64Array(16)); c.Q(t, t, [this._width / 2, -this._height / 2, 1]), c.O(t, t, [1, -1, 0]), this._clipSpaceToPixelsMatrix = t, t = c.ar(new Float64Array(16)), c.Q(t, t, [1, -1, 1]), c.O(t, t, [-1, -1, 0]), c.Q(t, t, [2 / this._width, 2 / this._height, 1]), this._pixelsToClipSpaceMatrix = t, this._cameraToCenterDistance = .5 / Math.tan(this.fovInRadians / 2) * this._height } this._callbacks.calcMatrices() } calculateCenterFromCameraLngLatAlt(t, s, l, d) { const g = l !== void 0 ? l : this.bearing, v = d = d !== void 0 ? d : this.pitch, { distanceToCenter: T, clampedElevation: E } = this._distanceToCenterFromAltElevationPitch(s, this.elevation, v), { x: I, y: A } = nr(v, g), R = c.a9.fromLngLat(t, s); let z, O, U = c.a_(1, R.y), X = 0; do { if (X += 1, X > 10) break; O = T / U, z = new c.a9(R.x + I * O, R.y + A * O), U = 1 / z.meterInMercatorCoordinateUnits() } while (Math.abs(T - O * U) > 1e-12); return { center: z.toLngLat(), elevation: E, zoom: c.at(this.height / 2 / Math.tan(this.fovInRadians / 2) / O / this.tileSize) } } recalculateZoomAndCenter(t) { if (this.elevation - t == 0) return; const s = 1 / this.worldSize, l = c.as(1, this.center.lat) * this.worldSize, d = c.a9.fromLngLat(this.center, this.elevation), g = d.x / s, v = d.y / s, T = d.z / s, E = this.pitch, I = this.bearing, { x: A, y: R, z } = nr(E, I), O = this.cameraToCenterDistance, U = g + O * -A, X = v + O * -R, Q = T + O * z, { distanceToCenter: Y, clampedElevation: te } = this._distanceToCenterFromAltElevationPitch(Q / l, t, E), le = Y * l, J = new c.a9((U + A * le) * s, (X + R * le) * s, 0).toLngLat(), oe = c.as(1, J.lat), ce = c.at(this.height / 2 / Math.tan(this.fovInRadians / 2) / Y / oe / this.tileSize); this._elevation = te, this._center = J, this.setZoom(ce) } _distanceToCenterFromAltElevationPitch(t, s, l) { const d = -Math.cos(c.ap(l)), g = t - s; let v, T = s; return d * g >= 0 || Math.abs(d) < .1 ? (v = 1e4, T = t + v * d) : v = -g / d, { distanceToCenter: v, clampedElevation: T } } getCameraPoint() { const t = Math.tan(this.pitchInRadians) * (this.cameraToCenterDistance || 1); return this.centerPoint.add(new c.P(t * Math.sin(this.rollInRadians), t * Math.cos(this.rollInRadians))) } getCameraAltitude() { return Math.cos(this.pitchInRadians) * this._cameraToCenterDistance / this._pixelPerMeter + this.elevation } getCameraLngLat() { const t = c.as(1, this.center.lat) * this.worldSize; return De(this.center, this.elevation, this.pitch, this.bearing, this.cameraToCenterDistance / t).toLngLat() } getMercatorTileCoordinates(t) { if (!t) return [0, 0, 1, 1]; const s = t.canonical.z >= 0 ? 1 << t.canonical.z : Math.pow(2, t.canonical.z); return [t.canonical.x / s, t.canonical.y / s, 1 / s / c.a5, 1 / s / c.a5] } } class ji { constructor(t, s) { this.min = t, this.max = s, this.center = c.a$([], c.b0([], this.min, this.max), .5) } quadrant(t) { const s = [t % 2 == 0, t < 2], l = c.b1(this.min), d = c.b1(this.max); for (let g = 0; g < s.length; g++)l[g] = s[g] ? this.min[g] : this.center[g], d[g] = s[g] ? this.center[g] : this.max[g]; return d[2] = this.max[2], new ji(l, d) } distanceX(t) { return Math.max(Math.min(this.max[0], t[0]), this.min[0]) - t[0] } distanceY(t) { return Math.max(Math.min(this.max[1], t[1]), this.min[1]) - t[1] } intersectsFrustum(t) { let s = !0; for (let l = 0; l < t.planes.length; l++) { const d = this.intersectsPlane(t.planes[l]); if (d === 0) return 0; d === 1 && (s = !1) } return s ? 2 : t.aabb.min[0] > this.max[0] || t.aabb.min[1] > this.max[1] || t.aabb.min[2] > this.max[2] || t.aabb.max[0] < this.min[0] || t.aabb.max[1] < this.min[1] || t.aabb.max[2] < this.min[2] ? 0 : 1 } intersectsPlane(t) { let s = t[3], l = t[3]; for (let d = 0; d < 3; d++)t[d] > 0 ? (s += t[d] * this.min[d], l += t[d] * this.max[d]) : (l += t[d] * this.min[d], s += t[d] * this.max[d]); return s >= 0 ? 2 : l < 0 ? 0 : 1 } } class Xl { distanceToTile2d(t, s, l, d) { const g = d.distanceX([t, s]), v = d.distanceY([t, s]); return Math.hypot(g, v) } getWrap(t, s, l) { return l } getTileBoundingVolume(t, s, l, d) { var g, v; let T = 0, E = 0; if (d != null && d.terrain) { const A = new c.a2(t.z, s, t.z, t.x, t.y), R = d.terrain.getMinMaxElevation(A); T = (g = R.minElevation) !== null && g !== void 0 ? g : Math.min(0, l), E = (v = R.maxElevation) !== null && v !== void 0 ? v : Math.max(0, l) } const I = 1 << t.z; return new ji([s + t.x / I, t.y / I, T], [s + (t.x + 1) / I, (t.y + 1) / I, E]) } allowVariableZoom(t, s) { const l = t.fov * (Math.abs(Math.cos(t.rollInRadians)) * t.height + Math.abs(Math.sin(t.rollInRadians)) * t.width) / t.height, d = c.an(78.5 - l / 2, 0, 60); return !!s.terrain || t.pitch > d } allowWorldCopies() { return !0 } prepareNextFrame() { } } class Un { constructor(t, s, l) { this.points = t, this.planes = s, this.aabb = l } static fromInvProjectionMatrix(t, s = 1, l = 0, d, g) { const v = g ? [[6, 5, 4], [0, 1, 2], [0, 3, 7], [2, 1, 5], [3, 2, 6], [0, 4, 5]] : [[0, 1, 2], [6, 5, 4], [0, 3, 7], [2, 1, 5], [3, 2, 6], [0, 4, 5]], T = Math.pow(2, l), E = [[-1, 1, -1, 1], [1, 1, -1, 1], [1, -1, -1, 1], [-1, -1, -1, 1], [-1, 1, 1, 1], [1, 1, 1, 1], [1, -1, 1, 1], [-1, -1, 1, 1]].map(z => function (O, U, X, Q) { const Y = c.aH([], O, U), te = 1 / Y[3] / X * Q; return c.b6(Y, Y, [te, te, 1 / Y[3], te]) }(z, t, s, T)); d && function (z, O, U, X) { const Q = X ? 4 : 0, Y = X ? 0 : 4; let te = 0; const le = [], J = []; for (let se = 0; se < 4; se++) { const fe = c.b2([], z[se + Y], z[se + Q]), Oe = c.b7(fe); c.a$(fe, fe, 1 / Oe), le.push(Oe), J.push(fe) } for (let se = 0; se < 4; se++) { const fe = c.b8(z[se + Q], J[se], U); te = fe !== null && fe >= 0 ? Math.max(te, fe) : Math.max(te, le[se]) } const oe = function (se, fe) { const Oe = c.b2([], se[fe[0]], se[fe[1]]), ke = c.b2([], se[fe[2]], se[fe[1]]), ze = [0, 0, 0, 0]; return c.b3(ze, c.b4([], Oe, ke)), ze[3] = -c.b5(ze, se[fe[0]]), ze }(z, O), ce = function (se, fe) { const Oe = c.b9(se), ke = c.ba([], se, 1 / Oe), ze = c.b2([], fe, c.a$([], ke, c.b5(fe, ke))), Re = c.b9(ze); if (Re > 0) { const Je = Math.sqrt(1 - ke[3] * ke[3]), tt = c.a$([], ke, -ke[3]), We = c.b0([], tt, c.a$([], ze, Je / Re)); return c.bb(fe, We) } return null }(U, oe); if (ce !== null) { const se = ce / c.b5(J[0], oe); te = Math.min(te, se) } for (let se = 0; se < 4; se++) { const fe = Math.min(te, le[se]); z[se + Y] = [z[se + Q][0] + J[se][0] * fe, z[se + Q][1] + J[se][1] * fe, z[se + Q][2] + J[se][2] * fe, 1] } }(E, v[0], d, g); const I = v.map(z => { const O = c.b2([], E[z[0]], E[z[1]]), U = c.b2([], E[z[2]], E[z[1]]), X = c.b3([], c.b4([], O, U)), Q = -c.b5(X, E[z[1]]); return X.concat(Q) }), A = [Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY], R = [Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY]; for (const z of E) for (let O = 0; O < 3; O++)A[O] = Math.min(A[O], z[O]), R[O] = Math.max(R[O], z[O]); return new Un(E, I, new ji(A, R)) } } class Zs { get pixelsToClipSpaceMatrix() { return this._helper.pixelsToClipSpaceMatrix } get clipSpaceToPixelsMatrix() { return this._helper.clipSpaceToPixelsMatrix } get pixelsToGLUnits() { return this._helper.pixelsToGLUnits } get centerOffset() { return this._helper.centerOffset } get size() { return this._helper.size } get rotationMatrix() { return this._helper.rotationMatrix } get centerPoint() { return this._helper.centerPoint } get pixelsPerMeter() { return this._helper.pixelsPerMeter } setMinZoom(t) { this._helper.setMinZoom(t) } setMaxZoom(t) { this._helper.setMaxZoom(t) } setMinPitch(t) { this._helper.setMinPitch(t) } setMaxPitch(t) { this._helper.setMaxPitch(t) } setRenderWorldCopies(t) { this._helper.setRenderWorldCopies(t) } setBearing(t) { this._helper.setBearing(t) } setPitch(t) { this._helper.setPitch(t) } setRoll(t) { this._helper.setRoll(t) } setFov(t) { this._helper.setFov(t) } setZoom(t) { this._helper.setZoom(t) } setCenter(t) { this._helper.setCenter(t) } setElevation(t) { this._helper.setElevation(t) } setMinElevationForCurrentTile(t) { this._helper.setMinElevationForCurrentTile(t) } setPadding(t) { this._helper.setPadding(t) } interpolatePadding(t, s, l) { return this._helper.interpolatePadding(t, s, l) } isPaddingEqual(t) { return this._helper.isPaddingEqual(t) } resize(t, s, l = !0) { this._helper.resize(t, s, l) } getMaxBounds() { return this._helper.getMaxBounds() } setMaxBounds(t) { this._helper.setMaxBounds(t) } setConstrainOverride(t) { this._helper.setConstrainOverride(t) } overrideNearFarZ(t, s) { this._helper.overrideNearFarZ(t, s) } clearNearFarZOverride() { this._helper.clearNearFarZOverride() } getCameraQueryGeometry(t) { return this._helper.getCameraQueryGeometry(this.getCameraPoint(), t) } get tileSize() { return this._helper.tileSize } get tileZoom() { return this._helper.tileZoom } get scale() { return this._helper.scale } get worldSize() { return this._helper.worldSize } get width() { return this._helper.width } get height() { return this._helper.height } get lngRange() { return this._helper.lngRange } get latRange() { return this._helper.latRange } get minZoom() { return this._helper.minZoom } get maxZoom() { return this._helper.maxZoom } get zoom() { return this._helper.zoom } get center() { return this._helper.center } get minPitch() { return this._helper.minPitch } get maxPitch() { return this._helper.maxPitch } get pitch() { return this._helper.pitch } get pitchInRadians() { return this._helper.pitchInRadians } get roll() { return this._helper.roll } get rollInRadians() { return this._helper.rollInRadians } get bearing() { return this._helper.bearing } get bearingInRadians() { return this._helper.bearingInRadians } get fov() { return this._helper.fov } get fovInRadians() { return this._helper.fovInRadians } get elevation() { return this._helper.elevation } get minElevationForCurrentTile() { return this._helper.minElevationForCurrentTile } get padding() { return this._helper.padding } get unmodified() { return this._helper.unmodified } get renderWorldCopies() { return this._helper.renderWorldCopies } get cameraToCenterDistance() { return this._helper.cameraToCenterDistance } get constrainOverride() { return this._helper.constrainOverride } get nearZ() { return this._helper.nearZ } get farZ() { return this._helper.farZ } get autoCalculateNearFarZ() { return this._helper.autoCalculateNearFarZ } setTransitionState(t, s) { } constructor(t) { this._posMatrixCache = new Map, this._alignedPosMatrixCache = new Map, this._fogMatrixCacheF32 = new Map, this.defaultConstrain = (s, l) => { l = c.an(+l, this.minZoom, this.maxZoom); const d = { center: new c.V(s.lng, s.lat), zoom: l }; let g = this._helper._lngRange; if (!this._helper._renderWorldCopies && g === null) { const J = 179.9999999999; g = [-J, J] } const v = this.tileSize * c.aq(d.zoom); let T = 0, E = v, I = 0, A = v, R = 0, z = 0; const { x: O, y: U } = this.size; if (this._helper._latRange) { const J = this._helper._latRange; T = c.X(J[1]) * v, E = c.X(J[0]) * v, E - T < U && (R = U / (E - T)) } g && (I = c.W(c.Y(g[0]) * v, 0, v), A = c.W(c.Y(g[1]) * v, 0, v), A < I && (A += v), A - I < O && (z = O / (A - I))); const { x: X, y: Q } = yt(v, s); let Y, te; const le = Math.max(z || 0, R || 0); if (le) { const J = new c.P(z ? (A + I) / 2 : X, R ? (E + T) / 2 : Q); return d.center = Pt(v, J).wrap(), d.zoom += c.at(le), d } if (this._helper._latRange) { const J = U / 2; Q - J < T && (te = T + J), Q + J > E && (te = E - J) } if (g) { const J = (I + A) / 2; let oe = X; this._helper._renderWorldCopies && (oe = c.W(X, J - v / 2, J + v / 2)); const ce = O / 2; oe - ce < I && (Y = I + ce), oe + ce > A && (Y = A - ce) } if (Y !== void 0 || te !== void 0) { const J = new c.P(Y ?? X, te ?? Q); d.center = Pt(v, J).wrap() } return d }, this.applyConstrain = (s, l) => this._helper.applyConstrain(s, l), this._helper = new qs({ calcMatrices: () => { this._calcMatrices() }, defaultConstrain: (s, l) => this.defaultConstrain(s, l) }, t), this._coveringTilesDetailsProvider = new Xl } clone() { const t = new Zs; return t.apply(this), t } apply(t, s, l) { this._helper.apply(t, s, l) } get cameraPosition() { return this._cameraPosition } get projectionMatrix() { return this._projectionMatrix } get modelViewProjectionMatrix() { return this._viewProjMatrix } get inverseProjectionMatrix() { return this._invProjMatrix } get mercatorMatrix() { return this._mercatorMatrix } getVisibleUnwrappedCoordinates(t) { const s = [new c.bc(0, t)]; if (this._helper._renderWorldCopies) { const l = this.screenPointToMercatorCoordinate(new c.P(0, 0)), d = this.screenPointToMercatorCoordinate(new c.P(this._helper._width, 0)), g = this.screenPointToMercatorCoordinate(new c.P(this._helper._width, this._helper._height)), v = this.screenPointToMercatorCoordinate(new c.P(0, this._helper._height)), T = Math.floor(Math.min(l.x, d.x, g.x, v.x)), E = Math.floor(Math.max(l.x, d.x, g.x, v.x)), I = 1; for (let A = T - I; A <= E + I; A++)A !== 0 && s.push(new c.bc(A, t)) } return s } getCameraFrustum() { return Un.fromInvProjectionMatrix(this._invViewProjMatrix, this.worldSize) } getClippingPlane() { return null } getCoveringTilesDetailsProvider() { return this._coveringTilesDetailsProvider } recalculateZoomAndCenter(t) { const s = this.screenPointToLocation(this.centerPoint, t), l = t ? t.getElevationForLngLatZoom(s, this._helper._tileZoom) : 0; this._helper.recalculateZoomAndCenter(l) } setLocationAtPoint(t, s) { const l = c.as(this.elevation, this.center.lat), d = this.screenPointToMercatorCoordinateAtZ(s, l), g = this.screenPointToMercatorCoordinateAtZ(this.centerPoint, l), v = c.a9.fromLngLat(t), T = new c.a9(v.x - (d.x - g.x), v.y - (d.y - g.y)); this.setCenter(T == null ? void 0 : T.toLngLat()), this._helper._renderWorldCopies && this.setCenter(this.center.wrap()) } locationToScreenPoint(t, s) { return s ? this.coordinatePoint(c.a9.fromLngLat(t), s.getElevationForLngLat(t, this), this._pixelMatrix3D) : this.coordinatePoint(c.a9.fromLngLat(t)) } screenPointToLocation(t, s) { var l; return (l = this.screenPointToMercatorCoordinate(t, s)) === null || l === void 0 ? void 0 : l.toLngLat() } screenPointToMercatorCoordinate(t, s) { if (s) { const l = s.pointCoordinate(t); if (l != null) return l } return this.screenPointToMercatorCoordinateAtZ(t) } screenPointToMercatorCoordinateAtZ(t, s) { const l = s || 0, d = [t.x, t.y, 0, 1], g = [t.x, t.y, 1, 1]; c.aH(d, d, this._pixelMatrixInverse), c.aH(g, g, this._pixelMatrixInverse); const v = d[3], T = g[3], E = d[1] / v, I = g[1] / T, A = d[2] / v, R = g[2] / T, z = A === R ? 0 : (l - A) / (R - A); return new c.a9(c.G.number(d[0] / v, g[0] / T, z) / this.worldSize, c.G.number(E, I, z) / this.worldSize, l) } coordinatePoint(t, s = 0, l = this._pixelMatrix) { const d = [t.x * this.worldSize, t.y * this.worldSize, s, 1]; return c.aH(d, d, l), new c.P(d[0] / d[3], d[1] / d[3]) } getBounds() { const t = Math.max(0, this._helper._height / 2 - tr(this)); return new Pr().extend(this.screenPointToLocation(new c.P(0, t))).extend(this.screenPointToLocation(new c.P(this._helper._width, t))).extend(this.screenPointToLocation(new c.P(this._helper._width, this._helper._height))).extend(this.screenPointToLocation(new c.P(0, this._helper._height))) } isPointOnMapSurface(t, s) { return s ? s.pointCoordinate(t) != null : t.y > this.height / 2 - tr(this) } calculatePosMatrix(t, s = !1, l) { var d; const g = (d = t.key) !== null && d !== void 0 ? d : c.bd(t.wrap, t.canonical.z, t.canonical.z, t.canonical.x, t.canonical.y), v = s ? this._alignedPosMatrixCache : this._posMatrixCache; if (v.has(g)) { const I = v.get(g); return l ? I.f32 : I.f64 } const T = Wt(t, this.worldSize); c.S(T, s ? this._alignedProjMatrix : this._viewProjMatrix, T); const E = { f64: T, f32: new Float32Array(T) }; return v.set(g, E), l ? E.f32 : E.f64 } calculateFogMatrix(t) { const s = t.key, l = this._fogMatrixCacheF32; if (l.has(s)) return l.get(s); const d = Wt(t, this.worldSize); return c.S(d, this._fogMatrix, d), l.set(s, new Float32Array(d)), l.get(s) } calculateCenterFromCameraLngLatAlt(t, s, l, d) { return this._helper.calculateCenterFromCameraLngLatAlt(t, s, l, d) } _calculateNearFarZIfNeeded(t, s, l) { if (!this._helper.autoCalculateNearFarZ) return; const d = Math.min(this.elevation, this.minElevationForCurrentTile, this.getCameraAltitude() - 100), g = t - d * this._helper._pixelPerMeter / Math.cos(s), v = d < 0 ? g : t, T = Math.PI / 2 + this.pitchInRadians, E = c.ap(this.fov) * (Math.abs(Math.cos(c.ap(this.roll))) * this.height + Math.abs(Math.sin(c.ap(this.roll))) * this.width) / this.height * (.5 + l.y / this.height), I = Math.sin(E) * v / Math.sin(c.an(Math.PI - T - E, .01, Math.PI - .01)), A = tr(this), R = Math.atan(A / this._helper.cameraToCenterDistance), z = c.ap(.75), O = R > z ? 2 * R * (.5 + l.y / (2 * A)) : z, U = Math.sin(O) * v / Math.sin(c.an(Math.PI - T - O, .01, Math.PI - .01)), X = Math.min(I, U); this._helper._farZ = 1.01 * (Math.cos(Math.PI / 2 - s) * X + v), this._helper._nearZ = this._helper._height / 50 } _calcMatrices() { if (!this._helper._height) return; const t = this.centerOffset, s = yt(this.worldSize, this.center), l = s.x, d = s.y; this._helper._pixelPerMeter = c.as(1, this.center.lat) * this.worldSize; const g = c.ap(Math.min(this.pitch, ht)), v = Math.max(this._helper.cameraToCenterDistance / 2, this._helper.cameraToCenterDistance + this._helper._elevation * this._helper._pixelPerMeter / Math.cos(g)); let T; this._calculateNearFarZIfNeeded(v, g, t), T = new Float64Array(16), c.be(T, this.fovInRadians, this._helper._width / this._helper._height, this._helper._nearZ, this._helper._farZ), this._invProjMatrix = new Float64Array(16), c.aB(this._invProjMatrix, T), T[8] = 2 * -t.x / this._helper._width, T[9] = 2 * t.y / this._helper._height, this._projectionMatrix = c.bf(T), c.Q(T, T, [1, -1, 1]), c.O(T, T, [0, 0, -this._helper.cameraToCenterDistance]), c.bg(T, T, -this.rollInRadians), c.bh(T, T, this.pitchInRadians), c.bg(T, T, -this.bearingInRadians), c.O(T, T, [-l, -d, 0]), this._mercatorMatrix = c.Q([], T, [this.worldSize, this.worldSize, this.worldSize]), c.Q(T, T, [1, 1, this._helper._pixelPerMeter]), this._pixelMatrix = c.S(new Float64Array(16), this.clipSpaceToPixelsMatrix, T), c.O(T, T, [0, 0, -this.elevation]), this._viewProjMatrix = T, this._invViewProjMatrix = c.aB([], T); const E = [0, 0, -1, 1]; c.aH(E, E, this._invViewProjMatrix), this._cameraPosition = [E[0] / E[3], E[1] / E[3], E[2] / E[3]], this._fogMatrix = new Float64Array(16), c.be(this._fogMatrix, this.fovInRadians, this.width / this.height, v, this._helper._farZ), this._fogMatrix[8] = 2 * -t.x / this.width, this._fogMatrix[9] = 2 * t.y / this.height, c.Q(this._fogMatrix, this._fogMatrix, [1, -1, 1]), c.O(this._fogMatrix, this._fogMatrix, [0, 0, -this.cameraToCenterDistance]), c.bg(this._fogMatrix, this._fogMatrix, -this.rollInRadians), c.bh(this._fogMatrix, this._fogMatrix, this.pitchInRadians), c.bg(this._fogMatrix, this._fogMatrix, -this.bearingInRadians), c.O(this._fogMatrix, this._fogMatrix, [-l, -d, 0]), c.Q(this._fogMatrix, this._fogMatrix, [1, 1, this._helper._pixelPerMeter]), c.O(this._fogMatrix, this._fogMatrix, [0, 0, -this.elevation]), this._pixelMatrix3D = c.S(new Float64Array(16), this.clipSpaceToPixelsMatrix, T); const I = this._helper._width % 2 / 2, A = this._helper._height % 2 / 2, R = Math.cos(this.bearingInRadians), z = Math.sin(-this.bearingInRadians), O = l - Math.round(l) + R * I + z * A, U = d - Math.round(d) + R * A + z * I, X = new Float64Array(T); if (c.O(X, X, [O > .5 ? O - 1 : O, U > .5 ? U - 1 : U, 0]), this._alignedProjMatrix = X, T = c.aB(new Float64Array(16), this._pixelMatrix), !T) throw new Error("failed to invert matrix"); this._pixelMatrixInverse = T, this._clearMatrixCaches() } _clearMatrixCaches() { this._posMatrixCache.clear(), this._alignedPosMatrixCache.clear(), this._fogMatrixCacheF32.clear() } maxPitchScaleFactor() { if (!this._pixelMatrixInverse) return 1; const t = this.screenPointToMercatorCoordinate(new c.P(0, 0)), s = [t.x * this.worldSize, t.y * this.worldSize, 0, 1]; return c.aH(s, s, this._pixelMatrix)[3] / this._helper.cameraToCenterDistance } getCameraPoint() { return this._helper.getCameraPoint() } getCameraAltitude() { return this._helper.getCameraAltitude() } getCameraLngLat() { const t = c.as(1, this.center.lat) * this.worldSize; return De(this.center, this.elevation, this.pitch, this.bearing, this._helper.cameraToCenterDistance / t).toLngLat() } lngLatToCameraDepth(t, s) { const l = c.a9.fromLngLat(t), d = [l.x * this.worldSize, l.y * this.worldSize, s, 1]; return c.aH(d, d, this._viewProjMatrix), d[2] / d[3] } getProjectionData(t) { const { overscaledTileID: s, aligned: l, applyTerrainMatrix: d } = t, g = this._helper.getMercatorTileCoordinates(s), v = s ? this.calculatePosMatrix(s, l, !0) : null; let T; return T = s && s.terrainRttPosMatrix32f && d ? s.terrainRttPosMatrix32f : v || c.bi(), { mainMatrix: T, tileMercatorCoords: g, clippingPlane: [0, 0, 0, 0], projectionTransition: 0, fallbackMatrix: T } } isLocationOccluded(t) { return !1 } getPixelScale() { return 1 } getCircleRadiusCorrection() { return 1 } getPitchedTextCorrection(t, s, l) { return 1 } transformLightDirection(t) { return c.b1(t) } getRayDirectionFromPixel(t) { throw new Error("Not implemented.") } projectTileCoordinates(t, s, l, d) { const g = this.calculatePosMatrix(l); let v; d ? (v = [t, s, d(t, s), 1], c.aH(v, v, g)) : (v = [t, s, 0, 1], Zl(v, v, g)); const T = v[3]; return { point: new c.P(v[0] / T, v[1] / T), signedDistanceFromCamera: T, isOccluded: !1 } } populateCache(t) { for (const s of t) this.calculatePosMatrix(s) } getMatrixForModel(t, s) { const l = c.a9.fromLngLat(t, s), d = l.meterInMercatorCoordinateUnits(), g = c.bj(); return c.O(g, g, [l.x, l.y, l.z]), c.bg(g, g, Math.PI), c.bh(g, g, Math.PI / 2), c.Q(g, g, [-d, d, d]), g } getProjectionDataForCustomLayer(t = !0) { const s = new c.a2(0, 0, 0, 0, 0), l = this.getProjectionData({ overscaledTileID: s, applyGlobeMatrix: t }), d = Wt(s, this.worldSize); c.S(d, this._viewProjMatrix, d), l.tileMercatorCoords = [0, 0, 1, 1]; const g = [c.a5, c.a5, this.worldSize / this._helper.pixelsPerMeter], v = c.bk(); return c.Q(v, d, g), l.fallbackMatrix = v, l.mainMatrix = v, l } getFastPathSimpleProjectionMatrix(t) { return this.calculatePosMatrix(t) } } function ts() { c.w("Map cannot fit within canvas with the given bounds, padding, and/or offset.") } function $d(m) { if (m.useSlerp) if (m.k < 1) { const t = c.bl(m.startEulerAngles.roll, m.startEulerAngles.pitch, m.startEulerAngles.bearing), s = c.bl(m.endEulerAngles.roll, m.endEulerAngles.pitch, m.endEulerAngles.bearing), l = new Float64Array(4); c.bm(l, t, s, m.k); const d = c.bn(l); m.tr.setRoll(d.roll), m.tr.setPitch(d.pitch), m.tr.setBearing(d.bearing) } else m.tr.setRoll(m.endEulerAngles.roll), m.tr.setPitch(m.endEulerAngles.pitch), m.tr.setBearing(m.endEulerAngles.bearing); else m.tr.setRoll(c.G.number(m.startEulerAngles.roll, m.endEulerAngles.roll, m.k)), m.tr.setPitch(c.G.number(m.startEulerAngles.pitch, m.endEulerAngles.pitch, m.k)), m.tr.setBearing(c.G.number(m.startEulerAngles.bearing, m.endEulerAngles.bearing, m.k)) } function zc(m, t, s, l, d) { const g = d.padding, v = yt(d.worldSize, s.getNorthWest()), T = yt(d.worldSize, s.getNorthEast()), E = yt(d.worldSize, s.getSouthEast()), I = yt(d.worldSize, s.getSouthWest()), A = c.ap(-l), R = v.rotate(A), z = T.rotate(A), O = E.rotate(A), U = I.rotate(A), X = new c.P(Math.max(R.x, z.x, U.x, O.x), Math.max(R.y, z.y, U.y, O.y)), Q = new c.P(Math.min(R.x, z.x, U.x, O.x), Math.min(R.y, z.y, U.y, O.y)), Y = X.sub(Q), te = (d.width - (g.left + g.right + t.left + t.right)) / Y.x, le = (d.height - (g.top + g.bottom + t.top + t.bottom)) / Y.y; if (le < 0 || te < 0) return void ts(); const J = Math.min(c.at(d.scale * Math.min(te, le)), m.maxZoom), oe = c.P.convert(m.offset), ce = new c.P((t.left - t.right) / 2, (t.top - t.bottom) / 2).rotate(c.ap(l)), se = oe.add(ce).mult(d.scale / c.aq(J)); return { center: Pt(d.worldSize, v.add(E).div(2).sub(se)), zoom: J, bearing: l } } class Ws { get useGlobeControls() { return !1 } handlePanInertia(t, s) { const l = t.mag(), d = Math.abs(tr(s)); return { easingOffset: t.mult(Math.min(.75 * d / l, 1)), easingCenter: s.center } } handleMapControlsRollPitchBearingZoom(t, s) { t.bearingDelta && s.setBearing(s.bearing + t.bearingDelta), t.pitchDelta && s.setPitch(s.pitch + t.pitchDelta), t.rollDelta && s.setRoll(s.roll + t.rollDelta), t.zoomDelta && s.setZoom(s.zoom + t.zoomDelta) } handleMapControlsPan(t, s, l) { t.around.distSqr(s.centerPoint) < .01 || s.setLocationAtPoint(l, t.around) } cameraForBoxAndBearing(t, s, l, d, g) { return zc(t, s, l, d, g) } handleJumpToCenterZoom(t, s) { t.zoom !== (s.zoom !== void 0 ? +s.zoom : t.zoom) && t.setZoom(+s.zoom), s.center !== void 0 && t.setCenter(c.V.convert(s.center)) } handleEaseTo(t, s) { const l = t.zoom, d = t.padding, g = { roll: t.roll, pitch: t.pitch, bearing: t.bearing }, v = { roll: s.roll === void 0 ? t.roll : s.roll, pitch: s.pitch === void 0 ? t.pitch : s.pitch, bearing: s.bearing === void 0 ? t.bearing : s.bearing }, T = s.zoom !== void 0, E = !t.isPaddingEqual(s.padding); let I = !1; const A = T ? +s.zoom : t.zoom; let R = t.centerPoint.add(s.offsetAsPoint); const z = t.screenPointToLocation(R), { center: O, zoom: U } = t.applyConstrain(c.V.convert(s.center || z), A ?? l); bs(t, O); const X = yt(t.worldSize, z), Q = yt(t.worldSize, O).sub(X), Y = c.aq(U - l); return I = U !== l, { easeFunc: te => { if (I && t.setZoom(c.G.number(l, U, te)), c.bo(g, v) || $d({ startEulerAngles: g, endEulerAngles: v, tr: t, k: te, useSlerp: g.roll != v.roll }), E && (t.interpolatePadding(d, s.padding, te), R = t.centerPoint.add(s.offsetAsPoint)), s.around) t.setLocationAtPoint(s.around, s.aroundPoint); else { const le = c.aq(t.zoom - l), J = U > l ? Math.min(2, Y) : Math.max(.5, Y), oe = Math.pow(J, 1 - te), ce = Pt(t.worldSize, X.add(Q.mult(te * oe)).mult(le)); t.setLocationAtPoint(t.renderWorldCopies ? ce.wrap() : ce, R) } }, isZooming: I, elevationCenter: O } } handleFlyTo(t, s) { const l = s.zoom !== void 0, d = t.zoom, g = t.applyConstrain(c.V.convert(s.center || s.locationAtOffset), l ? +s.zoom : d), v = g.center, T = g.zoom; bs(t, v); const E = yt(t.worldSize, s.locationAtOffset), I = yt(t.worldSize, v).sub(E), A = I.mag(), R = c.aq(T - d); let z; if (s.minZoom !== void 0) { const O = Math.min(+s.minZoom, d, T), U = t.applyConstrain(v, O).zoom; z = c.aq(U - d) } return { easeFunc: (O, U, X, Q) => { t.setZoom(O === 1 ? T : d + c.at(U)); const Y = O === 1 ? v : Pt(t.worldSize, E.add(I.mult(X)).mult(U)); t.setLocationAtPoint(t.renderWorldCopies ? Y.wrap() : Y, Q) }, scaleOfZoom: R, targetCenter: v, scaleOfMinZoom: z, pixelPathLength: A } } } class or { constructor(t, s, l) { this.blendFunction = t, this.blendColor = s, this.mask = l } } or.Replace = [1, 0], or.disabled = new or(or.Replace, c.bp.transparent, [!1, !1, !1, !1]), or.unblended = new or(or.Replace, c.bp.transparent, [!0, !0, !0, !0]), or.alphaBlended = new or([1, 771], c.bp.transparent, [!0, !0, !0, !0]); const Lo = 2305; class Nt { constructor(t, s, l) { this.enable = t, this.mode = s, this.frontFace = l } } Nt.disabled = new Nt(!1, 1029, Lo), Nt.backCCW = new Nt(!0, 1029, Lo), Nt.frontCCW = new Nt(!0, 1028, Lo); class kt { constructor(t, s, l) { this.func = t, this.mask = s, this.range = l } } kt.ReadOnly = !1, kt.ReadWrite = !0, kt.disabled = new kt(519, kt.ReadOnly, [0, 1]); const Fo = 7680; class jt { constructor(t, s, l, d, g, v) { this.test = t, this.ref = s, this.mask = l, this.fail = d, this.depthFail = g, this.pass = v } } jt.disabled = new jt({ func: 519, mask: 0 }, 0, 0, Fo, Fo, Fo); const Oa = new WeakMap; function ai(m) { var t; if (Oa.has(m)) return Oa.get(m); { const s = (t = m.getParameter(m.VERSION)) === null || t === void 0 ? void 0 : t.startsWith("WebGL 2.0"); return Oa.set(m, s), s } } class Bo { get awaitingQuery() { return !!this._readbackQueue } constructor(t) { this._readbackWaitFrames = 4, this._measureWaitFrames = 6, this._texWidth = 1, this._texHeight = 1, this._measuredError = 0, this._updateCount = 0, this._lastReadbackFrame = -1e3, this._readbackQueue = null, this._cachedRenderContext = t; const s = t.context, l = s.gl; this._texFormat = l.RGBA, this._texType = l.UNSIGNED_BYTE; const d = new c.aW; d.emplaceBack(-1, -1), d.emplaceBack(2, -1), d.emplaceBack(-1, 2); const g = new c.aY; g.emplaceBack(0, 1, 2), this._fullscreenTriangle = new sr(s.createVertexBuffer(d, ws.members), s.createIndexBuffer(g), c.aX.simpleSegment(0, 0, d.length, g.length)), this._resultBuffer = new Uint8Array(4), s.activeTexture.set(l.TEXTURE1); const v = l.createTexture(); l.bindTexture(l.TEXTURE_2D, v), l.texParameteri(l.TEXTURE_2D, l.TEXTURE_WRAP_S, l.CLAMP_TO_EDGE), l.texParameteri(l.TEXTURE_2D, l.TEXTURE_WRAP_T, l.CLAMP_TO_EDGE), l.texParameteri(l.TEXTURE_2D, l.TEXTURE_MIN_FILTER, l.NEAREST), l.texParameteri(l.TEXTURE_2D, l.TEXTURE_MAG_FILTER, l.NEAREST), l.texImage2D(l.TEXTURE_2D, 0, this._texFormat, this._texWidth, this._texHeight, 0, this._texFormat, this._texType, null), this._fbo = s.createFramebuffer(this._texWidth, this._texHeight, !1, !1), this._fbo.colorAttachment.set(v), ai(l) && (this._pbo = l.createBuffer(), l.bindBuffer(l.PIXEL_PACK_BUFFER, this._pbo), l.bufferData(l.PIXEL_PACK_BUFFER, 4, l.STREAM_READ), l.bindBuffer(l.PIXEL_PACK_BUFFER, null)) } destroy() { const t = this._cachedRenderContext.context.gl; this._fullscreenTriangle.destroy(), this._fbo.destroy(), t.deleteBuffer(this._pbo), this._fullscreenTriangle = null, this._fbo = null, this._pbo = null, this._resultBuffer = null } updateErrorLoop(t, s) { const l = this._updateCount; return this._readbackQueue ? l >= this._readbackQueue.frameNumberIssued + this._readbackWaitFrames && this._tryReadback() : l >= this._lastReadbackFrame + this._measureWaitFrames && this._renderErrorTexture(t, s), this._updateCount++, this._measuredError } _bindFramebuffer() { const t = this._cachedRenderContext.context, s = t.gl; t.activeTexture.set(s.TEXTURE1), s.bindTexture(s.TEXTURE_2D, this._fbo.colorAttachment.get()), t.bindFramebuffer.set(this._fbo.framebuffer) } _renderErrorTexture(t, s) { const l = this._cachedRenderContext.context, d = l.gl; if (this._bindFramebuffer(), l.viewport.set([0, 0, this._texWidth, this._texHeight]), l.clear({ color: c.bp.transparent }), this._cachedRenderContext.useProgram("projectionErrorMeasurement").draw(l, d.TRIANGLES, kt.disabled, jt.disabled, or.unblended, Nt.disabled, ((g, v) => ({ u_input: g, u_output_expected: v }))(t, s), null, null, "$clipping", this._fullscreenTriangle.vertexBuffer, this._fullscreenTriangle.indexBuffer, this._fullscreenTriangle.segments), this._pbo && ai(d)) { d.bindBuffer(d.PIXEL_PACK_BUFFER, this._pbo), d.readBuffer(d.COLOR_ATTACHMENT0), d.readPixels(0, 0, this._texWidth, this._texHeight, this._texFormat, this._texType, 0), d.bindBuffer(d.PIXEL_PACK_BUFFER, null); const g = d.fenceSync(d.SYNC_GPU_COMMANDS_COMPLETE, 0); d.flush(), this._readbackQueue = { frameNumberIssued: this._updateCount, sync: g } } else this._readbackQueue = { frameNumberIssued: this._updateCount, sync: null } } _tryReadback() { const t = this._cachedRenderContext.context.gl; if (this._pbo && this._readbackQueue && ai(t)) { const s = t.clientWaitSync(this._readbackQueue.sync, 0, 0); if (s === t.WAIT_FAILED) return c.w("WebGL2 clientWaitSync failed."), this._readbackQueue = null, void (this._lastReadbackFrame = this._updateCount); if (s === t.TIMEOUT_EXPIRED) return; t.bindBuffer(t.PIXEL_PACK_BUFFER, this._pbo), t.getBufferSubData(t.PIXEL_PACK_BUFFER, 0, this._resultBuffer, 0, 4), t.bindBuffer(t.PIXEL_PACK_BUFFER, null) } else this._bindFramebuffer(), t.readPixels(0, 0, this._texWidth, this._texHeight, this._texFormat, this._texType, this._resultBuffer); this._readbackQueue = null, this._measuredError = Bo._parseRGBA8float(this._resultBuffer), this._lastReadbackFrame = this._updateCount } static _parseRGBA8float(t) { let s = 0; return s += t[0] / 256, s += t[1] / 65536, s += t[2] / 16777216, t[3] < 127 && (s = -s), s / 128 } } const Ts = c.a5 / 128; function qd(m, t) { const s = m.granularity !== void 0 ? Math.max(m.granularity, 1) : 1, l = s + (m.generateBorders ? 2 : 0), d = s + (m.extendToNorthPole || m.generateBorders ? 1 : 0) + (m.extendToSouthPole || m.generateBorders ? 1 : 0), g = l + 1, v = d + 1, T = m.generateBorders ? -1 : 0, E = m.generateBorders || m.extendToNorthPole ? -1 : 0, I = s + (m.generateBorders ? 1 : 0), A = s + (m.generateBorders || m.extendToSouthPole ? 1 : 0), R = g * v, z = l * d * 6, O = g * v > 65536; if (O && t === "16bit") throw new Error("Granularity is too large and meshes would not fit inside 16 bit vertex indices."); const U = O || t === "32bit", X = new Int16Array(2 * R); let Q = 0; for (let le = E; le <= A; le++)for (let J = T; J <= I; J++) { let oe = J / s * c.a5; J === -1 && (oe = -Ts), J === s + 1 && (oe = c.a5 + Ts); let ce = le / s * c.a5; le === -1 && (ce = m.extendToNorthPole ? c.br : -Ts), le === s + 1 && (ce = m.extendToSouthPole ? c.bs : c.a5 + Ts), X[Q++] = oe, X[Q++] = ce } const Y = U ? new Uint32Array(z) : new Uint16Array(z); let te = 0; for (let le = 0; le < d; le++)for (let J = 0; J < l; J++) { const oe = J + 1 + le * g, ce = J + (le + 1) * g, se = J + 1 + (le + 1) * g; Y[te++] = J + le * g, Y[te++] = ce, Y[te++] = oe, Y[te++] = oe, Y[te++] = ce, Y[te++] = se } return { vertices: X.buffer.slice(0), indices: Y.buffer.slice(0), uses32bitIndices: U } } const Na = new c.aV({ fill: new c.bt(128, 2), line: new c.bt(512, 0), tile: new c.bt(128, 32), stencil: new c.bt(128, 1), circle: 3 }); class Rc { constructor() { this._tileMeshCache = {}, this._errorCorrectionUsable = 0, this._errorMeasurementLastValue = 0, this._errorCorrectionPreviousValue = 0, this._errorMeasurementLastChangeTime = -1e3 } get name() { return "vertical-perspective" } get transitionState() { return 1 } get useSubdivision() { return !0 } get shaderVariantName() { return "globe" } get shaderDefine() { return "#define GLOBE" } get shaderPreludeCode() { return br.projectionGlobe } get vertexShaderPreludeCode() { return br.projectionMercator.vertexSource } get subdivisionGranularity() { return Na } get useGlobeControls() { return !0 } get latitudeErrorCorrectionRadians() { return this._errorCorrectionUsable } destroy() { this._errorMeasurement && this._errorMeasurement.destroy() } updateGPUdependent(t) { this._errorMeasurement || (this._errorMeasurement = new Bo(t)); const s = c.X(this._errorQueryLatitudeDegrees), l = 2 * Math.atan(Math.exp(Math.PI - s * Math.PI * 2)) - .5 * Math.PI, d = this._errorMeasurement.updateErrorLoop(s, l), g = $e(); d !== this._errorMeasurementLastValue && (this._errorCorrectionPreviousValue = this._errorCorrectionUsable, this._errorMeasurementLastValue = d, this._errorMeasurementLastChangeTime = g); const v = Math.min(Math.max((g - this._errorMeasurementLastChangeTime) / 1e3 / .5, 0), 1); this._errorCorrectionUsable = c.bu(this._errorCorrectionPreviousValue, -this._errorMeasurementLastValue, c.bv(v)) } _getMeshKey(t) { return `${t.granularity.toString(36)}_${t.generateBorders ? "b" : ""}${t.extendToNorthPole ? "n" : ""}${t.extendToSouthPole ? "s" : ""}` } getMeshFromTileID(t, s, l, d, g) { const v = (g === "stencil" ? Na.stencil : Na.tile).getGranularityForZoomLevel(s.z); return this._getMesh(t, { granularity: v, generateBorders: l, extendToNorthPole: s.y === 0 && d, extendToSouthPole: s.y === (1 << s.z) - 1 && d }) } _getMesh(t, s) { const l = this._getMeshKey(s); if (l in this._tileMeshCache) return this._tileMeshCache[l]; const d = function (g, v) { const T = qd(v, "16bit"), E = c.aW.deserialize({ arrayBuffer: T.vertices, length: T.vertices.byteLength / 2 / 2 }), I = c.aY.deserialize({ arrayBuffer: T.indices, length: T.indices.byteLength / 2 / 3 }); return new sr(g.createVertexBuffer(E, ws.members), g.createIndexBuffer(I), c.aX.simpleSegment(0, 0, E.length, I.length)) }(t, s); return this._tileMeshCache[l] = d, d } recalculate(t) { } hasTransition() { const t = $e(); let s = !1; return s = s || (t - this._errorMeasurementLastChangeTime) / 1e3 < .7, s = s || this._errorMeasurement && this._errorMeasurement.awaitingQuery, s } setErrorQueryLatitudeDegrees(t) { this._errorQueryLatitudeDegrees = t } } const Om = new c.t({ type: new c.D(c.u.projection.type) }); class Zd extends c.E { constructor(t) { super(), this._transitionable = new c.x(Om, void 0), this.setProjection(t), this._transitioning = this._transitionable.untransitioned(), this.recalculate(new c.H(0)), this._mercatorProjection = new zn, this._verticalPerspectiveProjection = new Rc } get transitionState() { const t = this.properties.get("type"); if (typeof t == "string" && t === "mercator") return 0; if (typeof t == "string" && t === "vertical-perspective") return 1; if (t instanceof c.bw) { if (t.from === "vertical-perspective" && t.to === "mercator") return 1 - t.transition; if (t.from === "mercator" && t.to === "vertical-perspective") return t.transition } return 1 } get useGlobeRendering() { return this.transitionState > 0 } get latitudeErrorCorrectionRadians() { return this._verticalPerspectiveProjection.latitudeErrorCorrectionRadians } get currentProjection() { return this.useGlobeRendering ? this._verticalPerspectiveProjection : this._mercatorProjection } get name() { return "globe" } get useSubdivision() { return this.currentProjection.useSubdivision } get shaderVariantName() { return this.currentProjection.shaderVariantName } get shaderDefine() { return this.currentProjection.shaderDefine } get shaderPreludeCode() { return this.currentProjection.shaderPreludeCode } get vertexShaderPreludeCode() { return this.currentProjection.vertexShaderPreludeCode } get subdivisionGranularity() { return this.currentProjection.subdivisionGranularity } get useGlobeControls() { return this.transitionState > 0 } destroy() { this._mercatorProjection.destroy(), this._verticalPerspectiveProjection.destroy() } updateGPUdependent(t) { this._mercatorProjection.updateGPUdependent(t), this._verticalPerspectiveProjection.updateGPUdependent(t) } getMeshFromTileID(t, s, l, d, g) { return this.currentProjection.getMeshFromTileID(t, s, l, d, g) } setProjection(t) { this._transitionable.setValue("type", (t == null ? void 0 : t.type) || "mercator") } updateTransitions(t) { this._transitioning = this._transitionable.transitioned(t, this._transitioning) } hasTransition() { return this._transitioning.hasTransition() || this.currentProjection.hasTransition() } recalculate(t) { this.properties = this._transitioning.possiblyEvaluate(t) } setErrorQueryLatitudeDegrees(t) { this._verticalPerspectiveProjection.setErrorQueryLatitudeDegrees(t), this._mercatorProjection.setErrorQueryLatitudeDegrees(t) } } function Rn(m) { const t = Hs(m.worldSize, m.center.lat); return 2 * Math.PI * t } function Vi(m, t, s, l, d) { const g = 1 / (1 << d), v = t / c.a5 * g + l * g, T = c.by((m / c.a5 * g + s * g) * Math.PI * 2 + Math.PI, 2 * Math.PI), E = 2 * Math.atan(Math.exp(Math.PI - v * Math.PI * 2)) - .5 * Math.PI, I = Math.cos(E), A = new Float64Array(3); return A[0] = Math.sin(T) * I, A[1] = Math.sin(E), A[2] = Math.cos(T) * I, A } function _r(m) { return function (t, s) { const l = Math.cos(s), d = new Float64Array(3); return d[0] = Math.sin(t) * l, d[1] = Math.sin(s), d[2] = Math.cos(t) * l, d }(m.lng * Math.PI / 180, m.lat * Math.PI / 180) } function Hs(m, t) { return m / (2 * Math.PI) / Math.cos(t * Math.PI / 180) } function Lc(m) { const t = Math.asin(m[1]) / Math.PI * 180, s = Math.sqrt(m[0] * m[0] + m[2] * m[2]); if (s > 1e-6) { const l = m[0] / s, d = Math.acos(m[2] / s), g = (l > 0 ? d : -d) / Math.PI * 180; return new c.V(c.W(g, -180, 180), t) } return new c.V(0, t) } function ja(m) { return Math.cos(m * Math.PI / 180) } function Cr(m, t) { const s = ja(m), l = ja(t); return c.at(l / s) } function Wd(m, t) { const s = m.rotate(t.bearingInRadians), l = t.zoom + Cr(t.center.lat, 0), d = c.bu(1 / ja(t.center.lat), 1 / ja(Math.min(Math.abs(t.center.lat), 60)), c.bx(l, 7, 3, 0, 1)), g = 360 / Rn({ worldSize: t.worldSize, center: { lat: t.center.lat } }); return new c.V(t.center.lng - s.x * g * d, c.an(t.center.lat + s.y * g, -c.ao, c.ao)) } function Fc(m) { const t = .5 * m, s = Math.sin(t), l = Math.cos(t); return Math.log(s + l) - Math.log(l - s) } function Hd(m, t, s, l) { const d = m.lat + s * l; if (Math.abs(s) > 1) { const g = (Math.sign(m.lat + s) !== Math.sign(m.lat) ? -Math.abs(m.lat) : Math.abs(m.lat)) * Math.PI / 180, v = Math.abs(m.lat + s) * Math.PI / 180, T = Fc(g + l * (v - g)), E = Fc(g), I = Fc(v); return new c.V(m.lng + t * ((T - E) / (I - E)), d) } return new c.V(m.lng + t * l, d) } class Nm { constructor(t) { this._cachePrevious = new Map, this._cache = new Map, this._hadAnyChanges = !1, this._boundingVolumeFactory = t } swapBuffers() { if (!this._hadAnyChanges) return; const t = this._cachePrevious; this._cachePrevious = this._cache, this._cache = t, this._cache.clear(), this._hadAnyChanges = !1 } getTileBoundingVolume(t, s, l, d) { const g = `${t.z}_${t.x}_${t.y}_${d != null && d.terrain ? "t" : ""}`, v = this._cache.get(g); if (v) return v; const T = this._cachePrevious.get(g); if (T) return this._cache.set(g, T), T; const E = this._boundingVolumeFactory(t, s, l, d); return this._cache.set(g, E), this._hadAnyChanges = !0, E } } class Oo { constructor(t, s, l, d) { this.min = l, this.max = d, this.points = t, this.planes = s } static fromAabb(t, s) { const l = []; for (let d = 0; d < 8; d++)l.push([1 & ~d ? t[0] : s[0], (d >> 1 & 1) == 1 ? s[1] : t[1], (d >> 2 & 1) == 1 ? s[2] : t[2]]); return new Oo(l, [[-1, 0, 0, s[0]], [1, 0, 0, -t[0]], [0, -1, 0, s[1]], [0, 1, 0, -t[1]], [0, 0, -1, s[2]], [0, 0, 1, -t[2]]], t, s) } static fromCenterSizeAngles(t, s, l) { const d = c.bB([], l[0], l[1], l[2]), g = c.bC([], [s[0], 0, 0], d), v = c.bC([], [0, s[1], 0], d), T = c.bC([], [0, 0, s[2]], d), E = [...t], I = [...t]; for (let R = 0; R < 8; R++)for (let z = 0; z < 3; z++) { const O = t[z] + g[z] * (1 & ~R ? -1 : 1) + v[z] * ((R >> 1 & 1) == 1 ? 1 : -1) + T[z] * ((R >> 2 & 1) == 1 ? 1 : -1); E[z] = Math.min(E[z], O), I[z] = Math.max(I[z], O) } const A = []; for (let R = 0; R < 8; R++) { const z = [...t]; c.b0(z, z, c.a$([], g, 1 & ~R ? -1 : 1)), c.b0(z, z, c.a$([], v, (R >> 1 & 1) == 1 ? 1 : -1)), c.b0(z, z, c.a$([], T, (R >> 2 & 1) == 1 ? 1 : -1)), A.push(z) } return new Oo(A, [[...g, -c.b5(g, A[0])], [...v, -c.b5(v, A[0])], [...T, -c.b5(T, A[0])], [-g[0], -g[1], -g[2], -c.b5(g, A[7])], [-v[0], -v[1], -v[2], -c.b5(v, A[7])], [-T[0], -T[1], -T[2], -c.b5(T, A[7])]], E, I) } intersectsFrustum(t) { let s = !0; const l = this.points.length, d = this.planes.length, g = t.planes.length, v = t.points.length; for (let T = 0; T < g; T++) { const E = t.planes[T]; let I = 0; for (let A = 0; A < l; A++) { const R = this.points[A]; E[0] * R[0] + E[1] * R[1] + E[2] * R[2] + E[3] >= 0 && I++ } if (I === 0) return 0; I < l && (s = !1) } if (s) return 2; for (let T = 0; T < d; T++) { const E = this.planes[T]; let I = 0; for (let A = 0; A < v; A++) { const R = t.points[A]; E[0] * R[0] + E[1] * R[1] + E[2] * R[2] + E[3] >= 0 && I++ } if (I === 0) return 0 } return 1 } intersectsPlane(t) { const s = this.points.length; let l = 0; for (let d = 0; d < s; d++) { const g = this.points[d]; t[0] * g[0] + t[1] * g[1] + t[2] * g[2] + t[3] >= 0 && l++ } return l === s ? 2 : l === 0 ? 0 : 1 } } function Yl(m, t, s) { const l = m - t; return l < 0 ? -l : Math.max(0, l - s) } function No(m, t, s, l, d) { const g = m - s; let v; return v = g < 0 ? Math.min(-g, 1 + g - d) : g > 1 ? Math.min(Math.max(g - d, 0), 1 - g) : 0, Math.max(v, Yl(t, l, d)) } class Bc { constructor() { this._boundingVolumeCache = new Nm(this._computeTileBoundingVolume) } prepareNextFrame() { this._boundingVolumeCache.swapBuffers() } distanceToTile2d(t, s, l, d) { const g = 1 << l.z, v = 1 / g, T = l.x / g, E = l.y / g; let I = 2; return I = Math.min(I, No(t, s, T, E, v)), I = Math.min(I, No(t, s, T + .5, -E - v, v)), I = Math.min(I, No(t, s, T + .5, 2 - E - v, v)), I } getWrap(t, s, l) { const d = 1 << s.z, g = 1 / d, v = s.x / d, T = Yl(t.x, v, g), E = Yl(t.x, v - 1, g), I = Yl(t.x, v + 1, g), A = Math.min(T, E, I); return A === I ? 1 : A === E ? -1 : 0 } allowVariableZoom(t, s) { return pr(t, s) > 4 } allowWorldCopies() { return !1 } getTileBoundingVolume(t, s, l, d) { return this._boundingVolumeCache.getTileBoundingVolume(t, s, l, d) } _computeTileBoundingVolume(t, s, l, d) { var g, v; let T = 0, E = 0; if (d != null && d.terrain) { const I = new c.a2(t.z, s, t.z, t.x, t.y), A = d.terrain.getMinMaxElevation(I); T = (g = A.minElevation) !== null && g !== void 0 ? g : Math.min(0, l), E = (v = A.maxElevation) !== null && v !== void 0 ? v : Math.max(0, l) } if (T /= c.bE, E /= c.bE, T += 1, E += 1, t.z <= 0) return Oo.fromAabb([-E, -E, -E], [E, E, E]); if (t.z === 1) return Oo.fromAabb([t.x === 0 ? -E : 0, t.y === 0 ? 0 : -E, -E], [t.x === 0 ? 0 : E, t.y === 0 ? E : 0, E]); { const I = [Vi(0, 0, t.x, t.y, t.z), Vi(c.a5, 0, t.x, t.y, t.z), Vi(c.a5, c.a5, t.x, t.y, t.z), Vi(0, c.a5, t.x, t.y, t.z)], A = []; for (const ze of I) A.push(c.a$([], ze, E)); if (E !== T) for (const ze of I) A.push(c.a$([], ze, T)); t.y === 0 && A.push([0, 1, 0]), t.y === (1 << t.z) - 1 && A.push([0, -1, 0]); const R = [1, 1, 1], z = [-1, -1, -1]; for (const ze of A) for (let Re = 0; Re < 3; Re++)R[Re] = Math.min(R[Re], ze[Re]), z[Re] = Math.max(z[Re], ze[Re]); const O = Vi(c.a5 / 2, c.a5 / 2, t.x, t.y, t.z), U = c.b4([], [0, 1, 0], O); c.b3(U, U); const X = c.b4([], O, U); c.b3(X, X); const Q = c.b4([], I[2], I[1]); c.b3(Q, Q); const Y = c.b4([], I[0], I[3]); c.b3(Y, Y), A.push(c.a$([], O, E)), t.y >= (1 << t.z) / 2 && A.push(c.a$([], Vi(c.a5 / 2, 0, t.x, t.y, t.z), E)), t.y < (1 << t.z) / 2 && A.push(c.a$([], Vi(c.a5 / 2, c.a5, t.x, t.y, t.z), E)); const te = Va(O, A), le = Va(X, A), J = [-O[0], -O[1], -O[2], te.max], oe = [O[0], O[1], O[2], -te.min], ce = [-X[0], -X[1], -X[2], le.max], se = [X[0], X[1], X[2], -le.min], fe = [...Q, 0], Oe = [...Y, 0], ke = []; return t.y === 0 ? ke.push(c.bD(Oe, fe, J), c.bD(Oe, fe, oe)) : ke.push(c.bD(ce, fe, J), c.bD(ce, fe, oe), c.bD(ce, Oe, J), c.bD(ce, Oe, oe)), t.y === (1 << t.z) - 1 ? ke.push(c.bD(Oe, fe, J), c.bD(Oe, fe, oe)) : ke.push(c.bD(se, fe, J), c.bD(se, fe, oe), c.bD(se, Oe, J), c.bD(se, Oe, oe)), new Oo(ke, [J, oe, ce, se, fe, Oe], R, z) } } } function Va(m, t) { let s = 1 / 0, l = -1 / 0; for (const d of t) { const g = c.b5(m, d); s = Math.min(s, g), l = Math.max(l, g) } return { min: s, max: l } } class jo { get pixelsToClipSpaceMatrix() { return this._helper.pixelsToClipSpaceMatrix } get clipSpaceToPixelsMatrix() { return this._helper.clipSpaceToPixelsMatrix } get pixelsToGLUnits() { return this._helper.pixelsToGLUnits } get centerOffset() { return this._helper.centerOffset } get size() { return this._helper.size } get rotationMatrix() { return this._helper.rotationMatrix } get centerPoint() { return this._helper.centerPoint } get pixelsPerMeter() { return this._helper.pixelsPerMeter } setMinZoom(t) { this._helper.setMinZoom(t) } setMaxZoom(t) { this._helper.setMaxZoom(t) } setMinPitch(t) { this._helper.setMinPitch(t) } setMaxPitch(t) { this._helper.setMaxPitch(t) } setRenderWorldCopies(t) { this._helper.setRenderWorldCopies(t) } setBearing(t) { this._helper.setBearing(t) } setPitch(t) { this._helper.setPitch(t) } setRoll(t) { this._helper.setRoll(t) } setFov(t) { this._helper.setFov(t) } setZoom(t) { this._helper.setZoom(t) } setCenter(t) { this._helper.setCenter(t) } setElevation(t) { this._helper.setElevation(t) } setMinElevationForCurrentTile(t) { this._helper.setMinElevationForCurrentTile(t) } setPadding(t) { this._helper.setPadding(t) } interpolatePadding(t, s, l) { return this._helper.interpolatePadding(t, s, l) } isPaddingEqual(t) { return this._helper.isPaddingEqual(t) } resize(t, s) { this._helper.resize(t, s) } getMaxBounds() { return this._helper.getMaxBounds() } setMaxBounds(t) { this._helper.setMaxBounds(t) } setConstrainOverride(t) { this._helper.setConstrainOverride(t) } overrideNearFarZ(t, s) { this._helper.overrideNearFarZ(t, s) } clearNearFarZOverride() { this._helper.clearNearFarZOverride() } getCameraQueryGeometry(t) { return this._helper.getCameraQueryGeometry(this.getCameraPoint(), t) } get tileSize() { return this._helper.tileSize } get tileZoom() { return this._helper.tileZoom } get scale() { return this._helper.scale } get worldSize() { return this._helper.worldSize } get width() { return this._helper.width } get height() { return this._helper.height } get lngRange() { return this._helper.lngRange } get latRange() { return this._helper.latRange } get minZoom() { return this._helper.minZoom } get maxZoom() { return this._helper.maxZoom } get zoom() { return this._helper.zoom } get center() { return this._helper.center } get minPitch() { return this._helper.minPitch } get maxPitch() { return this._helper.maxPitch } get pitch() { return this._helper.pitch } get pitchInRadians() { return this._helper.pitchInRadians } get roll() { return this._helper.roll } get rollInRadians() { return this._helper.rollInRadians } get bearing() { return this._helper.bearing } get bearingInRadians() { return this._helper.bearingInRadians } get fov() { return this._helper.fov } get fovInRadians() { return this._helper.fovInRadians } get elevation() { return this._helper.elevation } get minElevationForCurrentTile() { return this._helper.minElevationForCurrentTile } get padding() { return this._helper.padding } get unmodified() { return this._helper.unmodified } get renderWorldCopies() { return this._helper.renderWorldCopies } get constrainOverride() { return this._helper.constrainOverride } get nearZ() { return this._helper.nearZ } get farZ() { return this._helper.farZ } get autoCalculateNearFarZ() { return this._helper.autoCalculateNearFarZ } setTransitionState(t) { } constructor(t) { this._cachedClippingPlane = c.bF(), this._projectionMatrix = c.bj(), this._globeViewProjMatrix32f = c.bi(), this._globeViewProjMatrixNoCorrection = c.bj(), this._globeViewProjMatrixNoCorrectionInverted = c.bj(), this._globeProjMatrixInverted = c.bj(), this._cameraPosition = c.bz(), this._globeLatitudeErrorCorrectionRadians = 0, this.defaultConstrain = (s, l) => { const d = c.an(s.lat, -c.ao, c.ao), g = c.an(+l, this.minZoom + Cr(0, d), this.maxZoom); return { center: new c.V(s.lng, d), zoom: g } }, this.applyConstrain = (s, l) => this._helper.applyConstrain(s, l), this._helper = new qs({ calcMatrices: () => { this._calcMatrices() }, defaultConstrain: (s, l) => this.defaultConstrain(s, l) }, t), this._coveringTilesDetailsProvider = new Bc } clone() { const t = new jo; return t.apply(this), t } apply(t, s) { this._globeLatitudeErrorCorrectionRadians = s || 0, this._helper.apply(t) } get projectionMatrix() { return this._projectionMatrix } get modelViewProjectionMatrix() { return this._globeViewProjMatrixNoCorrection } get inverseProjectionMatrix() { return this._globeProjMatrixInverted } get cameraPosition() { const t = c.bz(); return t[0] = this._cameraPosition[0], t[1] = this._cameraPosition[1], t[2] = this._cameraPosition[2], t } get cameraToCenterDistance() { return this._helper.cameraToCenterDistance } getProjectionData(t) { const { overscaledTileID: s, applyGlobeMatrix: l } = t, d = this._helper.getMercatorTileCoordinates(s); return { mainMatrix: this._globeViewProjMatrix32f, tileMercatorCoords: d, clippingPlane: this._cachedClippingPlane, projectionTransition: l ? 1 : 0, fallbackMatrix: this._globeViewProjMatrix32f } } _computeClippingPlane(t) { const s = this.pitchInRadians, l = this.cameraToCenterDistance / t, d = Math.sin(s) * l, g = Math.cos(s) * l + 1, v = 1 / Math.sqrt(d * d + g * g) * 1; let T = -d, E = g; const I = Math.sqrt(T * T + E * E); T /= I, E /= I; const A = [0, T, E]; c.bG(A, A, [0, 0, 0], -this.bearingInRadians), c.bH(A, A, [0, 0, 0], -1 * this.center.lat * Math.PI / 180), c.bI(A, A, [0, 0, 0], this.center.lng * Math.PI / 180); const R = 1 / c.b7(A); return c.a$(A, A, R), [...A, -v * R] } isLocationOccluded(t) { return !this.isSurfacePointVisible(_r(t)) } transformLightDirection(t) { const s = this._helper._center.lng * Math.PI / 180, l = this._helper._center.lat * Math.PI / 180, d = Math.cos(l), g = [Math.sin(s) * d, Math.sin(l), Math.cos(s) * d], v = [g[2], 0, -g[0]], T = [0, 0, 0]; c.b4(T, v, g), c.b3(v, v), c.b3(T, T); const E = [0, 0, 0]; return c.b3(E, [v[0] * t[0] + T[0] * t[1] + g[0] * t[2], v[1] * t[0] + T[1] * t[1] + g[1] * t[2], v[2] * t[0] + T[2] * t[1] + g[2] * t[2]]), E } getPixelScale() { return 1 / Math.cos(this._helper._center.lat * Math.PI / 180) } getCircleRadiusCorrection() { return Math.cos(this._helper._center.lat * Math.PI / 180) } getPitchedTextCorrection(t, s, l) { const d = function (T, E, I) { const A = 1 / (1 << I.z); return new c.a9(T / c.a5 * A + I.x * A, E / c.a5 * A + I.y * A) }(t, s, l.canonical), g = (v = d.y, [c.by(d.x * Math.PI * 2 + Math.PI, 2 * Math.PI), 2 * Math.atan(Math.exp(Math.PI - v * Math.PI * 2)) - .5 * Math.PI]); var v; return this.getCircleRadiusCorrection() / Math.cos(g[1]) } projectTileCoordinates(t, s, l, d) { const g = l.canonical, v = Vi(t, s, g.x, g.y, g.z), T = 1 + (d ? d(t, s) : 0) / c.bE, E = [v[0] * T, v[1] * T, v[2] * T, 1]; c.aH(E, E, this._globeViewProjMatrixNoCorrection); const I = this._cachedClippingPlane, A = I[0] * v[0] + I[1] * v[1] + I[2] * v[2] + I[3] < 0; return { point: new c.P(E[0] / E[3], E[1] / E[3]), signedDistanceFromCamera: E[3], isOccluded: A } } _calcMatrices() { if (!this._helper._width || !this._helper._height) return; const t = Hs(this.worldSize, this.center.lat), s = c.bk(), l = c.bk(); this._helper.autoCalculateNearFarZ && (this._helper._nearZ = .5, this._helper._farZ = this.cameraToCenterDistance + 2 * t), c.be(s, this.fovInRadians, this.width / this.height, this._helper._nearZ, this._helper._farZ); const d = this.centerOffset; s[8] = 2 * -d.x / this._helper._width, s[9] = 2 * d.y / this._helper._height, this._projectionMatrix = c.bf(s), this._globeProjMatrixInverted = c.bk(), c.aB(this._globeProjMatrixInverted, s), c.O(s, s, [0, 0, -this.cameraToCenterDistance]), c.bg(s, s, this.rollInRadians), c.bh(s, s, -this.pitchInRadians), c.bg(s, s, this.bearingInRadians), c.O(s, s, [0, 0, -t]); const g = c.bz(); g[0] = t, g[1] = t, g[2] = t, c.bh(l, s, this.center.lat * Math.PI / 180), c.bJ(l, l, -this.center.lng * Math.PI / 180), c.Q(l, l, g), this._globeViewProjMatrixNoCorrection = l, c.bh(s, s, this.center.lat * Math.PI / 180 - this._globeLatitudeErrorCorrectionRadians), c.bJ(s, s, -this.center.lng * Math.PI / 180), c.Q(s, s, g), this._globeViewProjMatrix32f = new Float32Array(s), this._globeViewProjMatrixNoCorrectionInverted = c.bk(), c.aB(this._globeViewProjMatrixNoCorrectionInverted, l); const v = c.bz(); this._cameraPosition = c.bz(), this._cameraPosition[2] = this.cameraToCenterDistance / t, c.bG(this._cameraPosition, this._cameraPosition, v, -this.rollInRadians), c.bH(this._cameraPosition, this._cameraPosition, v, this.pitchInRadians), c.bG(this._cameraPosition, this._cameraPosition, v, -this.bearingInRadians), c.b0(this._cameraPosition, this._cameraPosition, [0, 0, 1]), c.bH(this._cameraPosition, this._cameraPosition, v, -this.center.lat * Math.PI / 180), c.bI(this._cameraPosition, this._cameraPosition, v, this.center.lng * Math.PI / 180), this._cachedClippingPlane = this._computeClippingPlane(t); const T = c.bf(this._globeViewProjMatrixNoCorrectionInverted); c.Q(T, T, [1, 1, -1]), this._cachedFrustum = Un.fromInvProjectionMatrix(T, 1, 0, this._cachedClippingPlane, !0) } calculateFogMatrix(t) { c.w("calculateFogMatrix is not supported on globe projection."); const s = c.bk(); return c.ar(s), s } getVisibleUnwrappedCoordinates(t) { return [new c.bc(0, t)] } getCameraFrustum() { return this._cachedFrustum } getClippingPlane() { return this._cachedClippingPlane } getCoveringTilesDetailsProvider() { return this._coveringTilesDetailsProvider } recalculateZoomAndCenter(t) { t && c.w("terrain is not fully supported on vertical perspective projection."), this._helper.recalculateZoomAndCenter(0) } maxPitchScaleFactor() { return 1 } getCameraPoint() { return this._helper.getCameraPoint() } getCameraAltitude() { return this._helper.getCameraAltitude() } getCameraLngLat() { return this._helper.getCameraLngLat() } lngLatToCameraDepth(t, s) { if (!this._globeViewProjMatrixNoCorrection) return 1; const l = _r(t); c.a$(l, l, 1 + s / c.bE); const d = c.bF(); return c.aH(d, [l[0], l[1], l[2], 1], this._globeViewProjMatrixNoCorrection), d[2] / d[3] } populateCache(t) { } getBounds() { const t = .5 * this.width, s = .5 * this.height, l = [new c.P(0, 0), new c.P(t, 0), new c.P(this.width, 0), new c.P(this.width, s), new c.P(this.width, this.height), new c.P(t, this.height), new c.P(0, this.height), new c.P(0, s)], d = []; for (const R of l) d.push(this.unprojectScreenPoint(R)); let g = 0, v = 0, T = 0, E = 0; const I = this.center; for (const R of d) { const z = c.bK(I.lng, R.lng), O = c.bK(I.lat, R.lat); z < v && (v = z), z > g && (g = z), O < E && (E = O), O > T && (T = O) } const A = [I.lng + v, I.lat + E, I.lng + g, I.lat + T]; return this.isSurfacePointOnScreen([0, 1, 0]) && (A[3] = 90, A[0] = -180, A[2] = 180), this.isSurfacePointOnScreen([0, -1, 0]) && (A[1] = -90, A[0] = -180, A[2] = 180), new Pr(A) } calculateCenterFromCameraLngLatAlt(t, s, l, d) { return this._helper.calculateCenterFromCameraLngLatAlt(t, s, l, d) } setLocationAtPoint(t, s) { const l = _r(this.unprojectScreenPoint(s)), d = _r(t), g = c.bz(); c.bL(g); const v = c.bz(); c.bI(v, l, g, -this.center.lng * Math.PI / 180), c.bH(v, v, g, this.center.lat * Math.PI / 180); const T = d[0] * d[0] + d[2] * d[2], E = v[0] * v[0]; if (T < E) return; const I = Math.sqrt(T - E), A = -I, R = c.bM(d[0], d[2], v[0], I), z = c.bM(d[0], d[2], v[0], A), O = c.bz(); c.bI(O, d, g, -R); const U = c.bM(O[1], O[2], v[1], v[2]), X = c.bz(); c.bI(X, d, g, -z); const Q = c.bM(X[1], X[2], v[1], v[2]), Y = .5 * Math.PI, te = U >= -Y && U <= Y, le = Q >= -Y && Q <= Y; let J, oe; if (te && le) { const Oe = this.center.lng * Math.PI / 180, ke = this.center.lat * Math.PI / 180; c.bN(R, Oe) + c.bN(U, ke) < c.bN(z, Oe) + c.bN(Q, ke) ? (J = R, oe = U) : (J = z, oe = Q) } else if (te) J = R, oe = U; else { if (!le) return; J = z, oe = Q } const ce = J / Math.PI * 180, se = oe / Math.PI * 180, fe = this.center.lat; this.setCenter(new c.V(ce, c.an(se, -90, 90))), this.setZoom(this.zoom + Cr(fe, this.center.lat)) } locationToScreenPoint(t, s) { const l = _r(t); if (s) { const d = s.getElevationForLngLatZoom(t, this._helper._tileZoom); c.a$(l, l, 1 + d / c.bE) } return this._projectSurfacePointToScreen(l) } _projectSurfacePointToScreen(t) { const s = c.bF(); return c.aH(s, [...t, 1], this._globeViewProjMatrixNoCorrection), s[0] /= s[3], s[1] /= s[3], new c.P((.5 * s[0] + .5) * this.width, (.5 * -s[1] + .5) * this.height) } screenPointToMercatorCoordinate(t, s) { if (s) { const l = s.pointCoordinate(t); if (l) return l } return c.a9.fromLngLat(this.unprojectScreenPoint(t)) } screenPointToLocation(t, s) { var l; return (l = this.screenPointToMercatorCoordinate(t, s)) === null || l === void 0 ? void 0 : l.toLngLat() } isPointOnMapSurface(t, s) { const l = this._cameraPosition, d = this.getRayDirectionFromPixel(t); return !!this.rayPlanetIntersection(l, d) } getRayDirectionFromPixel(t) { const s = c.bF(); s[0] = t.x / this.width * 2 - 1, s[1] = -1 * (t.y / this.height * 2 - 1), s[2] = 1, s[3] = 1, c.aH(s, s, this._globeViewProjMatrixNoCorrectionInverted), s[0] /= s[3], s[1] /= s[3], s[2] /= s[3]; const l = c.bz(); l[0] = s[0] - this._cameraPosition[0], l[1] = s[1] - this._cameraPosition[1], l[2] = s[2] - this._cameraPosition[2]; const d = c.bz(); return c.b3(d, l), d } isSurfacePointVisible(t) { const s = this._cachedClippingPlane; return s[0] * t[0] + s[1] * t[1] + s[2] * t[2] + s[3] >= 0 } isSurfacePointOnScreen(t) { if (!this.isSurfacePointVisible(t)) return !1; const s = c.bF(); return c.aH(s, [...t, 1], this._globeViewProjMatrixNoCorrection), s[0] /= s[3], s[1] /= s[3], s[2] /= s[3], s[0] > -1 && s[0] < 1 && s[1] > -1 && s[1] < 1 && s[2] > -1 && s[2] < 1 } rayPlanetIntersection(t, s) { const l = c.b5(t, s), d = c.bz(), g = c.bz(); c.a$(g, s, l), c.b2(d, t, g); const v = 1 - c.b5(d, d); if (v < 0) return null; const T = c.b5(t, t) - 1, E = -l + (l < 0 ? 1 : -1) * Math.sqrt(v), I = T / E, A = E; return { tMin: Math.min(I, A), tMax: Math.max(I, A) } } unprojectScreenPoint(t) { const s = this._cameraPosition, l = this.getRayDirectionFromPixel(t), d = this.rayPlanetIntersection(s, l); if (d) { const A = c.bz(); c.b0(A, s, [l[0] * d.tMin, l[1] * d.tMin, l[2] * d.tMin]); const R = c.bz(); return c.b3(R, A), Lc(R) } const g = this._cachedClippingPlane, v = g[0] * l[0] + g[1] * l[1] + g[2] * l[2], T = -c.bb(g, s) / v, E = c.bz(); if (T > 0) c.b0(E, s, [l[0] * T, l[1] * T, l[2] * T]); else { const A = c.bz(); c.b0(A, s, [2 * l[0], 2 * l[1], 2 * l[2]]); const R = c.bb(this._cachedClippingPlane, A); c.b2(E, A, [this._cachedClippingPlane[0] * R, this._cachedClippingPlane[1] * R, this._cachedClippingPlane[2] * R]) } const I = function (A) { const R = c.bz(); return R[0] = A[0] * -A[3], R[1] = A[1] * -A[3], R[2] = A[2] * -A[3], { center: R, radius: Math.sqrt(1 - A[3] * A[3]) } }(g); return Lc(function (A, R, z) { const O = c.bz(); c.b2(O, z, A); const U = c.bz(); return c.bA(U, A, O, R / c.b9(O)), U }(I.center, I.radius, E)) } getMatrixForModel(t, s) { const l = c.V.convert(t), d = 1 / c.bE, g = c.bj(); return c.bJ(g, g, l.lng / 180 * Math.PI), c.bh(g, g, -l.lat / 180 * Math.PI), c.O(g, g, [0, 0, 1 + s / c.bE]), c.bh(g, g, .5 * Math.PI), c.Q(g, g, [d, d, d]), g } getProjectionDataForCustomLayer(t = !0) { const s = this.getProjectionData({ overscaledTileID: new c.a2(0, 0, 0, 0, 0), applyGlobeMatrix: t }); return s.tileMercatorCoords = [0, 0, 1, 1], s } getFastPathSimpleProjectionMatrix(t) { } } class Vo { get pixelsToClipSpaceMatrix() { return this._helper.pixelsToClipSpaceMatrix } get clipSpaceToPixelsMatrix() { return this._helper.clipSpaceToPixelsMatrix } get pixelsToGLUnits() { return this._helper.pixelsToGLUnits } get centerOffset() { return this._helper.centerOffset } get size() { return this._helper.size } get rotationMatrix() { return this._helper.rotationMatrix } get centerPoint() { return this._helper.centerPoint } get pixelsPerMeter() { return this._helper.pixelsPerMeter } setMinZoom(t) { this._helper.setMinZoom(t) } setMaxZoom(t) { this._helper.setMaxZoom(t) } setMinPitch(t) { this._helper.setMinPitch(t) } setMaxPitch(t) { this._helper.setMaxPitch(t) } setRenderWorldCopies(t) { this._helper.setRenderWorldCopies(t) } setBearing(t) { this._helper.setBearing(t) } setPitch(t) { this._helper.setPitch(t) } setRoll(t) { this._helper.setRoll(t) } setFov(t) { this._helper.setFov(t) } setZoom(t) { this._helper.setZoom(t) } setCenter(t) { this._helper.setCenter(t) } setElevation(t) { this._helper.setElevation(t) } setMinElevationForCurrentTile(t) { this._helper.setMinElevationForCurrentTile(t) } setPadding(t) { this._helper.setPadding(t) } interpolatePadding(t, s, l) { return this._helper.interpolatePadding(t, s, l) } isPaddingEqual(t) { return this._helper.isPaddingEqual(t) } resize(t, s, l = !0) { this._helper.resize(t, s, l) } getMaxBounds() { return this._helper.getMaxBounds() } setMaxBounds(t) { this._helper.setMaxBounds(t) } setConstrainOverride(t) { this._helper.setConstrainOverride(t) } overrideNearFarZ(t, s) { this._helper.overrideNearFarZ(t, s) } clearNearFarZOverride() { this._helper.clearNearFarZOverride() } getCameraQueryGeometry(t) { return this._helper.getCameraQueryGeometry(this.getCameraPoint(), t) } get tileSize() { return this._helper.tileSize } get tileZoom() { return this._helper.tileZoom } get scale() { return this._helper.scale } get worldSize() { return this._helper.worldSize } get width() { return this._helper.width } get height() { return this._helper.height } get lngRange() { return this._helper.lngRange } get latRange() { return this._helper.latRange } get minZoom() { return this._helper.minZoom } get maxZoom() { return this._helper.maxZoom } get zoom() { return this._helper.zoom } get center() { return this._helper.center } get minPitch() { return this._helper.minPitch } get maxPitch() { return this._helper.maxPitch } get pitch() { return this._helper.pitch } get pitchInRadians() { return this._helper.pitchInRadians } get roll() { return this._helper.roll } get rollInRadians() { return this._helper.rollInRadians } get bearing() { return this._helper.bearing } get bearingInRadians() { return this._helper.bearingInRadians } get fov() { return this._helper.fov } get fovInRadians() { return this._helper.fovInRadians } get elevation() { return this._helper.elevation } get minElevationForCurrentTile() { return this._helper.minElevationForCurrentTile } get padding() { return this._helper.padding } get unmodified() { return this._helper.unmodified } get renderWorldCopies() { return this._helper.renderWorldCopies } get cameraToCenterDistance() { return this._helper.cameraToCenterDistance } get constrainOverride() { return this._helper.constrainOverride } get nearZ() { return this._helper.nearZ } get farZ() { return this._helper.farZ } get autoCalculateNearFarZ() { return this._helper.autoCalculateNearFarZ } get isGlobeRendering() { return this._globeness > 0 } setTransitionState(t, s) { this._globeness = t, this._globeLatitudeErrorCorrectionRadians = s, this._calcMatrices(), this._verticalPerspectiveTransform.getCoveringTilesDetailsProvider().prepareNextFrame(), this._mercatorTransform.getCoveringTilesDetailsProvider().prepareNextFrame() } get currentTransform() { return this.isGlobeRendering ? this._verticalPerspectiveTransform : this._mercatorTransform } constructor(t) { this._globeLatitudeErrorCorrectionRadians = 0, this._globeness = 1, this.defaultConstrain = (s, l) => this.currentTransform.defaultConstrain(s, l), this.applyConstrain = (s, l) => this._helper.applyConstrain(s, l), this._helper = new qs({ calcMatrices: () => { this._calcMatrices() }, defaultConstrain: (s, l) => this.defaultConstrain(s, l) }, t), this._globeness = 1, this._mercatorTransform = new Zs, this._verticalPerspectiveTransform = new jo } clone() { const t = new Vo; return t._globeness = this._globeness, t._globeLatitudeErrorCorrectionRadians = this._globeLatitudeErrorCorrectionRadians, t.apply(this), t } apply(t) { this._helper.apply(t), this._mercatorTransform.apply(this), this._verticalPerspectiveTransform.apply(this, this._globeLatitudeErrorCorrectionRadians) } get projectionMatrix() { return this.currentTransform.projectionMatrix } get modelViewProjectionMatrix() { return this.currentTransform.modelViewProjectionMatrix } get inverseProjectionMatrix() { return this.currentTransform.inverseProjectionMatrix } get cameraPosition() { return this.currentTransform.cameraPosition } getProjectionData(t) { const s = this._mercatorTransform.getProjectionData(t), l = this._verticalPerspectiveTransform.getProjectionData(t); return { mainMatrix: this.isGlobeRendering ? l.mainMatrix : s.mainMatrix, clippingPlane: l.clippingPlane, tileMercatorCoords: l.tileMercatorCoords, projectionTransition: t.applyGlobeMatrix ? this._globeness : 0, fallbackMatrix: s.fallbackMatrix } } isLocationOccluded(t) { return this.currentTransform.isLocationOccluded(t) } transformLightDirection(t) { return this.currentTransform.transformLightDirection(t) } getPixelScale() { return c.bu(this._mercatorTransform.getPixelScale(), this._verticalPerspectiveTransform.getPixelScale(), this._globeness) } getCircleRadiusCorrection() { return c.bu(this._mercatorTransform.getCircleRadiusCorrection(), this._verticalPerspectiveTransform.getCircleRadiusCorrection(), this._globeness) } getPitchedTextCorrection(t, s, l) { const d = this._mercatorTransform.getPitchedTextCorrection(t, s, l), g = this._verticalPerspectiveTransform.getPitchedTextCorrection(t, s, l); return c.bu(d, g, this._globeness) } projectTileCoordinates(t, s, l, d) { return this.currentTransform.projectTileCoordinates(t, s, l, d) } _calcMatrices() { this._helper._width && this._helper._height && (this._verticalPerspectiveTransform.apply(this, this._globeLatitudeErrorCorrectionRadians), this._helper._nearZ = this._verticalPerspectiveTransform.nearZ, this._helper._farZ = this._verticalPerspectiveTransform.farZ, this._mercatorTransform.apply(this, !0, this.isGlobeRendering), this._helper._nearZ = this._mercatorTransform.nearZ, this._helper._farZ = this._mercatorTransform.farZ) } calculateFogMatrix(t) { return this.currentTransform.calculateFogMatrix(t) } getVisibleUnwrappedCoordinates(t) { return this.currentTransform.getVisibleUnwrappedCoordinates(t) } getCameraFrustum() { return this.currentTransform.getCameraFrustum() } getClippingPlane() { return this.currentTransform.getClippingPlane() } getCoveringTilesDetailsProvider() { return this.currentTransform.getCoveringTilesDetailsProvider() } recalculateZoomAndCenter(t) { this._mercatorTransform.recalculateZoomAndCenter(t), this._verticalPerspectiveTransform.recalculateZoomAndCenter(t) } maxPitchScaleFactor() { return this._mercatorTransform.maxPitchScaleFactor() } getCameraPoint() { return this._helper.getCameraPoint() } getCameraAltitude() { return this._helper.getCameraAltitude() } getCameraLngLat() { return this._helper.getCameraLngLat() } lngLatToCameraDepth(t, s) { return this.currentTransform.lngLatToCameraDepth(t, s) } populateCache(t) { this._mercatorTransform.populateCache(t), this._verticalPerspectiveTransform.populateCache(t) } getBounds() { return this.currentTransform.getBounds() } calculateCenterFromCameraLngLatAlt(t, s, l, d) { return this._helper.calculateCenterFromCameraLngLatAlt(t, s, l, d) } setLocationAtPoint(t, s) { if (!this.isGlobeRendering) return this._mercatorTransform.setLocationAtPoint(t, s), void this.apply(this._mercatorTransform); this._verticalPerspectiveTransform.setLocationAtPoint(t, s), this.apply(this._verticalPerspectiveTransform) } locationToScreenPoint(t, s) { return this.currentTransform.locationToScreenPoint(t, s) } screenPointToMercatorCoordinate(t, s) { return this.currentTransform.screenPointToMercatorCoordinate(t, s) } screenPointToLocation(t, s) { return this.currentTransform.screenPointToLocation(t, s) } isPointOnMapSurface(t, s) { return this.currentTransform.isPointOnMapSurface(t, s) } getRayDirectionFromPixel(t) { return this._verticalPerspectiveTransform.getRayDirectionFromPixel(t) } getMatrixForModel(t, s) { return this.currentTransform.getMatrixForModel(t, s) } getProjectionDataForCustomLayer(t = !0) { const s = this._mercatorTransform.getProjectionDataForCustomLayer(t); if (!this.isGlobeRendering) return s; const l = this._verticalPerspectiveTransform.getProjectionDataForCustomLayer(t); return l.fallbackMatrix = s.mainMatrix, l } getFastPathSimpleProjectionMatrix(t) { return this.currentTransform.getFastPathSimpleProjectionMatrix(t) } } class Xr { get useGlobeControls() { return !0 } handlePanInertia(t, s) { const l = Wd(t, s); return Math.abs(l.lng - s.center.lng) > 180 && (l.lng = s.center.lng + 179.5 * Math.sign(l.lng - s.center.lng)), { easingCenter: l, easingOffset: new c.P(0, 0) } } handleMapControlsRollPitchBearingZoom(t, s) { const l = t.around, d = s.screenPointToLocation(l); t.bearingDelta && s.setBearing(s.bearing + t.bearingDelta), t.pitchDelta && s.setPitch(s.pitch + t.pitchDelta), t.rollDelta && s.setRoll(s.roll + t.rollDelta); const g = s.zoom; t.zoomDelta && s.setZoom(s.zoom + t.zoomDelta); const v = s.zoom - g; if (v === 0) return; const T = c.bK(s.center.lng, d.lng), E = T / (Math.abs(T / 180) + 1), I = c.bK(s.center.lat, d.lat), A = s.getRayDirectionFromPixel(l), R = s.cameraPosition, z = -1 * c.b5(R, A), O = c.bz(); c.b0(O, R, [A[0] * z, A[1] * z, A[2] * z]); const U = c.b7(O) - 1, X = Math.exp(.5 * -Math.max(U - .3, 0)), Q = Hs(s.worldSize, s.center.lat) / Math.min(s.width, s.height), Y = c.bx(Q, .9, .5, 1, .25), te = (1 - c.aq(-v)) * Math.min(X, Y), le = s.center.lat, J = s.zoom, oe = new c.V(s.center.lng + E * te, c.an(s.center.lat + I * te, -c.ao, c.ao)); s.setLocationAtPoint(d, l); const ce = s.center, se = c.bx(Math.abs(T), 45, 85, 0, 1), fe = c.bx(Q, .75, .35, 0, 1), Oe = Math.pow(Math.max(se, fe), .25), ke = c.bK(ce.lng, oe.lng), ze = c.bK(ce.lat, oe.lat); s.setCenter(new c.V(ce.lng + ke * Oe, ce.lat + ze * Oe).wrap()), s.setZoom(J + Cr(le, s.center.lat)) } handleMapControlsPan(t, s, l) { if (!t.panDelta) return; const d = s.center.lat, g = s.zoom; s.setCenter(Wd(t.panDelta, s).wrap()), s.setZoom(g + Cr(d, s.center.lat)) } cameraForBoxAndBearing(t, s, l, d, g) { const v = zc(t, s, l, d, g), T = s.left / g.width * 2 - 1, E = (g.width - s.right) / g.width * 2 - 1, I = s.top / g.height * -2 + 1, A = (g.height - s.bottom) / g.height * -2 + 1, R = c.bK(l.getWest(), l.getEast()) < 0, z = R ? l.getEast() : l.getWest(), O = R ? l.getWest() : l.getEast(), U = Math.max(l.getNorth(), l.getSouth()), X = Math.min(l.getNorth(), l.getSouth()), Q = z + .5 * c.bK(z, O), Y = U + .5 * c.bK(U, X), te = g.clone(); te.setCenter(v.center), te.setBearing(v.bearing), te.setPitch(0), te.setRoll(0), te.setZoom(v.zoom); const le = te.modelViewProjectionMatrix, J = [_r(l.getNorthWest()), _r(l.getNorthEast()), _r(l.getSouthWest()), _r(l.getSouthEast()), _r(new c.V(O, Y)), _r(new c.V(z, Y)), _r(new c.V(Q, U)), _r(new c.V(Q, X))], oe = _r(v.center); let ce = Number.POSITIVE_INFINITY; for (const se of J) T < 0 && (ce = Xr.getLesserNonNegativeNonNull(ce, Xr.solveVectorScale(se, oe, le, "x", T))), E > 0 && (ce = Xr.getLesserNonNegativeNonNull(ce, Xr.solveVectorScale(se, oe, le, "x", E))), I > 0 && (ce = Xr.getLesserNonNegativeNonNull(ce, Xr.solveVectorScale(se, oe, le, "y", I))), A < 0 && (ce = Xr.getLesserNonNegativeNonNull(ce, Xr.solveVectorScale(se, oe, le, "y", A))); if (Number.isFinite(ce) && ce !== 0) return v.zoom = te.zoom + c.at(ce), v; ts() } handleJumpToCenterZoom(t, s) { const l = t.center.lat, d = t.applyConstrain(s.center ? c.V.convert(s.center) : t.center, t.zoom).center; t.setCenter(d.wrap()); const g = s.zoom !== void 0 ? +s.zoom : t.zoom + Cr(l, d.lat); t.zoom !== g && t.setZoom(g) } handleEaseTo(t, s) { const l = t.zoom, d = t.center, g = t.padding, v = { roll: t.roll, pitch: t.pitch, bearing: t.bearing }, T = { roll: s.roll === void 0 ? t.roll : s.roll, pitch: s.pitch === void 0 ? t.pitch : s.pitch, bearing: s.bearing === void 0 ? t.bearing : s.bearing }, E = s.zoom !== void 0, I = !t.isPaddingEqual(s.padding); let A = !1; const R = s.center ? c.V.convert(s.center) : d, z = t.applyConstrain(R, l).center; bs(t, z); const O = t.clone(); O.setCenter(z), O.setZoom(E ? +s.zoom : l + Cr(d.lat, R.lat)), O.setBearing(s.bearing); const U = new c.P(c.an(t.centerPoint.x + s.offsetAsPoint.x, 0, t.width), c.an(t.centerPoint.y + s.offsetAsPoint.y, 0, t.height)); O.setLocationAtPoint(z, U); const X = (s.offset && s.offsetAsPoint.mag()) > 0 ? O.center : z, Q = E ? +s.zoom : l + Cr(d.lat, X.lat), Y = l + Cr(d.lat, 0), te = Q + Cr(X.lat, 0), le = c.bK(d.lng, X.lng), J = c.bK(d.lat, X.lat), oe = c.aq(te - Y); return A = Q !== l, { easeFunc: ce => { if (c.bo(v, T) || $d({ startEulerAngles: v, endEulerAngles: T, tr: t, k: ce, useSlerp: v.roll != T.roll }), I && t.interpolatePadding(g, s.padding, ce), s.around) c.w("Easing around a point is not supported under globe projection."), t.setLocationAtPoint(s.around, s.aroundPoint); else { const se = te > Y ? Math.min(2, oe) : Math.max(.5, oe), fe = Math.pow(se, 1 - ce), Oe = Hd(d, le, J, ce * fe); t.setCenter(Oe.wrap()) } if (A) { const se = c.G.number(Y, te, ce) + Cr(0, t.center.lat); t.setZoom(se) } }, isZooming: A, elevationCenter: X } } handleFlyTo(t, s) { const l = s.zoom !== void 0, d = t.center, g = t.zoom, v = t.padding, T = !t.isPaddingEqual(s.padding), E = t.applyConstrain(c.V.convert(s.center || s.locationAtOffset), g).center, I = l ? +s.zoom : t.zoom + Cr(t.center.lat, E.lat), A = t.clone(); A.setCenter(E), A.setZoom(I), A.setBearing(s.bearing); const R = new c.P(c.an(t.centerPoint.x + s.offsetAsPoint.x, 0, t.width), c.an(t.centerPoint.y + s.offsetAsPoint.y, 0, t.height)); A.setLocationAtPoint(E, R); const z = A.center; bs(t, z); const O = function (J, oe, ce) { const se = _r(oe), fe = _r(ce), Oe = c.b5(se, fe), ke = Math.acos(Oe), ze = Rn(J); return ke / (2 * Math.PI) * ze }(t, d, z), U = g + Cr(d.lat, 0), X = I + Cr(z.lat, 0), Q = c.aq(X - U); let Y; if (typeof s.minZoom == "number") { const J = +s.minZoom + Cr(z.lat, 0), oe = Math.min(J, U, X) + Cr(0, z.lat), ce = t.applyConstrain(z, oe).zoom + Cr(z.lat, 0); Y = c.aq(ce - U) } const te = c.bK(d.lng, z.lng), le = c.bK(d.lat, z.lat); return { easeFunc: (J, oe, ce, se) => { const fe = Hd(d, te, le, ce); T && t.interpolatePadding(v, s.padding, J); const Oe = J === 1 ? z : fe; t.setCenter(Oe.wrap()); const ke = U + c.at(oe); t.setZoom(J === 1 ? I : ke + Cr(0, Oe.lat)) }, scaleOfZoom: Q, targetCenter: z, scaleOfMinZoom: Y, pixelPathLength: O } } static solveVectorScale(t, s, l, d, g) { const v = d === "x" ? [l[0], l[4], l[8], l[12]] : [l[1], l[5], l[9], l[13]], T = [l[3], l[7], l[11], l[15]], E = t[0] * v[0] + t[1] * v[1] + t[2] * v[2], I = t[0] * T[0] + t[1] * T[1] + t[2] * T[2], A = s[0] * v[0] + s[1] * v[1] + s[2] * v[2], R = s[0] * T[0] + s[1] * T[1] + s[2] * T[2]; return A + g * I === E + g * R || T[3] * (E - A) + v[3] * (R - I) + E * R == A * I ? null : (A + v[3] - g * R - g * T[3]) / (A - E - g * R + g * I) } static getLesserNonNegativeNonNull(t, s) { return s !== null && s >= 0 && s < t ? s : t } } class Xd { constructor(t) { this._globe = t, this._mercatorCameraHelper = new Ws, this._verticalPerspectiveCameraHelper = new Xr } get useGlobeControls() { return this._globe.useGlobeRendering } get currentHelper() { return this.useGlobeControls ? this._verticalPerspectiveCameraHelper : this._mercatorCameraHelper } handlePanInertia(t, s) { return this.currentHelper.handlePanInertia(t, s) } handleMapControlsRollPitchBearingZoom(t, s) { return this.currentHelper.handleMapControlsRollPitchBearingZoom(t, s) } handleMapControlsPan(t, s, l) { this.currentHelper.handleMapControlsPan(t, s, l) } cameraForBoxAndBearing(t, s, l, d, g) { return this.currentHelper.cameraForBoxAndBearing(t, s, l, d, g) } handleJumpToCenterZoom(t, s) { this.currentHelper.handleJumpToCenterZoom(t, s) } handleEaseTo(t, s) { return this.currentHelper.handleEaseTo(t, s) } handleFlyTo(t, s) { return this.currentHelper.handleFlyTo(t, s) } } const Uo = (m, t) => c.B(m, t && t.filter(s => s.identifier !== "source.canvas")), Ua = c.bO(); class Xs extends c.E { constructor(t, s = {}) { var l, d; super(), this._rtlPluginLoaded = () => { for (const v in this.tileManagers) { const T = this.tileManagers[v].getSource().type; T !== "vector" && T !== "geojson" || this.tileManagers[v].reload() } }, this.map = t, this.dispatcher = new In(vi(), t._getMapId()), this.dispatcher.registerMessageHandler("GG", (v, T) => this.getGlyphs(v, T)), this.dispatcher.registerMessageHandler("GI", (v, T) => this.getImages(v, T)), this.dispatcher.registerMessageHandler("GDA", (v, T) => this.getDashes(v, T)), this.imageManager = new xe, this.imageManager.setEventedParent(this); const g = ((l = t._container) === null || l === void 0 ? void 0 : l.lang) || typeof document < "u" && ((d = document.documentElement) === null || d === void 0 ? void 0 : d.lang) || void 0; this.glyphManager = new Le(t._requestManager, s.localIdeographFontFamily, g), this.lineAtlas = new Zt(256, 512), this.crossTileSymbolIndex = new Vn, this._setInitialValues(), this._resetUpdates(), this.dispatcher.broadcast("SR", c.bP()), Ee().on(ue, this._rtlPluginLoaded), this.on("data", v => { if (v.dataType !== "source" || v.sourceDataType !== "metadata") return; const T = this.tileManagers[v.sourceId]; if (!T) return; const E = T.getSource(); if (E && E.vectorLayerIds) for (const I in this._layers) { const A = this._layers[I]; A.source === E.id && this._validateLayer(A) } }) } _setInitialValues() { var t; this._spritesImagesIds = {}, this._layers = {}, this._order = [], this.tileManagers = {}, this.zoomHistory = new c.bQ, this._availableImages = [], this._globalState = {}, this._serializedLayers = {}, this.stylesheet = null, this.light = null, this.sky = null, this.projection && (this.projection.destroy(), delete this.projection), this._loaded = !1, this._changed = !1, this._updatedLayers = {}, this._updatedSources = {}, this._changedImages = {}, this._glyphsDidChange = !1, this._updatedPaintProps = {}, this._layerOrderChanged = !1, this.crossTileSymbolIndex = new (((t = this.crossTileSymbolIndex) === null || t === void 0 ? void 0 : t.constructor) || Object), this.pauseablePlacement = void 0, this.placement = void 0, this.z = 0 } setGlobalStateProperty(t, s) { var l, d, g; this._checkLoaded(); const v = s === null ? (g = (d = (l = this.stylesheet.state) === null || l === void 0 ? void 0 : l[t]) === null || d === void 0 ? void 0 : d.default) !== null && g !== void 0 ? g : null : s; if (c.bR(v, this._globalState[t])) return this; this._globalState[t] = v, this._applyGlobalStateChanges([t]) } getGlobalState() { return this._globalState } setGlobalState(t) { this._checkLoaded(); const s = []; for (const l in t) !c.bR(this._globalState[l], t[l].default) && (s.push(l), this._globalState[l] = t[l].default); this._applyGlobalStateChanges(s) } _applyGlobalStateChanges(t) { if (t.length === 0) return; const s = new Set, l = {}; for (const d of t) { l[d] = this._globalState[d]; for (const g in this._layers) { const v = this._layers[g], T = v.getLayoutAffectingGlobalStateRefs(), E = v.getPaintAffectingGlobalStateRefs(), I = v.getVisibilityAffectingGlobalStateRefs(); if (T.has(d) && s.add(v.source), E.has(d)) for (const { name: A, value: R } of E.get(d)) this._updatePaintProperty(v, A, R); I != null && I.has(d) && (v.recalculateVisibility(), this._updateLayer(v)) } } this.dispatcher.broadcast("UGS", l); for (const d in this.tileManagers) s.has(d) && (this._reloadSource(d), this._changed = !0) } loadURL(t, s = {}, l) { this.fire(new c.l("dataloading", { dataType: "style" })), s.validate = typeof s.validate != "boolean" || s.validate; const d = this.map._requestManager.transformRequest(t, "Style"); this._loadStyleRequest = new AbortController; const g = this._loadStyleRequest; c.j(d, this._loadStyleRequest).then(v => { this._loadStyleRequest = null, this._load(v.data, s, l) }).catch(v => { this._loadStyleRequest = null, v && !g.signal.aborted && this.fire(new c.k(v)) }) } loadJSON(t, s = {}, l) { this.fire(new c.l("dataloading", { dataType: "style" })), this._frameRequest = new AbortController, Ge.frameAsync(this._frameRequest).then(() => { this._frameRequest = null, s.validate = s.validate !== !1, this._load(t, s, l) }).catch(() => { }) } loadEmpty() { this.fire(new c.l("dataloading", { dataType: "style" })), this._load(Ua, { validate: !1 }) } _load(t, s, l) { var d, g; let v = s.transformStyle ? s.transformStyle(l, t) : t; if (!s.validate || !Uo(this, c.C(v))) { v = Object.assign({}, v), this._loaded = !0, this.stylesheet = v; for (const T in v.sources) this.addSource(T, v.sources[T], { validate: !1 }); v.sprite ? this._loadSprite(v.sprite) : this.imageManager.setLoaded(!0), this.glyphManager.setURL(v.glyphs), this._createLayers(), this.light = new et(this.stylesheet.light), this._setProjectionInternal(((d = this.stylesheet.projection) === null || d === void 0 ? void 0 : d.type) || "mercator"), this.sky = new Tt(this.stylesheet.sky), this.map.setTerrain((g = this.stylesheet.terrain) !== null && g !== void 0 ? g : null), this.fire(new c.l("data", { dataType: "style" })), this.fire(new c.l("style.load")) } } _createLayers() { var t, s, l; const d = c.bS(this.stylesheet.layers); this.setGlobalState((t = this.stylesheet.state) !== null && t !== void 0 ? t : null), this.dispatcher.broadcast("SL", d), this._order = d.map(g => g.id), this._layers = {}, this._serializedLayers = null; for (const g of d) { const v = c.bT(g, this._globalState); if (v.setEventedParent(this, { layer: { id: g.id } }), this._layers[g.id] = v, c.bU(v) && this.tileManagers[v.source]) { const T = (l = (s = g.paint) === null || s === void 0 ? void 0 : s["raster-fade-duration"]) !== null && l !== void 0 ? l : v.paint.get("raster-fade-duration"); this.tileManagers[v.source].setRasterFadeDuration(T) } } } _loadSprite(t, s = !1, l = void 0) { this.imageManager.setLoaded(!1); const d = new AbortController; let g; this._spriteRequest = d, function (v, T, E, I) { return c._(this, void 0, void 0, function* () { const A = re(v), R = E > 1 ? "@2x" : "", z = {}, O = {}; for (const { id: U, url: X } of A) { const Q = T.transformRequest(ie(X, R, ".json"), "SpriteJSON"); z[U] = c.j(Q, I); const Y = T.transformRequest(ie(X, R, ".png"), "SpriteImage"); O[U] = ct.getImage(Y, I) } return yield Promise.all([...Object.values(z), ...Object.values(O)]), function (U, X) { return c._(this, void 0, void 0, function* () { const Q = {}; for (const Y in U) { Q[Y] = {}; const te = Ge.getImageCanvasContext((yield X[Y]).data), le = (yield U[Y]).data; for (const J in le) { const { width: oe, height: ce, x: se, y: fe, sdf: Oe, pixelRatio: ke, stretchX: ze, stretchY: Re, content: Je, textFitWidth: tt, textFitHeight: We } = le[J]; Q[Y][J] = { data: null, pixelRatio: ke, sdf: Oe, stretchX: ze, stretchY: Re, content: Je, textFitWidth: tt, textFitHeight: We, spriteData: { width: oe, height: ce, x: se, y: fe, context: te } } } } return Q }) }(z, O) }) }(t, this.map._requestManager, this.map.getPixelRatio(), this._spriteRequest).then(v => { if (this._spriteRequest = null, v) for (const T in v) { this._spritesImagesIds[T] = []; const E = this._spritesImagesIds[T] ? this._spritesImagesIds[T].filter(I => !(I in v)) : []; for (const I of E) this.imageManager.removeImage(I), this._changedImages[I] = !0; for (const I in v[T]) { const A = T === "default" ? I : `${T}:${I}`; this._spritesImagesIds[T].push(A), A in this.imageManager.images ? this.imageManager.updateImage(A, v[T][I], !1) : this.imageManager.addImage(A, v[T][I]), s && (this._changedImages[A] = !0) } } }).catch(v => { this._spriteRequest = null, g = v, d.signal.aborted || this.fire(new c.k(g)) }).finally(() => { this.imageManager.setLoaded(!0), this._availableImages = this.imageManager.listImages(), s && (this._changed = !0), this.dispatcher.broadcast("SI", this._availableImages), this.fire(new c.l("data", { dataType: "style" })), l && l(g) }) } _unloadSprite() { for (const t of Object.values(this._spritesImagesIds).flat()) this.imageManager.removeImage(t), this._changedImages[t] = !0; this._spritesImagesIds = {}, this._availableImages = this.imageManager.listImages(), this._changed = !0, this.dispatcher.broadcast("SI", this._availableImages), this.fire(new c.l("data", { dataType: "style" })) } _validateLayer(t) { const s = this.tileManagers[t.source]; if (!s) return; const l = t.sourceLayer; if (!l) return; const d = s.getSource(); (d.type === "geojson" || d.vectorLayerIds && d.vectorLayerIds.indexOf(l) === -1) && this.fire(new c.k(new Error(`Source layer "${l}" does not exist on source "${d.id}" as specified by style layer "${t.id}".`))) } loaded() { if (!this._loaded || Object.keys(this._updatedSources).length) return !1; for (const t in this.tileManagers) if (!this.tileManagers[t].loaded()) return !1; return !!this.imageManager.isLoaded() } _serializeByIds(t, s = !1) { const l = this._serializedAllLayers(); if (!t || t.length === 0) return Object.values(s ? c.bV(l) : l); const d = []; for (const g of t) if (l[g]) { const v = s ? c.bV(l[g]) : l[g]; d.push(v) } return d } _serializedAllLayers() { let t = this._serializedLayers; if (t) return t; t = this._serializedLayers = {}; const s = Object.keys(this._layers); for (const l of s) { const d = this._layers[l]; d.type !== "custom" && (t[l] = d.serialize()) } return t } hasTransitions() { var t, s, l; if (!((t = this.light) === null || t === void 0) && t.hasTransition() || !((s = this.sky) === null || s === void 0) && s.hasTransition() || !((l = this.projection) === null || l === void 0) && l.hasTransition()) return !0; for (const d in this.tileManagers) if (this.tileManagers[d].hasTransition()) return !0; for (const d in this._layers) if (this._layers[d].hasTransition()) return !0; return !1 } _checkLoaded() { if (!this._loaded) throw new Error("Style is not done loading.") } update(t) { if (!this._loaded) return; const s = this._changed; if (s) { const d = Object.keys(this._updatedLayers), g = Object.keys(this._removedLayers); (d.length || g.length) && this._updateWorkerLayers(d, g); for (const v in this._updatedSources) { const T = this._updatedSources[v]; if (T === "reload") this._reloadSource(v); else { if (T !== "clear") throw new Error(`Invalid action ${T}`); this._clearSource(v) } } this._updateTilesForChangedImages(), this._updateTilesForChangedGlyphs(); for (const v in this._updatedPaintProps) this._layers[v].updateTransitions(t); this.light.updateTransitions(t), this.sky.updateTransitions(t), this._resetUpdates() } const l = {}; for (const d in this.tileManagers) { const g = this.tileManagers[d]; l[d] = g.used, g.used = !1 } for (const d of this._order) { const g = this._layers[d]; g.recalculate(t, this._availableImages), !g.isHidden(t.zoom) && g.source && (this.tileManagers[g.source].used = !0) } for (const d in l) { const g = this.tileManagers[d]; !!l[d] != !!g.used && g.fire(new c.l("data", { sourceDataType: "visibility", dataType: "source", sourceId: d })) } this.light.recalculate(t), this.sky.recalculate(t), this.projection.recalculate(t), this.z = t.zoom, s && this.fire(new c.l("data", { dataType: "style" })) } _updateTilesForChangedImages() { const t = Object.keys(this._changedImages); if (t.length) { for (const s in this.tileManagers) this.tileManagers[s].reloadTilesForDependencies(["icons", "patterns"], t); this._changedImages = {} } } _updateTilesForChangedGlyphs() { if (this._glyphsDidChange) { for (const t in this.tileManagers) this.tileManagers[t].reloadTilesForDependencies(["glyphs"], [""]); this._glyphsDidChange = !1 } } _updateWorkerLayers(t, s) { this.dispatcher.broadcast("UL", { layers: this._serializeByIds(t, !1), removedIds: s }) } _resetUpdates() { this._changed = !1, this._updatedLayers = {}, this._removedLayers = {}, this._updatedSources = {}, this._updatedPaintProps = {}, this._changedImages = {}, this._glyphsDidChange = !1 } setState(t, s = {}) { var l; this._checkLoaded(); const d = this.serialize(); if (t = s.transformStyle ? s.transformStyle(d, t) : t, ((l = s.validate) === null || l === void 0 || l) && Uo(this, c.C(t))) return !1; (t = c.bV(t)).layers = c.bS(t.layers); const g = c.bW(d, t), v = this._getOperationsToPerform(g); if (v.unimplemented.length > 0) throw new Error(`Unimplemented: ${v.unimplemented.join(", ")}.`); if (v.operations.length === 0) return !1; for (const T of v.operations) T(); return this.stylesheet = t, this._serializedLayers = null, !0 } _getOperationsToPerform(t) { const s = [], l = []; for (const d of t) switch (d.command) { case "setCenter": case "setZoom": case "setBearing": case "setPitch": case "setRoll": continue; case "addLayer": s.push(() => this.addLayer.apply(this, d.args)); break; case "removeLayer": s.push(() => this.removeLayer.apply(this, d.args)); break; case "setPaintProperty": s.push(() => this.setPaintProperty.apply(this, d.args)); break; case "setLayoutProperty": s.push(() => this.setLayoutProperty.apply(this, d.args)); break; case "setFilter": s.push(() => this.setFilter.apply(this, d.args)); break; case "addSource": s.push(() => this.addSource.apply(this, d.args)); break; case "removeSource": s.push(() => this.removeSource.apply(this, d.args)); break; case "setLayerZoomRange": s.push(() => this.setLayerZoomRange.apply(this, d.args)); break; case "setLight": s.push(() => this.setLight.apply(this, d.args)); break; case "setGeoJSONSourceData": s.push(() => this.setGeoJSONSourceData.apply(this, d.args)); break; case "setGlyphs": s.push(() => this.setGlyphs.apply(this, d.args)); break; case "setSprite": s.push(() => this.setSprite.apply(this, d.args)); break; case "setTerrain": s.push(() => this.map.setTerrain.apply(this, d.args)); break; case "setSky": s.push(() => this.setSky.apply(this, d.args)); break; case "setProjection": this.setProjection.apply(this, d.args); break; case "setGlobalState": s.push(() => this.setGlobalState.apply(this, d.args)); break; case "setTransition": s.push(() => { }); break; default: l.push(d.command) }return { operations: s, unimplemented: l } } addImage(t, s) { if (this.getImage(t)) return this.fire(new c.k(new Error(`An image named "${t}" already exists.`))); this.imageManager.addImage(t, s), this._afterImageUpdated(t) } updateImage(t, s) { this.imageManager.updateImage(t, s) } getImage(t) { return this.imageManager.getImage(t) } removeImage(t) { if (!this.getImage(t)) return this.fire(new c.k(new Error(`An image named "${t}" does not exist.`))); this.imageManager.removeImage(t), this._afterImageUpdated(t) } _afterImageUpdated(t) { this._availableImages = this.imageManager.listImages(), this._changedImages[t] = !0, this._changed = !0, this.dispatcher.broadcast("SI", this._availableImages), this.fire(new c.l("data", { dataType: "style" })) } listImages() { return this._checkLoaded(), this.imageManager.listImages() } addSource(t, s, l = {}) { if (this._checkLoaded(), this.tileManagers[t] !== void 0) throw new Error(`Source "${t}" already exists.`); if (!s.type) throw new Error(`The type property must be defined, but only the following properties were given: ${Object.keys(s).join(", ")}.`); if (["vector", "raster", "geojson", "video", "image"].indexOf(s.type) >= 0 && this._validate(c.C.source, `sources.${t}`, s, null, l)) return; this.map && this.map._collectResourceTiming && (s.collectResourceTiming = !0); const d = this.tileManagers[t] = new oi(t, s, this.dispatcher); d.style = this, d.setEventedParent(this, () => ({ isSourceLoaded: d.loaded(), source: d.serialize(), sourceId: t })), d.onAdd(this.map), this._changed = !0 } removeSource(t) { if (this._checkLoaded(), this.tileManagers[t] === void 0) throw new Error("There is no source with this ID"); for (const l in this._layers) if (this._layers[l].source === t) return this.fire(new c.k(new Error(`Source "${t}" cannot be removed while layer "${l}" is using it.`))); const s = this.tileManagers[t]; delete this.tileManagers[t], delete this._updatedSources[t], s.fire(new c.l("data", { sourceDataType: "metadata", dataType: "source", sourceId: t })), s.setEventedParent(null), s.onRemove(this.map), this._changed = !0 } setGeoJSONSourceData(t, s) { if (this._checkLoaded(), this.tileManagers[t] === void 0) throw new Error(`There is no source with this ID=${t}`); const l = this.tileManagers[t].getSource(); if (l.type !== "geojson") throw new Error(`geojsonSource.type is ${l.type}, which is !== 'geojson`); l.setData(s), this._changed = !0 } getSource(t) { return this.tileManagers[t] && this.tileManagers[t].getSource() } addLayer(t, s, l = {}) { this._checkLoaded(); const d = t.id; if (this.getLayer(d)) return void this.fire(new c.k(new Error(`Layer "${d}" already exists on this map.`))); let g; if (t.type === "custom") { if (Uo(this, c.bX(t))) return; g = c.bT(t, this._globalState) } else { if ("source" in t && typeof t.source == "object" && (this.addSource(d, t.source), t = c.bV(t), t = c.e(t, { source: d })), this._validate(c.C.layer, `layers.${d}`, t, { arrayIndex: -1 }, l)) return; g = c.bT(t, this._globalState), this._validateLayer(g), g.setEventedParent(this, { layer: { id: d } }) } const v = s ? this._order.indexOf(s) : this._order.length; if (s && v === -1) this.fire(new c.k(new Error(`Cannot add layer "${d}" before non-existing layer "${s}".`))); else { if (this._order.splice(v, 0, d), this._layerOrderChanged = !0, this._layers[d] = g, this._removedLayers[d] && g.source && g.type !== "custom") { const T = this._removedLayers[d]; delete this._removedLayers[d], T.type !== g.type ? this._updatedSources[g.source] = "clear" : (this._updatedSources[g.source] = "reload", this.tileManagers[g.source].pause()) } this._updateLayer(g), g.onAdd && g.onAdd(this.map) } } moveLayer(t, s) { if (this._checkLoaded(), this._changed = !0, !this._layers[t]) return void this.fire(new c.k(new Error(`The layer '${t}' does not exist in the map's style and cannot be moved.`))); if (t === s) return; const l = this._order.indexOf(t); this._order.splice(l, 1); const d = s ? this._order.indexOf(s) : this._order.length; s && d === -1 ? this.fire(new c.k(new Error(`Cannot move layer "${t}" before non-existing layer "${s}".`))) : (this._order.splice(d, 0, t), this._layerOrderChanged = !0) } removeLayer(t) { this._checkLoaded(); const s = this._layers[t]; if (!s) return void this.fire(new c.k(new Error(`Cannot remove non-existing layer "${t}".`))); s.setEventedParent(null); const l = this._order.indexOf(t); this._order.splice(l, 1), this._layerOrderChanged = !0, this._changed = !0, this._removedLayers[t] = s, delete this._layers[t], this._serializedLayers && delete this._serializedLayers[t], delete this._updatedLayers[t], delete this._updatedPaintProps[t], s.onRemove && s.onRemove(this.map) } getLayer(t) { return this._layers[t] } getLayersOrder() { return [...this._order] } hasLayer(t) { return t in this._layers } setLayerZoomRange(t, s, l) { this._checkLoaded(); const d = this.getLayer(t); d ? d.minzoom === s && d.maxzoom === l || (s != null && (d.minzoom = s), l != null && (d.maxzoom = l), this._updateLayer(d)) : this.fire(new c.k(new Error(`Cannot set the zoom range of non-existing layer "${t}".`))) } setFilter(t, s, l = {}) { this._checkLoaded(); const d = this.getLayer(t); if (d) { if (!c.bR(d.filter, s)) return s == null ? (d.setFilter(void 0), void this._updateLayer(d)) : void (this._validate(c.C.filter, `layers.${d.id}.filter`, s, null, l) || (d.setFilter(c.bV(s)), this._updateLayer(d))) } else this.fire(new c.k(new Error(`Cannot filter non-existing layer "${t}".`))) } getFilter(t) { return c.bV(this.getLayer(t).filter) } setLayoutProperty(t, s, l, d = {}) { this._checkLoaded(); const g = this.getLayer(t); g ? c.bR(g.getLayoutProperty(s), l) || (g.setLayoutProperty(s, l, d), this._updateLayer(g)) : this.fire(new c.k(new Error(`Cannot style non-existing layer "${t}".`))) } getLayoutProperty(t, s) { const l = this.getLayer(t); if (l) return l.getLayoutProperty(s); this.fire(new c.k(new Error(`Cannot get style of non-existing layer "${t}".`))) } setPaintProperty(t, s, l, d = {}) { this._checkLoaded(); const g = this.getLayer(t); g ? c.bR(g.getPaintProperty(s), l) || this._updatePaintProperty(g, s, l, d) : this.fire(new c.k(new Error(`Cannot style non-existing layer "${t}".`))) } _updatePaintProperty(t, s, l, d = {}) { t.setPaintProperty(s, l, d) && this._updateLayer(t), c.bU(t) && s === "raster-fade-duration" && this.tileManagers[t.source].setRasterFadeDuration(l), this._changed = !0, this._updatedPaintProps[t.id] = !0, this._serializedLayers = null } getPaintProperty(t, s) { return this.getLayer(t).getPaintProperty(s) } setFeatureState(t, s) { this._checkLoaded(); const l = t.source, d = t.sourceLayer, g = this.tileManagers[l]; if (g === void 0) return void this.fire(new c.k(new Error(`The source '${l}' does not exist in the map's style.`))); const v = g.getSource().type; v === "geojson" && d ? this.fire(new c.k(new Error("GeoJSON sources cannot have a sourceLayer parameter."))) : v !== "vector" || d ? (t.id === void 0 && this.fire(new c.k(new Error("The feature id parameter must be provided."))), g.setFeatureState(d, t.id, s)) : this.fire(new c.k(new Error("The sourceLayer parameter must be provided for vector source types."))) } removeFeatureState(t, s) { this._checkLoaded(); const l = t.source, d = this.tileManagers[l]; if (d === void 0) return void this.fire(new c.k(new Error(`The source '${l}' does not exist in the map's style.`))); const g = d.getSource().type, v = g === "vector" ? t.sourceLayer : void 0; g !== "vector" || v ? s && typeof t.id != "string" && typeof t.id != "number" ? this.fire(new c.k(new Error("A feature id is required to remove its specific state property."))) : d.removeFeatureState(v, t.id, s) : this.fire(new c.k(new Error("The sourceLayer parameter must be provided for vector source types."))) } getFeatureState(t) { this._checkLoaded(); const s = t.source, l = t.sourceLayer, d = this.tileManagers[s]; if (d !== void 0) return d.getSource().type !== "vector" || l ? (t.id === void 0 && this.fire(new c.k(new Error("The feature id parameter must be provided."))), d.getFeatureState(l, t.id)) : void this.fire(new c.k(new Error("The sourceLayer parameter must be provided for vector source types."))); this.fire(new c.k(new Error(`The source '${s}' does not exist in the map's style.`))) } getTransition() { return c.e({ duration: 300, delay: 0 }, this.stylesheet && this.stylesheet.transition) } serialize() { if (!this._loaded) return; const t = c.bY(this.tileManagers, g => g.serialize()), s = this._serializeByIds(this._order, !0), l = this.map.getTerrain() || void 0, d = this.stylesheet; return c.bZ({ version: d.version, name: d.name, metadata: d.metadata, light: d.light, sky: d.sky, center: d.center, zoom: d.zoom, bearing: d.bearing, pitch: d.pitch, sprite: d.sprite, glyphs: d.glyphs, transition: d.transition, projection: d.projection, sources: t, layers: s, terrain: l }, g => g !== void 0) } _updateLayer(t) { this._updatedLayers[t.id] = !0, t.source && !this._updatedSources[t.source] && this.tileManagers[t.source].getSource().type !== "raster" && (this._updatedSources[t.source] = "reload", this.tileManagers[t.source].pause()), this._serializedLayers = null, this._changed = !0 } _flattenAndSortRenderedFeatures(t) { const s = v => this._layers[v].type === "fill-extrusion", l = {}, d = []; for (let v = this._order.length - 1; v >= 0; v--) { const T = this._order[v]; if (s(T)) { l[T] = v; for (const E of t) { const I = E[T]; if (I) for (const A of I) d.push(A) } } } d.sort((v, T) => T.intersectionZ - v.intersectionZ); const g = []; for (let v = this._order.length - 1; v >= 0; v--) { const T = this._order[v]; if (s(T)) for (let E = d.length - 1; E >= 0; E--) { const I = d[E].feature; if (l[I.layer.id] < v) break; g.push(I), d.pop() } else for (const E of t) { const I = E[T]; if (I) for (const A of I) g.push(A.feature) } } return g } queryRenderedFeatures(t, s, l) { s && s.filter && this._validate(c.C.filter, "queryRenderedFeatures.filter", s.filter, null, s); const d = {}; if (s && s.layers) { if (!(Array.isArray(s.layers) || s.layers instanceof Set)) return this.fire(new c.k(new Error("parameters.layers must be an Array or a Set of strings"))), []; for (const I of s.layers) { const A = this._layers[I]; if (!A) return this.fire(new c.k(new Error(`The layer '${I}' does not exist in the map's style and cannot be queried for features.`))), []; d[A.source] = !0 } } const g = []; s.availableImages = this._availableImages; const v = this._serializedAllLayers(), T = s.layers instanceof Set ? s.layers : Array.isArray(s.layers) ? new Set(s.layers) : null, E = Object.assign(Object.assign({}, s), { layers: T, globalState: this._globalState }); for (const I in this.tileManagers) s.layers && !d[I] || g.push(rn(this.tileManagers[I], this._layers, v, t, E, l, this.map.terrain ? (A, R, z) => this.map.terrain.getElevation(A, R, z) : void 0)); return this.placement && g.push(function (I, A, R, z, O, U, X) { const Q = {}, Y = U.queryRenderedSymbols(z), te = []; for (const le of Object.keys(Y).map(Number)) te.push(X[le]); te.sort(qt); for (const le of te) { const J = le.featureIndex.lookupSymbolFeatures(Y[le.bucketInstanceId], A, le.bucketIndex, le.sourceLayerIndex, { filterSpec: O.filter, globalState: O.globalState }, O.layers, O.availableImages, I); for (const oe in J) { const ce = Q[oe] = Q[oe] || [], se = J[oe]; se.sort((fe, Oe) => { const ke = le.featureSortOrder; if (ke) { const ze = ke.indexOf(fe.featureIndex); return ke.indexOf(Oe.featureIndex) - ze } return Oe.featureIndex - fe.featureIndex }); for (const fe of se) ce.push(fe) } } return function (le, J, oe) { for (const ce in le) for (const se of le[ce]) Gt(se, oe[J[ce].source]); return le }(Q, I, R) }(this._layers, v, this.tileManagers, t, E, this.placement.collisionIndex, this.placement.retainedQueryData)), this._flattenAndSortRenderedFeatures(g) } querySourceFeatures(t, s) { s != null && s.filter && this._validate(c.C.filter, "querySourceFeatures.filter", s.filter, null, s); const l = this.tileManagers[t]; return l ? function (d, g) { const v = d.getRenderableIds().map(I => d.getTileByID(I)), T = [], E = {}; for (let I = 0; I < v.length; I++) { const A = v[I], R = A.tileID.canonical.key; E[R] || (E[R] = !0, A.querySourceFeatures(T, g)) } return T }(l, s ? Object.assign(Object.assign({}, s), { globalState: this._globalState }) : { globalState: this._globalState }) : [] } getLight() { return this.light.getLight() } setLight(t, s = {}) { this._checkLoaded(); const l = this.light.getLight(); let d = !1; for (const v in t) if (!c.bR(t[v], l[v])) { d = !0; break } if (!d) return; const g = { now: $e(), transition: c.e({ duration: 300, delay: 0 }, this.stylesheet.transition) }; this.light.setLight(t, s), this.light.updateTransitions(g) } getProjection() { var t; return (t = this.stylesheet) === null || t === void 0 ? void 0 : t.projection } setProjection(t) { if (this._checkLoaded(), this.projection) { if (this.projection.name === t.type) return; this.projection.destroy(), delete this.projection } this.stylesheet.projection = t, this._setProjectionInternal(t.type) } getSky() { var t; return (t = this.stylesheet) === null || t === void 0 ? void 0 : t.sky } setSky(t, s = {}) { this._checkLoaded(); const l = this.getSky(); let d = !1; if (!t && !l) return; if (t && !l) d = !0; else if (!t && l) d = !0; else for (const v in t) if (!c.bR(t[v], l[v])) { d = !0; break } if (!d) return; const g = { now: $e(), transition: c.e({ duration: 300, delay: 0 }, this.stylesheet.transition) }; this.stylesheet.sky = t, this.sky.setSky(t, s), this.sky.updateTransitions(g) } _setProjectionInternal(t) { const s = function (l, d) { const g = { constrainOverride: d }; if (Array.isArray(l)) { const v = new Zd({ type: l }); return { projection: v, transform: new Vo(g), cameraHelper: new Xd(v) } } switch (l) { case "mercator": return { projection: new zn, transform: new Zs(g), cameraHelper: new Ws }; case "globe": { const v = new Zd({ type: ["interpolate", ["linear"], ["zoom"], 11, "vertical-perspective", 12, "mercator"] }); return { projection: v, transform: new Vo(g), cameraHelper: new Xd(v) } } case "vertical-perspective": return { projection: new Rc, transform: new jo(g), cameraHelper: new Xr }; default: return c.w(`Unknown projection name: ${l}. Falling back to mercator projection.`), { projection: new zn, transform: new Zs(g), cameraHelper: new Ws } } }(t, this.map.transformConstrain); this.projection = s.projection, this.map.migrateProjection(s.transform, s.cameraHelper); for (const l in this.tileManagers) this.tileManagers[l].reload() } _validate(t, s, l, d, g = {}) { return (!g || g.validate !== !1) && Uo(this, t.call(c.C, c.e({ key: s, style: this.serialize(), value: l, styleSpec: c.u }, d))) } _remove(t = !0) { this._frameRequest && (this._frameRequest.abort(), this._frameRequest = null), this._loadStyleRequest && (this._loadStyleRequest.abort(), this._loadStyleRequest = null), this._spriteRequest && (this._spriteRequest.abort(), this._spriteRequest = null), Ee().off(ue, this._rtlPluginLoaded); for (const s in this._layers) this._layers[s].setEventedParent(null); for (const s in this.tileManagers) { const l = this.tileManagers[s]; l.setEventedParent(null), l.onRemove(this.map) } this.imageManager.setEventedParent(null), this.setEventedParent(null), t && this.dispatcher.broadcast("RM", void 0), this.dispatcher.remove(t) } _clearSource(t) { this.tileManagers[t].clearTiles() } _reloadSource(t) { this.tileManagers[t].resume(), this.tileManagers[t].reload() } _updateSources(t) { for (const s in this.tileManagers) this.tileManagers[s].update(t, this.map.terrain) } _generateCollisionBoxes() { for (const t in this.tileManagers) this._reloadSource(t) } _updatePlacement(t, s, l, d, g = !1) { let v = !1, T = !1; const E = {}; for (const I of this._order) { const A = this._layers[I]; if (A.type !== "symbol") continue; if (!E[A.source]) { const z = this.tileManagers[A.source]; E[A.source] = z.getRenderableIds(!0).map(O => z.getTileByID(O)).sort((O, U) => U.tileID.overscaledZ - O.tileID.overscaledZ || (O.tileID.isLessThan(U.tileID) ? -1 : 1)) } const R = this.crossTileSymbolIndex.addLayer(A, E[A.source], t.center.lng); v = v || R } if (this.crossTileSymbolIndex.pruneUnusedLayers(this._order), ((g = g || this._layerOrderChanged || l === 0) || !this.pauseablePlacement || this.pauseablePlacement.isDone() && !this.placement.stillRecent($e(), t.zoom)) && (this.pauseablePlacement = new zo(t, this.map.terrain, this._order, g, s, l, d, this.placement), this._layerOrderChanged = !1), this.pauseablePlacement.isDone() ? this.placement.setStale() : (this.pauseablePlacement.continuePlacement(this._order, this._layers, E), this.pauseablePlacement.isDone() && (this.placement = this.pauseablePlacement.commit($e()), T = !0), v && this.pauseablePlacement.placement.setStale()), T || v) for (const I of this._order) { const A = this._layers[I]; A.type === "symbol" && this.placement.updateLayerOpacities(A, E[A.source]) } return !this.pauseablePlacement.isDone() || this.placement.hasTransitions($e()) } _releaseSymbolFadeTiles() { for (const t in this.tileManagers) this.tileManagers[t].releaseSymbolFadeTiles() } getImages(t, s) { return c._(this, void 0, void 0, function* () { const l = yield this.imageManager.getImages(s.icons); this._updateTilesForChangedImages(); const d = this.tileManagers[s.source]; return d && d.setDependencies(s.tileID.key, s.type, s.icons), l }) } getGlyphs(t, s) { return c._(this, void 0, void 0, function* () { const l = yield this.glyphManager.getGlyphs(s.stacks), d = this.tileManagers[s.source]; return d && d.setDependencies(s.tileID.key, s.type, [""]), l }) } getGlyphsUrl() { return this.stylesheet.glyphs || null } setGlyphs(t, s = {}) { this._checkLoaded(), t && this._validate(c.C.glyphs, "glyphs", t, null, s) || (this._glyphsDidChange = !0, this.stylesheet.glyphs = t, this.glyphManager.entries = {}, this.glyphManager.setURL(t)) } getDashes(t, s) { return c._(this, void 0, void 0, function* () { const l = {}; for (const [d, g] of Object.entries(s.dashes)) l[d] = this.lineAtlas.getDash(g.dasharray, g.round); return l }) } addSprite(t, s, l = {}, d) { this._checkLoaded(); const g = [{ id: t, url: s }], v = [...re(this.stylesheet.sprite), ...g]; this._validate(c.C.sprite, "sprite", v, null, l) || (this.stylesheet.sprite = v, this._loadSprite(g, !0, d)) } removeSprite(t) { this._checkLoaded(); const s = re(this.stylesheet.sprite); if (s.find(l => l.id === t)) { if (this._spritesImagesIds[t]) for (const l of this._spritesImagesIds[t]) this.imageManager.removeImage(l), this._changedImages[l] = !0; s.splice(s.findIndex(l => l.id === t), 1), this.stylesheet.sprite = s.length > 0 ? s : void 0, delete this._spritesImagesIds[t], this._availableImages = this.imageManager.listImages(), this._changed = !0, this.dispatcher.broadcast("SI", this._availableImages), this.fire(new c.l("data", { dataType: "style" })) } else this.fire(new c.k(new Error(`Sprite "${t}" doesn't exists on this map.`))) } getSprite() { return re(this.stylesheet.sprite) } setSprite(t, s = {}, l) { this._checkLoaded(), t && this._validate(c.C.sprite, "sprite", t, null, s) || (this.stylesheet.sprite = t, t ? this._loadSprite(t, !0, l) : (this._unloadSprite(), l && l(null))) } destroy() { this._frameRequest && (this._frameRequest.abort(), this._frameRequest = null), this._loadStyleRequest && (this._loadStyleRequest.abort(), this._loadStyleRequest = null), this._spriteRequest && (this._spriteRequest.abort(), this._spriteRequest = null); for (const t in this.tileManagers) { const s = this.tileManagers[t]; s.setEventedParent(null), s.onRemove(this.map) } this.tileManagers = {}, this.imageManager && (this.imageManager.setEventedParent(null), this.imageManager.destroy(), this._availableImages = [], this._spritesImagesIds = {}), this.glyphManager && this.glyphManager.destroy(); for (const t in this._layers) { const s = this._layers[t]; s.setEventedParent(null), s.onRemove && s.onRemove(this.map) } this._setInitialValues(), this.setEventedParent(null), this.dispatcher.unregisterMessageHandler("GG"), this.dispatcher.unregisterMessageHandler("GI"), this.dispatcher.unregisterMessageHandler("GDA"), this.dispatcher.remove(!0), this._listeners = {}, this._oneTimeListeners = {} } } var jm = c.aU([{ name: "a_pos", type: "Int16", components: 2 }, { name: "a_texture_pos", type: "Int16", components: 2 }]); class Kl { constructor() { this.boundProgram = null, this.boundLayoutVertexBuffer = null, this.boundPaintVertexBuffers = [], this.boundIndexBuffer = null, this.boundVertexOffset = null, this.boundDynamicVertexBuffer = null, this.vao = null } bind(t, s, l, d, g, v, T, E, I) { this.context = t; let A = this.boundPaintVertexBuffers.length !== d.length; for (let R = 0; !A && R < d.length; R++)this.boundPaintVertexBuffers[R] !== d[R] && (A = !0); !this.vao || this.boundProgram !== s || this.boundLayoutVertexBuffer !== l || A || this.boundIndexBuffer !== g || this.boundVertexOffset !== v || this.boundDynamicVertexBuffer !== T || this.boundDynamicVertexBuffer2 !== E || this.boundDynamicVertexBuffer3 !== I ? this.freshBind(s, l, d, g, v, T, E, I) : (t.bindVertexArray.set(this.vao), T && T.bind(), g && g.dynamicDraw && g.bind(), E && E.bind(), I && I.bind()) } freshBind(t, s, l, d, g, v, T, E) { const I = t.numAttributes, A = this.context, R = A.gl; this.vao && this.destroy(), this.vao = A.createVertexArray(), A.bindVertexArray.set(this.vao), this.boundProgram = t, this.boundLayoutVertexBuffer = s, this.boundPaintVertexBuffers = l, this.boundIndexBuffer = d, this.boundVertexOffset = g, this.boundDynamicVertexBuffer = v, this.boundDynamicVertexBuffer2 = T, this.boundDynamicVertexBuffer3 = E, s.enableAttributes(R, t); for (const z of l) z.enableAttributes(R, t); v && v.enableAttributes(R, t), T && T.enableAttributes(R, t), E && E.enableAttributes(R, t), s.bind(), s.setVertexAttribPointers(R, t, g); for (const z of l) z.bind(), z.setVertexAttribPointers(R, t, g); v && (v.bind(), v.setVertexAttribPointers(R, t, g)), d && d.bind(), T && (T.bind(), T.setVertexAttribPointers(R, t, g)), E && (E.bind(), E.setVertexAttribPointers(R, t, g)), A.currentNumAttributes = I } destroy() { this.vao && (this.context.deleteVertexArray(this.vao), this.vao = null) } } const Vm = (m, t, s, l, d) => ({ u_texture: 0, u_ele_delta: m, u_fog_matrix: t, u_fog_color: s ? s.properties.get("fog-color") : c.bp.white, u_fog_ground_blend: s ? s.properties.get("fog-ground-blend") : 1, u_fog_ground_blend_opacity: d ? 0 : s ? s.calculateFogBlendOpacity(l) : 0, u_horizon_color: s ? s.properties.get("horizon-color") : c.bp.white, u_horizon_fog_blend: s ? s.properties.get("horizon-fog-blend") : 1, u_is_globe_mode: d ? 1 : 0 }), Go = { mainMatrix: "u_projection_matrix", tileMercatorCoords: "u_projection_tile_mercator_coords", clippingPlane: "u_projection_clipping_plane", projectionTransition: "u_projection_transition", fallbackMatrix: "u_projection_fallback_matrix" }; function Ql(m) { const t = []; for (let s = 0; s < m.length; s++) { if (m[s] === null) continue; const l = m[s].split(" "); t.push(l.pop()) } return t } class Yd {
                constructor(t, s, l, d, g, v, T, E, I = []) {
                    const A = t.gl; this.program = A.createProgram(); const R = Ql(s.staticAttributes), z = l ? l.getBinderAttributes() : [], O = R.concat(z), U = br.prelude.staticUniforms ? Ql(br.prelude.staticUniforms) : [], X = T.staticUniforms ? Ql(T.staticUniforms) : [], Q = s.staticUniforms ? Ql(s.staticUniforms) : [], Y = l ? l.getBinderUniforms() : [], te = U.concat(X).concat(Q).concat(Y), le = []; for (const ke of te) le.indexOf(ke) < 0 && le.push(ke); const J = l ? l.defines() : []; ai(A) && J.unshift("#version 300 es"), g && J.push("#define OVERDRAW_INSPECTOR;"), v && J.push("#define TERRAIN3D;"), E && J.push(E), I && J.push(...I); let oe = J.concat(br.prelude.fragmentSource, T.fragmentSource, s.fragmentSource).join(`
`), ce = J.concat(br.prelude.vertexSource, T.vertexSource, s.vertexSource).join(`
`); ai(A) || (oe = function (ke) { return ke.replace(/\bin\s/g, "varying ").replace("out highp vec4 fragColor;", "").replace(/fragColor/g, "gl_FragColor").replace(/texture\(/g, "texture2D(") }(oe), ce = function (ke) { return ke.replace(/\bin\s/g, "attribute ").replace(/\bout\s/g, "varying ").replace(/texture\(/g, "texture2D(") }(ce)); const se = A.createShader(A.FRAGMENT_SHADER); if (A.isContextLost()) return void (this.failedToCreate = !0); if (A.shaderSource(se, oe), A.compileShader(se), !A.getShaderParameter(se, A.COMPILE_STATUS)) throw new Error(`Could not compile fragment shader: ${A.getShaderInfoLog(se)}`); A.attachShader(this.program, se); const fe = A.createShader(A.VERTEX_SHADER); if (A.isContextLost()) return void (this.failedToCreate = !0); if (A.shaderSource(fe, ce), A.compileShader(fe), !A.getShaderParameter(fe, A.COMPILE_STATUS)) throw new Error(`Could not compile vertex shader: ${A.getShaderInfoLog(fe)}`); A.attachShader(this.program, fe), this.attributes = {}; const Oe = {}; this.numAttributes = O.length; for (let ke = 0; ke < this.numAttributes; ke++)O[ke] && (A.bindAttribLocation(this.program, ke, O[ke]), this.attributes[O[ke]] = ke); if (A.linkProgram(this.program), !A.getProgramParameter(this.program, A.LINK_STATUS)) throw new Error(`Program failed to link: ${A.getProgramInfoLog(this.program)}`); A.deleteShader(fe), A.deleteShader(se); for (let ke = 0; ke < le.length; ke++) { const ze = le[ke]; if (ze && !Oe[ze]) { const Re = A.getUniformLocation(this.program, ze); Re && (Oe[ze] = Re) } } this.fixedUniforms = d(t, Oe), this.terrainUniforms = ((ke, ze) => ({ u_depth: new c.b_(ke, ze.u_depth), u_terrain: new c.b_(ke, ze.u_terrain), u_terrain_dim: new c.bq(ke, ze.u_terrain_dim), u_terrain_matrix: new c.c0(ke, ze.u_terrain_matrix), u_terrain_unpack: new c.c1(ke, ze.u_terrain_unpack), u_terrain_exaggeration: new c.bq(ke, ze.u_terrain_exaggeration) }))(t, Oe), this.projectionUniforms = ((ke, ze) => ({ u_projection_matrix: new c.c0(ke, ze.u_projection_matrix), u_projection_tile_mercator_coords: new c.c1(ke, ze.u_projection_tile_mercator_coords), u_projection_clipping_plane: new c.c1(ke, ze.u_projection_clipping_plane), u_projection_transition: new c.bq(ke, ze.u_projection_transition), u_projection_fallback_matrix: new c.c0(ke, ze.u_projection_fallback_matrix) }))(t, Oe), this.binderUniforms = l ? l.getUniforms(t, Oe) : []
                } draw(t, s, l, d, g, v, T, E, I, A, R, z, O, U, X, Q, Y, te, le) { const J = t.gl; if (this.failedToCreate) return; if (t.program.set(this.program), t.setDepthMode(l), t.setStencilMode(d), t.setColorMode(g), t.setCullFace(v), E) { t.activeTexture.set(J.TEXTURE2), J.bindTexture(J.TEXTURE_2D, E.depthTexture), t.activeTexture.set(J.TEXTURE3), J.bindTexture(J.TEXTURE_2D, E.texture); for (const ce in this.terrainUniforms) this.terrainUniforms[ce].set(E[ce]) } if (I) for (const ce in I) this.projectionUniforms[Go[ce]].set(I[ce]); if (T) for (const ce in this.fixedUniforms) this.fixedUniforms[ce].set(T[ce]); Q && Q.setUniforms(t, this.binderUniforms, U, { zoom: X }); let oe = 0; switch (s) { case J.LINES: oe = 2; break; case J.TRIANGLES: oe = 3; break; case J.LINE_STRIP: oe = 1 }for (const ce of O.get()) { const se = ce.vaos || (ce.vaos = {}); (se[A] || (se[A] = new Kl)).bind(t, this, R, Q ? Q.getPaintVertexBuffers() : [], z, ce.vertexOffset, Y, te, le), J.drawElements(s, ce.primitiveLength * oe, J.UNSIGNED_SHORT, ce.primitiveOffset * oe * 2) } }
            } function Kd(m, t, s) { const l = 1 / c.aN(s, 1, t.transform.tileZoom), d = Math.pow(2, s.tileID.overscaledZ), g = s.tileSize * Math.pow(2, t.transform.tileZoom) / d, v = g * (s.tileID.canonical.x + s.tileID.wrap * d), T = g * s.tileID.canonical.y; return { u_image: 0, u_texsize: s.imageAtlasTexture.size, u_scale: [l, m.fromScale, m.toScale], u_fade: m.t, u_pixel_coord_upper: [v >> 16, T >> 16], u_pixel_coord_lower: [65535 & v, 65535 & T] } } const Oc = (m, t, s, l) => { const d = m.style.light, g = d.properties.get("position"), v = [g.x, g.y, g.z], T = c.c4(); d.properties.get("anchor") === "viewport" && c.c5(T, m.transform.bearingInRadians), c.c6(v, v, T); const E = m.transform.transformLightDirection(v), I = d.properties.get("color"); return { u_lightpos: v, u_lightpos_globe: E, u_lightintensity: d.properties.get("intensity"), u_lightcolor: [I.r, I.g, I.b], u_vertical_gradient: +t, u_opacity: s, u_fill_translate: l } }, Nc = (m, t, s, l, d, g, v) => c.e(Oc(m, t, s, l), Kd(g, m, v), { u_height_factor: -Math.pow(2, d.overscaledZ) / v.tileSize / 8 }), jc = (m, t, s, l) => c.e(Kd(t, m, s), { u_fill_translate: l }), Qd = (m, t) => ({ u_world: m, u_fill_translate: t }), Jd = (m, t, s, l, d) => c.e(jc(m, t, s, d), { u_world: l }), ep = (m, t, s, l, d) => { const g = m.transform; let v, T, E = 0; if (s.paint.get("circle-pitch-alignment") === "map") { const I = c.aN(t, 1, g.zoom); v = !0, T = [I, I], E = I / (c.a5 * Math.pow(2, t.tileID.overscaledZ)) * 2 * Math.PI * d } else v = !1, T = g.pixelsToGLUnits; return { u_camera_to_center_distance: g.cameraToCenterDistance, u_scale_with_map: +(s.paint.get("circle-pitch-scale") === "map"), u_pitch_with_map: +v, u_device_pixel_ratio: m.pixelRatio, u_extrude_scale: T, u_globe_extrude_scale: E, u_translate: l } }, Ys = m => ({ u_pixel_extrude_scale: [1 / m.width, 1 / m.height] }), tp = m => ({ u_viewport_size: [m.width, m.height] }), Vc = (m, t = 1) => ({ u_color: m, u_overlay: 0, u_overlay_scale: t }), $o = (m, t, s, l) => { const d = c.aN(m, 1, t) / (c.a5 * Math.pow(2, m.tileID.overscaledZ)) * 2 * Math.PI * l; return { u_extrude_scale: c.aN(m, 1, t), u_intensity: s, u_globe_extrude_scale: d } }, rp = (m, t, s, l) => { const d = c.N(); c.c7(d, 0, m.width, m.height, 0, 0, 1); const g = m.context.gl; return { u_matrix: d, u_world: [g.drawingBufferWidth, g.drawingBufferHeight], u_image: s, u_color_ramp: l, u_opacity: t.paint.get("heatmap-opacity") } }, Jl = (m, t, s) => { const l = s.paint.get("hillshade-accent-color"); let d; switch (s.paint.get("hillshade-method")) { case "basic": d = 4; break; case "combined": d = 1; break; case "igor": d = 2; break; case "multidirectional": d = 3; break; default: d = 0 }const g = s.getIlluminationProperties(); for (let v = 0; v < g.directionRadians.length; v++)s.paint.get("hillshade-illumination-anchor") === "viewport" && (g.directionRadians[v] += m.transform.bearingInRadians); return { u_image: 0, u_latrange: Gm(0, t.tileID), u_exaggeration: s.paint.get("hillshade-exaggeration"), u_altitudes: g.altitudeRadians, u_azimuths: g.directionRadians, u_accent: l, u_method: d, u_highlights: g.highlightColor, u_shadows: g.shadowColor } }, Um = (m, t) => { const s = t.stride, l = c.N(); return c.c7(l, 0, c.a5, -c.a5, 0, 0, 1), c.O(l, l, [0, -c.a5, 0]), { u_matrix: l, u_image: 1, u_dimension: [s, s], u_zoom: m.overscaledZ, u_unpack: t.getUnpackVector() } }; function Gm(m, t) { const s = Math.pow(2, t.canonical.z), l = t.canonical.y; return [new c.a9(0, l / s).toLngLat().lat, new c.a9(0, (l + 1) / s).toLngLat().lat] } const np = (m, t, s = 0) => ({ u_image: 0, u_unpack: t.getUnpackVector(), u_dimension: [t.stride, t.stride], u_elevation_stops: 1, u_color_stops: 4, u_color_ramp_size: s, u_opacity: m.paint.get("color-relief-opacity") }), Ga = (m, t, s, l) => { const d = m.transform; return { u_translation: tu(m, t, s), u_ratio: l / c.aN(t, 1, d.zoom), u_device_pixel_ratio: m.pixelRatio, u_units_to_pixels: [1 / d.pixelsToGLUnits[0], 1 / d.pixelsToGLUnits[1]] } }, ip = (m, t, s, l, d) => c.e(Ga(m, t, s, l), { u_image: 0, u_image_height: d }), Uc = (m, t, s, l, d) => { const g = m.transform, v = bi(t, g); return { u_translation: tu(m, t, s), u_texsize: t.imageAtlasTexture.size, u_ratio: l / c.aN(t, 1, g.zoom), u_device_pixel_ratio: m.pixelRatio, u_image: 0, u_scale: [v, d.fromScale, d.toScale], u_fade: d.t, u_units_to_pixels: [1 / g.pixelsToGLUnits[0], 1 / g.pixelsToGLUnits[1]] } }, sp = (m, t, s, l, d) => { const g = bi(t, m.transform); return c.e(Ga(m, t, s, l), { u_tileratio: g, u_crossfade_from: d.fromScale, u_crossfade_to: d.toScale, u_image: 0, u_mix: d.t, u_lineatlas_width: m.lineAtlas.width, u_lineatlas_height: m.lineAtlas.height }) }, eu = (m, t, s, l, d, g) => { const v = bi(t, m.transform); return c.e(Ga(m, t, s, l), { u_image: 0, u_image_height: g, u_tileratio: v, u_crossfade_from: d.fromScale, u_crossfade_to: d.toScale, u_image_dash: 1, u_mix: d.t, u_lineatlas_width: m.lineAtlas.width, u_lineatlas_height: m.lineAtlas.height }) }; function bi(m, t) { return 1 / c.aN(m, 1, t.tileZoom) } function tu(m, t, s) { return c.aO(m.transform, t, s.paint.get("line-translate"), s.paint.get("line-translate-anchor")) } const Gc = (m, t, s, l, d) => { return { u_tl_parent: m, u_scale_parent: t, u_buffer_scale: 1, u_fade_t: s.mix, u_opacity: s.opacity * l.paint.get("raster-opacity"), u_image0: 0, u_image1: 1, u_brightness_low: l.paint.get("raster-brightness-min"), u_brightness_high: l.paint.get("raster-brightness-max"), u_saturation_factor: (v = l.paint.get("raster-saturation"), v > 0 ? 1 - 1 / (1.001 - v) : -v), u_contrast_factor: (g = l.paint.get("raster-contrast"), g > 0 ? 1 / (1 - g) : 1 + g), u_spin_weights: $c(l.paint.get("raster-hue-rotate")), u_coords_top: [d[0].x, d[0].y, d[1].x, d[1].y], u_coords_bottom: [d[3].x, d[3].y, d[2].x, d[2].y] }; var g, v }; function $c(m) { m *= Math.PI / 180; const t = Math.sin(m), s = Math.cos(m); return [(2 * s + 1) / 3, (-Math.sqrt(3) * t - s + 1) / 3, (Math.sqrt(3) * t - s + 1) / 3] } const qc = (m, t, s, l, d, g, v, T, E, I, A, R, z) => { const O = v.transform; return { u_is_size_zoom_constant: +(m === "constant" || m === "source"), u_is_size_feature_constant: +(m === "constant" || m === "camera"), u_size_t: t ? t.uSizeT : 0, u_size: t ? t.uSize : 0, u_camera_to_center_distance: O.cameraToCenterDistance, u_pitch: O.pitch / 360 * 2 * Math.PI, u_rotate_symbol: +s, u_aspect_ratio: O.width / O.height, u_fade_change: v.options.fadeDuration ? v.symbolFadeChange : 1, u_label_plane_matrix: T, u_coord_matrix: E, u_is_text: +A, u_pitch_with_map: +l, u_is_along_line: d, u_is_variable_anchor: g, u_texsize: R, u_texture: 0, u_translation: I, u_pitched_scale: z } }, ru = (m, t, s, l, d, g, v, T, E, I, A, R, z, O) => { const U = v.transform; return c.e(qc(m, t, s, l, d, g, v, T, E, I, A, R, O), { u_gamma_scale: l ? Math.cos(U.pitch * Math.PI / 180) * U.cameraToCenterDistance : 1, u_device_pixel_ratio: v.pixelRatio, u_is_halo: 1 }) }, Ks = (m, t, s, l, d, g, v, T, E, I, A, R, z) => c.e(ru(m, t, s, l, d, g, v, T, E, I, !0, A, 0, z), { u_texsize_icon: R, u_texture_icon: 1 }), Zc = (m, t) => ({ u_opacity: m, u_color: t }), $m = (m, t, s, l, d) => c.e(function (g, v, T, E) { const I = T.imageManager.getPattern(g.from.toString()), A = T.imageManager.getPattern(g.to.toString()), { width: R, height: z } = T.imageManager.getPixelSize(), O = Math.pow(2, E.tileID.overscaledZ), U = E.tileSize * Math.pow(2, T.transform.tileZoom) / O, X = U * (E.tileID.canonical.x + E.tileID.wrap * O), Q = U * E.tileID.canonical.y; return { u_image: 0, u_pattern_tl_a: I.tl, u_pattern_br_a: I.br, u_pattern_tl_b: A.tl, u_pattern_br_b: A.br, u_texsize: [R, z], u_mix: v.t, u_pattern_size_a: I.displaySize, u_pattern_size_b: A.displaySize, u_scale_a: v.fromScale, u_scale_b: v.toScale, u_tile_units_to_pixels: 1 / c.aN(E, 1, T.transform.tileZoom), u_pixel_coord_upper: [X >> 16, Q >> 16], u_pixel_coord_lower: [65535 & X, 65535 & Q] } }(s, d, t, l), { u_opacity: m }), op = (m, t) => { }, qm = { fillExtrusion: (m, t) => ({ u_lightpos: new c.c2(m, t.u_lightpos), u_lightpos_globe: new c.c2(m, t.u_lightpos_globe), u_lightintensity: new c.bq(m, t.u_lightintensity), u_lightcolor: new c.c2(m, t.u_lightcolor), u_vertical_gradient: new c.bq(m, t.u_vertical_gradient), u_opacity: new c.bq(m, t.u_opacity), u_fill_translate: new c.c3(m, t.u_fill_translate) }), fillExtrusionPattern: (m, t) => ({ u_lightpos: new c.c2(m, t.u_lightpos), u_lightpos_globe: new c.c2(m, t.u_lightpos_globe), u_lightintensity: new c.bq(m, t.u_lightintensity), u_lightcolor: new c.c2(m, t.u_lightcolor), u_vertical_gradient: new c.bq(m, t.u_vertical_gradient), u_height_factor: new c.bq(m, t.u_height_factor), u_opacity: new c.bq(m, t.u_opacity), u_fill_translate: new c.c3(m, t.u_fill_translate), u_image: new c.b_(m, t.u_image), u_texsize: new c.c3(m, t.u_texsize), u_pixel_coord_upper: new c.c3(m, t.u_pixel_coord_upper), u_pixel_coord_lower: new c.c3(m, t.u_pixel_coord_lower), u_scale: new c.c2(m, t.u_scale), u_fade: new c.bq(m, t.u_fade) }), fill: (m, t) => ({ u_fill_translate: new c.c3(m, t.u_fill_translate) }), fillPattern: (m, t) => ({ u_image: new c.b_(m, t.u_image), u_texsize: new c.c3(m, t.u_texsize), u_pixel_coord_upper: new c.c3(m, t.u_pixel_coord_upper), u_pixel_coord_lower: new c.c3(m, t.u_pixel_coord_lower), u_scale: new c.c2(m, t.u_scale), u_fade: new c.bq(m, t.u_fade), u_fill_translate: new c.c3(m, t.u_fill_translate) }), fillOutline: (m, t) => ({ u_world: new c.c3(m, t.u_world), u_fill_translate: new c.c3(m, t.u_fill_translate) }), fillOutlinePattern: (m, t) => ({ u_world: new c.c3(m, t.u_world), u_image: new c.b_(m, t.u_image), u_texsize: new c.c3(m, t.u_texsize), u_pixel_coord_upper: new c.c3(m, t.u_pixel_coord_upper), u_pixel_coord_lower: new c.c3(m, t.u_pixel_coord_lower), u_scale: new c.c2(m, t.u_scale), u_fade: new c.bq(m, t.u_fade), u_fill_translate: new c.c3(m, t.u_fill_translate) }), circle: (m, t) => ({ u_camera_to_center_distance: new c.bq(m, t.u_camera_to_center_distance), u_scale_with_map: new c.b_(m, t.u_scale_with_map), u_pitch_with_map: new c.b_(m, t.u_pitch_with_map), u_extrude_scale: new c.c3(m, t.u_extrude_scale), u_device_pixel_ratio: new c.bq(m, t.u_device_pixel_ratio), u_globe_extrude_scale: new c.bq(m, t.u_globe_extrude_scale), u_translate: new c.c3(m, t.u_translate) }), collisionBox: (m, t) => ({ u_pixel_extrude_scale: new c.c3(m, t.u_pixel_extrude_scale) }), collisionCircle: (m, t) => ({ u_viewport_size: new c.c3(m, t.u_viewport_size) }), debug: (m, t) => ({ u_color: new c.b$(m, t.u_color), u_overlay: new c.b_(m, t.u_overlay), u_overlay_scale: new c.bq(m, t.u_overlay_scale) }), depth: op, clippingMask: op, heatmap: (m, t) => ({ u_extrude_scale: new c.bq(m, t.u_extrude_scale), u_intensity: new c.bq(m, t.u_intensity), u_globe_extrude_scale: new c.bq(m, t.u_globe_extrude_scale) }), heatmapTexture: (m, t) => ({ u_matrix: new c.c0(m, t.u_matrix), u_world: new c.c3(m, t.u_world), u_image: new c.b_(m, t.u_image), u_color_ramp: new c.b_(m, t.u_color_ramp), u_opacity: new c.bq(m, t.u_opacity) }), hillshade: (m, t) => ({ u_image: new c.b_(m, t.u_image), u_latrange: new c.c3(m, t.u_latrange), u_exaggeration: new c.bq(m, t.u_exaggeration), u_altitudes: new c.c9(m, t.u_altitudes), u_azimuths: new c.c9(m, t.u_azimuths), u_accent: new c.b$(m, t.u_accent), u_method: new c.b_(m, t.u_method), u_shadows: new c.c8(m, t.u_shadows), u_highlights: new c.c8(m, t.u_highlights) }), hillshadePrepare: (m, t) => ({ u_matrix: new c.c0(m, t.u_matrix), u_image: new c.b_(m, t.u_image), u_dimension: new c.c3(m, t.u_dimension), u_zoom: new c.bq(m, t.u_zoom), u_unpack: new c.c1(m, t.u_unpack) }), colorRelief: (m, t) => ({ u_image: new c.b_(m, t.u_image), u_unpack: new c.c1(m, t.u_unpack), u_dimension: new c.c3(m, t.u_dimension), u_elevation_stops: new c.b_(m, t.u_elevation_stops), u_color_stops: new c.b_(m, t.u_color_stops), u_color_ramp_size: new c.b_(m, t.u_color_ramp_size), u_opacity: new c.bq(m, t.u_opacity) }), line: (m, t) => ({ u_translation: new c.c3(m, t.u_translation), u_ratio: new c.bq(m, t.u_ratio), u_device_pixel_ratio: new c.bq(m, t.u_device_pixel_ratio), u_units_to_pixels: new c.c3(m, t.u_units_to_pixels) }), lineGradient: (m, t) => ({ u_translation: new c.c3(m, t.u_translation), u_ratio: new c.bq(m, t.u_ratio), u_device_pixel_ratio: new c.bq(m, t.u_device_pixel_ratio), u_units_to_pixels: new c.c3(m, t.u_units_to_pixels), u_image: new c.b_(m, t.u_image), u_image_height: new c.bq(m, t.u_image_height) }), linePattern: (m, t) => ({ u_translation: new c.c3(m, t.u_translation), u_texsize: new c.c3(m, t.u_texsize), u_ratio: new c.bq(m, t.u_ratio), u_device_pixel_ratio: new c.bq(m, t.u_device_pixel_ratio), u_image: new c.b_(m, t.u_image), u_units_to_pixels: new c.c3(m, t.u_units_to_pixels), u_scale: new c.c2(m, t.u_scale), u_fade: new c.bq(m, t.u_fade) }), lineSDF: (m, t) => ({ u_translation: new c.c3(m, t.u_translation), u_ratio: new c.bq(m, t.u_ratio), u_device_pixel_ratio: new c.bq(m, t.u_device_pixel_ratio), u_units_to_pixels: new c.c3(m, t.u_units_to_pixels), u_image: new c.b_(m, t.u_image), u_mix: new c.bq(m, t.u_mix), u_tileratio: new c.bq(m, t.u_tileratio), u_crossfade_from: new c.bq(m, t.u_crossfade_from), u_crossfade_to: new c.bq(m, t.u_crossfade_to), u_lineatlas_width: new c.bq(m, t.u_lineatlas_width), u_lineatlas_height: new c.bq(m, t.u_lineatlas_height) }), lineGradientSDF: (m, t) => ({ u_translation: new c.c3(m, t.u_translation), u_ratio: new c.bq(m, t.u_ratio), u_device_pixel_ratio: new c.bq(m, t.u_device_pixel_ratio), u_units_to_pixels: new c.c3(m, t.u_units_to_pixels), u_image: new c.b_(m, t.u_image), u_image_height: new c.bq(m, t.u_image_height), u_tileratio: new c.bq(m, t.u_tileratio), u_crossfade_from: new c.bq(m, t.u_crossfade_from), u_crossfade_to: new c.bq(m, t.u_crossfade_to), u_image_dash: new c.b_(m, t.u_image_dash), u_mix: new c.bq(m, t.u_mix), u_lineatlas_width: new c.bq(m, t.u_lineatlas_width), u_lineatlas_height: new c.bq(m, t.u_lineatlas_height) }), raster: (m, t) => ({ u_tl_parent: new c.c3(m, t.u_tl_parent), u_scale_parent: new c.bq(m, t.u_scale_parent), u_buffer_scale: new c.bq(m, t.u_buffer_scale), u_fade_t: new c.bq(m, t.u_fade_t), u_opacity: new c.bq(m, t.u_opacity), u_image0: new c.b_(m, t.u_image0), u_image1: new c.b_(m, t.u_image1), u_brightness_low: new c.bq(m, t.u_brightness_low), u_brightness_high: new c.bq(m, t.u_brightness_high), u_saturation_factor: new c.bq(m, t.u_saturation_factor), u_contrast_factor: new c.bq(m, t.u_contrast_factor), u_spin_weights: new c.c2(m, t.u_spin_weights), u_coords_top: new c.c1(m, t.u_coords_top), u_coords_bottom: new c.c1(m, t.u_coords_bottom) }), symbolIcon: (m, t) => ({ u_is_size_zoom_constant: new c.b_(m, t.u_is_size_zoom_constant), u_is_size_feature_constant: new c.b_(m, t.u_is_size_feature_constant), u_size_t: new c.bq(m, t.u_size_t), u_size: new c.bq(m, t.u_size), u_camera_to_center_distance: new c.bq(m, t.u_camera_to_center_distance), u_pitch: new c.bq(m, t.u_pitch), u_rotate_symbol: new c.b_(m, t.u_rotate_symbol), u_aspect_ratio: new c.bq(m, t.u_aspect_ratio), u_fade_change: new c.bq(m, t.u_fade_change), u_label_plane_matrix: new c.c0(m, t.u_label_plane_matrix), u_coord_matrix: new c.c0(m, t.u_coord_matrix), u_is_text: new c.b_(m, t.u_is_text), u_pitch_with_map: new c.b_(m, t.u_pitch_with_map), u_is_along_line: new c.b_(m, t.u_is_along_line), u_is_variable_anchor: new c.b_(m, t.u_is_variable_anchor), u_texsize: new c.c3(m, t.u_texsize), u_texture: new c.b_(m, t.u_texture), u_translation: new c.c3(m, t.u_translation), u_pitched_scale: new c.bq(m, t.u_pitched_scale) }), symbolSDF: (m, t) => ({ u_is_size_zoom_constant: new c.b_(m, t.u_is_size_zoom_constant), u_is_size_feature_constant: new c.b_(m, t.u_is_size_feature_constant), u_size_t: new c.bq(m, t.u_size_t), u_size: new c.bq(m, t.u_size), u_camera_to_center_distance: new c.bq(m, t.u_camera_to_center_distance), u_pitch: new c.bq(m, t.u_pitch), u_rotate_symbol: new c.b_(m, t.u_rotate_symbol), u_aspect_ratio: new c.bq(m, t.u_aspect_ratio), u_fade_change: new c.bq(m, t.u_fade_change), u_label_plane_matrix: new c.c0(m, t.u_label_plane_matrix), u_coord_matrix: new c.c0(m, t.u_coord_matrix), u_is_text: new c.b_(m, t.u_is_text), u_pitch_with_map: new c.b_(m, t.u_pitch_with_map), u_is_along_line: new c.b_(m, t.u_is_along_line), u_is_variable_anchor: new c.b_(m, t.u_is_variable_anchor), u_texsize: new c.c3(m, t.u_texsize), u_texture: new c.b_(m, t.u_texture), u_gamma_scale: new c.bq(m, t.u_gamma_scale), u_device_pixel_ratio: new c.bq(m, t.u_device_pixel_ratio), u_is_halo: new c.b_(m, t.u_is_halo), u_translation: new c.c3(m, t.u_translation), u_pitched_scale: new c.bq(m, t.u_pitched_scale) }), symbolTextAndIcon: (m, t) => ({ u_is_size_zoom_constant: new c.b_(m, t.u_is_size_zoom_constant), u_is_size_feature_constant: new c.b_(m, t.u_is_size_feature_constant), u_size_t: new c.bq(m, t.u_size_t), u_size: new c.bq(m, t.u_size), u_camera_to_center_distance: new c.bq(m, t.u_camera_to_center_distance), u_pitch: new c.bq(m, t.u_pitch), u_rotate_symbol: new c.b_(m, t.u_rotate_symbol), u_aspect_ratio: new c.bq(m, t.u_aspect_ratio), u_fade_change: new c.bq(m, t.u_fade_change), u_label_plane_matrix: new c.c0(m, t.u_label_plane_matrix), u_coord_matrix: new c.c0(m, t.u_coord_matrix), u_is_text: new c.b_(m, t.u_is_text), u_pitch_with_map: new c.b_(m, t.u_pitch_with_map), u_is_along_line: new c.b_(m, t.u_is_along_line), u_is_variable_anchor: new c.b_(m, t.u_is_variable_anchor), u_texsize: new c.c3(m, t.u_texsize), u_texsize_icon: new c.c3(m, t.u_texsize_icon), u_texture: new c.b_(m, t.u_texture), u_texture_icon: new c.b_(m, t.u_texture_icon), u_gamma_scale: new c.bq(m, t.u_gamma_scale), u_device_pixel_ratio: new c.bq(m, t.u_device_pixel_ratio), u_is_halo: new c.b_(m, t.u_is_halo), u_translation: new c.c3(m, t.u_translation), u_pitched_scale: new c.bq(m, t.u_pitched_scale) }), background: (m, t) => ({ u_opacity: new c.bq(m, t.u_opacity), u_color: new c.b$(m, t.u_color) }), backgroundPattern: (m, t) => ({ u_opacity: new c.bq(m, t.u_opacity), u_image: new c.b_(m, t.u_image), u_pattern_tl_a: new c.c3(m, t.u_pattern_tl_a), u_pattern_br_a: new c.c3(m, t.u_pattern_br_a), u_pattern_tl_b: new c.c3(m, t.u_pattern_tl_b), u_pattern_br_b: new c.c3(m, t.u_pattern_br_b), u_texsize: new c.c3(m, t.u_texsize), u_mix: new c.bq(m, t.u_mix), u_pattern_size_a: new c.c3(m, t.u_pattern_size_a), u_pattern_size_b: new c.c3(m, t.u_pattern_size_b), u_scale_a: new c.bq(m, t.u_scale_a), u_scale_b: new c.bq(m, t.u_scale_b), u_pixel_coord_upper: new c.c3(m, t.u_pixel_coord_upper), u_pixel_coord_lower: new c.c3(m, t.u_pixel_coord_lower), u_tile_units_to_pixels: new c.bq(m, t.u_tile_units_to_pixels) }), terrain: (m, t) => ({ u_texture: new c.b_(m, t.u_texture), u_ele_delta: new c.bq(m, t.u_ele_delta), u_fog_matrix: new c.c0(m, t.u_fog_matrix), u_fog_color: new c.b$(m, t.u_fog_color), u_fog_ground_blend: new c.bq(m, t.u_fog_ground_blend), u_fog_ground_blend_opacity: new c.bq(m, t.u_fog_ground_blend_opacity), u_horizon_color: new c.b$(m, t.u_horizon_color), u_horizon_fog_blend: new c.bq(m, t.u_horizon_fog_blend), u_is_globe_mode: new c.bq(m, t.u_is_globe_mode) }), terrainDepth: (m, t) => ({ u_ele_delta: new c.bq(m, t.u_ele_delta) }), terrainCoords: (m, t) => ({ u_texture: new c.b_(m, t.u_texture), u_terrain_coords_id: new c.bq(m, t.u_terrain_coords_id), u_ele_delta: new c.bq(m, t.u_ele_delta) }), projectionErrorMeasurement: (m, t) => ({ u_input: new c.bq(m, t.u_input), u_output_expected: new c.bq(m, t.u_output_expected) }), atmosphere: (m, t) => ({ u_sun_pos: new c.c2(m, t.u_sun_pos), u_atmosphere_blend: new c.bq(m, t.u_atmosphere_blend), u_globe_position: new c.c2(m, t.u_globe_position), u_globe_radius: new c.bq(m, t.u_globe_radius), u_inv_proj_matrix: new c.c0(m, t.u_inv_proj_matrix) }), sky: (m, t) => ({ u_sky_color: new c.b$(m, t.u_sky_color), u_horizon_color: new c.b$(m, t.u_horizon_color), u_horizon: new c.c3(m, t.u_horizon), u_horizon_normal: new c.c3(m, t.u_horizon_normal), u_sky_horizon_blend: new c.bq(m, t.u_sky_horizon_blend), u_sky_blend: new c.bq(m, t.u_sky_blend) }) }; class Zm { constructor(t, s, l) { this.context = t; const d = t.gl; this.buffer = d.createBuffer(), this.dynamicDraw = !!l, this.context.unbindVAO(), t.bindElementBuffer.set(this.buffer), d.bufferData(d.ELEMENT_ARRAY_BUFFER, s.arrayBuffer, this.dynamicDraw ? d.DYNAMIC_DRAW : d.STATIC_DRAW), this.dynamicDraw || delete s.arrayBuffer } bind() { this.context.bindElementBuffer.set(this.buffer) } updateData(t) { const s = this.context.gl; if (!this.dynamicDraw) throw new Error("Attempted to update data while not in dynamic mode."); this.context.unbindVAO(), this.bind(), s.bufferSubData(s.ELEMENT_ARRAY_BUFFER, 0, t.arrayBuffer) } destroy() { this.buffer && (this.context.gl.deleteBuffer(this.buffer), delete this.buffer) } } const ap = { Int8: "BYTE", Uint8: "UNSIGNED_BYTE", Int16: "SHORT", Uint16: "UNSIGNED_SHORT", Int32: "INT", Uint32: "UNSIGNED_INT", Float32: "FLOAT" }; class Wm { constructor(t, s, l, d) { this.length = s.length, this.attributes = l, this.itemSize = s.bytesPerElement, this.dynamicDraw = d, this.context = t; const g = t.gl; this.buffer = g.createBuffer(), t.bindVertexBuffer.set(this.buffer), g.bufferData(g.ARRAY_BUFFER, s.arrayBuffer, this.dynamicDraw ? g.DYNAMIC_DRAW : g.STATIC_DRAW), this.dynamicDraw || delete s.arrayBuffer } bind() { this.context.bindVertexBuffer.set(this.buffer) } updateData(t) { if (t.length !== this.length) throw new Error(`Length of new data is ${t.length}, which doesn't match current length of ${this.length}`); const s = this.context.gl; this.bind(), s.bufferSubData(s.ARRAY_BUFFER, 0, t.arrayBuffer) } enableAttributes(t, s) { for (let l = 0; l < this.attributes.length; l++) { const d = s.attributes[this.attributes[l].name]; d !== void 0 && t.enableVertexAttribArray(d) } } setVertexAttribPointers(t, s, l) { for (let d = 0; d < this.attributes.length; d++) { const g = this.attributes[d], v = s.attributes[g.name]; v !== void 0 && t.vertexAttribPointer(v, g.components, t[ap[g.type]], !1, this.itemSize, g.offset + this.itemSize * (l || 0)) } } destroy() { this.buffer && (this.context.gl.deleteBuffer(this.buffer), delete this.buffer) } } class Ht { constructor(t) { this.gl = t.gl, this.default = this.getDefault(), this.current = this.default, this.dirty = !1 } get() { return this.current } set(t) { } getDefault() { return this.default } setDefault() { this.set(this.default) } } class nu extends Ht { getDefault() { return c.bp.transparent } set(t) { const s = this.current; (t.r !== s.r || t.g !== s.g || t.b !== s.b || t.a !== s.a || this.dirty) && (this.gl.clearColor(t.r, t.g, t.b, t.a), this.current = t, this.dirty = !1) } } class iu extends Ht { getDefault() { return 1 } set(t) { (t !== this.current || this.dirty) && (this.gl.clearDepth(t), this.current = t, this.dirty = !1) } } class su extends Ht { getDefault() { return 0 } set(t) { (t !== this.current || this.dirty) && (this.gl.clearStencil(t), this.current = t, this.dirty = !1) } } class Wc extends Ht { getDefault() { return [!0, !0, !0, !0] } set(t) { const s = this.current; (t[0] !== s[0] || t[1] !== s[1] || t[2] !== s[2] || t[3] !== s[3] || this.dirty) && (this.gl.colorMask(t[0], t[1], t[2], t[3]), this.current = t, this.dirty = !1) } } class Qs extends Ht { getDefault() { return !0 } set(t) { (t !== this.current || this.dirty) && (this.gl.depthMask(t), this.current = t, this.dirty = !1) } } class $a extends Ht { getDefault() { return 255 } set(t) { (t !== this.current || this.dirty) && (this.gl.stencilMask(t), this.current = t, this.dirty = !1) } } class qo extends Ht { getDefault() { return { func: this.gl.ALWAYS, ref: 0, mask: 255 } } set(t) { const s = this.current; (t.func !== s.func || t.ref !== s.ref || t.mask !== s.mask || this.dirty) && (this.gl.stencilFunc(t.func, t.ref, t.mask), this.current = t, this.dirty = !1) } } class li extends Ht { getDefault() { const t = this.gl; return [t.KEEP, t.KEEP, t.KEEP] } set(t) { const s = this.current; (t[0] !== s[0] || t[1] !== s[1] || t[2] !== s[2] || this.dirty) && (this.gl.stencilOp(t[0], t[1], t[2]), this.current = t, this.dirty = !1) } } class lp extends Ht { getDefault() { return !1 } set(t) { if (t === this.current && !this.dirty) return; const s = this.gl; t ? s.enable(s.STENCIL_TEST) : s.disable(s.STENCIL_TEST), this.current = t, this.dirty = !1 } } class up extends Ht { getDefault() { return [0, 1] } set(t) { const s = this.current; (t[0] !== s[0] || t[1] !== s[1] || this.dirty) && (this.gl.depthRange(t[0], t[1]), this.current = t, this.dirty = !1) } } class Hc extends Ht { getDefault() { return !1 } set(t) { if (t === this.current && !this.dirty) return; const s = this.gl; t ? s.enable(s.DEPTH_TEST) : s.disable(s.DEPTH_TEST), this.current = t, this.dirty = !1 } } class Js extends Ht { getDefault() { return this.gl.LESS } set(t) { (t !== this.current || this.dirty) && (this.gl.depthFunc(t), this.current = t, this.dirty = !1) } } class ou extends Ht { getDefault() { return !1 } set(t) { if (t === this.current && !this.dirty) return; const s = this.gl; t ? s.enable(s.BLEND) : s.disable(s.BLEND), this.current = t, this.dirty = !1 } } class au extends Ht { getDefault() { const t = this.gl; return [t.ONE, t.ZERO] } set(t) { const s = this.current; (t[0] !== s[0] || t[1] !== s[1] || this.dirty) && (this.gl.blendFunc(t[0], t[1]), this.current = t, this.dirty = !1) } } class qa extends Ht { getDefault() { return c.bp.transparent } set(t) { const s = this.current; (t.r !== s.r || t.g !== s.g || t.b !== s.b || t.a !== s.a || this.dirty) && (this.gl.blendColor(t.r, t.g, t.b, t.a), this.current = t, this.dirty = !1) } } class lu extends Ht { getDefault() { return this.gl.FUNC_ADD } set(t) { (t !== this.current || this.dirty) && (this.gl.blendEquation(t), this.current = t, this.dirty = !1) } } class cp extends Ht { getDefault() { return !1 } set(t) { if (t === this.current && !this.dirty) return; const s = this.gl; t ? s.enable(s.CULL_FACE) : s.disable(s.CULL_FACE), this.current = t, this.dirty = !1 } } class Zo extends Ht { getDefault() { return this.gl.BACK } set(t) { (t !== this.current || this.dirty) && (this.gl.cullFace(t), this.current = t, this.dirty = !1) } } class Wo extends Ht { getDefault() { return this.gl.CCW } set(t) { (t !== this.current || this.dirty) && (this.gl.frontFace(t), this.current = t, this.dirty = !1) } } class hp extends Ht { getDefault() { return null } set(t) { (t !== this.current || this.dirty) && (this.gl.useProgram(t), this.current = t, this.dirty = !1) } } class Xc extends Ht { getDefault() { return this.gl.TEXTURE0 } set(t) { (t !== this.current || this.dirty) && (this.gl.activeTexture(t), this.current = t, this.dirty = !1) } } class Lt extends Ht { getDefault() { const t = this.gl; return [0, 0, t.drawingBufferWidth, t.drawingBufferHeight] } set(t) { const s = this.current; (t[0] !== s[0] || t[1] !== s[1] || t[2] !== s[2] || t[3] !== s[3] || this.dirty) && (this.gl.viewport(t[0], t[1], t[2], t[3]), this.current = t, this.dirty = !1) } } class uu extends Ht { getDefault() { return null } set(t) { if (t === this.current && !this.dirty) return; const s = this.gl; s.bindFramebuffer(s.FRAMEBUFFER, t), this.current = t, this.dirty = !1 } } class Hm extends Ht { getDefault() { return null } set(t) { if (t === this.current && !this.dirty) return; const s = this.gl; s.bindRenderbuffer(s.RENDERBUFFER, t), this.current = t, this.dirty = !1 } } class dp extends Ht { getDefault() { return null } set(t) { if (t === this.current && !this.dirty) return; const s = this.gl; s.bindTexture(s.TEXTURE_2D, t), this.current = t, this.dirty = !1 } } class Za extends Ht { getDefault() { return null } set(t) { if (t === this.current && !this.dirty) return; const s = this.gl; s.bindBuffer(s.ARRAY_BUFFER, t), this.current = t, this.dirty = !1 } } class Xm extends Ht { getDefault() { return null } set(t) { const s = this.gl; s.bindBuffer(s.ELEMENT_ARRAY_BUFFER, t), this.current = t, this.dirty = !1 } } class Ym extends Ht { getDefault() { return null } set(t) { var s; if (t === this.current && !this.dirty) return; const l = this.gl; ai(l) ? l.bindVertexArray(t) : (s = l.getExtension("OES_vertex_array_object")) === null || s === void 0 || s.bindVertexArrayOES(t), this.current = t, this.dirty = !1 } } class pp extends Ht { getDefault() { return 4 } set(t) { if (t === this.current && !this.dirty) return; const s = this.gl; s.pixelStorei(s.UNPACK_ALIGNMENT, t), this.current = t, this.dirty = !1 } } class Km extends Ht { getDefault() { return !1 } set(t) { if (t === this.current && !this.dirty) return; const s = this.gl; s.pixelStorei(s.UNPACK_PREMULTIPLY_ALPHA_WEBGL, t), this.current = t, this.dirty = !1 } } class Yc extends Ht { getDefault() { return !1 } set(t) { if (t === this.current && !this.dirty) return; const s = this.gl; s.pixelStorei(s.UNPACK_FLIP_Y_WEBGL, t), this.current = t, this.dirty = !1 } } class Ho extends Ht { constructor(t, s) { super(t), this.context = t, this.parent = s } getDefault() { return null } } class Wa extends Ho { setDirty() { this.dirty = !0 } set(t) { if (t === this.current && !this.dirty) return; this.context.bindFramebuffer.set(this.parent); const s = this.gl; s.framebufferTexture2D(s.FRAMEBUFFER, s.COLOR_ATTACHMENT0, s.TEXTURE_2D, t, 0), this.current = t, this.dirty = !1 } } class cu extends Ho { set(t) { if (t === this.current && !this.dirty) return; this.context.bindFramebuffer.set(this.parent); const s = this.gl; s.framebufferRenderbuffer(s.FRAMEBUFFER, s.DEPTH_ATTACHMENT, s.RENDERBUFFER, t), this.current = t, this.dirty = !1 } } class Kc extends Ho { set(t) { if (t === this.current && !this.dirty) return; this.context.bindFramebuffer.set(this.parent); const s = this.gl; s.framebufferRenderbuffer(s.FRAMEBUFFER, s.DEPTH_STENCIL_ATTACHMENT, s.RENDERBUFFER, t), this.current = t, this.dirty = !1 } } const Qc = "Framebuffer is not complete"; class hu { constructor(t, s, l, d, g) { this.context = t, this.width = s, this.height = l; const v = t.gl, T = this.framebuffer = v.createFramebuffer(); if (this.colorAttachment = new Wa(t, T), d) this.depthAttachment = g ? new Kc(t, T) : new cu(t, T); else if (g) throw new Error("Stencil cannot be set without depth"); if (v.checkFramebufferStatus(v.FRAMEBUFFER) !== v.FRAMEBUFFER_COMPLETE) throw new Error(Qc) } destroy() { const t = this.context.gl, s = this.colorAttachment.get(); if (s && t.deleteTexture(s), this.depthAttachment) { const l = this.depthAttachment.get(); l && t.deleteRenderbuffer(l) } t.deleteFramebuffer(this.framebuffer) } } class du { constructor(t) { var s, l; if (this.gl = t, this.clearColor = new nu(this), this.clearDepth = new iu(this), this.clearStencil = new su(this), this.colorMask = new Wc(this), this.depthMask = new Qs(this), this.stencilMask = new $a(this), this.stencilFunc = new qo(this), this.stencilOp = new li(this), this.stencilTest = new lp(this), this.depthRange = new up(this), this.depthTest = new Hc(this), this.depthFunc = new Js(this), this.blend = new ou(this), this.blendFunc = new au(this), this.blendColor = new qa(this), this.blendEquation = new lu(this), this.cullFace = new cp(this), this.cullFaceSide = new Zo(this), this.frontFace = new Wo(this), this.program = new hp(this), this.activeTexture = new Xc(this), this.viewport = new Lt(this), this.bindFramebuffer = new uu(this), this.bindRenderbuffer = new Hm(this), this.bindTexture = new dp(this), this.bindVertexBuffer = new Za(this), this.bindElementBuffer = new Xm(this), this.bindVertexArray = new Ym(this), this.pixelStoreUnpack = new pp(this), this.pixelStoreUnpackPremultiplyAlpha = new Km(this), this.pixelStoreUnpackFlipY = new Yc(this), this.extTextureFilterAnisotropic = t.getExtension("EXT_texture_filter_anisotropic") || t.getExtension("MOZ_EXT_texture_filter_anisotropic") || t.getExtension("WEBKIT_EXT_texture_filter_anisotropic"), this.extTextureFilterAnisotropic && (this.extTextureFilterAnisotropicMax = t.getParameter(this.extTextureFilterAnisotropic.MAX_TEXTURE_MAX_ANISOTROPY_EXT)), this.maxTextureSize = t.getParameter(t.MAX_TEXTURE_SIZE), ai(t)) { this.HALF_FLOAT = t.HALF_FLOAT; const d = t.getExtension("EXT_color_buffer_half_float"); this.RGBA16F = (s = t.RGBA16F) !== null && s !== void 0 ? s : d == null ? void 0 : d.RGBA16F_EXT, this.RGB16F = (l = t.RGB16F) !== null && l !== void 0 ? l : d == null ? void 0 : d.RGB16F_EXT, t.getExtension("EXT_color_buffer_float") } else { t.getExtension("EXT_color_buffer_half_float"), t.getExtension("OES_texture_half_float_linear"); const d = t.getExtension("OES_texture_half_float"); this.HALF_FLOAT = d == null ? void 0 : d.HALF_FLOAT_OES } } setDefault() { this.unbindVAO(), this.clearColor.setDefault(), this.clearDepth.setDefault(), this.clearStencil.setDefault(), this.colorMask.setDefault(), this.depthMask.setDefault(), this.stencilMask.setDefault(), this.stencilFunc.setDefault(), this.stencilOp.setDefault(), this.stencilTest.setDefault(), this.depthRange.setDefault(), this.depthTest.setDefault(), this.depthFunc.setDefault(), this.blend.setDefault(), this.blendFunc.setDefault(), this.blendColor.setDefault(), this.blendEquation.setDefault(), this.cullFace.setDefault(), this.cullFaceSide.setDefault(), this.frontFace.setDefault(), this.program.setDefault(), this.activeTexture.setDefault(), this.bindFramebuffer.setDefault(), this.pixelStoreUnpack.setDefault(), this.pixelStoreUnpackPremultiplyAlpha.setDefault(), this.pixelStoreUnpackFlipY.setDefault() } setDirty() { this.clearColor.dirty = !0, this.clearDepth.dirty = !0, this.clearStencil.dirty = !0, this.colorMask.dirty = !0, this.depthMask.dirty = !0, this.stencilMask.dirty = !0, this.stencilFunc.dirty = !0, this.stencilOp.dirty = !0, this.stencilTest.dirty = !0, this.depthRange.dirty = !0, this.depthTest.dirty = !0, this.depthFunc.dirty = !0, this.blend.dirty = !0, this.blendFunc.dirty = !0, this.blendColor.dirty = !0, this.blendEquation.dirty = !0, this.cullFace.dirty = !0, this.cullFaceSide.dirty = !0, this.frontFace.dirty = !0, this.program.dirty = !0, this.activeTexture.dirty = !0, this.viewport.dirty = !0, this.bindFramebuffer.dirty = !0, this.bindRenderbuffer.dirty = !0, this.bindTexture.dirty = !0, this.bindVertexBuffer.dirty = !0, this.bindElementBuffer.dirty = !0, this.bindVertexArray.dirty = !0, this.pixelStoreUnpack.dirty = !0, this.pixelStoreUnpackPremultiplyAlpha.dirty = !0, this.pixelStoreUnpackFlipY.dirty = !0 } createIndexBuffer(t, s) { return new Zm(this, t, s) } createVertexBuffer(t, s, l) { return new Wm(this, t, s, l) } createRenderbuffer(t, s, l) { const d = this.gl, g = d.createRenderbuffer(); return this.bindRenderbuffer.set(g), d.renderbufferStorage(d.RENDERBUFFER, t, s, l), this.bindRenderbuffer.set(null), g } createFramebuffer(t, s, l, d) { return new hu(this, t, s, l, d) } clear({ color: t, depth: s, stencil: l }) { const d = this.gl; let g = 0; t && (g |= d.COLOR_BUFFER_BIT, this.clearColor.set(t), this.colorMask.set([!0, !0, !0, !0])), s !== void 0 && (g |= d.DEPTH_BUFFER_BIT, this.depthRange.set([0, 1]), this.clearDepth.set(s), this.depthMask.set(!0)), l !== void 0 && (g |= d.STENCIL_BUFFER_BIT, this.clearStencil.set(l), this.stencilMask.set(255)), d.clear(g) } setCullFace(t) { t.enable === !1 ? this.cullFace.set(!1) : (this.cullFace.set(!0), this.cullFaceSide.set(t.mode), this.frontFace.set(t.frontFace)) } setDepthMode(t) { t.func !== this.gl.ALWAYS || t.mask ? (this.depthTest.set(!0), this.depthFunc.set(t.func), this.depthMask.set(t.mask), this.depthRange.set(t.range)) : this.depthTest.set(!1) } setStencilMode(t) { t.test.func !== this.gl.ALWAYS || t.mask ? (this.stencilTest.set(!0), this.stencilMask.set(t.mask), this.stencilOp.set([t.fail, t.depthFail, t.pass]), this.stencilFunc.set({ func: t.test.func, ref: t.ref, mask: t.test.mask })) : this.stencilTest.set(!1) } setColorMode(t) { c.bR(t.blendFunction, or.Replace) ? this.blend.set(!1) : (this.blend.set(!0), this.blendFunc.set(t.blendFunction), this.blendColor.set(t.blendColor)), this.colorMask.set(t.mask) } createVertexArray() { var t; return ai(this.gl) ? this.gl.createVertexArray() : (t = this.gl.getExtension("OES_vertex_array_object")) === null || t === void 0 ? void 0 : t.createVertexArrayOES() } deleteVertexArray(t) { var s; return ai(this.gl) ? this.gl.deleteVertexArray(t) : (s = this.gl.getExtension("OES_vertex_array_object")) === null || s === void 0 ? void 0 : s.deleteVertexArrayOES(t) } unbindVAO() { this.bindVertexArray.set(null) } } let Ss; function eo(m, t, s, l, d) { const g = m.context, v = m.transform, T = g.gl, E = m.useProgram("collisionBox"), I = []; let A = 0, R = 0; for (let Y = 0; Y < l.length; Y++) { const te = l[Y], le = t.getTile(te).getBucket(s); if (!le) continue; const J = d ? le.textCollisionBox : le.iconCollisionBox, oe = le.collisionCircleArray; oe.length > 0 && (I.push({ circleArray: oe, circleOffset: R, coord: te }), A += oe.length / 4, R = A), J && E.draw(g, T.LINES, kt.disabled, jt.disabled, m.colorModeForRenderPass(), Nt.disabled, Ys(m.transform), m.style.map.terrain && m.style.map.terrain.getTerrainData(te), v.getProjectionData({ overscaledTileID: te, applyGlobeMatrix: !0, applyTerrainMatrix: !0 }), s.id, J.layoutVertexBuffer, J.indexBuffer, J.segments, null, m.transform.zoom, null, null, J.collisionVertexBuffer) } if (!d || !I.length) return; const z = m.useProgram("collisionCircle"), O = new c.ca; O.resize(4 * A), O._trim(); let U = 0; for (const Y of I) for (let te = 0; te < Y.circleArray.length / 4; te++) { const le = 4 * te, J = Y.circleArray[le + 0], oe = Y.circleArray[le + 1], ce = Y.circleArray[le + 2], se = Y.circleArray[le + 3]; O.emplace(U++, J, oe, ce, se, 0), O.emplace(U++, J, oe, ce, se, 1), O.emplace(U++, J, oe, ce, se, 2), O.emplace(U++, J, oe, ce, se, 3) } (!Ss || Ss.length < 2 * A) && (Ss = function (Y) { const te = 2 * Y, le = new c.cc; le.resize(te), le._trim(); for (let J = 0; J < te; J++) { const oe = 6 * J; le.uint16[oe + 0] = 4 * J + 0, le.uint16[oe + 1] = 4 * J + 1, le.uint16[oe + 2] = 4 * J + 2, le.uint16[oe + 3] = 4 * J + 2, le.uint16[oe + 4] = 4 * J + 3, le.uint16[oe + 5] = 4 * J + 0 } return le }(A)); const X = g.createIndexBuffer(Ss, !0), Q = g.createVertexBuffer(O, c.cb.members, !0); for (const Y of I) { const te = tp(m.transform); z.draw(g, T.TRIANGLES, kt.disabled, jt.disabled, m.colorModeForRenderPass(), Nt.disabled, te, m.style.map.terrain && m.style.map.terrain.getTerrainData(Y.coord), null, s.id, Q, X, c.aX.simpleSegment(0, 2 * Y.circleOffset, Y.circleArray.length, Y.circleArray.length / 2), null, m.transform.zoom, null, null, null) } Q.destroy(), X.destroy() } const Jc = c.ar(new Float32Array(16)); function Qm(m, t, s, l, d, g) { const { horizontalAlign: v, verticalAlign: T } = c.aS(m); return new c.P((-(v - .5) * t / d + l[0]) * g, (-(T - .5) * s / d + l[1]) * g) } function Ha(m, t, s, l, d, g) { const v = t.tileAnchorPoint.add(new c.P(t.translation[0], t.translation[1])); if (t.pitchWithMap) { let T = l.mult(g); s || (T = T.rotate(-d)); const E = v.add(T); return At(E.x, E.y, t.pitchedLabelPlaneMatrix, t.getElevation).point } if (s) { const T = er(t.tileAnchorPoint.x + 1, t.tileAnchorPoint.y, t).point.sub(m), E = Math.atan(T.y / T.x) + (T.x < 0 ? Math.PI : 0); return m.add(l.rotate(E)) } return m.add(l) } function Jm(m, t, s, l, d, g, v, T, E, I, A, R) { const z = m.text.placedSymbolArray, O = m.text.dynamicLayoutVertexArray, U = m.icon.dynamicLayoutVertexArray, X = {}; O.clear(); for (let Q = 0; Q < z.length; Q++) { const Y = z.get(Q), te = Y.hidden || !Y.crossTileID || m.allowVerticalPlacement && !Y.placedOrientation ? null : l[Y.crossTileID]; if (te) { const le = new c.P(Y.anchorX, Y.anchorY), J = { getElevation: R, width: d.width, height: d.height, pitchedLabelPlaneMatrix: g, pitchWithMap: s, transform: d, tileAnchorPoint: le, translation: I, unwrappedTileID: A }, oe = s ? ko(le.x, le.y, J) : er(le.x, le.y, J), ce = Aa(d.cameraToCenterDistance, oe.signedDistanceFromCamera); let se = c.aA(m.textSizeData, T, Y) * ce / c.aM; s && (se *= m.tilePixelRatio / v); const { width: fe, height: Oe, anchor: ke, textOffset: ze, textBoxScale: Re } = te, Je = Qm(ke, fe, Oe, ze, Re, se), tt = d.getPitchedTextCorrection(le.x + I[0], le.y + I[1], A), We = Ha(oe.point, J, t, Je, -d.bearingInRadians, tt), it = m.allowVerticalPlacement && Y.placedOrientation === c.az.vertical ? Math.PI / 2 : 0; for (let It = 0; It < Y.numGlyphs; It++)c.aG(O, We, it); E && Y.associatedIconIndex >= 0 && (X[Y.associatedIconIndex] = { shiftedAnchor: We, angle: it }) } else $s(Y.numGlyphs, O) } if (E) { U.clear(); const Q = m.icon.placedSymbolArray; for (let Y = 0; Y < Q.length; Y++) { const te = Q.get(Y); if (te.hidden) $s(te.numGlyphs, U); else { const le = X[Y]; if (le) for (let J = 0; J < te.numGlyphs; J++)c.aG(U, le.shiftedAnchor, le.angle); else $s(te.numGlyphs, U) } } m.icon.dynamicLayoutVertexBuffer.updateData(U) } m.text.dynamicLayoutVertexBuffer.updateData(O) } function fp(m, t, s) { return s.iconsInText && t ? "symbolTextAndIcon" : m ? "symbolSDF" : "symbolIcon" } function Xa(m, t, s, l, d, g, v, T, E, I, A, R, z) { const O = m.context, U = O.gl, X = m.transform, Q = T === "map", Y = E === "map", te = T !== "viewport" && s.layout.get("symbol-placement") !== "point", le = Q && !Y && !te, J = !s.layout.get("symbol-sort-key").isConstant(); let oe = !1; const ce = m.getDepthModeForSublayer(0, kt.ReadOnly), se = s._unevaluatedLayout.hasValue("text-variable-anchor") || s._unevaluatedLayout.hasValue("text-variable-anchor-offset"), fe = [], Oe = X.getCircleRadiusCorrection(); for (const ke of l) { const ze = t.getTile(ke), Re = ze.getBucket(s); if (!Re) continue; const Je = d ? Re.text : Re.icon; if (!Je || !Je.segments.get().length || !Je.hasVisibleVertices) continue; const tt = Je.programConfigurations.get(s.id), We = d || Re.sdfIcons, it = d ? Re.textSizeData : Re.iconSizeData, It = Y || X.pitch !== 0, Kt = m.useProgram(fp(We, d, Re), tt), fr = c.ay(it, X.zoom), ar = m.style.map.terrain && m.style.map.terrain.getTerrainData(ke); let yr, lr, Ar, vr, sn = [0, 0], Vr = null; if (d) lr = ze.glyphAtlasTexture, Ar = U.LINEAR, yr = ze.glyphAtlasTexture.size, Re.iconsInText && (sn = ze.imageAtlasTexture.size, Vr = ze.imageAtlasTexture, vr = It || m.options.rotating || m.options.zooming || it.kind === "composite" || it.kind === "camera" ? U.LINEAR : U.NEAREST); else { const cr = s.layout.get("icon-size").constantOr(0) !== 1 || Re.iconsNeedLinear; lr = ze.imageAtlasTexture, Ar = We || m.options.rotating || m.options.zooming || cr || It ? U.LINEAR : U.NEAREST, yr = ze.imageAtlasTexture.size } const Or = c.aN(ze, 1, m.transform.zoom), mn = Yn(Q, m.transform, Or), Cs = c.N(); c.aB(Cs, mn); const ns = Gl(Y, Q, m.transform, Or), Ui = c.aO(X, ze, g, v), Gn = X.getProjectionData({ overscaledTileID: ke, applyGlobeMatrix: !z, applyTerrainMatrix: !0 }), oo = se && Re.hasTextData(), ml = s.layout.get("icon-text-fit") !== "none" && oo && Re.hasIconData(); if (te) { const cr = m.style.map.terrain ? (Jr, en) => m.style.map.terrain.getElevation(ke, Jr, en) : null, ur = s.layout.get("text-rotation-alignment") === "map"; $l(Re, m, d, mn, Cs, Y, I, ur, ke.toUnwrapped(), X.width, X.height, Ui, cr) } const ao = d && se || ml, hi = te || ao ? Jc : Y ? mn : m.transform.clipSpaceToPixelsMatrix, Gi = We && s.paint.get(d ? "text-halo-width" : "icon-halo-width").constantOr(1) !== 0; let Mi; Mi = We ? Re.iconsInText ? Ks(it.kind, fr, le, Y, te, ao, m, hi, ns, Ui, yr, sn, Oe) : ru(it.kind, fr, le, Y, te, ao, m, hi, ns, Ui, d, yr, 0, Oe) : qc(it.kind, fr, le, Y, te, ao, m, hi, ns, Ui, d, yr, Oe); const Ii = { program: Kt, buffers: Je, uniformValues: Mi, projectionData: Gn, atlasTexture: lr, atlasTextureIcon: Vr, atlasInterpolation: Ar, atlasInterpolationIcon: vr, isSDF: We, hasHalo: Gi }; if (J && Re.canOverlap) { oe = !0; const cr = Je.segments.get(); for (const ur of cr) fe.push({ segments: new c.aX([ur]), sortKey: ur.sortKey, state: Ii, terrainData: ar }) } else fe.push({ segments: Je.segments, sortKey: 0, state: Ii, terrainData: ar }) } oe && fe.sort((ke, ze) => ke.sortKey - ze.sortKey); for (const ke of fe) { const ze = ke.state; if (O.activeTexture.set(U.TEXTURE0), ze.atlasTexture.bind(ze.atlasInterpolation, U.CLAMP_TO_EDGE), ze.atlasTextureIcon && (O.activeTexture.set(U.TEXTURE1), ze.atlasTextureIcon && ze.atlasTextureIcon.bind(ze.atlasInterpolationIcon, U.CLAMP_TO_EDGE)), ze.isSDF) { const Re = ze.uniformValues; ze.hasHalo && (Re.u_is_halo = 1, pu(ze.buffers, ke.segments, s, m, ze.program, ce, A, R, Re, ze.projectionData, ke.terrainData)), Re.u_is_halo = 0 } pu(ze.buffers, ke.segments, s, m, ze.program, ce, A, R, ze.uniformValues, ze.projectionData, ke.terrainData) } } function pu(m, t, s, l, d, g, v, T, E, I, A) { const R = l.context; d.draw(R, R.gl.TRIANGLES, g, v, T, Nt.backCCW, E, A, I, s.id, m.layoutVertexBuffer, m.indexBuffer, t, s.paint, l.transform.zoom, m.programConfigurations.get(s.id), m.dynamicLayoutVertexBuffer, m.opacityVertexBuffer) } function mp(m, t, s, l, d) { const g = m.context, v = g.gl, T = jt.disabled, E = new or([v.ONE, v.ONE], c.bp.transparent, [!0, !0, !0, !0]), I = t.getBucket(s); if (!I) return; const A = l.key; let R = s.heatmapFbos.get(A); R || (R = Ya(g, t.tileSize, t.tileSize), s.heatmapFbos.set(A, R)), g.bindFramebuffer.set(R.framebuffer), g.viewport.set([0, 0, t.tileSize, t.tileSize]), g.clear({ color: c.bp.transparent }); const z = I.programConfigurations.get(s.id), O = m.useProgram("heatmap", z, !d), U = m.transform.getProjectionData({ overscaledTileID: t.tileID, applyGlobeMatrix: !0, applyTerrainMatrix: !0 }), X = m.style.map.terrain.getTerrainData(l); O.draw(g, v.TRIANGLES, kt.disabled, T, E, Nt.disabled, $o(t, m.transform.zoom, s.paint.get("heatmap-intensity"), 1), X, U, s.id, I.layoutVertexBuffer, I.indexBuffer, I.segments, s.paint, m.transform.zoom, z) } function gp(m, t, s, l, d) { const g = m.context, v = g.gl, T = m.transform; g.setColorMode(m.colorModeForRenderPass()); const E = fu(g, t), I = s.key, A = t.heatmapFbos.get(I); if (!A) return; g.activeTexture.set(v.TEXTURE0), v.bindTexture(v.TEXTURE_2D, A.colorAttachment.get()), g.activeTexture.set(v.TEXTURE1), E.bind(v.LINEAR, v.CLAMP_TO_EDGE); const R = T.getProjectionData({ overscaledTileID: s, applyTerrainMatrix: d, applyGlobeMatrix: !l }); m.useProgram("heatmapTexture").draw(g, v.TRIANGLES, kt.disabled, jt.disabled, m.colorModeForRenderPass(), Nt.disabled, rp(m, t, 0, 1), null, R, t.id, m.rasterBoundsBuffer, m.quadTriangleIndexBuffer, m.rasterBoundsSegments, t.paint, T.zoom), A.destroy(), t.heatmapFbos.delete(I) } function Ya(m, t, s) { var l, d; const g = m.gl, v = g.createTexture(); g.bindTexture(g.TEXTURE_2D, v), g.texParameteri(g.TEXTURE_2D, g.TEXTURE_WRAP_S, g.CLAMP_TO_EDGE), g.texParameteri(g.TEXTURE_2D, g.TEXTURE_WRAP_T, g.CLAMP_TO_EDGE), g.texParameteri(g.TEXTURE_2D, g.TEXTURE_MIN_FILTER, g.LINEAR), g.texParameteri(g.TEXTURE_2D, g.TEXTURE_MAG_FILTER, g.LINEAR); const T = (l = m.HALF_FLOAT) !== null && l !== void 0 ? l : g.UNSIGNED_BYTE, E = (d = m.RGBA16F) !== null && d !== void 0 ? d : g.RGBA; g.texImage2D(g.TEXTURE_2D, 0, E, t, s, 0, g.RGBA, T, null); const I = m.createFramebuffer(t, s, !1, !1); return I.colorAttachment.set(v), I } function fu(m, t) { return t.colorRampTexture || (t.colorRampTexture = new c.T(m, t.colorRamp, m.gl.RGBA)), t.colorRampTexture } function _p(m, t, s, l, d, g, v, T) { let E = 256; if (d.stepInterpolant) { const I = t.getSource().maxzoom, A = v.canonical.z === I ? Math.ceil(1 << m.transform.maxZoom - v.canonical.z) : 1; E = c.an(c.ce(g.maxLineLength / c.a5 * 1024 * A), 256, s.maxTextureSize) } return T.gradient = c.cf({ expression: d.gradientExpression(), evaluationKey: "lineProgress", resolution: E, image: T.gradient || void 0, clips: g.lineClipsArray }), T.texture ? T.texture.update(T.gradient) : T.texture = new c.T(s, T.gradient, l.RGBA), T.version = d.gradientVersion, T.texture } function yp(m, t, s, l, d) { m.activeTexture.set(t.TEXTURE0), s.imageAtlasTexture.bind(t.LINEAR, t.CLAMP_TO_EDGE), l.updatePaintBuffers(d) } function Fr(m, t, s, l, d, g) { (d || m.lineAtlas.dirty) && (t.activeTexture.set(s.TEXTURE0), m.lineAtlas.bind(t)), l.updatePaintBuffers(g) } function to(m, t, s, l, d, g, v) { const T = g.gradients[d.id]; let E = T.texture; d.gradientVersion !== T.version && (E = _p(m, t, s, l, d, g, v, T)), s.activeTexture.set(l.TEXTURE0), E.bind(d.stepInterpolant ? l.NEAREST : l.LINEAR, l.CLAMP_TO_EDGE) } function Qn(m, t, s, l, d, g, v, T, E) { const I = g.gradients[d.id]; let A = I.texture; d.gradientVersion !== I.version && (A = _p(m, t, s, l, d, g, v, I)), s.activeTexture.set(l.TEXTURE0), A.bind(d.stepInterpolant ? l.NEAREST : l.LINEAR, l.CLAMP_TO_EDGE), s.activeTexture.set(l.TEXTURE1), m.lineAtlas.bind(s), T.updatePaintBuffers(E) } function mu(m, t, s, l, d) { if (!s || !l || !l.imageAtlas) return; const g = l.imageAtlas.patternPositions; let v = g[s.to.toString()], T = g[s.from.toString()]; if (!v && T && (v = T), !T && v && (T = v), !v || !T) { const E = d.getPaintProperty(t); v = g[E], T = g[E] } v && T && m.setConstantPatternPositions(v, T) } function Ka(m, t, s, l, d, g, v, T) { const E = m.context.gl, I = "fill-pattern", A = s.paint.get(I), R = A && A.constantOr(1), z = s.getCrossfadeParameters(); let O, U, X, Q, Y; const te = m.transform, le = s.paint.get("fill-translate"), J = s.paint.get("fill-translate-anchor"); v ? (U = R && !s.getPaintProperty("fill-outline-color") ? "fillOutlinePattern" : "fillOutline", O = E.LINES) : (U = R ? "fillPattern" : "fill", O = E.TRIANGLES); const oe = A.constantOr(null); for (const ce of l) { const se = t.getTile(ce); if (R && !se.patternsLoaded()) continue; const fe = se.getBucket(s); if (!fe) continue; const Oe = fe.programConfigurations.get(s.id), ke = m.useProgram(U, Oe), ze = m.style.map.terrain && m.style.map.terrain.getTerrainData(ce); R && (m.context.activeTexture.set(E.TEXTURE0), se.imageAtlasTexture.bind(E.LINEAR, E.CLAMP_TO_EDGE), Oe.updatePaintBuffers(z)), mu(Oe, I, oe, se, s); const Re = te.getProjectionData({ overscaledTileID: ce, applyGlobeMatrix: !T, applyTerrainMatrix: !0 }), Je = c.aO(te, se, le, J); if (v) { Q = fe.indexBuffer2, Y = fe.segments2; const We = [E.drawingBufferWidth, E.drawingBufferHeight]; X = U === "fillOutlinePattern" && R ? Jd(m, z, se, We, Je) : Qd(We, Je) } else Q = fe.indexBuffer, Y = fe.segments, X = R ? jc(m, z, se, Je) : { u_fill_translate: Je }; const tt = m.stencilModeForClipping(ce); ke.draw(m.context, O, d, tt, g, Nt.backCCW, X, ze, Re, s.id, fe.layoutVertexBuffer, Q, Y, s.paint, m.transform.zoom, Oe) } } function gu(m, t, s, l, d, g, v, T) { const E = m.context, I = E.gl, A = "fill-extrusion-pattern", R = s.paint.get(A), z = R.constantOr(1), O = s.getCrossfadeParameters(), U = s.paint.get("fill-extrusion-opacity"), X = R.constantOr(null), Q = m.transform; for (const Y of l) { const te = t.getTile(Y), le = te.getBucket(s); if (!le) continue; const J = m.style.map.terrain && m.style.map.terrain.getTerrainData(Y), oe = le.programConfigurations.get(s.id), ce = m.useProgram(z ? "fillExtrusionPattern" : "fillExtrusion", oe); z && (m.context.activeTexture.set(I.TEXTURE0), te.imageAtlasTexture.bind(I.LINEAR, I.CLAMP_TO_EDGE), oe.updatePaintBuffers(O)); const se = Q.getProjectionData({ overscaledTileID: Y, applyGlobeMatrix: !T, applyTerrainMatrix: !0 }); mu(oe, A, X, te, s); const fe = c.aO(Q, te, s.paint.get("fill-extrusion-translate"), s.paint.get("fill-extrusion-translate-anchor")), Oe = s.paint.get("fill-extrusion-vertical-gradient"), ke = z ? Nc(m, Oe, U, fe, Y, O, te) : Oc(m, Oe, U, fe); ce.draw(E, E.gl.TRIANGLES, d, g, v, Nt.backCCW, ke, J, se, s.id, le.layoutVertexBuffer, le.indexBuffer, le.segments, s.paint, m.transform.zoom, oe, m.style.map.terrain && le.centroidVertexBuffer) } } function Es(m, t, s, l, d, g, v, T, E) { var I; const A = m.style.projection, R = m.context, z = m.transform, O = R.gl, U = [`#define NUM_ILLUMINATION_SOURCES ${s.paint.get("hillshade-highlight-color").values.length}`], X = m.useProgram("hillshade", null, !1, U), Q = !m.options.moving; for (const Y of l) { const te = t.getTile(Y), le = te.fbo; if (!le) continue; const J = A.getMeshFromTileID(R, Y.canonical, T, !0, "raster"), oe = (I = m.style.map.terrain) === null || I === void 0 ? void 0 : I.getTerrainData(Y); R.activeTexture.set(O.TEXTURE0), O.bindTexture(O.TEXTURE_2D, le.colorAttachment.get()); const ce = z.getProjectionData({ overscaledTileID: Y, aligned: Q, applyGlobeMatrix: !E, applyTerrainMatrix: !0 }); X.draw(R, O.TRIANGLES, g, d[Y.overscaledZ], v, Nt.backCCW, Jl(m, te, s), oe, ce, s.id, J.vertexBuffer, J.indexBuffer, J.segments) } } function Qa(m, t, s, l, d, g, v, T, E) { var I; const A = m.style.projection, R = m.context, z = m.transform, O = R.gl, U = m.useProgram("colorRelief"), X = !m.options.moving; let Q = !0, Y = 0; for (const te of l) { const le = t.getTile(te), J = le.dem; if (Q) { const ke = O.getParameter(O.MAX_TEXTURE_SIZE), { elevationTexture: ze, colorTexture: Re } = s.getColorRampTextures(R, ke, J.getUnpackVector()); R.activeTexture.set(O.TEXTURE1), ze.bind(O.NEAREST, O.CLAMP_TO_EDGE), R.activeTexture.set(O.TEXTURE4), Re.bind(O.LINEAR, O.CLAMP_TO_EDGE), Q = !1, Y = ze.size[0] } if (!J || !J.data) continue; const oe = J.stride, ce = J.getPixels(); if (R.activeTexture.set(O.TEXTURE0), R.pixelStoreUnpackPremultiplyAlpha.set(!1), le.demTexture = le.demTexture || m.getTileTexture(oe), le.demTexture) { const ke = le.demTexture; ke.update(ce, { premultiply: !1 }), ke.bind(O.LINEAR, O.CLAMP_TO_EDGE) } else le.demTexture = new c.T(R, ce, O.RGBA, { premultiply: !1 }), le.demTexture.bind(O.LINEAR, O.CLAMP_TO_EDGE); const se = A.getMeshFromTileID(R, te.canonical, T, !0, "raster"), fe = (I = m.style.map.terrain) === null || I === void 0 ? void 0 : I.getTerrainData(te), Oe = z.getProjectionData({ overscaledTileID: te, aligned: X, applyGlobeMatrix: !E, applyTerrainMatrix: !0 }); U.draw(R, O.TRIANGLES, g, d[te.overscaledZ], v, Nt.backCCW, np(s, le.dem, Y), fe, Oe, s.id, se.vertexBuffer, se.indexBuffer, se.segments) } } const ro = [new c.P(0, 0), new c.P(c.a5, 0), new c.P(c.a5, c.a5), new c.P(0, c.a5)]; function Xo(m, t, s, l, d, g, v, T, E = !1, I = !1) { const A = l[l.length - 1].overscaledZ, R = m.context, z = R.gl, O = m.useProgram("raster"), U = m.transform, X = m.style.projection, Q = m.colorModeForRenderPass(), Y = !m.options.moving, te = s.paint.get("raster-opacity"), le = s.paint.get("raster-resampling"), J = s.paint.get("raster-fade-duration"), oe = !!m.style.map.terrain; for (const ce of l) { const se = m.getDepthModeForSublayer(ce.overscaledZ - A, te === 1 ? kt.ReadWrite : kt.ReadOnly, z.LESS), fe = t.getTile(ce), Oe = le === "nearest" ? z.NEAREST : z.LINEAR; R.activeTexture.set(z.TEXTURE0), fe.texture.bind(Oe, z.CLAMP_TO_EDGE, z.LINEAR_MIPMAP_NEAREST), R.activeTexture.set(z.TEXTURE1); const { parentTile: ke, parentScaleBy: ze, parentTopLeft: Re, fadeValues: Je } = vp(fe, t, J, oe); fe.fadeOpacity = Je.tileOpacity, ke ? (ke.fadeOpacity = Je.parentTileOpacity, ke.texture.bind(Oe, z.CLAMP_TO_EDGE, z.LINEAR_MIPMAP_NEAREST)) : fe.texture.bind(Oe, z.CLAMP_TO_EDGE, z.LINEAR_MIPMAP_NEAREST), fe.texture.useMipmap && R.extTextureFilterAnisotropic && m.transform.pitch > 20 && z.texParameterf(z.TEXTURE_2D, R.extTextureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT, R.extTextureFilterAnisotropicMax); const tt = m.style.map.terrain && m.style.map.terrain.getTerrainData(ce), We = U.getProjectionData({ overscaledTileID: ce, aligned: Y, applyGlobeMatrix: !I, applyTerrainMatrix: !0 }), it = Gc(Re, ze, Je.fadeMix, s, T), It = X.getMeshFromTileID(R, ce.canonical, g, v, "raster"); O.draw(R, z.TRIANGLES, se, d ? d[ce.overscaledZ] : jt.disabled, Q, E ? Nt.frontCCW : Nt.backCCW, it, tt, We, s.id, It.vertexBuffer, It.indexBuffer, It.segments) } } function vp(m, t, s, l) { const d = { parentTile: null, parentScaleBy: 1, parentTopLeft: [0, 0], fadeValues: { tileOpacity: 1, parentTileOpacity: 1, fadeMix: { opacity: 1, mix: 0 } } }; if (s === 0 || l) return d; if (m.fadingParentID) { const g = t.getLoadedTile(m.fadingParentID); if (!g) return d; const v = Math.pow(2, g.tileID.overscaledZ - m.tileID.overscaledZ), T = [m.tileID.canonical.x * v % 1, m.tileID.canonical.y * v % 1], E = function (I, A, R) { const z = $e(), O = (z - A.timeAdded) / R, U = I.fadingDirection === Be.Incoming, X = c.an((z - I.timeAdded) / R, 0, 1), Q = c.an(1 - O, 0, 1), Y = U ? X : Q; return { tileOpacity: Y, parentTileOpacity: U ? Q : X, fadeMix: { opacity: 1, mix: 1 - Y } } }(m, g, s); return { parentTile: g, parentScaleBy: v, parentTopLeft: T, fadeValues: E } } if (m.selfFading) { const g = function (v, T) { const E = ($e() - v.timeAdded) / T, I = c.an(E, 0, 1); return { tileOpacity: I, fadeMix: { opacity: I, mix: 0 } } }(m, s); return { parentTile: null, parentScaleBy: 1, parentTopLeft: [0, 0], fadeValues: g } } return d } const xp = new c.bp(1, 0, 0, 1), wp = new c.bp(0, 1, 0, 1), bp = new c.bp(0, 0, 1, 1), Tp = new c.bp(1, 0, 1, 1), Ps = new c.bp(0, 1, 1, 1); function eh(m, t, s, l) { Ja(m, 0, t + s / 2, m.transform.width, s, l) } function th(m, t, s, l) { Ja(m, t - s / 2, 0, s, m.transform.height, l) } function Ja(m, t, s, l, d, g) { const v = m.context, T = v.gl; T.enable(T.SCISSOR_TEST), T.scissor(t * m.pixelRatio, s * m.pixelRatio, l * m.pixelRatio, d * m.pixelRatio), v.clear({ color: g }), T.disable(T.SCISSOR_TEST) } function Sp(m, t, s) { const l = m.context, d = l.gl, g = m.useProgram("debug"), v = kt.disabled, T = jt.disabled, E = m.colorModeForRenderPass(), I = "$debug", A = m.style.map.terrain && m.style.map.terrain.getTerrainData(s); l.activeTexture.set(d.TEXTURE0); const R = t.getTileByID(s.key).latestRawTileData, z = Math.floor((R && R.byteLength || 0) / 1024), O = t.getTile(s).tileSize, U = 512 / Math.min(O, 512) * (s.overscaledZ / m.transform.zoom) * .5; let X = s.canonical.toString(); s.overscaledZ !== s.canonical.z && (X += ` => ${s.overscaledZ}`), function (Y, te) { Y.initDebugOverlayCanvas(); const le = Y.debugOverlayCanvas, J = Y.context.gl, oe = Y.debugOverlayCanvas.getContext("2d"); oe.clearRect(0, 0, le.width, le.height), oe.shadowColor = "white", oe.shadowBlur = 2, oe.lineWidth = 1.5, oe.strokeStyle = "white", oe.textBaseline = "top", oe.font = "bold 36px Open Sans, sans-serif", oe.fillText(te, 5, 5), oe.strokeText(te, 5, 5), Y.debugOverlayTexture.update(le), Y.debugOverlayTexture.bind(J.LINEAR, J.CLAMP_TO_EDGE) }(m, `${X} ${z}kB`); const Q = m.transform.getProjectionData({ overscaledTileID: s, applyGlobeMatrix: !0, applyTerrainMatrix: !0 }); g.draw(l, d.TRIANGLES, v, T, or.alphaBlended, Nt.disabled, Vc(c.bp.transparent, U), null, Q, I, m.debugBuffer, m.quadTriangleIndexBuffer, m.debugSegments), g.draw(l, d.LINE_STRIP, v, T, E, Nt.disabled, Vc(c.bp.red), A, Q, I, m.debugBuffer, m.tileBorderIndexBuffer, m.debugSegments) } function rh(m, t, s, l) { const { isRenderingGlobe: d } = l, g = m.context, v = g.gl, T = m.transform, E = m.colorModeForRenderPass(), I = m.getDepthModeFor3D(), A = m.useProgram("terrain"); g.bindFramebuffer.set(null), g.viewport.set([0, 0, m.width, m.height]); for (const R of s) { const z = t.getTerrainMesh(R.tileID), O = m.renderToTexture.getTexture(R), U = t.getTerrainData(R.tileID); g.activeTexture.set(v.TEXTURE0), v.bindTexture(v.TEXTURE_2D, O.texture); const X = t.getMeshFrameDelta(T.zoom), Q = T.calculateFogMatrix(R.tileID.toUnwrapped()), Y = Vm(X, Q, m.style.sky, T.pitch, d), te = T.getProjectionData({ overscaledTileID: R.tileID, applyTerrainMatrix: !1, applyGlobeMatrix: !0 }); A.draw(g, v.TRIANGLES, I, jt.disabled, E, Nt.backCCW, Y, U, te, "terrain", z.vertexBuffer, z.indexBuffer, z.segments) } } function nh(m, t) { if (!t.mesh) { const s = new c.aW; s.emplaceBack(-1, -1), s.emplaceBack(1, -1), s.emplaceBack(1, 1), s.emplaceBack(-1, 1); const l = new c.aY; l.emplaceBack(0, 1, 2), l.emplaceBack(0, 2, 3), t.mesh = new sr(m.createVertexBuffer(s, ws.members), m.createIndexBuffer(l), c.aX.simpleSegment(0, 0, s.length, l.length)) } return t.mesh } class Ep {
                constructor(t, s) { this.context = new du(t), this.transform = s, this._tileTextures = {}, this.terrainFacilitator = { dirty: !0, matrix: c.ar(new Float64Array(16)), renderTime: 0 }, this.setup(), this.numSublayers = oi.maxOverzooming + oi.maxUnderzooming + 1, this.depthEpsilon = 1 / Math.pow(2, 16), this.crossTileSymbolIndex = new Vn } resize(t, s, l) { if (this.width = Math.floor(t * l), this.height = Math.floor(s * l), this.pixelRatio = l, this.context.viewport.set([0, 0, this.width, this.height]), this.style) for (const d of this.style._order) this.style._layers[d].resize() } setup() { const t = this.context, s = new c.aW; s.emplaceBack(0, 0), s.emplaceBack(c.a5, 0), s.emplaceBack(0, c.a5), s.emplaceBack(c.a5, c.a5), this.tileExtentBuffer = t.createVertexBuffer(s, ws.members), this.tileExtentSegments = c.aX.simpleSegment(0, 0, 4, 2); const l = new c.aW; l.emplaceBack(0, 0), l.emplaceBack(c.a5, 0), l.emplaceBack(0, c.a5), l.emplaceBack(c.a5, c.a5), this.debugBuffer = t.createVertexBuffer(l, ws.members), this.debugSegments = c.aX.simpleSegment(0, 0, 4, 5); const d = new c.ch; d.emplaceBack(0, 0, 0, 0), d.emplaceBack(c.a5, 0, c.a5, 0), d.emplaceBack(0, c.a5, 0, c.a5), d.emplaceBack(c.a5, c.a5, c.a5, c.a5), this.rasterBoundsBuffer = t.createVertexBuffer(d, jm.members), this.rasterBoundsSegments = c.aX.simpleSegment(0, 0, 4, 2); const g = new c.aW; g.emplaceBack(0, 0), g.emplaceBack(c.a5, 0), g.emplaceBack(0, c.a5), g.emplaceBack(c.a5, c.a5), this.rasterBoundsBufferPosOnly = t.createVertexBuffer(g, ws.members), this.rasterBoundsSegmentsPosOnly = c.aX.simpleSegment(0, 0, 4, 5); const v = new c.aW; v.emplaceBack(0, 0), v.emplaceBack(1, 0), v.emplaceBack(0, 1), v.emplaceBack(1, 1), this.viewportBuffer = t.createVertexBuffer(v, ws.members), this.viewportSegments = c.aX.simpleSegment(0, 0, 4, 2); const T = new c.ci; T.emplaceBack(0), T.emplaceBack(1), T.emplaceBack(3), T.emplaceBack(2), T.emplaceBack(0), this.tileBorderIndexBuffer = t.createIndexBuffer(T); const E = new c.aY; E.emplaceBack(1, 0, 2), E.emplaceBack(1, 2, 3), this.quadTriangleIndexBuffer = t.createIndexBuffer(E); const I = this.context.gl; this.stencilClearMode = new jt({ func: I.ALWAYS, mask: 0 }, 0, 255, I.ZERO, I.ZERO, I.ZERO), this.tileExtentMesh = new sr(this.tileExtentBuffer, this.quadTriangleIndexBuffer, this.tileExtentSegments) } clearStencil() { const t = this.context, s = t.gl; this.nextStencilID = 1, this.currentStencilSource = void 0; const l = c.N(); c.c7(l, 0, this.width, this.height, 0, 0, 1), c.Q(l, l, [s.drawingBufferWidth, s.drawingBufferHeight, 0]); const d = { mainMatrix: l, tileMercatorCoords: [0, 0, 1, 1], clippingPlane: [0, 0, 0, 0], projectionTransition: 0, fallbackMatrix: l }; this.useProgram("clippingMask", null, !0).draw(t, s.TRIANGLES, kt.disabled, this.stencilClearMode, or.disabled, Nt.disabled, null, null, d, "$clipping", this.viewportBuffer, this.quadTriangleIndexBuffer, this.viewportSegments) } _renderTileClippingMasks(t, s, l) { if (this.currentStencilSource === t.source || !t.isTileClipped() || !s || !s.length) return; this.currentStencilSource = t.source, this.nextStencilID + s.length > 256 && this.clearStencil(); const d = this.context; d.setColorMode(or.disabled), d.setDepthMode(kt.disabled); const g = {}; for (const v of s) g[v.key] = this.nextStencilID++; this._renderTileMasks(g, s, l, !0), this._renderTileMasks(g, s, l, !1), this._tileClippingMaskIDs = g } _renderTileMasks(t, s, l, d) { const g = this.context, v = g.gl, T = this.style.projection, E = this.transform, I = this.useProgram("clippingMask"); for (const A of s) { const R = t[A.key], z = this.style.map.terrain && this.style.map.terrain.getTerrainData(A), O = T.getMeshFromTileID(this.context, A.canonical, d, !0, "stencil"), U = E.getProjectionData({ overscaledTileID: A, applyGlobeMatrix: !l, applyTerrainMatrix: !0 }); I.draw(g, v.TRIANGLES, kt.disabled, new jt({ func: v.ALWAYS, mask: 0 }, R, 255, v.KEEP, v.KEEP, v.REPLACE), or.disabled, l ? Nt.disabled : Nt.backCCW, null, z, U, "$clipping", O.vertexBuffer, O.indexBuffer, O.segments) } } _renderTilesDepthBuffer() { const t = this.context, s = t.gl, l = this.style.projection, d = this.transform, g = this.useProgram("depth"), v = this.getDepthModeFor3D(), T = Mr(d, { tileSize: d.tileSize }); for (const E of T) { const I = this.style.map.terrain && this.style.map.terrain.getTerrainData(E), A = l.getMeshFromTileID(this.context, E.canonical, !0, !0, "raster"), R = d.getProjectionData({ overscaledTileID: E, applyGlobeMatrix: !0, applyTerrainMatrix: !0 }); g.draw(t, s.TRIANGLES, v, jt.disabled, or.disabled, Nt.backCCW, null, I, R, "$clipping", A.vertexBuffer, A.indexBuffer, A.segments) } } stencilModeFor3D() { this.currentStencilSource = void 0, this.nextStencilID + 1 > 256 && this.clearStencil(); const t = this.nextStencilID++, s = this.context.gl; return new jt({ func: s.NOTEQUAL, mask: 255 }, t, 255, s.KEEP, s.KEEP, s.REPLACE) } stencilModeForClipping(t) { const s = this.context.gl; return new jt({ func: s.EQUAL, mask: 255 }, this._tileClippingMaskIDs[t.key], 0, s.KEEP, s.KEEP, s.REPLACE) } getStencilConfigForOverlapAndUpdateStencilID(t) { const s = this.context.gl, l = t.sort((v, T) => T.overscaledZ - v.overscaledZ), d = l[l.length - 1].overscaledZ, g = l[0].overscaledZ - d + 1; if (g > 1) { this.currentStencilSource = void 0, this.nextStencilID + g > 256 && this.clearStencil(); const v = {}; for (let T = 0; T < g; T++)v[T + d] = new jt({ func: s.GEQUAL, mask: 255 }, T + this.nextStencilID, 255, s.KEEP, s.KEEP, s.REPLACE); return this.nextStencilID += g, [v, l] } return [{ [d]: jt.disabled }, l] } stencilConfigForOverlapTwoPass(t) { const s = this.context.gl, l = t.sort((v, T) => T.overscaledZ - v.overscaledZ), d = l[l.length - 1].overscaledZ, g = l[0].overscaledZ - d + 1; if (this.clearStencil(), g > 1) { const v = {}, T = {}; for (let E = 0; E < g; E++)v[E + d] = new jt({ func: s.GREATER, mask: 255 }, g + 1 + E, 255, s.KEEP, s.KEEP, s.REPLACE), T[E + d] = new jt({ func: s.GREATER, mask: 255 }, 1 + E, 255, s.KEEP, s.KEEP, s.REPLACE); return this.nextStencilID = 2 * g + 1, [v, T, l] } return this.nextStencilID = 3, [{ [d]: new jt({ func: s.GREATER, mask: 255 }, 2, 255, s.KEEP, s.KEEP, s.REPLACE) }, { [d]: new jt({ func: s.GREATER, mask: 255 }, 1, 255, s.KEEP, s.KEEP, s.REPLACE) }, l] } colorModeForRenderPass() { const t = this.context.gl; return this._showOverdrawInspector ? new or([t.CONSTANT_COLOR, t.ONE], new c.bp(.125, .125, .125, 0), [!0, !0, !0, !0]) : this.renderPass === "opaque" ? or.unblended : or.alphaBlended } getDepthModeForSublayer(t, s, l) { if (!this.opaquePassEnabledForLayer()) return kt.disabled; const d = 1 - ((1 + this.currentLayer) * this.numSublayers + t) * this.depthEpsilon; return new kt(l || this.context.gl.LEQUAL, s, [d, d]) } getDepthModeFor3D() { return new kt(this.context.gl.LEQUAL, kt.ReadWrite, this.depthRangeFor3D) } opaquePassEnabledForLayer() { return this.currentLayer < this.opaquePassCutoff } render(t, s) { var l, d; this.style = t, this.options = s, this.lineAtlas = t.lineAtlas, this.imageManager = t.imageManager, this.glyphManager = t.glyphManager, this.symbolFadeChange = t.placement.symbolFadeChange($e()), this.imageManager.beginFrame(); const g = this.style._order, v = this.style.tileManagers, T = {}, E = {}, I = {}, A = { isRenderingToTexture: !1, isRenderingGlobe: ((l = t.projection) === null || l === void 0 ? void 0 : l.transitionState) > 0 }; for (const z in v) { const O = v[z]; O.used && O.prepare(this.context), T[z] = O.getVisibleCoordinates(!1), E[z] = T[z].slice().reverse(), I[z] = O.getVisibleCoordinates(!0).reverse() } this.opaquePassCutoff = 1 / 0; for (let z = 0; z < g.length; z++)if (this.style._layers[g[z]].is3D()) { this.opaquePassCutoff = z; break } this.maybeDrawDepthAndCoords(!1), this.renderToTexture && (this.renderToTexture.prepareForRender(this.style, this.transform.zoom), this.opaquePassCutoff = 0), this.renderPass = "offscreen"; for (const z of g) { const O = this.style._layers[z]; if (!O.hasOffscreenPass() || O.isHidden(this.transform.zoom)) continue; const U = E[O.source]; (O.type === "custom" || U.length) && this.renderLayer(this, v[O.source], O, U, A) } if ((d = this.style.projection) === null || d === void 0 || d.updateGPUdependent({ context: this.context, useProgram: z => this.useProgram(z) }), this.context.viewport.set([0, 0, this.width, this.height]), this.context.bindFramebuffer.set(null), this.context.clear({ color: s.showOverdrawInspector ? c.bp.black : c.bp.transparent, depth: 1 }), this.clearStencil(), this.style.sky && function (z, O) { const U = z.context, X = U.gl, Q = ((ce, se, fe) => { const Oe = Math.cos(se.rollInRadians), ke = Math.sin(se.rollInRadians), ze = tr(se), Re = se.getProjectionData({ overscaledTileID: null, applyGlobeMatrix: !0, applyTerrainMatrix: !0 }).projectionTransition; return { u_sky_color: ce.properties.get("sky-color"), u_horizon_color: ce.properties.get("horizon-color"), u_horizon: [(se.width / 2 - ze * ke) * fe, (se.height / 2 + ze * Oe) * fe], u_horizon_normal: [-ke, Oe], u_sky_horizon_blend: ce.properties.get("sky-horizon-blend") * se.height / 2 * fe, u_sky_blend: Re } })(O, z.style.map.transform, z.pixelRatio), Y = new kt(X.LEQUAL, kt.ReadWrite, [0, 1]), te = jt.disabled, le = z.colorModeForRenderPass(), J = z.useProgram("sky"), oe = nh(U, O); J.draw(U, X.TRIANGLES, Y, te, le, Nt.disabled, Q, null, void 0, "sky", oe.vertexBuffer, oe.indexBuffer, oe.segments) }(this, this.style.sky), this._showOverdrawInspector = s.showOverdrawInspector, this.depthRangeFor3D = [0, 1 - (t._order.length + 2) * this.numSublayers * this.depthEpsilon], !this.renderToTexture) for (this.renderPass = "opaque", this.currentLayer = g.length - 1; this.currentLayer >= 0; this.currentLayer--) { const z = this.style._layers[g[this.currentLayer]], O = v[z.source], U = T[z.source]; this._renderTileClippingMasks(z, U, !1), this.renderLayer(this, O, z, U, A) } this.renderPass = "translucent"; let R = !1; for (this.currentLayer = 0; this.currentLayer < g.length; this.currentLayer++) { const z = this.style._layers[g[this.currentLayer]], O = v[z.source]; if (this.renderToTexture && this.renderToTexture.renderLayer(z, A)) continue; this.opaquePassEnabledForLayer() || R || (R = !0, A.isRenderingGlobe && !this.style.map.terrain && this._renderTilesDepthBuffer()); const U = (z.type === "symbol" ? I : E)[z.source]; this._renderTileClippingMasks(z, T[z.source], !!this.renderToTexture), this.renderLayer(this, O, z, U, A) } if (A.isRenderingGlobe && function (z, O, U) { const X = z.context, Q = X.gl, Y = z.useProgram("atmosphere"), te = new kt(Q.LEQUAL, kt.ReadOnly, [0, 1]), le = z.transform, J = function (Re, Je) { const tt = Re.properties.get("position"), We = [-tt.x, -tt.y, -tt.z], it = c.ar(new Float64Array(16)); return Re.properties.get("anchor") === "map" && (c.bg(it, it, Je.rollInRadians), c.bh(it, it, -Je.pitchInRadians), c.bg(it, it, Je.bearingInRadians), c.bh(it, it, Je.center.lat * Math.PI / 180), c.bJ(it, it, -Je.center.lng * Math.PI / 180)), c.cg(We, We, it), We }(U, z.transform), oe = le.getProjectionData({ overscaledTileID: null, applyGlobeMatrix: !0, applyTerrainMatrix: !0 }), ce = O.properties.get("atmosphere-blend") * oe.projectionTransition; if (ce === 0) return; const se = Hs(le.worldSize, le.center.lat), fe = le.inverseProjectionMatrix, Oe = new Float64Array(4); Oe[3] = 1, c.aH(Oe, Oe, le.modelViewProjectionMatrix), Oe[0] /= Oe[3], Oe[1] /= Oe[3], Oe[2] /= Oe[3], Oe[3] = 1, c.aH(Oe, Oe, fe), Oe[0] /= Oe[3], Oe[1] /= Oe[3], Oe[2] /= Oe[3], Oe[3] = 1; const ke = ((Re, Je, tt, We, it) => ({ u_sun_pos: Re, u_atmosphere_blend: Je, u_globe_position: tt, u_globe_radius: We, u_inv_proj_matrix: it }))(J, ce, [Oe[0], Oe[1], Oe[2]], se, fe), ze = nh(X, O); Y.draw(X, Q.TRIANGLES, te, jt.disabled, or.alphaBlended, Nt.disabled, ke, null, null, "atmosphere", ze.vertexBuffer, ze.indexBuffer, ze.segments) }(this, this.style.sky, this.style.light), this.options.showTileBoundaries) { const z = function (O, U) { let X = null; const Q = Object.values(O._layers).flatMap(J => J.source && !J.isHidden(U) ? [O.tileManagers[J.source]] : []), Y = Q.filter(J => J.getSource().type === "vector"), te = Q.filter(J => J.getSource().type !== "vector"), le = J => { (!X || X.getSource().maxzoom < J.getSource().maxzoom) && (X = J) }; return Y.forEach(J => le(J)), X || te.forEach(J => le(J)), X }(this.style, this.transform.zoom); z && function (O, U, X) { for (let Q = 0; Q < X.length; Q++)Sp(O, U, X[Q]) }(this, z, z.getVisibleCoordinates()) } this.options.showPadding && function (z) { const O = z.transform.padding; eh(z, z.transform.height - (O.top || 0), 3, xp), eh(z, O.bottom || 0, 3, wp), th(z, O.left || 0, 3, bp), th(z, z.transform.width - (O.right || 0), 3, Tp); const U = z.transform.centerPoint; (function (X, Q, Y, te) { Ja(X, Q - 1, Y - 10, 2, 20, te), Ja(X, Q - 10, Y - 1, 20, 2, te) })(z, U.x, z.transform.height - U.y, Ps) }(this), this.context.setDefault() } maybeDrawDepthAndCoords(t) { if (!this.style || !this.style.map || !this.style.map.terrain) return; const s = this.terrainFacilitator.matrix, l = this.transform.modelViewProjectionMatrix; let d = this.terrainFacilitator.dirty; d || (d = t ? !c.cj(s, l) : !c.ck(s, l)), d || (d = this.style.map.terrain.tileManager.anyTilesAfterTime(this.terrainFacilitator.renderTime)), d && (c.cl(s, l), this.terrainFacilitator.renderTime = Date.now(), this.terrainFacilitator.dirty = !1, function (g, v) { const T = g.context, E = T.gl, I = g.transform, A = or.unblended, R = new kt(E.LEQUAL, kt.ReadWrite, [0, 1]), z = v.tileManager.getRenderableTiles(), O = g.useProgram("terrainDepth"); T.bindFramebuffer.set(v.getFramebuffer("depth").framebuffer), T.viewport.set([0, 0, g.width / devicePixelRatio, g.height / devicePixelRatio]), T.clear({ color: c.bp.transparent, depth: 1 }); for (const U of z) { const X = v.getTerrainMesh(U.tileID), Q = v.getTerrainData(U.tileID), Y = I.getProjectionData({ overscaledTileID: U.tileID, applyTerrainMatrix: !1, applyGlobeMatrix: !0 }), te = { u_ele_delta: v.getMeshFrameDelta(I.zoom) }; O.draw(T, E.TRIANGLES, R, jt.disabled, A, Nt.backCCW, te, Q, Y, "terrain", X.vertexBuffer, X.indexBuffer, X.segments) } T.bindFramebuffer.set(null), T.viewport.set([0, 0, g.width, g.height]) }(this, this.style.map.terrain), function (g, v) { const T = g.context, E = T.gl, I = g.transform, A = or.unblended, R = new kt(E.LEQUAL, kt.ReadWrite, [0, 1]), z = v.getCoordsTexture(), O = v.tileManager.getRenderableTiles(), U = g.useProgram("terrainCoords"); T.bindFramebuffer.set(v.getFramebuffer("coords").framebuffer), T.viewport.set([0, 0, g.width / devicePixelRatio, g.height / devicePixelRatio]), T.clear({ color: c.bp.transparent, depth: 1 }), v.coordsIndex = []; for (const X of O) { const Q = v.getTerrainMesh(X.tileID), Y = v.getTerrainData(X.tileID); T.activeTexture.set(E.TEXTURE0), E.bindTexture(E.TEXTURE_2D, z.texture); const te = { u_terrain_coords_id: (255 - v.coordsIndex.length) / 255, u_texture: 0, u_ele_delta: v.getMeshFrameDelta(I.zoom) }, le = I.getProjectionData({ overscaledTileID: X.tileID, applyTerrainMatrix: !1, applyGlobeMatrix: !0 }); U.draw(T, E.TRIANGLES, R, jt.disabled, A, Nt.backCCW, te, Y, le, "terrain", Q.vertexBuffer, Q.indexBuffer, Q.segments), v.coordsIndex.push(X.tileID.key) } T.bindFramebuffer.set(null), T.viewport.set([0, 0, g.width, g.height]) }(this, this.style.map.terrain)) } renderLayer(t, s, l, d, g) {
                    l.isHidden(this.transform.zoom) || (l.type === "background" || l.type === "custom" || (d || []).length) && (this.id = l.id, c.cm(l) ? function (v, T, E, I, A, R) { if (v.renderPass !== "translucent") return; const { isRenderingToTexture: z } = R, O = jt.disabled, U = v.colorModeForRenderPass(); (E._unevaluatedLayout.hasValue("text-variable-anchor") || E._unevaluatedLayout.hasValue("text-variable-anchor-offset")) && function (X, Q, Y, te, le, J, oe, ce, se) { const fe = Q.transform, Oe = Q.style.map.terrain, ke = le === "map", ze = J === "map"; for (const Re of X) { const Je = te.getTile(Re), tt = Je.getBucket(Y); if (!tt || !tt.text || !tt.text.segments.get().length) continue; const We = c.ay(tt.textSizeData, fe.zoom), it = c.aN(Je, 1, Q.transform.zoom), It = Yn(ke, Q.transform, it), Kt = Y.layout.get("icon-text-fit") !== "none" && tt.hasIconData(); if (We) { const fr = Math.pow(2, fe.zoom - Je.tileID.overscaledZ), ar = Oe ? (yr, lr) => Oe.getElevation(Re, yr, lr) : null; Jm(tt, ke, ze, se, fe, It, fr, We, Kt, c.aO(fe, Je, oe, ce), Re.toUnwrapped(), ar) } } }(I, v, E, T, E.layout.get("text-rotation-alignment"), E.layout.get("text-pitch-alignment"), E.paint.get("text-translate"), E.paint.get("text-translate-anchor"), A), E.paint.get("icon-opacity").constantOr(1) !== 0 && Xa(v, T, E, I, !1, E.paint.get("icon-translate"), E.paint.get("icon-translate-anchor"), E.layout.get("icon-rotation-alignment"), E.layout.get("icon-pitch-alignment"), E.layout.get("icon-keep-upright"), O, U, z), E.paint.get("text-opacity").constantOr(1) !== 0 && Xa(v, T, E, I, !0, E.paint.get("text-translate"), E.paint.get("text-translate-anchor"), E.layout.get("text-rotation-alignment"), E.layout.get("text-pitch-alignment"), E.layout.get("text-keep-upright"), O, U, z), T.map.showCollisionBoxes && (eo(v, T, E, I, !0), eo(v, T, E, I, !1)) }(t, s, l, d, this.style.placement.variableOffsets, g) : c.cn(l) ? function (v, T, E, I, A) { if (v.renderPass !== "translucent") return; const { isRenderingToTexture: R } = A, z = E.paint.get("circle-opacity"), O = E.paint.get("circle-stroke-width"), U = E.paint.get("circle-stroke-opacity"), X = !E.layout.get("circle-sort-key").isConstant(); if (z.constantOr(1) === 0 && (O.constantOr(1) === 0 || U.constantOr(1) === 0)) return; const Q = v.context, Y = Q.gl, te = v.transform, le = v.getDepthModeForSublayer(0, kt.ReadOnly), J = jt.disabled, oe = v.colorModeForRenderPass(), ce = [], se = te.getCircleRadiusCorrection(); for (let fe = 0; fe < I.length; fe++) { const Oe = I[fe], ke = T.getTile(Oe), ze = ke.getBucket(E); if (!ze) continue; const Re = E.paint.get("circle-translate"), Je = E.paint.get("circle-translate-anchor"), tt = c.aO(te, ke, Re, Je), We = ze.programConfigurations.get(E.id), it = v.useProgram("circle", We), It = ze.layoutVertexBuffer, Kt = ze.indexBuffer, fr = v.style.map.terrain && v.style.map.terrain.getTerrainData(Oe), ar = { programConfiguration: We, program: it, layoutVertexBuffer: It, indexBuffer: Kt, uniformValues: ep(v, ke, E, tt, se), terrainData: fr, projectionData: te.getProjectionData({ overscaledTileID: Oe, applyGlobeMatrix: !R, applyTerrainMatrix: !0 }) }; if (X) { const yr = ze.segments.get(); for (const lr of yr) ce.push({ segments: new c.aX([lr]), sortKey: lr.sortKey, state: ar }) } else ce.push({ segments: ze.segments, sortKey: 0, state: ar }) } X && ce.sort((fe, Oe) => fe.sortKey - Oe.sortKey); for (const fe of ce) { const { programConfiguration: Oe, program: ke, layoutVertexBuffer: ze, indexBuffer: Re, uniformValues: Je, terrainData: tt, projectionData: We } = fe.state; ke.draw(Q, Y.TRIANGLES, le, J, oe, Nt.backCCW, Je, tt, We, E.id, ze, Re, fe.segments, E.paint, v.transform.zoom, Oe) } }(t, s, l, d, g) : c.co(l) ? function (v, T, E, I, A) { if (E.paint.get("heatmap-opacity") === 0) return; const R = v.context, { isRenderingToTexture: z, isRenderingGlobe: O } = A; if (v.style.map.terrain) { for (const U of I) { const X = T.getTile(U); T.hasRenderableParent(U) || (v.renderPass === "offscreen" ? mp(v, X, E, U, O) : v.renderPass === "translucent" && gp(v, E, U, z, O)) } R.viewport.set([0, 0, v.width, v.height]) } else v.renderPass === "offscreen" ? function (U, X, Q, Y) { const te = U.context, le = te.gl, J = U.transform, oe = jt.disabled, ce = new or([le.ONE, le.ONE], c.bp.transparent, [!0, !0, !0, !0]); (function (se, fe, Oe) { const ke = se.gl; se.activeTexture.set(ke.TEXTURE1), se.viewport.set([0, 0, fe.width / 4, fe.height / 4]); let ze = Oe.heatmapFbos.get(c.cd); ze ? (ke.bindTexture(ke.TEXTURE_2D, ze.colorAttachment.get()), se.bindFramebuffer.set(ze.framebuffer)) : (ze = Ya(se, fe.width / 4, fe.height / 4), Oe.heatmapFbos.set(c.cd, ze)) })(te, U, Q), te.clear({ color: c.bp.transparent }); for (let se = 0; se < Y.length; se++) { const fe = Y[se]; if (X.hasRenderableParent(fe)) continue; const Oe = X.getTile(fe), ke = Oe.getBucket(Q); if (!ke) continue; const ze = ke.programConfigurations.get(Q.id), Re = U.useProgram("heatmap", ze), Je = J.getProjectionData({ overscaledTileID: fe, applyGlobeMatrix: !0, applyTerrainMatrix: !1 }), tt = J.getCircleRadiusCorrection(); Re.draw(te, le.TRIANGLES, kt.disabled, oe, ce, Nt.backCCW, $o(Oe, J.zoom, Q.paint.get("heatmap-intensity"), tt), null, Je, Q.id, ke.layoutVertexBuffer, ke.indexBuffer, ke.segments, Q.paint, J.zoom, ze) } te.viewport.set([0, 0, U.width, U.height]) }(v, T, E, I) : v.renderPass === "translucent" && function (U, X) { const Q = U.context, Y = Q.gl; Q.setColorMode(U.colorModeForRenderPass()); const te = X.heatmapFbos.get(c.cd); te && (Q.activeTexture.set(Y.TEXTURE0), Y.bindTexture(Y.TEXTURE_2D, te.colorAttachment.get()), Q.activeTexture.set(Y.TEXTURE1), fu(Q, X).bind(Y.LINEAR, Y.CLAMP_TO_EDGE), U.useProgram("heatmapTexture").draw(Q, Y.TRIANGLES, kt.disabled, jt.disabled, U.colorModeForRenderPass(), Nt.disabled, rp(U, X, 0, 1), null, null, X.id, U.viewportBuffer, U.quadTriangleIndexBuffer, U.viewportSegments, X.paint, U.transform.zoom)) }(v, E) }(t, s, l, d, g) : c.cp(l) ? function (v, T, E, I, A) { if (v.renderPass !== "translucent") return; const { isRenderingToTexture: R } = A, z = E.paint.get("line-opacity"), O = E.paint.get("line-width"); if (z.constantOr(1) === 0 || O.constantOr(1) === 0) return; const U = v.getDepthModeForSublayer(0, kt.ReadOnly), X = v.colorModeForRenderPass(), Q = E.paint.get("line-dasharray"), Y = Q.constantOr(1), te = E.paint.get("line-pattern"), le = te.constantOr(1), J = E.paint.get("line-gradient"), oe = E.getCrossfadeParameters(); let ce; ce = le ? "linePattern" : Y && J ? "lineGradientSDF" : Y ? "lineSDF" : J ? "lineGradient" : "line"; const se = v.context, fe = se.gl, Oe = v.transform; let ke = !0; for (const ze of I) { const Re = T.getTile(ze); if (le && !Re.patternsLoaded()) continue; const Je = Re.getBucket(E); if (!Je) continue; const tt = Je.programConfigurations.get(E.id), We = v.context.program.get(), it = v.useProgram(ce, tt), It = ke || it.program !== We, Kt = v.style.map.terrain && v.style.map.terrain.getTerrainData(ze), fr = te.constantOr(null), ar = Q && Q.constantOr(null); if (fr && Re.imageAtlas) { const sn = Re.imageAtlas, Vr = sn.patternPositions[fr.to.toString()], Or = sn.patternPositions[fr.from.toString()]; Vr && Or && tt.setConstantPatternPositions(Vr, Or) } else if (ar) { const sn = E.layout.get("line-cap") === "round", Vr = v.lineAtlas.getDash(ar.to, sn), Or = v.lineAtlas.getDash(ar.from, sn); tt.setConstantDashPositions(Vr, Or) } const yr = Oe.getProjectionData({ overscaledTileID: ze, applyGlobeMatrix: !R, applyTerrainMatrix: !0 }), lr = Oe.getPixelScale(); let Ar; le ? (Ar = Uc(v, Re, E, lr, oe), yp(se, fe, Re, tt, oe)) : Y && J ? (Ar = eu(v, Re, E, lr, oe, Je.lineClipsArray.length), Qn(v, T, se, fe, E, Je, ze, tt, oe)) : Y ? (Ar = sp(v, Re, E, lr, oe), Fr(v, se, fe, tt, It, oe)) : J ? (Ar = ip(v, Re, E, lr, Je.lineClipsArray.length), to(v, T, se, fe, E, Je, ze)) : Ar = Ga(v, Re, E, lr); const vr = v.stencilModeForClipping(ze); it.draw(se, fe.TRIANGLES, U, vr, X, Nt.disabled, Ar, Kt, yr, E.id, Je.layoutVertexBuffer, Je.indexBuffer, Je.segments, E.paint, v.transform.zoom, tt, Je.layoutVertexBuffer2), ke = !1 } }(t, s, l, d, g) : c.cq(l) ? function (v, T, E, I, A) { const R = E.paint.get("fill-color"), z = E.paint.get("fill-opacity"); if (z.constantOr(1) === 0) return; const { isRenderingToTexture: O } = A, U = v.colorModeForRenderPass(), X = E.paint.get("fill-pattern"), Q = v.opaquePassEnabledForLayer() && !X.constantOr(1) && R.constantOr(c.bp.transparent).a === 1 && z.constantOr(0) === 1 ? "opaque" : "translucent"; if (v.renderPass === Q) { const Y = v.getDepthModeForSublayer(1, v.renderPass === "opaque" ? kt.ReadWrite : kt.ReadOnly); Ka(v, T, E, I, Y, U, !1, O) } if (v.renderPass === "translucent" && E.paint.get("fill-antialias")) { const Y = v.getDepthModeForSublayer(E.getPaintProperty("fill-outline-color") ? 2 : 0, kt.ReadOnly); Ka(v, T, E, I, Y, U, !0, O) } }(t, s, l, d, g) : c.cr(l) ? function (v, T, E, I, A) { const R = E.paint.get("fill-extrusion-opacity"); if (R === 0) return; const { isRenderingToTexture: z } = A; if (v.renderPass === "translucent") { const O = new kt(v.context.gl.LEQUAL, kt.ReadWrite, v.depthRangeFor3D); if (R !== 1 || E.paint.get("fill-extrusion-pattern").constantOr(1)) gu(v, T, E, I, O, jt.disabled, or.disabled, z), gu(v, T, E, I, O, v.stencilModeFor3D(), v.colorModeForRenderPass(), z); else { const U = v.colorModeForRenderPass(); gu(v, T, E, I, O, jt.disabled, U, z) } } }(t, s, l, d, g) : c.cs(l) ? function (v, T, E, I, A) { if (v.renderPass !== "offscreen" && v.renderPass !== "translucent") return; const { isRenderingToTexture: R } = A, z = v.context, O = v.style.projection.useSubdivision, U = v.getDepthModeForSublayer(0, kt.ReadOnly), X = v.colorModeForRenderPass(); if (v.renderPass === "offscreen") (function (Q, Y, te, le, J, oe, ce) { const se = Q.context, fe = se.gl; for (const Oe of te) { const ke = Y.getTile(Oe), ze = ke.dem; if (!ze || !ze.data || !ke.needsHillshadePrepare) continue; const Re = ze.dim, Je = ze.stride, tt = ze.getPixels(); if (se.activeTexture.set(fe.TEXTURE1), se.pixelStoreUnpackPremultiplyAlpha.set(!1), ke.demTexture = ke.demTexture || Q.getTileTexture(Je), ke.demTexture) { const it = ke.demTexture; it.update(tt, { premultiply: !1 }), it.bind(fe.NEAREST, fe.CLAMP_TO_EDGE) } else ke.demTexture = new c.T(se, tt, fe.RGBA, { premultiply: !1 }), ke.demTexture.bind(fe.NEAREST, fe.CLAMP_TO_EDGE); se.activeTexture.set(fe.TEXTURE0); let We = ke.fbo; if (!We) { const it = new c.T(se, { width: Re, height: Re, data: null }, fe.RGBA); it.bind(fe.LINEAR, fe.CLAMP_TO_EDGE), We = ke.fbo = se.createFramebuffer(Re, Re, !0, !1), We.colorAttachment.set(it.texture) } se.bindFramebuffer.set(We.framebuffer), se.viewport.set([0, 0, Re, Re]), Q.useProgram("hillshadePrepare").draw(se, fe.TRIANGLES, J, oe, ce, Nt.disabled, Um(ke.tileID, ze), null, null, le.id, Q.rasterBoundsBuffer, Q.quadTriangleIndexBuffer, Q.rasterBoundsSegments), ke.needsHillshadePrepare = !1 } })(v, T, I, E, U, jt.disabled, X), z.viewport.set([0, 0, v.width, v.height]); else if (v.renderPass === "translucent") if (O) { const [Q, Y, te] = v.stencilConfigForOverlapTwoPass(I); Es(v, T, E, te, Q, U, X, !1, R), Es(v, T, E, te, Y, U, X, !0, R) } else { const [Q, Y] = v.getStencilConfigForOverlapAndUpdateStencilID(I); Es(v, T, E, Y, Q, U, X, !1, R) } }(t, s, l, d, g) : c.ct(l) ? function (v, T, E, I, A) { if (v.renderPass !== "translucent" || !I.length) return; const { isRenderingToTexture: R } = A, z = v.style.projection.useSubdivision, O = v.getDepthModeForSublayer(0, kt.ReadOnly), U = v.colorModeForRenderPass(); if (z) { const [X, Q, Y] = v.stencilConfigForOverlapTwoPass(I); Qa(v, T, E, Y, X, O, U, !1, R), Qa(v, T, E, Y, Q, O, U, !0, R) } else { const [X, Q] = v.getStencilConfigForOverlapAndUpdateStencilID(I); Qa(v, T, E, Q, X, O, U, !1, R) } }(t, s, l, d, g) : c.bU(l) ? function (v, T, E, I, A) { if (v.renderPass !== "translucent" || E.paint.get("raster-opacity") === 0 || !I.length) return; const { isRenderingToTexture: R } = A, z = T.getSource(), O = v.style.projection.useSubdivision; if (z instanceof jn) Xo(v, T, E, I, null, !1, !1, z.tileCoords, z.flippedWindingOrder, R); else if (O) { const [U, X, Q] = v.stencilConfigForOverlapTwoPass(I); Xo(v, T, E, Q, U, !1, !0, ro, !1, R), Xo(v, T, E, Q, X, !0, !0, ro, !1, R) } else { const [U, X] = v.getStencilConfigForOverlapAndUpdateStencilID(I); Xo(v, T, E, X, U, !1, !0, ro, !1, R) } }(t, s, l, d, g) : c.cu(l) ? function (v, T, E, I, A) { const R = E.paint.get("background-color"), z = E.paint.get("background-opacity"); if (z === 0) return; const { isRenderingToTexture: O } = A, U = v.context, X = U.gl, Q = v.style.projection, Y = v.transform, te = Y.tileSize, le = E.paint.get("background-pattern"); if (v.isPatternMissing(le)) return; const J = !le && R.a === 1 && z === 1 && v.opaquePassEnabledForLayer() ? "opaque" : "translucent"; if (v.renderPass !== J) return; const oe = jt.disabled, ce = v.getDepthModeForSublayer(0, J === "opaque" ? kt.ReadWrite : kt.ReadOnly), se = v.colorModeForRenderPass(), fe = v.useProgram(le ? "backgroundPattern" : "background"), Oe = I || Mr(Y, { tileSize: te, terrain: v.style.map.terrain }); le && (U.activeTexture.set(X.TEXTURE0), v.imageManager.bind(v.context)); const ke = E.getCrossfadeParameters(); for (const ze of Oe) { const Re = Y.getProjectionData({ overscaledTileID: ze, applyGlobeMatrix: !O, applyTerrainMatrix: !0 }), Je = le ? $m(z, v, le, { tileID: ze, tileSize: te }, ke) : Zc(z, R), tt = v.style.map.terrain && v.style.map.terrain.getTerrainData(ze), We = Q.getMeshFromTileID(U, ze.canonical, !1, !0, "raster"); fe.draw(U, X.TRIANGLES, ce, oe, se, Nt.backCCW, Je, tt, Re, E.id, We.vertexBuffer, We.indexBuffer, We.segments) } }(t, 0, l, d, g) : c.cv(l) && function (v, T, E, I) {
                        const { isRenderingGlobe: A } = I, R = v.context, z = E.implementation, O = v.style.projection, U = v.transform, X = U.getProjectionDataForCustomLayer(A), Q = {
                            farZ: U.farZ, nearZ: U.nearZ, fov: U.fov * Math.PI / 180, modelViewProjectionMatrix: U.modelViewProjectionMatrix, projectionMatrix: U.projectionMatrix, shaderData: {
                                variantName: O.shaderVariantName, vertexShaderPrelude: `const float PI = 3.141592653589793;
uniform mat4 u_projection_matrix;
${O.shaderPreludeCode.vertexSource}`, define: O.shaderDefine
                            }, defaultProjectionData: X
                        }, Y = z.renderingMode ? z.renderingMode : "2d"; if (v.renderPass === "offscreen") { const te = z.prerender; te && (v.setCustomLayerDefaults(), R.setColorMode(v.colorModeForRenderPass()), te.call(z, R.gl, Q), R.setDirty(), v.setBaseState()) } else if (v.renderPass === "translucent") { v.setCustomLayerDefaults(), R.setColorMode(v.colorModeForRenderPass()), R.setStencilMode(jt.disabled); const te = Y === "3d" ? v.getDepthModeFor3D() : v.getDepthModeForSublayer(0, kt.ReadOnly); R.setDepthMode(te), z.render(R.gl, Q), R.setDirty(), v.setBaseState(), R.bindFramebuffer.set(null) }
                    }(t, 0, l, g))
                } saveTileTexture(t) { const s = this._tileTextures[t.size[0]]; s ? s.push(t) : this._tileTextures[t.size[0]] = [t] } getTileTexture(t) { const s = this._tileTextures[t]; return s && s.length > 0 ? s.pop() : null } isPatternMissing(t) { if (!t) return !1; if (!t.from || !t.to) return !0; const s = this.imageManager.getPattern(t.from.toString()), l = this.imageManager.getPattern(t.to.toString()); return !s || !l } useProgram(t, s, l = !1, d = []) { this.cache = this.cache || {}; const g = !!this.style.map.terrain, v = this.style.projection, T = l ? br.projectionMercator : v.shaderPreludeCode, E = l ? Dn : v.shaderDefine, I = t + (s ? s.cacheKey : "") + `/${l ? Kn : v.shaderVariantName}` + (this._showOverdrawInspector ? "/overdraw" : "") + (g ? "/terrain" : "") + (d ? `/${d.join("/")}` : ""); return this.cache[I] || (this.cache[I] = new Yd(this.context, br[t], s, qm[t], this._showOverdrawInspector, g, T, E, d)), this.cache[I] } setCustomLayerDefaults() { this.context.unbindVAO(), this.context.cullFace.setDefault(), this.context.activeTexture.setDefault(), this.context.pixelStoreUnpack.setDefault(), this.context.pixelStoreUnpackPremultiplyAlpha.setDefault(), this.context.pixelStoreUnpackFlipY.setDefault() } setBaseState() { const t = this.context.gl; this.context.cullFace.set(!1), this.context.viewport.set([0, 0, this.width, this.height]), this.context.blendEquation.set(t.FUNC_ADD) } initDebugOverlayCanvas() { this.debugOverlayCanvas == null && (this.debugOverlayCanvas = document.createElement("canvas"), this.debugOverlayCanvas.width = 512, this.debugOverlayCanvas.height = 512, this.debugOverlayTexture = new c.T(this.context, this.debugOverlayCanvas, this.context.gl.RGBA)) } destroy() { var t, s; if (this._tileTextures) { for (const l in this._tileTextures) { const d = this._tileTextures[l]; if (d) for (const g of d) g.destroy() } this._tileTextures = {} } if (this.tileExtentBuffer && this.tileExtentBuffer.destroy(), this.debugBuffer && this.debugBuffer.destroy(), this.rasterBoundsBuffer && this.rasterBoundsBuffer.destroy(), this.rasterBoundsBufferPosOnly && this.rasterBoundsBufferPosOnly.destroy(), this.viewportBuffer && this.viewportBuffer.destroy(), this.tileBorderIndexBuffer && this.tileBorderIndexBuffer.destroy(), this.quadTriangleIndexBuffer && this.quadTriangleIndexBuffer.destroy(), this.tileExtentMesh && ((t = this.tileExtentMesh.vertexBuffer) === null || t === void 0 || t.destroy()), this.tileExtentMesh && ((s = this.tileExtentMesh.indexBuffer) === null || s === void 0 || s.destroy()), this.debugOverlayTexture && this.debugOverlayTexture.destroy(), this.cache) { for (const l in this.cache) { const d = this.cache[l]; d && d.program && this.context.gl.deleteProgram(d.program) } this.cache = {} } this.context && this.context.setDefault() } overLimit() { const { drawingBufferWidth: t, drawingBufferHeight: s } = this.context.gl; return this.width !== t || this.height !== s }
            } function ih(m, t) { let s, l = !1, d = null, g = null; const v = () => { d = null, l && (m.apply(g, s), d = setTimeout(v, t), l = !1) }; return (...T) => (l = !0, g = this, s = T, d || v(), d) } class sh { constructor(t) { this._getCurrentHash = () => { const s = window.location.hash.replace("#", ""); if (this._hashName) { let l; return s.split("&").map(d => d.split("=")).forEach(d => { d[0] === this._hashName && (l = d) }), (l && l[1] || "").split("/") } return s.split("/") }, this._onHashChange = () => { const s = this._getCurrentHash(); if (!this._isValidHash(s)) return !1; const l = this._map.dragRotate.isEnabled() && this._map.touchZoomRotate.isEnabled() ? +(s[3] || 0) : this._map.getBearing(); return this._map.jumpTo({ center: [+s[2], +s[1]], zoom: +s[0], bearing: l, pitch: +(s[4] || 0) }), !0 }, this._updateHashUnthrottled = () => { const s = window.location.href.replace(/(#.*)?$/, this.getHashString()); window.history.replaceState(window.history.state, null, s) }, this._removeHash = () => { const s = this._getCurrentHash(); if (s.length === 0) return; const l = s.join("/"); let d = l; d.split("&").length > 0 && (d = d.split("&")[0]), this._hashName && (d = `${this._hashName}=${l}`); let g = window.location.hash.replace(d, ""); g.startsWith("#&") ? g = g.slice(0, 1) + g.slice(2) : g === "#" && (g = ""); let v = window.location.href.replace(/(#.+)?$/, g); v = v.replace("&&", "&"), window.history.replaceState(window.history.state, null, v) }, this._updateHash = ih(this._updateHashUnthrottled, 300), this._hashName = t && encodeURIComponent(t) } addTo(t) { return this._map = t, addEventListener("hashchange", this._onHashChange, !1), this._map.on("moveend", this._updateHash), this } remove() { return removeEventListener("hashchange", this._onHashChange, !1), this._map.off("moveend", this._updateHash), clearTimeout(this._updateHash()), this._removeHash(), delete this._map, this } getHashString(t) { const s = this._map.getCenter(), l = Math.round(100 * this._map.getZoom()) / 100, d = Math.ceil((l * Math.LN2 + Math.log(512 / 360 / .5)) / Math.LN10), g = Math.pow(10, d), v = Math.round(s.lng * g) / g, T = Math.round(s.lat * g) / g, E = this._map.getBearing(), I = this._map.getPitch(); let A = ""; if (A += t ? `/${v}/${T}/${l}` : `${l}/${T}/${v}`, (E || I) && (A += "/" + Math.round(10 * E) / 10), I && (A += `/${Math.round(I)}`), this._hashName) { const R = this._hashName; let z = !1; const O = window.location.hash.slice(1).split("&").map(U => { const X = U.split("=")[0]; return X === R ? (z = !0, `${X}=${A}`) : U }).filter(U => U); return z || O.push(`${R}=${A}`), `#${O.join("&")}` } return `#${A}` } _isValidHash(t) { if (t.length < 3 || t.some(isNaN)) return !1; try { new c.V(+t[2], +t[1]) } catch { return !1 } const s = +t[0], l = +(t[3] || 0), d = +(t[4] || 0); return s >= this._map.getMinZoom() && s <= this._map.getMaxZoom() && l >= -180 && l <= 180 && d >= this._map.getMinPitch() && d <= this._map.getMaxPitch() } } const Ms = { linearity: .3, easing: c.cw(0, 0, .3, 1) }, Pp = c.e({ deceleration: 2500, maxSpeed: 1400 }, Ms), ui = c.e({ deceleration: 20, maxSpeed: 1400 }, Ms), Ti = c.e({ deceleration: 1e3, maxSpeed: 360 }, Ms), Mp = c.e({ deceleration: 1e3, maxSpeed: 90 }, Ms), Si = c.e({ deceleration: 1e3, maxSpeed: 360 }, Ms); class eg { constructor(t) { this._map = t, this.clear() } clear() { this._inertiaBuffer = [] } record(t) { this._drainInertiaBuffer(), this._inertiaBuffer.push({ time: $e(), settings: t }) } _drainInertiaBuffer() { const t = this._inertiaBuffer, s = $e(); for (; t.length > 0 && s - t[0].time > 160;)t.shift() } _onMoveEnd(t) { if (this._drainInertiaBuffer(), this._inertiaBuffer.length < 2) return; const s = { zoom: 0, bearing: 0, pitch: 0, roll: 0, pan: new c.P(0, 0), pinchAround: void 0, around: void 0 }; for (const { settings: g } of this._inertiaBuffer) s.zoom += g.zoomDelta || 0, s.bearing += g.bearingDelta || 0, s.pitch += g.pitchDelta || 0, s.roll += g.rollDelta || 0, g.panDelta && s.pan._add(g.panDelta), g.around && (s.around = g.around), g.pinchAround && (s.pinchAround = g.pinchAround); const l = this._inertiaBuffer[this._inertiaBuffer.length - 1].time - this._inertiaBuffer[0].time, d = {}; if (s.pan.mag()) { const g = tl(s.pan.mag(), l, c.e({}, Pp, t || {})), v = s.pan.mult(g.amount / s.pan.mag()), T = this._map.cameraHelper.handlePanInertia(v, this._map.transform); d.center = T.easingCenter, d.offset = T.easingOffset, el(d, g) } if (s.zoom) { const g = tl(s.zoom, l, ui); d.zoom = this._map.transform.zoom + g.amount, el(d, g) } if (s.bearing) { const g = tl(s.bearing, l, Ti); d.bearing = this._map.transform.bearing + c.an(g.amount, -179, 179), el(d, g) } if (s.pitch) { const g = tl(s.pitch, l, Mp); d.pitch = this._map.transform.pitch + g.amount, el(d, g) } if (s.roll) { const g = tl(s.roll, l, Si); d.roll = this._map.transform.roll + c.an(g.amount, -179, 179), el(d, g) } if (d.zoom || d.bearing) { const g = s.pinchAround === void 0 ? s.around : s.pinchAround; d.around = g ? this._map.unproject(g) : this._map.getCenter() } return this.clear(), c.e(d, { noMoveStart: !0 }) } } function el(m, t) { (!m.duration || m.duration < t.duration) && (m.duration = t.duration, m.easing = t.easing) } function tl(m, t, s) { const { maxSpeed: l, linearity: d, deceleration: g } = s, v = c.an(m * d / (t / 1e3), -l, l), T = Math.abs(v) / (g * d); return { easing: s.easing, duration: 1e3 * T, amount: v * (T / 2) } } class nn extends c.l { preventDefault() { this._defaultPrevented = !0 } get defaultPrevented() { return this._defaultPrevented } constructor(t, s, l, d = {}) { l = l instanceof MouseEvent ? l : new MouseEvent(t, l); const g = ye.mousePos(s.getCanvas(), l), v = s.unproject(g); super(t, c.e({ point: g, lngLat: v, originalEvent: l }, d)), this._defaultPrevented = !1, this.target = s } } class rl extends c.l { preventDefault() { this._defaultPrevented = !0 } get defaultPrevented() { return this._defaultPrevented } constructor(t, s, l) { const d = t === "touchend" ? l.changedTouches : l.touches, g = ye.touchPos(s.getCanvasContainer(), d), v = g.map(E => s.unproject(E)), T = g.reduce((E, I, A, R) => E.add(I.div(R.length)), new c.P(0, 0)); super(t, { points: g, point: T, lngLats: v, lngLat: s.unproject(T), originalEvent: l }), this._defaultPrevented = !1 } } class Ip extends c.l { preventDefault() { this._defaultPrevented = !0 } get defaultPrevented() { return this._defaultPrevented } constructor(t, s, l) { super(t, { originalEvent: l }), this._defaultPrevented = !1 } } class tg { constructor(t, s) { this._map = t, this._clickTolerance = s.clickTolerance } reset() { delete this._mousedownPos } wheel(t) { return this._firePreventable(new Ip(t.type, this._map, t)) } mousedown(t, s) { return this._mousedownPos = s, this._firePreventable(new nn(t.type, this._map, t)) } mouseup(t) { this._map.fire(new nn(t.type, this._map, t)) } click(t, s) { this._mousedownPos && this._mousedownPos.dist(s) >= this._clickTolerance || this._map.fire(new nn(t.type, this._map, t)) } dblclick(t) { return this._firePreventable(new nn(t.type, this._map, t)) } mouseover(t) { this._map.fire(new nn(t.type, this._map, t)) } mouseout(t) { this._map.fire(new nn(t.type, this._map, t)) } touchstart(t) { return this._firePreventable(new rl(t.type, this._map, t)) } touchmove(t) { this._map.fire(new rl(t.type, this._map, t)) } touchend(t) { this._map.fire(new rl(t.type, this._map, t)) } touchcancel(t) { this._map.fire(new rl(t.type, this._map, t)) } _firePreventable(t) { if (this._map.fire(t), t.defaultPrevented) return {} } isEnabled() { return !0 } isActive() { return !1 } enable() { } disable() { } } class rg { constructor(t) { this._map = t } reset() { this._delayContextMenu = !1, this._ignoreContextMenu = !0, delete this._contextMenuEvent } mousemove(t) { this._map.fire(new nn(t.type, this._map, t)) } mousedown() { this._delayContextMenu = !0, this._ignoreContextMenu = !1 } mouseup() { this._delayContextMenu = !1, this._contextMenuEvent && (this._map.fire(new nn("contextmenu", this._map, this._contextMenuEvent)), delete this._contextMenuEvent) } contextmenu(t) { this._delayContextMenu ? this._contextMenuEvent = t : this._ignoreContextMenu || this._map.fire(new nn(t.type, this._map, t)), this._map.listens("contextmenu") && t.preventDefault() } isEnabled() { return !0 } isActive() { return !1 } enable() { } disable() { } } class Yo { constructor(t) { this._map = t } get transform() { return this._map._requestedCameraState || this._map.transform } get center() { return { lng: this.transform.center.lng, lat: this.transform.center.lat } } get zoom() { return this.transform.zoom } get pitch() { return this.transform.pitch } get bearing() { return this.transform.bearing } unproject(t) { return this.transform.screenPointToLocation(c.P.convert(t), this._map.terrain) } } class Ko { constructor(t, s) { this._map = t, this._tr = new Yo(t), this._el = t.getCanvasContainer(), this._container = t.getContainer(), this._clickTolerance = s.clickTolerance || 1 } isEnabled() { return !!this._enabled } isActive() { return !!this._active } enable() { this.isEnabled() || (this._enabled = !0) } disable() { this.isEnabled() && (this._enabled = !1) } mousedown(t, s) { this.isEnabled() && t.shiftKey && t.button === 0 && (ye.disableDrag(), this._startPos = this._lastPos = s, this._active = !0) } mousemoveWindow(t, s) { if (!this._active) return; const l = s; if (this._lastPos.equals(l) || !this._box && l.dist(this._startPos) < this._clickTolerance) return; const d = this._startPos; this._lastPos = l, this._box || (this._box = ye.create("div", "maplibregl-boxzoom", this._container), this._container.classList.add("maplibregl-crosshair"), this._fireEvent("boxzoomstart", t)); const g = Math.min(d.x, l.x), v = Math.max(d.x, l.x), T = Math.min(d.y, l.y), E = Math.max(d.y, l.y); ye.setTransform(this._box, `translate(${g}px,${T}px)`), this._box.style.width = v - g + "px", this._box.style.height = E - T + "px" } mouseupWindow(t, s) { if (!this._active || t.button !== 0) return; const l = this._startPos, d = s; if (this.reset(), ye.suppressClick(), l.x !== d.x || l.y !== d.y) return this._map.fire(new c.l("boxzoomend", { originalEvent: t })), { cameraAnimation: g => g.fitScreenCoordinates(l, d, this._tr.bearing, { linear: !0 }) }; this._fireEvent("boxzoomcancel", t) } keydown(t) { this._active && t.keyCode === 27 && (this.reset(), this._fireEvent("boxzoomcancel", t)) } reset() { this._active = !1, this._container.classList.remove("maplibregl-crosshair"), this._box && (ye.remove(this._box), this._box = null), ye.enableDrag(), delete this._startPos, delete this._lastPos } _fireEvent(t, s) { return this._map.fire(new c.l(t, { originalEvent: s })) } } function Ei(m, t) { if (m.length !== t.length) throw new Error(`The number of touches and points are not equal - touches ${m.length}, points ${t.length}`); const s = {}; for (let l = 0; l < m.length; l++)s[m[l].identifier] = t[l]; return s } class pt { constructor(t) { this.reset(), this.numTouches = t.numTouches } reset() { delete this.centroid, delete this.startTime, delete this.touches, this.aborted = !1 } touchstart(t, s, l) { (this.centroid || l.length > this.numTouches) && (this.aborted = !0), this.aborted || (this.startTime === void 0 && (this.startTime = t.timeStamp), l.length === this.numTouches && (this.centroid = function (d) { const g = new c.P(0, 0); for (const v of d) g._add(v); return g.div(d.length) }(s), this.touches = Ei(l, s))) } touchmove(t, s, l) { if (this.aborted || !this.centroid) return; const d = Ei(l, s); for (const g in this.touches) { const v = d[g]; (!v || v.dist(this.touches[g]) > 30) && (this.aborted = !0) } } touchend(t, s, l) { if ((!this.centroid || t.timeStamp - this.startTime > 500) && (this.aborted = !0), l.length === 0) { const d = !this.aborted && this.centroid; if (this.reset(), d) return d } } } class _u { constructor(t) { this.singleTap = new pt(t), this.numTaps = t.numTaps, this.reset() } reset() { this.lastTime = 1 / 0, delete this.lastTap, this.count = 0, this.singleTap.reset() } touchstart(t, s, l) { this.singleTap.touchstart(t, s, l) } touchmove(t, s, l) { this.singleTap.touchmove(t, s, l) } touchend(t, s, l) { const d = this.singleTap.touchend(t, s, l); if (d) { const g = t.timeStamp - this.lastTime < 500, v = !this.lastTap || this.lastTap.dist(d) < 30; if (g && v || this.reset(), this.count++, this.lastTime = t.timeStamp, this.lastTap = d, this.count === this.numTaps) return this.reset(), d } } } class oh { constructor(t) { this._tr = new Yo(t), this._zoomIn = new _u({ numTouches: 1, numTaps: 2 }), this._zoomOut = new _u({ numTouches: 2, numTaps: 1 }), this.reset() } reset() { this._active = !1, this._zoomIn.reset(), this._zoomOut.reset() } touchstart(t, s, l) { this._zoomIn.touchstart(t, s, l), this._zoomOut.touchstart(t, s, l) } touchmove(t, s, l) { this._zoomIn.touchmove(t, s, l), this._zoomOut.touchmove(t, s, l) } touchend(t, s, l) { const d = this._zoomIn.touchend(t, s, l), g = this._zoomOut.touchend(t, s, l), v = this._tr; return d ? (this._active = !0, t.preventDefault(), setTimeout(() => this.reset(), 0), { cameraAnimation: T => T.easeTo({ duration: 300, zoom: v.zoom + 1, around: v.unproject(d) }, { originalEvent: t }) }) : g ? (this._active = !0, t.preventDefault(), setTimeout(() => this.reset(), 0), { cameraAnimation: T => T.easeTo({ duration: 300, zoom: v.zoom - 1, around: v.unproject(g) }, { originalEvent: t }) }) : void 0 } touchcancel() { this.reset() } enable() { this._enabled = !0 } disable() { this._enabled = !1, this.reset() } isEnabled() { return this._enabled } isActive() { return this._active } } class Qo { constructor(t) { this._enabled = !!t.enable, this._moveStateManager = t.moveStateManager, this._clickTolerance = t.clickTolerance || 1, this._moveFunction = t.move, this._activateOnStart = !!t.activateOnStart, t.assignEvents(this), this.reset() } reset(t) { this._active = !1, this._moved = !1, delete this._lastPoint, this._moveStateManager.endMove(t) } _move(...t) { const s = this._moveFunction(...t); if (s.bearingDelta || s.pitchDelta || s.rollDelta || s.around || s.panDelta) return this._active = !0, s } dragStart(t, s) { this.isEnabled() && !this._lastPoint && this._moveStateManager.isValidStartEvent(t) && (this._moveStateManager.startMove(t), this._lastPoint = Array.isArray(s) ? s[0] : s, this._activateOnStart && this._lastPoint && (this._active = !0)) } dragMove(t, s) { if (!this.isEnabled()) return; const l = this._lastPoint; if (!l) return; if (t.preventDefault(), !this._moveStateManager.isValidMoveEvent(t)) return void this.reset(t); const d = Array.isArray(s) ? s[0] : s; return !this._moved && d.dist(l) < this._clickTolerance ? void 0 : (this._moved = !0, this._lastPoint = d, this._move(l, d)) } dragEnd(t) { this.isEnabled() && this._lastPoint && this._moveStateManager.isValidEndEvent(t) && (this._moved && ye.suppressClick(), this.reset(t)) } enable() { this._enabled = !0 } disable() { this._enabled = !1, this.reset() } isEnabled() { return this._enabled } isActive() { return this._active } getClickTolerance() { return this._clickTolerance } } const nl = 0, il = 2, ah = { [nl]: 1, [il]: 2 }; class sl { constructor(t) { this._correctEvent = t.checkCorrectEvent } startMove(t) { const s = ye.mouseButton(t); this._eventButton = s } endMove(t) { delete this._eventButton } isValidStartEvent(t) { return this._correctEvent(t) } isValidMoveEvent(t) { return !function (s, l) { const d = ah[l]; return s.buttons === void 0 || (s.buttons & d) !== d }(t, this._eventButton) } isValidEndEvent(t) { return ye.mouseButton(t) === this._eventButton } } class lh { constructor() { this._firstTouch = void 0 } _isOneFingerTouch(t) { return t.targetTouches.length === 1 } _isSameTouchEvent(t) { return t.targetTouches[0].identifier === this._firstTouch } startMove(t) { this._firstTouch = t.targetTouches[0].identifier } endMove(t) { delete this._firstTouch } isValidStartEvent(t) { return this._isOneFingerTouch(t) } isValidMoveEvent(t) { return this._isOneFingerTouch(t) && this._isSameTouchEvent(t) } isValidEndEvent(t) { return this._isOneFingerTouch(t) && this._isSameTouchEvent(t) } } class Cp { constructor(t = new sl({ checkCorrectEvent: () => !0 }), s = new lh) { this.mouseMoveStateManager = t, this.oneFingerTouchMoveStateManager = s } _executeRelevantHandler(t, s, l) { return t instanceof MouseEvent ? s(t) : typeof TouchEvent < "u" && t instanceof TouchEvent ? l(t) : void 0 } startMove(t) { this._executeRelevantHandler(t, s => this.mouseMoveStateManager.startMove(s), s => this.oneFingerTouchMoveStateManager.startMove(s)) } endMove(t) { this._executeRelevantHandler(t, s => this.mouseMoveStateManager.endMove(s), s => this.oneFingerTouchMoveStateManager.endMove(s)) } isValidStartEvent(t) { return this._executeRelevantHandler(t, s => this.mouseMoveStateManager.isValidStartEvent(s), s => this.oneFingerTouchMoveStateManager.isValidStartEvent(s)) } isValidMoveEvent(t) { return this._executeRelevantHandler(t, s => this.mouseMoveStateManager.isValidMoveEvent(s), s => this.oneFingerTouchMoveStateManager.isValidMoveEvent(s)) } isValidEndEvent(t) { return this._executeRelevantHandler(t, s => this.mouseMoveStateManager.isValidEndEvent(s), s => this.oneFingerTouchMoveStateManager.isValidEndEvent(s)) } } const Jo = m => { m.mousedown = m.dragStart, m.mousemoveWindow = m.dragMove, m.mouseup = m.dragEnd, m.contextmenu = t => { t.preventDefault() } }; class ng { constructor(t, s) { this._clickTolerance = t.clickTolerance || 1, this._map = s, this.reset() } reset() { this._active = !1, this._touches = {}, this._sum = new c.P(0, 0) } _shouldBePrevented(t) { return t < (this._map.cooperativeGestures.isEnabled() ? 2 : 1) } touchstart(t, s, l) { return this._calculateTransform(t, s, l) } touchmove(t, s, l) { if (this._active) { if (!this._shouldBePrevented(l.length)) return t.preventDefault(), this._calculateTransform(t, s, l); this._map.cooperativeGestures.notifyGestureBlocked("touch_pan", t) } } touchend(t, s, l) { this._calculateTransform(t, s, l), this._active && this._shouldBePrevented(l.length) && this.reset() } touchcancel() { this.reset() } _calculateTransform(t, s, l) { l.length > 0 && (this._active = !0); const d = Ei(l, s), g = new c.P(0, 0), v = new c.P(0, 0); let T = 0; for (const I in d) { const A = d[I], R = this._touches[I]; R && (g._add(A), v._add(A.sub(R)), T++, d[I] = A) } if (this._touches = d, this._shouldBePrevented(T) || !v.mag()) return; const E = v.div(T); return this._sum._add(E), this._sum.mag() < this._clickTolerance ? void 0 : { around: g.div(T), panDelta: E } } enable() { this._enabled = !0 } disable() { this._enabled = !1, this.reset() } isEnabled() { return this._enabled } isActive() { return this._active } } class yu { constructor() { this.reset() } reset() { this._active = !1, delete this._firstTwoTouches } touchstart(t, s, l) { this._firstTwoTouches || l.length < 2 || (this._firstTwoTouches = [l[0].identifier, l[1].identifier], this._start([s[0], s[1]])) } touchmove(t, s, l) { if (!this._firstTwoTouches) return; t.preventDefault(); const [d, g] = this._firstTwoTouches, v = vu(l, s, d), T = vu(l, s, g); if (!v || !T) return; const E = this._aroundCenter ? null : v.add(T).div(2); return this._move([v, T], E, t) } touchend(t, s, l) { if (!this._firstTwoTouches) return; const [d, g] = this._firstTwoTouches, v = vu(l, s, d), T = vu(l, s, g); v && T || (this._active && ye.suppressClick(), this.reset()) } touchcancel() { this.reset() } enable(t) { this._enabled = !0, this._aroundCenter = !!t && t.around === "center" } disable() { this._enabled = !1, this.reset() } isEnabled() { return !!this._enabled } isActive() { return !!this._active } } function vu(m, t, s) { for (let l = 0; l < m.length; l++)if (m[l].identifier === s) return t[l] } function Ap(m, t) { return Math.log(m / t) / Math.LN2 } class uh extends yu { reset() { super.reset(), delete this._distance, delete this._startDistance } _start(t) { this._startDistance = this._distance = t[0].dist(t[1]) } _move(t, s) { const l = this._distance; if (this._distance = t[0].dist(t[1]), this._active || !(Math.abs(Ap(this._distance, this._startDistance)) < .1)) return this._active = !0, { zoomDelta: Ap(this._distance, l), pinchAround: s } } } function kp(m, t) { return 180 * m.angleWith(t) / Math.PI } class ch extends yu { reset() { super.reset(), delete this._minDiameter, delete this._startVector, delete this._vector } _start(t) { this._startVector = this._vector = t[0].sub(t[1]), this._minDiameter = t[0].dist(t[1]) } _move(t, s, l) { const d = this._vector; if (this._vector = t[0].sub(t[1]), this._active || !this._isBelowThreshold(this._vector)) return this._active = !0, { bearingDelta: kp(this._vector, d), pinchAround: s } } _isBelowThreshold(t) { this._minDiameter = Math.min(this._minDiameter, t.mag()); const s = 25 / (Math.PI * this._minDiameter) * 360, l = kp(t, this._startVector); return Math.abs(l) < s } } function hh(m) { return Math.abs(m.y) > Math.abs(m.x) } class Dp extends yu { constructor(t) { super(), this._currentTouchCount = 0, this._map = t } reset() { super.reset(), this._valid = void 0, delete this._firstMove, delete this._lastPoints } touchstart(t, s, l) { super.touchstart(t, s, l), this._currentTouchCount = l.length } _start(t) { this._lastPoints = t, hh(t[0].sub(t[1])) && (this._valid = !1) } _move(t, s, l) { if (this._map.cooperativeGestures.isEnabled() && this._currentTouchCount < 3) return; const d = t[0].sub(this._lastPoints[0]), g = t[1].sub(this._lastPoints[1]); return this._valid = this.gestureBeginsVertically(d, g, l.timeStamp), this._valid ? (this._lastPoints = t, this._active = !0, { pitchDelta: (d.y + g.y) / 2 * -.5 }) : void 0 } gestureBeginsVertically(t, s, l) { if (this._valid !== void 0) return this._valid; const d = t.mag() >= 2, g = s.mag() >= 2; if (!d && !g) return; if (!d || !g) return this._firstMove === void 0 && (this._firstMove = l), l - this._firstMove < 100 && void 0; const v = t.y > 0 == s.y > 0; return hh(t) && hh(s) && v } } const Is = { panStep: 100, bearingStep: 15, pitchStep: 10 }; class rr { constructor(t) { this._tr = new Yo(t); const s = Is; this._panStep = s.panStep, this._bearingStep = s.bearingStep, this._pitchStep = s.pitchStep, this._rotationDisabled = !1 } reset() { this._active = !1 } keydown(t) { if (t.altKey || t.ctrlKey || t.metaKey) return; let s = 0, l = 0, d = 0, g = 0, v = 0; switch (t.keyCode) { case 61: case 107: case 171: case 187: s = 1; break; case 189: case 109: case 173: s = -1; break; case 37: t.shiftKey ? l = -1 : (t.preventDefault(), g = -1); break; case 39: t.shiftKey ? l = 1 : (t.preventDefault(), g = 1); break; case 38: t.shiftKey ? d = 1 : (t.preventDefault(), v = -1); break; case 40: t.shiftKey ? d = -1 : (t.preventDefault(), v = 1); break; default: return }return this._rotationDisabled && (l = 0, d = 0), { cameraAnimation: T => { const E = this._tr; T.easeTo({ duration: 300, easeId: "keyboardHandler", easing: ig, zoom: s ? Math.round(E.zoom) + s * (t.shiftKey ? 2 : 1) : E.zoom, bearing: E.bearing + l * this._bearingStep, pitch: E.pitch + d * this._pitchStep, offset: [-g * this._panStep, -v * this._panStep], center: E.center }, { originalEvent: t }) } } } enable() { this._enabled = !0 } disable() { this._enabled = !1, this.reset() } isEnabled() { return this._enabled } isActive() { return this._active } disableRotation() { this._rotationDisabled = !0 } enableRotation() { this._rotationDisabled = !1 } } function ig(m) { return m * (2 - m) } const ol = 4.000244140625, xu = 1 / 450; class wu { constructor(t, s) { this._onTimeout = l => { this._type = "wheel", this._delta -= this._lastValue, this._active || this._start(l) }, this._map = t, this._tr = new Yo(t), this._triggerRenderFrame = s, this._delta = 0, this._defaultZoomRate = .01, this._wheelZoomRate = xu } setZoomRate(t) { this._defaultZoomRate = t } setWheelZoomRate(t) { this._wheelZoomRate = t } isEnabled() { return !!this._enabled } isActive() { return !!this._active || this._finishTimeout !== void 0 } isZooming() { return !!this._zooming } enable(t) { this.isEnabled() || (this._enabled = !0, this._aroundCenter = !!t && t.around === "center") } disable() { this.isEnabled() && (this._enabled = !1) } _shouldBePrevented(t) { return !!this._map.cooperativeGestures.isEnabled() && !(t.ctrlKey || this._map.cooperativeGestures.isBypassed(t)) } wheel(t) { if (!this.isEnabled()) return; if (this._shouldBePrevented(t)) return void this._map.cooperativeGestures.notifyGestureBlocked("wheel_zoom", t); let s = t.deltaMode === WheelEvent.DOM_DELTA_LINE ? 40 * t.deltaY : t.deltaY; const l = $e(), d = l - (this._lastWheelEventTime || 0); this._lastWheelEventTime = l, s !== 0 && s % ol == 0 ? this._type = "wheel" : s !== 0 && Math.abs(s) < 4 ? this._type = "trackpad" : d > 400 ? (this._type = null, this._lastValue = s, this._timeout = setTimeout(this._onTimeout, 40, t)) : this._type || (this._type = Math.abs(d * s) < 200 ? "trackpad" : "wheel", this._timeout && (clearTimeout(this._timeout), this._timeout = null, s += this._lastValue)), t.shiftKey && s && (s /= 4), this._type && (this._lastWheelEvent = t, this._delta -= s, this._active || this._start(t)), t.preventDefault() } _start(t) { if (!this._delta) return; this._frameId && (this._frameId = null), this._active = !0, this.isZooming() || (this._zooming = !0), this._finishTimeout && (clearTimeout(this._finishTimeout), delete this._finishTimeout); const s = ye.mousePos(this._map.getCanvas(), t), l = this._tr; this._aroundPoint = this._aroundCenter ? l.transform.locationToScreenPoint(c.V.convert(l.center)) : s, this._frameId || (this._frameId = !0, this._triggerRenderFrame()) } renderFrame() { if (!this._frameId || (this._frameId = null, !this.isActive())) return; const t = this._tr.transform; if (typeof this._lastExpectedZoom == "number") { const T = t.zoom - this._lastExpectedZoom; typeof this._startZoom == "number" && (this._startZoom += T), typeof this._targetZoom == "number" && (this._targetZoom += T) } if (this._delta !== 0) { const T = this._type === "wheel" && Math.abs(this._delta) > ol ? this._wheelZoomRate : this._defaultZoomRate; let E = 2 / (1 + Math.exp(-Math.abs(this._delta * T))); this._delta < 0 && E !== 0 && (E = 1 / E); const I = typeof this._targetZoom != "number" ? t.scale : c.aq(this._targetZoom); this._targetZoom = t.applyConstrain(t.getCameraLngLat(), c.at(I * E)).zoom, this._type === "wheel" && (this._startZoom = t.zoom, this._easing = this._smoothOutEasing(200)), this._delta = 0 } const s = typeof this._targetZoom != "number" ? t.zoom : this._targetZoom, l = this._startZoom, d = this._easing; let g, v = !1; if (this._type === "wheel" && l && d) { const T = $e() - this._lastWheelEventTime, E = Math.min((T + 5) / 200, 1), I = d(E); g = c.G.number(l, s, I), E < 1 ? this._frameId || (this._frameId = !0) : v = !0 } else g = s, v = !0; return this._active = !0, v && (this._active = !1, this._finishTimeout = setTimeout(() => { this._zooming = !1, this._triggerRenderFrame(), delete this._targetZoom, delete this._lastExpectedZoom, delete this._finishTimeout }, 200)), this._lastExpectedZoom = g, { noInertia: !0, needsRenderFrame: !v, zoomDelta: g - t.zoom, around: this._aroundPoint, originalEvent: this._lastWheelEvent } } _smoothOutEasing(t) { let s = c.cy; if (this._prevEase) { const l = this._prevEase, d = ($e() - l.start) / l.duration, g = l.easing(d + .01) - l.easing(d), v = .27 / Math.sqrt(g * g + 1e-4) * .01, T = Math.sqrt(.0729 - v * v); s = c.cw(v, T, .25, 1) } return this._prevEase = { start: $e(), duration: t, easing: s }, s } reset() { this._active = !1, this._zooming = !1, delete this._targetZoom, delete this._lastExpectedZoom, this._finishTimeout && (clearTimeout(this._finishTimeout), delete this._finishTimeout) } } class dh { constructor(t, s) { this._clickZoom = t, this._tapZoom = s } enable() { this._clickZoom.enable(), this._tapZoom.enable() } disable() { this._clickZoom.disable(), this._tapZoom.disable() } isEnabled() { return this._clickZoom.isEnabled() && this._tapZoom.isEnabled() } isActive() { return this._clickZoom.isActive() || this._tapZoom.isActive() } } class zp { constructor(t) { this._tr = new Yo(t), this.reset() } reset() { this._active = !1 } dblclick(t, s) { return t.preventDefault(), { cameraAnimation: l => { l.easeTo({ duration: 300, zoom: this._tr.zoom + (t.shiftKey ? -1 : 1), around: this._tr.unproject(s) }, { originalEvent: t }) } } } enable() { this._enabled = !0 } disable() { this._enabled = !1, this.reset() } isEnabled() { return this._enabled } isActive() { return this._active } } class Rp { constructor() { this._tap = new _u({ numTouches: 1, numTaps: 1 }), this.reset() } reset() { this._active = !1, delete this._swipePoint, delete this._swipeTouch, delete this._tapTime, delete this._tapPoint, this._tap.reset() } touchstart(t, s, l) { if (!this._swipePoint) if (this._tapTime) { const d = s[0], g = t.timeStamp - this._tapTime < 500, v = this._tapPoint.dist(d) < 30; g && v ? l.length > 0 && (this._swipePoint = d, this._swipeTouch = l[0].identifier) : this.reset() } else this._tap.touchstart(t, s, l) } touchmove(t, s, l) { if (this._tapTime) { if (this._swipePoint) { if (l[0].identifier !== this._swipeTouch) return; const d = s[0], g = d.y - this._swipePoint.y; return this._swipePoint = d, t.preventDefault(), this._active = !0, { zoomDelta: g / 128 } } } else this._tap.touchmove(t, s, l) } touchend(t, s, l) { if (this._tapTime) this._swipePoint && l.length === 0 && this.reset(); else { const d = this._tap.touchend(t, s, l); d && (this._tapTime = t.timeStamp, this._tapPoint = d) } } touchcancel() { this.reset() } enable() { this._enabled = !0 } disable() { this._enabled = !1, this.reset() } isEnabled() { return this._enabled } isActive() { return this._active } } class Lp { constructor(t, s, l) { this._el = t, this._mousePan = s, this._touchPan = l } enable(t) { this._inertiaOptions = t || {}, this._mousePan.enable(), this._touchPan.enable(), this._el.classList.add("maplibregl-touch-drag-pan") } disable() { this._mousePan.disable(), this._touchPan.disable(), this._el.classList.remove("maplibregl-touch-drag-pan") } isEnabled() { return this._mousePan.isEnabled() && this._touchPan.isEnabled() } isActive() { return this._mousePan.isActive() || this._touchPan.isActive() } } class Pi { constructor(t, s, l, d) { this._pitchWithRotate = t.pitchWithRotate, this._rollEnabled = t.rollEnabled, this._mouseRotate = s, this._mousePitch = l, this._mouseRoll = d } enable() { this._mouseRotate.enable(), this._pitchWithRotate && this._mousePitch.enable(), this._rollEnabled && this._mouseRoll.enable() } disable() { this._mouseRotate.disable(), this._mousePitch.disable(), this._mouseRoll.disable() } isEnabled() { return this._mouseRotate.isEnabled() && (!this._pitchWithRotate || this._mousePitch.isEnabled()) && (!this._rollEnabled || this._mouseRoll.isEnabled()) } isActive() { return this._mouseRotate.isActive() || this._mousePitch.isActive() || this._mouseRoll.isActive() } } class al { constructor(t, s, l, d) { this._el = t, this._touchZoom = s, this._touchRotate = l, this._tapDragZoom = d, this._rotationDisabled = !1, this._enabled = !0 } enable(t) { this._touchZoom.enable(t), this._rotationDisabled || this._touchRotate.enable(t), this._tapDragZoom.enable(), this._el.classList.add("maplibregl-touch-zoom-rotate") } disable() { this._touchZoom.disable(), this._touchRotate.disable(), this._tapDragZoom.disable(), this._el.classList.remove("maplibregl-touch-zoom-rotate") } isEnabled() { return this._touchZoom.isEnabled() && (this._rotationDisabled || this._touchRotate.isEnabled()) && this._tapDragZoom.isEnabled() } isActive() { return this._touchZoom.isActive() || this._touchRotate.isActive() || this._tapDragZoom.isActive() } disableRotation() { this._rotationDisabled = !0, this._touchRotate.disable() } enableRotation() { this._rotationDisabled = !1, this._touchZoom.isEnabled() && this._touchRotate.enable() } } class vt { constructor(t, s) { this._bypassKey = navigator.userAgent.indexOf("Mac") !== -1 ? "metaKey" : "ctrlKey", this._map = t, this._options = s, this._enabled = !1 } isActive() { return !1 } reset() { } _setupUI() { if (this._container) return; const t = this._map.getCanvasContainer(); t.classList.add("maplibregl-cooperative-gestures"), this._container = ye.create("div", "maplibregl-cooperative-gesture-screen", t); let s = this._map._getUIString("CooperativeGesturesHandler.WindowsHelpText"); this._bypassKey === "metaKey" && (s = this._map._getUIString("CooperativeGesturesHandler.MacHelpText")); const l = this._map._getUIString("CooperativeGesturesHandler.MobileHelpText"), d = document.createElement("div"); d.className = "maplibregl-desktop-message", d.textContent = s, this._container.appendChild(d); const g = document.createElement("div"); g.className = "maplibregl-mobile-message", g.textContent = l, this._container.appendChild(g), this._container.setAttribute("aria-hidden", "true") } _destroyUI() { this._container && (ye.remove(this._container), this._map.getCanvasContainer().classList.remove("maplibregl-cooperative-gestures")), delete this._container } enable() { this._setupUI(), this._enabled = !0 } disable() { this._enabled = !1, this._destroyUI() } isEnabled() { return this._enabled } isBypassed(t) { return t[this._bypassKey] } notifyGestureBlocked(t, s) { this._enabled && (this._map.fire(new c.l("cooperativegestureprevented", { gestureType: t, originalEvent: s })), this._container.classList.add("maplibregl-show"), setTimeout(() => { this._container.classList.remove("maplibregl-show") }, 100)) } } const bt = m => m.zoom || m.drag || m.roll || m.pitch || m.rotate; class ll extends c.l { } function bu(m) { return m.panDelta && m.panDelta.mag() || m.zoomDelta || m.bearingDelta || m.pitchDelta || m.rollDelta } class Tu { constructor(t, s) { this.handleWindowEvent = d => { this.handleEvent(d, `${d.type}Window`) }, this.handleEvent = (d, g) => { if (d.type === "blur") return void this.stop(!0); this._updatingCamera = !0; const v = d.type === "renderFrame" ? void 0 : d, T = { needsRenderFrame: !1 }, E = {}, I = {}; for (const { handlerName: z, handler: O, allowed: U } of this._handlers) { if (!O.isEnabled()) continue; let X; if (this._blockedByActive(I, U, z)) O.reset(); else if (O[g || d.type]) { if (c.cz(d, g || d.type)) { const Q = ye.mousePos(this._map.getCanvas(), d); X = O[g || d.type](d, Q) } else if (c.cA(d, g || d.type)) { const Q = this._getMapTouches(d.touches), Y = ye.touchPos(this._map.getCanvas(), Q); X = O[g || d.type](d, Y, Q) } else c.cB(g || d.type) || (X = O[g || d.type](d)); this.mergeHandlerResult(T, E, X, z, v), X && X.needsRenderFrame && this._triggerRenderFrame() } (X || O.isActive()) && (I[z] = O) } const A = {}; for (const z in this._previousActiveHandlers) I[z] || (A[z] = v); this._previousActiveHandlers = I, (Object.keys(A).length || bu(T)) && (this._changes.push([T, E, A]), this._triggerRenderFrame()), (Object.keys(I).length || bu(T)) && this._map._stop(!0), this._updatingCamera = !1; const { cameraAnimation: R } = T; R && (this._inertia.clear(), this._fireEvents({}, {}, !0), this._changes = [], R(this._map)) }, this._map = t, this._el = this._map.getCanvasContainer(), this._handlers = [], this._handlersById = {}, this._changes = [], this._inertia = new eg(t), this._bearingSnap = s.bearingSnap, this._previousActiveHandlers = {}, this._eventsInProgress = {}, this._addDefaultHandlers(s); const l = this._el; this._listeners = [[l, "touchstart", { passive: !0 }], [l, "touchmove", { passive: !1 }], [l, "touchend", void 0], [l, "touchcancel", void 0], [l, "mousedown", void 0], [l, "mousemove", void 0], [l, "mouseup", void 0], [document, "mousemove", { capture: !0 }], [document, "mouseup", void 0], [l, "mouseover", void 0], [l, "mouseout", void 0], [l, "dblclick", void 0], [l, "click", void 0], [l, "keydown", { capture: !1 }], [l, "keyup", void 0], [l, "wheel", { passive: !1 }], [l, "contextmenu", void 0], [window, "blur", void 0]]; for (const [d, g, v] of this._listeners) ye.addEventListener(d, g, d === document ? this.handleWindowEvent : this.handleEvent, v) } destroy() { for (const [t, s, l] of this._listeners) ye.removeEventListener(t, s, t === document ? this.handleWindowEvent : this.handleEvent, l) } _addDefaultHandlers(t) { const s = this._map, l = s.getCanvasContainer(); this._add("mapEvent", new tg(s, t)); const d = s.boxZoom = new Ko(s, t); this._add("boxZoom", d), t.interactive && t.boxZoom && d.enable(); const g = s.cooperativeGestures = new vt(s, t.cooperativeGestures); this._add("cooperativeGestures", g), t.cooperativeGestures && g.enable(); const v = new oh(s), T = new zp(s); s.doubleClickZoom = new dh(T, v), this._add("tapZoom", v), this._add("clickZoom", T), t.interactive && t.doubleClickZoom && s.doubleClickZoom.enable(); const E = new Rp; this._add("tapDragZoom", E); const I = s.touchPitch = new Dp(s); this._add("touchPitch", I), t.interactive && t.touchPitch && s.touchPitch.enable(t.touchPitch); const A = () => s.project(s.getCenter()), R = function ({ enable: J, clickTolerance: oe, aroundCenter: ce = !0, minPixelCenterThreshold: se = 100, rotateDegreesPerPixelMoved: fe = .8 }, Oe) { const ke = new sl({ checkCorrectEvent: ze => ye.mouseButton(ze) === 0 && ze.ctrlKey || ye.mouseButton(ze) === 2 && !ze.ctrlKey }); return new Qo({ clickTolerance: oe, move: (ze, Re) => { const Je = Oe(); if (ce && Math.abs(Je.y - ze.y) > se) return { bearingDelta: c.cx(new c.P(ze.x, Re.y), Re, Je) }; let tt = (Re.x - ze.x) * fe; return ce && Re.y < Je.y && (tt = -tt), { bearingDelta: tt } }, moveStateManager: ke, enable: J, assignEvents: Jo }) }(t, A), z = function ({ enable: J, clickTolerance: oe, pitchDegreesPerPixelMoved: ce = -.5 }) { const se = new sl({ checkCorrectEvent: fe => ye.mouseButton(fe) === 0 && fe.ctrlKey || ye.mouseButton(fe) === 2 }); return new Qo({ clickTolerance: oe, move: (fe, Oe) => ({ pitchDelta: (Oe.y - fe.y) * ce }), moveStateManager: se, enable: J, assignEvents: Jo }) }(t), O = function ({ enable: J, clickTolerance: oe, rollDegreesPerPixelMoved: ce = .3 }, se) { const fe = new sl({ checkCorrectEvent: Oe => ye.mouseButton(Oe) === 2 && Oe.ctrlKey }); return new Qo({ clickTolerance: oe, move: (Oe, ke) => { const ze = se(); let Re = (ke.x - Oe.x) * ce; return ke.y < ze.y && (Re = -Re), { rollDelta: Re } }, moveStateManager: fe, enable: J, assignEvents: Jo }) }(t, A); s.dragRotate = new Pi(t, R, z, O), this._add("mouseRotate", R, ["mousePitch"]), this._add("mousePitch", z, ["mouseRotate", "mouseRoll"]), this._add("mouseRoll", O, ["mousePitch"]), t.interactive && t.dragRotate && s.dragRotate.enable(); const U = function ({ enable: J, clickTolerance: oe }) { const ce = new sl({ checkCorrectEvent: se => ye.mouseButton(se) === 0 && !se.ctrlKey }); return new Qo({ clickTolerance: oe, move: (se, fe) => ({ around: fe, panDelta: fe.sub(se) }), activateOnStart: !0, moveStateManager: ce, enable: J, assignEvents: Jo }) }(t), X = new ng(t, s); s.dragPan = new Lp(l, U, X), this._add("mousePan", U), this._add("touchPan", X, ["touchZoom", "touchRotate"]), t.interactive && t.dragPan && s.dragPan.enable(t.dragPan); const Q = new ch, Y = new uh; s.touchZoomRotate = new al(l, Y, Q, E), this._add("touchRotate", Q, ["touchPan", "touchZoom"]), this._add("touchZoom", Y, ["touchPan", "touchRotate"]), t.interactive && t.touchZoomRotate && s.touchZoomRotate.enable(t.touchZoomRotate), this._add("blockableMapEvent", new rg(s)); const te = s.scrollZoom = new wu(s, () => this._triggerRenderFrame()); this._add("scrollZoom", te, ["mousePan"]), t.interactive && t.scrollZoom && s.scrollZoom.enable(t.scrollZoom); const le = s.keyboard = new rr(s); this._add("keyboard", le), t.interactive && t.keyboard && s.keyboard.enable() } _add(t, s, l) { this._handlers.push({ handlerName: t, handler: s, allowed: l }), this._handlersById[t] = s } stop(t) { if (!this._updatingCamera) { for (const { handler: s } of this._handlers) s.reset(); this._inertia.clear(), this._fireEvents({}, {}, t), this._changes = [] } } isActive() { for (const { handler: t } of this._handlers) if (t.isActive()) return !0; return !1 } isZooming() { return !!this._eventsInProgress.zoom || this._map.scrollZoom.isZooming() } isRotating() { return !!this._eventsInProgress.rotate } isMoving() { return !!bt(this._eventsInProgress) || this.isZooming() } _blockedByActive(t, s, l) { for (const d in t) if (d !== l && (!s || s.indexOf(d) < 0)) return !0; return !1 } _getMapTouches(t) { const s = []; for (const l of t) this._el.contains(l.target) && s.push(l); return s } mergeHandlerResult(t, s, l, d, g) { if (!l) return; c.e(t, l); const v = { handlerName: d, originalEvent: l.originalEvent || g }; l.zoomDelta !== void 0 && (s.zoom = v), l.panDelta !== void 0 && (s.drag = v), l.rollDelta !== void 0 && (s.roll = v), l.pitchDelta !== void 0 && (s.pitch = v), l.bearingDelta !== void 0 && (s.rotate = v) } _applyChanges() { const t = {}, s = {}, l = {}; for (const [d, g, v] of this._changes) d.panDelta && (t.panDelta = (t.panDelta || new c.P(0, 0))._add(d.panDelta)), d.zoomDelta && (t.zoomDelta = (t.zoomDelta || 0) + d.zoomDelta), d.bearingDelta && (t.bearingDelta = (t.bearingDelta || 0) + d.bearingDelta), d.pitchDelta && (t.pitchDelta = (t.pitchDelta || 0) + d.pitchDelta), d.rollDelta && (t.rollDelta = (t.rollDelta || 0) + d.rollDelta), d.around !== void 0 && (t.around = d.around), d.pinchAround !== void 0 && (t.pinchAround = d.pinchAround), d.noInertia && (t.noInertia = d.noInertia), c.e(s, g), c.e(l, v); this._updateMapTransform(t, s, l), this._changes = [] } _updateMapTransform(t, s, l) { const d = this._map, g = d._getTransformForUpdate(), v = d.terrain; if (!(bu(t) || v && this._terrainMovement)) return this._fireEvents(s, l, !0); d._stop(!0); let { panDelta: T, zoomDelta: E, bearingDelta: I, pitchDelta: A, rollDelta: R, around: z, pinchAround: O } = t; O !== void 0 && (z = O), z = z || d.transform.centerPoint, v && !g.isPointOnMapSurface(z) && (z = g.centerPoint); const U = { panDelta: T, zoomDelta: E, rollDelta: R, pitchDelta: A, bearingDelta: I, around: z }; this._map.cameraHelper.useGlobeControls && !g.isPointOnMapSurface(z) && (z = g.centerPoint); const X = z.distSqr(g.centerPoint) < .01 ? g.center : g.screenPointToLocation(T ? z.sub(T) : z); this._handleMapControls({ terrain: v, tr: g, deltasForHelper: U, preZoomAroundLoc: X, combinedEventsInProgress: s, panDelta: T }), d._applyUpdatedTransform(g), this._map._update(), t.noInertia || this._inertia.record(t), this._fireEvents(s, l, !0) } _handleMapControls({ terrain: t, tr: s, deltasForHelper: l, preZoomAroundLoc: d, combinedEventsInProgress: g, panDelta: v }) { const T = this._map.cameraHelper; if (T.handleMapControlsRollPitchBearingZoom(l, s), t) return T.useGlobeControls ? (this._terrainMovement || !g.drag && !g.zoom || (this._terrainMovement = !0, this._map._elevationFreeze = !0), void T.handleMapControlsPan(l, s, d)) : this._terrainMovement || !g.drag && !g.zoom ? void (g.drag && this._terrainMovement && v ? s.setCenter(s.screenPointToLocation(s.centerPoint.sub(v))) : T.handleMapControlsPan(l, s, d)) : (this._terrainMovement = !0, this._map._elevationFreeze = !0, void T.handleMapControlsPan(l, s, d)); T.handleMapControlsPan(l, s, d) } _fireEvents(t, s, l) { const d = bt(this._eventsInProgress), g = bt(t), v = {}; for (const R in t) { const { originalEvent: z } = t[R]; this._eventsInProgress[R] || (v[`${R}start`] = z), this._eventsInProgress[R] = t[R] } !d && g && this._fireEvent("movestart", g.originalEvent); for (const R in v) this._fireEvent(R, v[R]); g && this._fireEvent("move", g.originalEvent); for (const R in t) { const { originalEvent: z } = t[R]; this._fireEvent(R, z) } const T = {}; let E; for (const R in this._eventsInProgress) { const { handlerName: z, originalEvent: O } = this._eventsInProgress[R]; this._handlersById[z].isActive() || (delete this._eventsInProgress[R], E = s[z] || O, T[`${R}end`] = E) } for (const R in T) this._fireEvent(R, T[R]); const I = bt(this._eventsInProgress), A = (d || g) && !I; if (A && this._terrainMovement) { this._map._elevationFreeze = !1, this._terrainMovement = !1; const R = this._map._getTransformForUpdate(); this._map.getCenterClampedToGround() && R.recalculateZoomAndCenter(this._map.terrain), this._map._applyUpdatedTransform(R) } if (l && A) { this._updatingCamera = !0; const R = this._inertia._onMoveEnd(this._map.dragPan._inertiaOptions), z = O => O !== 0 && -this._bearingSnap < O && O < this._bearingSnap; !R || !R.essential && Ge.prefersReducedMotion ? (this._map.fire(new c.l("moveend", { originalEvent: E })), z(this._map.getBearing()) && this._map.resetNorth()) : (z(R.bearing || this._map.getBearing()) && (R.bearing = 0), R.freezeElevation = !0, this._map.easeTo(R, { originalEvent: E })), this._updatingCamera = !1 } } _fireEvent(t, s) { this._map.fire(new c.l(t, s ? { originalEvent: s } : {})) } _requestFrame() { return this._map.triggerRepaint(), this._map._renderTaskQueue.add(t => { delete this._frameId, this.handleEvent(new ll("renderFrame", { timeStamp: t })), this._applyChanges() }) } _triggerRenderFrame() { this._frameId === void 0 && (this._frameId = this._requestFrame()) } } class Ln extends c.E { constructor(t, s, l) { super(), this._renderFrameCallback = () => { const d = Math.min(($e() - this._easeStart) / this._easeOptions.duration, 1); this._onEaseFrame(this._easeOptions.easing(d)), d < 1 && this._easeFrameId ? this._easeFrameId = this._requestRenderFrame(this._renderFrameCallback) : this.stop() }, this._moving = !1, this._zooming = !1, this.transform = t, this._bearingSnap = l.bearingSnap, this.cameraHelper = s, this.on("moveend", () => { delete this._requestedCameraState }) } migrateProjection(t, s) { t.apply(this.transform), this.transform = t, this.cameraHelper = s } getCenter() { return new c.V(this.transform.center.lng, this.transform.center.lat) } setCenter(t, s) { return this.jumpTo({ center: t }, s) } getCenterElevation() { return this.transform.elevation } setCenterElevation(t, s) { return this.jumpTo({ elevation: t }, s), this } getCenterClampedToGround() { return this._centerClampedToGround } setCenterClampedToGround(t) { this._centerClampedToGround = t } panBy(t, s, l) { return t = c.P.convert(t).mult(-1), this.panTo(this.transform.center, c.e({ offset: t }, s), l) } panTo(t, s, l) { return this.easeTo(c.e({ center: t }, s), l) } getZoom() { return this.transform.zoom } setZoom(t, s) { return this.jumpTo({ zoom: t }, s), this } zoomTo(t, s, l) { return this.easeTo(c.e({ zoom: t }, s), l) } zoomIn(t, s) { return this.zoomTo(this.getZoom() + 1, t, s), this } zoomOut(t, s) { return this.zoomTo(this.getZoom() - 1, t, s), this } getVerticalFieldOfView() { return this.transform.fov } setVerticalFieldOfView(t, s) { return t != this.transform.fov && (this.transform.setFov(t), this.fire(new c.l("movestart", s)).fire(new c.l("move", s)).fire(new c.l("moveend", s))), this } getBearing() { return this.transform.bearing } setBearing(t, s) { return this.jumpTo({ bearing: t }, s), this } getPadding() { return this.transform.padding } setPadding(t, s) { return this.jumpTo({ padding: t }, s), this } rotateTo(t, s, l) { return this.easeTo(c.e({ bearing: t }, s), l) } resetNorth(t, s) { return this.rotateTo(0, c.e({ duration: 1e3 }, t), s), this } resetNorthPitch(t, s) { return this.easeTo(c.e({ bearing: 0, pitch: 0, roll: 0, duration: 1e3 }, t), s), this } snapToNorth(t, s) { return Math.abs(this.getBearing()) < this._bearingSnap ? this.resetNorth(t, s) : this } getPitch() { return this.transform.pitch } setPitch(t, s) { return this.jumpTo({ pitch: t }, s), this } getRoll() { return this.transform.roll } setRoll(t, s) { return this.jumpTo({ roll: t }, s), this } cameraForBounds(t, s) { t = Pr.convert(t).adjustAntiMeridian(); const l = s && s.bearing || 0; return this._cameraForBoxAndBearing(t.getNorthWest(), t.getSouthEast(), l, s) } _cameraForBoxAndBearing(t, s, l, d) { const g = { top: 0, bottom: 0, right: 0, left: 0 }; if (typeof (d = c.e({ padding: g, offset: [0, 0], maxZoom: this.transform.maxZoom }, d)).padding == "number") { const I = d.padding; d.padding = { top: I, bottom: I, right: I, left: I } } const v = c.e(g, d.padding); d.padding = v; const T = this.transform, E = new Pr(t, s); return this.cameraHelper.cameraForBoxAndBearing(d, v, E, l, T) } fitBounds(t, s, l) { return this._fitInternal(this.cameraForBounds(t, s), s, l) } fitScreenCoordinates(t, s, l, d, g) { return this._fitInternal(this._cameraForBoxAndBearing(this.transform.screenPointToLocation(c.P.convert(t)), this.transform.screenPointToLocation(c.P.convert(s)), l, d), d, g) } _fitInternal(t, s, l) { return t ? (delete (s = c.e(t, s)).padding, s.linear ? this.easeTo(s, l) : this.flyTo(s, l)) : this } jumpTo(t, s) { this.stop(); const l = this._getTransformForUpdate(); let d = !1, g = !1, v = !1; const T = l.zoom; this.cameraHelper.handleJumpToCenterZoom(l, t); const E = l.zoom !== T; return "elevation" in t && l.elevation !== +t.elevation && l.setElevation(+t.elevation), "bearing" in t && l.bearing !== +t.bearing && (d = !0, l.setBearing(+t.bearing)), "pitch" in t && l.pitch !== +t.pitch && (g = !0, l.setPitch(+t.pitch)), "roll" in t && l.roll !== +t.roll && (v = !0, l.setRoll(+t.roll)), t.padding == null || l.isPaddingEqual(t.padding) || l.setPadding(t.padding), this._applyUpdatedTransform(l), this.fire(new c.l("movestart", s)).fire(new c.l("move", s)), E && this.fire(new c.l("zoomstart", s)).fire(new c.l("zoom", s)).fire(new c.l("zoomend", s)), d && this.fire(new c.l("rotatestart", s)).fire(new c.l("rotate", s)).fire(new c.l("rotateend", s)), g && this.fire(new c.l("pitchstart", s)).fire(new c.l("pitch", s)).fire(new c.l("pitchend", s)), v && this.fire(new c.l("rollstart", s)).fire(new c.l("roll", s)).fire(new c.l("rollend", s)), this.fire(new c.l("moveend", s)) } calculateCameraOptionsFromTo(t, s, l, d = 0) { const g = c.a9.fromLngLat(t, s), v = c.a9.fromLngLat(l, d), T = v.x - g.x, E = v.y - g.y, I = v.z - g.z, A = Math.hypot(T, E, I); if (A === 0) throw new Error("Can't calculate camera options with same From and To"); const R = Math.hypot(T, E), z = c.at(this.transform.cameraToCenterDistance / A / this.transform.tileSize), O = 180 * Math.atan2(T, -E) / Math.PI; let U = 180 * Math.acos(R / A) / Math.PI; return U = I < 0 ? 90 - U : 90 + U, { center: v.toLngLat(), elevation: d, zoom: z, pitch: U, bearing: O } } calculateCameraOptionsFromCameraLngLatAltRotation(t, s, l, d, g) { const v = this.transform.calculateCenterFromCameraLngLatAlt(t, s, l, d); return { center: v.center, elevation: v.elevation, zoom: v.zoom, bearing: l, pitch: d, roll: g } } easeTo(t, s) { this._stop(!1, t.easeId), ((t = c.e({ offset: [0, 0], duration: 500, easing: c.cy }, t)).animate === !1 || !t.essential && Ge.prefersReducedMotion) && (t.duration = 0); const l = this._getTransformForUpdate(), d = this.getBearing(), g = l.pitch, v = l.roll, T = "bearing" in t ? this._normalizeBearing(t.bearing, d) : d, E = "pitch" in t ? +t.pitch : g, I = "roll" in t ? this._normalizeBearing(t.roll, v) : v, A = "padding" in t ? t.padding : l.padding, R = c.P.convert(t.offset); let z, O; t.around && (z = c.V.convert(t.around), O = l.locationToScreenPoint(z)); const U = { moving: this._moving, zooming: this._zooming, rotating: this._rotating, pitching: this._pitching, rolling: this._rolling }, X = this.cameraHelper.handleEaseTo(l, { bearing: T, pitch: E, roll: I, padding: A, around: z, aroundPoint: O, offsetAsPoint: R, offset: t.offset, zoom: t.zoom, center: t.center }); return this._rotating = this._rotating || d !== T, this._pitching = this._pitching || E !== g, this._rolling = this._rolling || I !== v, this._padding = !l.isPaddingEqual(A), this._zooming = this._zooming || X.isZooming, this._easeId = t.easeId, this._prepareEase(s, t.noMoveStart, U), this.terrain && this._prepareElevation(X.elevationCenter), this._ease(Q => { X.easeFunc(Q), this.terrain && !t.freezeElevation && this._updateElevation(Q), this._applyUpdatedTransform(l), this._fireMoveEvents(s) }, Q => { this.terrain && t.freezeElevation && this._finalizeElevation(), this._afterEase(s, Q) }, t), this } _prepareEase(t, s, l = {}) { this._moving = !0, s || l.moving || this.fire(new c.l("movestart", t)), this._zooming && !l.zooming && this.fire(new c.l("zoomstart", t)), this._rotating && !l.rotating && this.fire(new c.l("rotatestart", t)), this._pitching && !l.pitching && this.fire(new c.l("pitchstart", t)), this._rolling && !l.rolling && this.fire(new c.l("rollstart", t)) } _prepareElevation(t) { this._elevationCenter = t, this._elevationStart = this.transform.elevation, this._elevationTarget = this.terrain.getElevationForLngLatZoom(t, this.transform.tileZoom), this._elevationFreeze = !0 } _updateElevation(t) { this._elevationStart !== void 0 && this._elevationCenter !== void 0 || this._prepareElevation(this.transform.center), this.transform.setMinElevationForCurrentTile(this.terrain.getMinTileElevationForLngLatZoom(this._elevationCenter, this.transform.tileZoom)); const s = this.terrain.getElevationForLngLatZoom(this._elevationCenter, this.transform.tileZoom); if (t < 1 && s !== this._elevationTarget) { const l = this._elevationTarget - this._elevationStart; this._elevationStart += t * (l - (s - (l * t + this._elevationStart)) / (1 - t)), this._elevationTarget = s } this.transform.setElevation(c.G.number(this._elevationStart, this._elevationTarget, t)) } _finalizeElevation() { this._elevationFreeze = !1, this.getCenterClampedToGround() && this.transform.recalculateZoomAndCenter(this.terrain) } _getTransformForUpdate() { return this.transformCameraUpdate || this.terrain ? (this._requestedCameraState || (this._requestedCameraState = this.transform.clone()), this._requestedCameraState) : this.transform } _elevateCameraIfInsideTerrain(t) { if (!this.terrain && t.elevation >= 0 && t.pitch <= 90) return {}; const s = t.getCameraLngLat(), l = t.getCameraAltitude(), d = this.terrain ? this.terrain.getElevationForLngLatZoom(s, t.zoom) : 0; if (l < d) { const g = this.calculateCameraOptionsFromTo(s, d, t.center, t.elevation); return { pitch: g.pitch, zoom: g.zoom } } return {} } _applyUpdatedTransform(t) { const s = []; if (s.push(d => this._elevateCameraIfInsideTerrain(d)), this.transformCameraUpdate && s.push(d => this.transformCameraUpdate(d)), !s.length) return; const l = t.clone(); for (const d of s) { const g = l.clone(), { center: v, zoom: T, roll: E, pitch: I, bearing: A, elevation: R } = d(g); v && g.setCenter(v), R !== void 0 && g.setElevation(R), T !== void 0 && g.setZoom(T), E !== void 0 && g.setRoll(E), I !== void 0 && g.setPitch(I), A !== void 0 && g.setBearing(A), l.apply(g) } this.transform.apply(l) } _fireMoveEvents(t) { this.fire(new c.l("move", t)), this._zooming && this.fire(new c.l("zoom", t)), this._rotating && this.fire(new c.l("rotate", t)), this._pitching && this.fire(new c.l("pitch", t)), this._rolling && this.fire(new c.l("roll", t)) } _afterEase(t, s) { if (this._easeId && s && this._easeId === s) return; delete this._easeId; const l = this._zooming, d = this._rotating, g = this._pitching, v = this._rolling; this._moving = !1, this._zooming = !1, this._rotating = !1, this._pitching = !1, this._rolling = !1, this._padding = !1, l && this.fire(new c.l("zoomend", t)), d && this.fire(new c.l("rotateend", t)), g && this.fire(new c.l("pitchend", t)), v && this.fire(new c.l("rollend", t)), this.fire(new c.l("moveend", t)) } flyTo(t, s) { if (!t.essential && Ge.prefersReducedMotion) { const Re = c.U(t, ["center", "zoom", "bearing", "pitch", "roll", "elevation", "padding"]); return this.jumpTo(Re, s) } this.stop(), t = c.e({ offset: [0, 0], speed: 1.2, curve: 1.42, easing: c.cy }, t); const l = this._getTransformForUpdate(), d = l.bearing, g = l.pitch, v = l.roll, T = l.padding, E = "bearing" in t ? this._normalizeBearing(t.bearing, d) : d, I = "pitch" in t ? +t.pitch : g, A = "roll" in t ? this._normalizeBearing(t.roll, v) : v, R = "padding" in t ? t.padding : l.padding, z = c.P.convert(t.offset); let O = l.centerPoint.add(z); const U = l.screenPointToLocation(O), X = this.cameraHelper.handleFlyTo(l, { bearing: E, pitch: I, roll: A, padding: R, locationAtOffset: U, offsetAsPoint: z, center: t.center, minZoom: t.minZoom, zoom: t.zoom }); let Q = t.curve; const Y = Math.max(l.width, l.height), te = Y / X.scaleOfZoom, le = X.pixelPathLength; typeof X.scaleOfMinZoom == "number" && (Q = Math.sqrt(Y / X.scaleOfMinZoom / le * 2)); const J = Q * Q; function oe(Re) { const Je = (te * te - Y * Y + (Re ? -1 : 1) * J * J * le * le) / (2 * (Re ? te : Y) * J * le); return Math.log(Math.sqrt(Je * Je + 1) - Je) } function ce(Re) { return (Math.exp(Re) - Math.exp(-Re)) / 2 } function se(Re) { return (Math.exp(Re) + Math.exp(-Re)) / 2 } const fe = oe(!1); let Oe = function (Re) { return se(fe) / se(fe + Q * Re) }, ke = function (Re) { return Y * ((se(fe) * (ce(Je = fe + Q * Re) / se(Je)) - ce(fe)) / J) / le; var Je }, ze = (oe(!0) - fe) / Q; if (Math.abs(le) < 2e-6 || !isFinite(ze)) { if (Math.abs(Y - te) < 1e-6) return this.easeTo(t, s); const Re = te < Y ? -1 : 1; ze = Math.abs(Math.log(te / Y)) / Q, ke = () => 0, Oe = Je => Math.exp(Re * Q * Je) } return t.duration = "duration" in t ? +t.duration : 1e3 * ze / ("screenSpeed" in t ? +t.screenSpeed / Q : +t.speed), t.maxDuration && t.duration > t.maxDuration && (t.duration = 0), this._zooming = !0, this._rotating = d !== E, this._pitching = I !== g, this._rolling = A !== v, this._padding = !l.isPaddingEqual(R), this._prepareEase(s, !1), this.terrain && this._prepareElevation(X.targetCenter), this._ease(Re => { const Je = Re * ze, tt = 1 / Oe(Je), We = ke(Je); this._rotating && l.setBearing(c.G.number(d, E, Re)), this._pitching && l.setPitch(c.G.number(g, I, Re)), this._rolling && l.setRoll(c.G.number(v, A, Re)), this._padding && (l.interpolatePadding(T, R, Re), O = l.centerPoint.add(z)), X.easeFunc(Re, tt, We, O), this.terrain && !t.freezeElevation && this._updateElevation(Re), this._applyUpdatedTransform(l), this._fireMoveEvents(s) }, () => { this.terrain && t.freezeElevation && this._finalizeElevation(), this._afterEase(s) }, t), this } isEasing() { return !!this._easeFrameId } stop() { return this._stop() } _stop(t, s) { var l; if (this._easeFrameId && (this._cancelRenderFrame(this._easeFrameId), delete this._easeFrameId, delete this._onEaseFrame), this._onEaseEnd) { const d = this._onEaseEnd; delete this._onEaseEnd, d.call(this, s) } return t || (l = this.handlers) === null || l === void 0 || l.stop(!1), this } _ease(t, s, l) { l.animate === !1 || l.duration === 0 ? (t(1), s()) : (this._easeStart = $e(), this._easeOptions = l, this._onEaseFrame = t, this._onEaseEnd = s, this._easeFrameId = this._requestRenderFrame(this._renderFrameCallback)) } _normalizeBearing(t, s) { t = c.W(t, -180, 180); const l = Math.abs(t - s); return Math.abs(t - 360 - s) < l && (t -= 360), Math.abs(t + 360 - s) < l && (t += 360), t } queryTerrainElevation(t) { return this.terrain ? this.terrain.getElevationForLngLat(c.V.convert(t), this.transform) : null } } const ci = { compact: !0, customAttribution: '<a href="https://maplibre.org/" target="_blank">MapLibre</a>' }; class ph { constructor(t = ci) { this._toggleAttribution = () => { this._container.classList.contains("maplibregl-compact") && (this._container.classList.contains("maplibregl-compact-show") ? (this._container.setAttribute("open", ""), this._container.classList.remove("maplibregl-compact-show")) : (this._container.classList.add("maplibregl-compact-show"), this._container.removeAttribute("open"))) }, this._updateData = s => { !s || s.sourceDataType !== "metadata" && s.sourceDataType !== "visibility" && s.dataType !== "style" && s.type !== "terrain" || this._updateAttributions() }, this._updateCompact = () => { this._map.getCanvasContainer().offsetWidth <= 640 || this._compact ? this._compact === !1 ? this._container.setAttribute("open", "") : this._container.classList.contains("maplibregl-compact") || this._container.classList.contains("maplibregl-attrib-empty") || (this._container.setAttribute("open", ""), this._container.classList.add("maplibregl-compact", "maplibregl-compact-show")) : (this._container.setAttribute("open", ""), this._container.classList.contains("maplibregl-compact") && this._container.classList.remove("maplibregl-compact", "maplibregl-compact-show")) }, this._updateCompactMinimize = () => { this._container.classList.contains("maplibregl-compact") && this._container.classList.contains("maplibregl-compact-show") && this._container.classList.remove("maplibregl-compact-show") }, this.options = t } getDefaultPosition() { return "bottom-right" } onAdd(t) { return this._map = t, this._compact = this.options.compact, this._container = ye.create("details", "maplibregl-ctrl maplibregl-ctrl-attrib"), this._compactButton = ye.create("summary", "maplibregl-ctrl-attrib-button", this._container), this._compactButton.addEventListener("click", this._toggleAttribution), this._setElementTitle(this._compactButton, "ToggleAttribution"), this._innerContainer = ye.create("div", "maplibregl-ctrl-attrib-inner", this._container), this._updateAttributions(), this._updateCompact(), this._map.on("styledata", this._updateData), this._map.on("sourcedata", this._updateData), this._map.on("terrain", this._updateData), this._map.on("resize", this._updateCompact), this._map.on("drag", this._updateCompactMinimize), this._container } onRemove() { ye.remove(this._container), this._map.off("styledata", this._updateData), this._map.off("sourcedata", this._updateData), this._map.off("terrain", this._updateData), this._map.off("resize", this._updateCompact), this._map.off("drag", this._updateCompactMinimize), this._map = void 0, this._compact = void 0, this._attribHTML = void 0 } _setElementTitle(t, s) { const l = this._map._getUIString(`AttributionControl.${s}`); t.title = l, t.setAttribute("aria-label", l) } _updateAttributions() { if (!this._map.style) return; let t = []; if (this.options.customAttribution && (Array.isArray(this.options.customAttribution) ? t = t.concat(this.options.customAttribution.map(d => typeof d != "string" ? "" : d)) : typeof this.options.customAttribution == "string" && t.push(this.options.customAttribution)), this._map.style.stylesheet) { const d = this._map.style.stylesheet; this.styleOwner = d.owner, this.styleId = d.id } const s = this._map.style.tileManagers; for (const d in s) { const g = s[d]; if (g.used || g.usedForTerrain) { const v = g.getSource(); v.attribution && t.indexOf(v.attribution) < 0 && t.push(v.attribution) } } t = t.filter(d => String(d).trim()), t.sort((d, g) => d.length - g.length), t = t.filter((d, g) => { for (let v = g + 1; v < t.length; v++)if (t[v].indexOf(d) >= 0) return !1; return !0 }); const l = t.join(" | "); l !== this._attribHTML && (this._attribHTML = l, t.length ? (this._innerContainer.innerHTML = ye.sanitize(l), this._container.classList.remove("maplibregl-attrib-empty")) : this._container.classList.add("maplibregl-attrib-empty"), this._updateCompact(), this._editLink = null) } } class Fp { constructor(t = {}) { this._updateCompact = () => { const s = this._container.children; if (s.length) { const l = s[0]; this._map.getCanvasContainer().offsetWidth <= 640 || this._compact ? this._compact !== !1 && l.classList.add("maplibregl-compact") : l.classList.remove("maplibregl-compact") } }, this.options = t } getDefaultPosition() { return "bottom-left" } onAdd(t) { this._map = t, this._compact = this.options && this.options.compact, this._container = ye.create("div", "maplibregl-ctrl"); const s = ye.create("a", "maplibregl-ctrl-logo"); return s.target = "_blank", s.rel = "noopener nofollow", s.href = "https://maplibre.org/", s.setAttribute("aria-label", this._map._getUIString("LogoControl.Title")), s.setAttribute("rel", "noopener nofollow"), this._container.appendChild(s), this._container.style.display = "block", this._map.on("resize", this._updateCompact), this._updateCompact(), this._container } onRemove() { ye.remove(this._container), this._map.off("resize", this._updateCompact), this._map = void 0, this._compact = void 0 } } class sg { constructor() { this._queue = [], this._id = 0, this._cleared = !1, this._currentlyRunning = !1 } add(t) { const s = ++this._id; return this._queue.push({ callback: t, id: s, cancelled: !1 }), s } remove(t) { const s = this._currentlyRunning, l = s ? this._queue.concat(s) : this._queue; for (const d of l) if (d.id === t) return void (d.cancelled = !0) } run(t = 0) { if (this._currentlyRunning) throw new Error("Attempting to run(), but is already running."); const s = this._currentlyRunning = this._queue; this._queue = []; for (const l of s) if (!l.cancelled && (l.callback(t), this._cleared)) break; this._cleared = !1, this._currentlyRunning = !1 } clear() { this._currentlyRunning && (this._cleared = !0), this._queue = [] } } var og = c.aU([{ name: "a_pos3d", type: "Int16", components: 3 }]); class ul extends c.E { constructor(t) { super(), this._lastTilesetChange = $e(), this.tileManager = t, this._tiles = {}, this._renderableTilesKeys = [], this._sourceTileCache = {}, this.minzoom = 0, this.maxzoom = 22, this.deltaZoom = 1, this.tileSize = t._source.tileSize * 2 ** this.deltaZoom, t.usedForTerrain = !0, t.tileSize = this.tileSize } destruct() { this.tileManager.usedForTerrain = !1, this.tileManager.tileSize = null } getSource() { return this.tileManager._source } update(t, s) { this.tileManager.update(t, s), this._renderableTilesKeys = []; const l = {}; for (const d of Mr(t, { tileSize: this.tileSize, minzoom: this.minzoom, maxzoom: this.maxzoom, reparseOverscaled: !1, terrain: s, calculateTileZoom: this.tileManager._source.calculateTileZoom })) l[d.key] = !0, this._renderableTilesKeys.push(d.key), this._tiles[d.key] || (d.terrainRttPosMatrix32f = new Float64Array(16), c.c7(d.terrainRttPosMatrix32f, 0, c.a5, c.a5, 0, 0, 1), this._tiles[d.key] = new Xe(d, this.tileSize), this._lastTilesetChange = $e()); for (const d in this._tiles) l[d] || delete this._tiles[d] } freeRtt(t) { for (const s in this._tiles) { const l = this._tiles[s]; (!t || l.tileID.equals(t) || l.tileID.isChildOf(t) || t.isChildOf(l.tileID)) && (l.rtt = []) } } getRenderableTiles() { return this._renderableTilesKeys.map(t => this.getTileByID(t)) } getTileByID(t) { return this._tiles[t] } getTerrainCoords(t, s) { return s ? this._getTerrainCoordsForTileRanges(t, s) : this._getTerrainCoordsForRegularTile(t) } _getTerrainCoordsForRegularTile(t) { const s = {}; for (const l of this._renderableTilesKeys) { const d = this._tiles[l].tileID, g = t.clone(), v = c.bk(); if (d.canonical.equals(t.canonical)) c.c7(v, 0, c.a5, c.a5, 0, 0, 1); else if (d.canonical.isChildOf(t.canonical)) { const T = d.canonical.z - t.canonical.z, E = d.canonical.x - (d.canonical.x >> T << T), I = d.canonical.y - (d.canonical.y >> T << T), A = c.a5 >> T; c.c7(v, 0, A, A, 0, 0, 1), c.O(v, v, [-E * A, -I * A, 0]) } else { if (!t.canonical.isChildOf(d.canonical)) continue; { const T = t.canonical.z - d.canonical.z, E = t.canonical.x - (t.canonical.x >> T << T), I = t.canonical.y - (t.canonical.y >> T << T), A = c.a5 >> T; c.c7(v, 0, c.a5, c.a5, 0, 0, 1), c.O(v, v, [E * A, I * A, 0]), c.Q(v, v, [1 / 2 ** T, 1 / 2 ** T, 0]) } } g.terrainRttPosMatrix32f = new Float32Array(v), s[l] = g } return s } _getTerrainCoordsForTileRanges(t, s) { const l = {}; for (const d of this._renderableTilesKeys) { const g = this._tiles[d].tileID; if (!this._isWithinTileRanges(g, s)) continue; const v = t.clone(), T = c.bk(); if (g.canonical.z === t.canonical.z) { const E = t.canonical.x - g.canonical.x, I = t.canonical.y - g.canonical.y; c.c7(T, 0, c.a5, c.a5, 0, 0, 1), c.O(T, T, [E * c.a5, I * c.a5, 0]) } else if (g.canonical.z > t.canonical.z) { const E = g.canonical.z - t.canonical.z, I = g.canonical.x - (g.canonical.x >> E << E), A = g.canonical.y - (g.canonical.y >> E << E), R = t.canonical.x - (g.canonical.x >> E), z = t.canonical.y - (g.canonical.y >> E), O = c.a5 >> E; c.c7(T, 0, O, O, 0, 0, 1), c.O(T, T, [-I * O + R * c.a5, -A * O + z * c.a5, 0]) } else { const E = t.canonical.z - g.canonical.z, I = t.canonical.x - (t.canonical.x >> E << E), A = t.canonical.y - (t.canonical.y >> E << E), R = (t.canonical.x >> E) - g.canonical.x, z = (t.canonical.y >> E) - g.canonical.y, O = c.a5 << E; c.c7(T, 0, O, O, 0, 0, 1), c.O(T, T, [I * c.a5 + R * O, A * c.a5 + z * O, 0]) } v.terrainRttPosMatrix32f = new Float32Array(T), l[d] = v } return l } getSourceTile(t, s) { const l = this.tileManager._source; let d = t.overscaledZ - this.deltaZoom; if (d > l.maxzoom && (d = l.maxzoom), d < l.minzoom) return; this._sourceTileCache[t.key] || (this._sourceTileCache[t.key] = t.scaledTo(d).key); let g = this.findTileInCaches(this._sourceTileCache[t.key]); if (!(g != null && g.dem) && s) for (; d >= l.minzoom && !(g != null && g.dem);)g = this.findTileInCaches(t.scaledTo(d--).key); return g } findTileInCaches(t) { let s = this.tileManager.getTileByID(t); return s || (s = this.tileManager._outOfViewCache.getByKey(t), s) } anyTilesAfterTime(t = Date.now()) { return this._lastTilesetChange >= t } _isWithinTileRanges(t, s) { return s[t.canonical.z] && t.canonical.x >= s[t.canonical.z].minTileX && t.canonical.x <= s[t.canonical.z].maxTileX && t.canonical.y >= s[t.canonical.z].minTileY && t.canonical.y <= s[t.canonical.z].maxTileY } } class Tr { constructor(t, s, l) { this._meshCache = {}, this.painter = t, this.tileManager = new ul(s), this.options = l, this.exaggeration = typeof l.exaggeration == "number" ? l.exaggeration : 1, this.qualityFactor = 2, this.meshSize = 128, this._demMatrixCache = {}, this.coordsIndex = [], this._coordsTextureSize = 1024 } getDEMElevation(t, s, l, d = c.a5) { var g; if (!(s >= 0 && s < d && l >= 0 && l < d)) return 0; const v = this.getTerrainData(t), T = (g = v.tile) === null || g === void 0 ? void 0 : g.dem; if (!T) return 0; const E = c.cC([], [s / d * c.a5, l / d * c.a5], v.u_terrain_matrix), I = [E[0] * T.dim, E[1] * T.dim], A = Math.floor(I[0]), R = Math.floor(I[1]), z = I[0] - A, O = I[1] - R; return T.get(A, R) * (1 - z) * (1 - O) + T.get(A + 1, R) * z * (1 - O) + T.get(A, R + 1) * (1 - z) * O + T.get(A + 1, R + 1) * z * O } getElevationForLngLatZoom(t, s) { if (!c.cD(s, t.wrap())) return 0; const { tileID: l, mercatorX: d, mercatorY: g } = this._getOverscaledTileIDFromLngLatZoom(t, s); return this.getElevation(l, d % c.a5, g % c.a5, c.a5) } getElevationForLngLat(t, s) { const l = Mr(s, { maxzoom: this.tileManager.maxzoom, minzoom: this.tileManager.minzoom, tileSize: 512, terrain: this }); let d = 0; for (const g of l) g.canonical.z > d && (d = Math.min(g.canonical.z, this.tileManager.maxzoom)); return this.getElevationForLngLatZoom(t, d) } getElevation(t, s, l, d = c.a5) { return this.getDEMElevation(t, s, l, d) * this.exaggeration } getTerrainData(t) { if (!this._emptyDemTexture) { const d = this.painter.context, g = new c.R({ width: 1, height: 1 }, new Uint8Array(4)); this._emptyDepthTexture = new c.T(d, g, d.gl.RGBA, { premultiply: !1 }), this._emptyDemUnpack = [0, 0, 0, 0], this._emptyDemTexture = new c.T(d, new c.R({ width: 1, height: 1 }), d.gl.RGBA, { premultiply: !1 }), this._emptyDemTexture.bind(d.gl.NEAREST, d.gl.CLAMP_TO_EDGE), this._emptyDemMatrix = c.ar([]) } const s = this.tileManager.getSourceTile(t, !0); if (s && s.dem && (!s.demTexture || s.needsTerrainPrepare)) { const d = this.painter.context; s.demTexture = this.painter.getTileTexture(s.dem.stride), s.demTexture ? s.demTexture.update(s.dem.getPixels(), { premultiply: !1 }) : s.demTexture = new c.T(d, s.dem.getPixels(), d.gl.RGBA, { premultiply: !1 }), s.demTexture.bind(d.gl.NEAREST, d.gl.CLAMP_TO_EDGE), s.needsTerrainPrepare = !1 } const l = s && s.toString() + s.tileID.key + t.key; if (l && !this._demMatrixCache[l]) { const d = this.tileManager.getSource().maxzoom; let g = t.canonical.z - s.tileID.canonical.z; t.overscaledZ > t.canonical.z && (t.canonical.z >= d ? g = t.canonical.z - d : c.w("cannot calculate elevation if elevation maxzoom > source.maxzoom")); const v = t.canonical.x - (t.canonical.x >> g << g), T = t.canonical.y - (t.canonical.y >> g << g), E = c.cE(new Float64Array(16), [1 / (c.a5 << g), 1 / (c.a5 << g), 0]); c.O(E, E, [v * c.a5, T * c.a5, 0]), this._demMatrixCache[t.key] = { matrix: E, coord: t } } return { u_depth: 2, u_terrain: 3, u_terrain_dim: s && s.dem && s.dem.dim || 1, u_terrain_matrix: l ? this._demMatrixCache[t.key].matrix : this._emptyDemMatrix, u_terrain_unpack: s && s.dem && s.dem.getUnpackVector() || this._emptyDemUnpack, u_terrain_exaggeration: this.exaggeration, texture: (s && s.demTexture || this._emptyDemTexture).texture, depthTexture: (this._fboDepthTexture || this._emptyDepthTexture).texture, tile: s } } getFramebuffer(t) { const s = this.painter, l = s.width / devicePixelRatio, d = s.height / devicePixelRatio; return !this._fbo || this._fbo.width === l && this._fbo.height === d || (this._fbo.destroy(), this._fboCoordsTexture.destroy(), this._fboDepthTexture.destroy(), delete this._fbo, delete this._fboDepthTexture, delete this._fboCoordsTexture), this._fboCoordsTexture || (this._fboCoordsTexture = new c.T(s.context, { width: l, height: d, data: null }, s.context.gl.RGBA, { premultiply: !1 }), this._fboCoordsTexture.bind(s.context.gl.NEAREST, s.context.gl.CLAMP_TO_EDGE)), this._fboDepthTexture || (this._fboDepthTexture = new c.T(s.context, { width: l, height: d, data: null }, s.context.gl.RGBA, { premultiply: !1 }), this._fboDepthTexture.bind(s.context.gl.NEAREST, s.context.gl.CLAMP_TO_EDGE)), this._fbo || (this._fbo = s.context.createFramebuffer(l, d, !0, !1), this._fbo.depthAttachment.set(s.context.createRenderbuffer(s.context.gl.DEPTH_COMPONENT16, l, d))), this._fbo.colorAttachment.set(t === "coords" ? this._fboCoordsTexture.texture : this._fboDepthTexture.texture), this._fbo } getCoordsTexture() { const t = this.painter.context; if (this._coordsTexture) return this._coordsTexture; const s = new Uint8Array(this._coordsTextureSize * this._coordsTextureSize * 4); for (let g = 0, v = 0; g < this._coordsTextureSize; g++)for (let T = 0; T < this._coordsTextureSize; T++, v += 4)s[v + 0] = 255 & T, s[v + 1] = 255 & g, s[v + 2] = T >> 8 << 4 | g >> 8, s[v + 3] = 0; const l = new c.R({ width: this._coordsTextureSize, height: this._coordsTextureSize }, new Uint8Array(s.buffer)), d = new c.T(t, l, t.gl.RGBA, { premultiply: !1 }); return d.bind(t.gl.NEAREST, t.gl.CLAMP_TO_EDGE), this._coordsTexture = d, d } pointCoordinate(t) { this.painter.maybeDrawDepthAndCoords(!0); const s = new Uint8Array(4), l = this.painter.context, d = l.gl, g = Math.round(t.x * this.painter.pixelRatio / devicePixelRatio), v = Math.round(t.y * this.painter.pixelRatio / devicePixelRatio), T = Math.round(this.painter.height / devicePixelRatio); l.bindFramebuffer.set(this.getFramebuffer("coords").framebuffer), d.readPixels(g, T - v - 1, 1, 1, d.RGBA, d.UNSIGNED_BYTE, s), l.bindFramebuffer.set(null); const E = s[0] + (s[2] >> 4 << 8), I = s[1] + ((15 & s[2]) << 8), A = this.coordsIndex[255 - s[3]], R = A && this.tileManager.getTileByID(A); if (!R) return null; const z = this._coordsTextureSize, O = (1 << R.tileID.canonical.z) * z; return new c.a9((R.tileID.canonical.x * z + E) / O + R.tileID.wrap, (R.tileID.canonical.y * z + I) / O, this.getElevation(R.tileID, E, I, z)) } depthAtPoint(t) { const s = new Uint8Array(4), l = this.painter.context, d = l.gl; return l.bindFramebuffer.set(this.getFramebuffer("depth").framebuffer), d.readPixels(t.x, this.painter.height / devicePixelRatio - t.y - 1, 1, 1, d.RGBA, d.UNSIGNED_BYTE, s), l.bindFramebuffer.set(null), (s[0] / 16777216 + s[1] / 65536 + s[2] / 256 + s[3]) / 256 } getTerrainMesh(t) { var s; const l = ((s = this.painter.style.projection) === null || s === void 0 ? void 0 : s.transitionState) > 0, d = l && t.canonical.y === 0, g = l && t.canonical.y === (1 << t.canonical.z) - 1, v = `m_${d ? "n" : ""}_${g ? "s" : ""}`; if (this._meshCache[v]) return this._meshCache[v]; const T = this.painter.context, E = new c.cF, I = new c.aY, A = this.meshSize, R = c.a5 / A, z = A * A; for (let se = 0; se <= A; se++)for (let fe = 0; fe <= A; fe++)E.emplaceBack(fe * R, se * R, 0); for (let se = 0; se < z; se += A + 1)for (let fe = 0; fe < A; fe++)I.emplaceBack(fe + se, A + fe + se + 1, A + fe + se + 2), I.emplaceBack(fe + se, A + fe + se + 2, fe + se + 1); const O = E.length, U = O + (A + 1), X = (A + 1) * A, Q = d ? c.br : 0, Y = d ? 0 : 1, te = g ? c.bs : c.a5, le = g ? 0 : 1; for (let se = 0; se <= A; se++)E.emplaceBack(se * R, Q, Y); for (let se = 0; se <= A; se++)E.emplaceBack(se * R, te, le); for (let se = 0; se < A; se++)I.emplaceBack(X + se, U + se, U + se + 1), I.emplaceBack(X + se, U + se + 1, X + se + 1), I.emplaceBack(0 + se, O + se + 1, O + se), I.emplaceBack(0 + se, 0 + se + 1, O + se + 1); const J = E.length, oe = J + 2 * (A + 1); for (const se of [0, 1]) for (let fe = 0; fe <= A; fe++)for (const Oe of [0, 1]) E.emplaceBack(se * c.a5, fe * R, Oe); for (let se = 0; se < 2 * A; se += 2)I.emplaceBack(J + se, J + se + 1, J + se + 3), I.emplaceBack(J + se, J + se + 3, J + se + 2), I.emplaceBack(oe + se, oe + se + 3, oe + se + 1), I.emplaceBack(oe + se, oe + se + 2, oe + se + 3); const ce = new sr(T.createVertexBuffer(E, og.members), T.createIndexBuffer(I), c.aX.simpleSegment(0, 0, E.length, I.length)); return this._meshCache[v] = ce, ce } getMeshFrameDelta(t) { return 2 * Math.PI * c.bE / Math.pow(2, Math.max(t, 0)) / 5 } getMinTileElevationForLngLatZoom(t, s) { var l; if (!c.cD(s, t.wrap())) return 0; const { tileID: d } = this._getOverscaledTileIDFromLngLatZoom(t, s); return (l = this.getMinMaxElevation(d).minElevation) !== null && l !== void 0 ? l : 0 } getMinMaxElevation(t) { const s = this.getTerrainData(t).tile, l = { minElevation: null, maxElevation: null }; return s && s.dem && (l.minElevation = s.dem.min * this.exaggeration, l.maxElevation = s.dem.max * this.exaggeration), l } _getOverscaledTileIDFromLngLatZoom(t, s) { const l = c.a9.fromLngLat(t.wrap()), d = (1 << s) * c.a5, g = l.x * d, v = l.y * d, T = Math.floor(g / c.a5), E = Math.floor(v / c.a5); return { tileID: new c.a2(s, 0, s, T, E), mercatorX: g, mercatorY: v } } } class Br { constructor(t, s, l) { this._context = t, this._size = s, this._tileSize = l, this._objects = [], this._recentlyUsed = [], this._stamp = 0 } destruct() { for (const t of this._objects) t.texture.destroy(), t.fbo.destroy() } _createObject(t) { const s = this._context.createFramebuffer(this._tileSize, this._tileSize, !0, !0), l = new c.T(this._context, { width: this._tileSize, height: this._tileSize, data: null }, this._context.gl.RGBA); return l.bind(this._context.gl.LINEAR, this._context.gl.CLAMP_TO_EDGE), this._context.extTextureFilterAnisotropic && this._context.gl.texParameterf(this._context.gl.TEXTURE_2D, this._context.extTextureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT, this._context.extTextureFilterAnisotropicMax), s.depthAttachment.set(this._context.createRenderbuffer(this._context.gl.DEPTH_STENCIL, this._tileSize, this._tileSize)), s.colorAttachment.set(l.texture), { id: t, fbo: s, texture: l, stamp: -1, inUse: !1 } } getObjectForId(t) { return this._objects[t] } useObject(t) { t.inUse = !0, this._recentlyUsed = this._recentlyUsed.filter(s => t.id !== s), this._recentlyUsed.push(t.id) } stampObject(t) { t.stamp = ++this._stamp } getOrCreateFreeObject() { for (const s of this._recentlyUsed) if (!this._objects[s].inUse) return this._objects[s]; if (this._objects.length >= this._size) throw new Error("No free RenderPool available, call freeAllObjects() required!"); const t = this._createObject(this._objects.length); return this._objects.push(t), t } freeObject(t) { t.inUse = !1 } freeAllObjects() { for (const t of this._objects) this.freeObject(t) } isFull() { return !(this._objects.length < this._size) && this._objects.some(t => !t.inUse) === !1 } } const no = { background: !0, fill: !0, line: !0, raster: !0, hillshade: !0, "color-relief": !0 }; class cl { constructor(t, s) { this.painter = t, this.terrain = s, this.pool = new Br(t.context, 30, s.tileManager.tileSize * s.qualityFactor) } destruct() { this.pool.destruct() } getTexture(t) { return this.pool.getObjectForId(t.rtt[this._stacks.length - 1].id).texture } prepareForRender(t, s) { this._stacks = [], this._prevType = null, this._rttTiles = [], this._renderableTiles = this.terrain.tileManager.getRenderableTiles(), this._renderableLayerIds = t._order.filter(l => !t._layers[l].isHidden(s)), this._coordsAscending = {}; for (const l in t.tileManagers) { this._coordsAscending[l] = {}; const d = t.tileManagers[l].getVisibleCoordinates(), g = t.tileManagers[l].getSource(), v = g instanceof jn ? g.terrainTileRanges : null; for (const T of d) { const E = this.terrain.tileManager.getTerrainCoords(T, v); for (const I in E) this._coordsAscending[l][I] || (this._coordsAscending[l][I] = []), this._coordsAscending[l][I].push(E[I]) } } this._coordsAscendingStr = {}; for (const l of t._order) { const d = t._layers[l], g = d.source; if (no[d.type] && !this._coordsAscendingStr[g]) { this._coordsAscendingStr[g] = {}; for (const v in this._coordsAscending[g]) this._coordsAscendingStr[g][v] = this._coordsAscending[g][v].map(T => T.key).sort().join() } } for (const l of this._renderableTiles) for (const d in this._coordsAscendingStr) { const g = this._coordsAscendingStr[d][l.tileID.key]; g && g !== l.rttCoords[d] && (l.rtt = []) } } renderLayer(t, s) { if (t.isHidden(this.painter.transform.zoom)) return !1; const l = Object.assign(Object.assign({}, s), { isRenderingToTexture: !0 }), d = t.type, g = this.painter, v = this._renderableLayerIds[this._renderableLayerIds.length - 1] === t.id; if (no[d] && (this._prevType && no[this._prevType] || this._stacks.push([]), this._prevType = d, this._stacks[this._stacks.length - 1].push(t.id), !v)) return !0; if (no[this._prevType] || no[d] && v) { this._prevType = d; const T = this._stacks.length - 1, E = this._stacks[T] || []; for (const I of this._renderableTiles) { if (this.pool.isFull() && (rh(this.painter, this.terrain, this._rttTiles, l), this._rttTiles = [], this.pool.freeAllObjects()), this._rttTiles.push(I), I.rtt[T]) { const R = this.pool.getObjectForId(I.rtt[T].id); if (R.stamp === I.rtt[T].stamp) { this.pool.useObject(R); continue } } const A = this.pool.getOrCreateFreeObject(); this.pool.useObject(A), this.pool.stampObject(A), I.rtt[T] = { id: A.id, stamp: A.stamp }, g.context.bindFramebuffer.set(A.fbo.framebuffer), g.context.clear({ color: c.bp.transparent, stencil: 0 }), g.currentStencilSource = void 0; for (let R = 0; R < E.length; R++) { const z = g.style._layers[E[R]], O = z.source ? this._coordsAscending[z.source][I.tileID.key] : [I.tileID]; g.context.viewport.set([0, 0, A.fbo.width, A.fbo.height]), g._renderTileClippingMasks(z, O, !0), g.renderLayer(g, g.style.tileManagers[z.source], z, O, l), z.source && (I.rttCoords[z.source] = this._coordsAscendingStr[z.source][I.tileID.key]) } } return rh(this.painter, this.terrain, this._rttTiles, l), this._rttTiles = [], this.pool.freeAllObjects(), no[d] } return !1 } } const Su = { "AttributionControl.ToggleAttribution": "Toggle attribution", "AttributionControl.MapFeedback": "Map feedback", "FullscreenControl.Enter": "Enter fullscreen", "FullscreenControl.Exit": "Exit fullscreen", "GeolocateControl.FindMyLocation": "Find my location", "GeolocateControl.LocationNotAvailable": "Location not available", "LogoControl.Title": "MapLibre logo", "Map.Title": "Map", "Marker.Title": "Map marker", "NavigationControl.ResetBearing": "Reset bearing to north", "NavigationControl.ZoomIn": "Zoom in", "NavigationControl.ZoomOut": "Zoom out", "Popup.Close": "Close popup", "ScaleControl.Feet": "ft", "ScaleControl.Meters": "m", "ScaleControl.Kilometers": "km", "ScaleControl.Miles": "mi", "ScaleControl.NauticalMiles": "nm", "GlobeControl.Enable": "Enable globe", "GlobeControl.Disable": "Disable globe", "TerrainControl.Enable": "Enable terrain", "TerrainControl.Disable": "Disable terrain", "CooperativeGesturesHandler.WindowsHelpText": "Use Ctrl + scroll to zoom the map", "CooperativeGesturesHandler.MacHelpText": "Use  + scroll to zoom the map", "CooperativeGesturesHandler.MobileHelpText": "Use two fingers to move the map" }, fh = B, Eu = { hash: !1, interactive: !0, bearingSnap: 7, attributionControl: ci, maplibreLogo: !1, refreshExpiredTiles: !0, canvasContextAttributes: { antialias: !1, preserveDrawingBuffer: !1, powerPreference: "high-performance", failIfMajorPerformanceCaveat: !1, desynchronized: !1, contextType: void 0 }, scrollZoom: !0, minZoom: -2, maxZoom: 22, minPitch: 0, maxPitch: 60, boxZoom: !0, dragRotate: !0, dragPan: !0, keyboard: !0, doubleClickZoom: !0, touchZoomRotate: !0, touchPitch: !0, cooperativeGestures: !1, trackResize: !0, center: [0, 0], elevation: 0, zoom: 0, bearing: 0, pitch: 0, roll: 0, renderWorldCopies: !0, maxTileCacheSize: null, maxTileCacheZoomLevels: c.c.MAX_TILE_CACHE_ZOOM_LEVELS, transformRequest: null, transformCameraUpdate: null, transformConstrain: null, fadeDuration: 300, crossSourceCollisions: !0, clickTolerance: 3, localIdeographFontFamily: "sans-serif", pitchWithRotate: !0, rollEnabled: !1, reduceMotion: void 0, validateStyle: !0, maxCanvasSize: [4096, 4096], cancelPendingTileRequestsWhileZooming: !0, centerClampedToGround: !0, experimentalZoomLevelsToOverscale: void 0 }, mh = { showCompass: !0, showZoom: !0, visualizePitch: !1, visualizeRoll: !0 }; class hl { constructor(t, s, l = !1) { this.mousedown = g => { this.startMove(g, ye.mousePos(this.element, g)), ye.addEventListener(window, "mousemove", this.mousemove), ye.addEventListener(window, "mouseup", this.mouseup) }, this.mousemove = g => { this.move(g, ye.mousePos(this.element, g)) }, this.mouseup = g => { this._rotatePitchHandler.dragEnd(g), this.offTemp() }, this.touchstart = g => { g.targetTouches.length !== 1 ? this.reset() : (this._startPos = this._lastPos = ye.touchPos(this.element, g.targetTouches)[0], this.startMove(g, this._startPos), ye.addEventListener(window, "touchmove", this.touchmove, { passive: !1 }), ye.addEventListener(window, "touchend", this.touchend)) }, this.touchmove = g => { g.targetTouches.length !== 1 ? this.reset() : (this._lastPos = ye.touchPos(this.element, g.targetTouches)[0], this.move(g, this._lastPos)) }, this.touchend = g => { g.targetTouches.length === 0 && this._startPos && this._lastPos && this._startPos.dist(this._lastPos) < this._clickTolerance && this.element.click(), delete this._startPos, delete this._lastPos, this.offTemp() }, this.reset = () => { this._rotatePitchHandler.reset(), delete this._startPos, delete this._lastPos, this.offTemp() }, this._clickTolerance = 10, this.element = s; const d = new Cp; this._rotatePitchHandler = new Qo({ clickTolerance: 3, move: (g, v) => { const T = s.getBoundingClientRect(), E = new c.P((T.bottom - T.top) / 2, (T.right - T.left) / 2); return { bearingDelta: c.cx(new c.P(g.x, v.y), v, E), pitchDelta: l ? -.5 * (v.y - g.y) : void 0 } }, moveStateManager: d, enable: !0, assignEvents: () => { } }), this.map = t, ye.addEventListener(s, "mousedown", this.mousedown), ye.addEventListener(s, "touchstart", this.touchstart, { passive: !1 }), ye.addEventListener(s, "touchcancel", this.reset) } startMove(t, s) { this._rotatePitchHandler.dragStart(t, s), ye.disableDrag() } move(t, s) { const l = this.map, { bearingDelta: d, pitchDelta: g } = this._rotatePitchHandler.dragMove(t, s) || {}; d && l.setBearing(l.getBearing() + d), g && l.setPitch(l.getPitch() + g) } off() { const t = this.element; ye.removeEventListener(t, "mousedown", this.mousedown), ye.removeEventListener(t, "touchstart", this.touchstart, { passive: !1 }), ye.removeEventListener(window, "touchmove", this.touchmove, { passive: !1 }), ye.removeEventListener(window, "touchend", this.touchend), ye.removeEventListener(t, "touchcancel", this.reset), this.offTemp() } offTemp() { ye.enableDrag(), ye.removeEventListener(window, "mousemove", this.mousemove), ye.removeEventListener(window, "mouseup", this.mouseup), ye.removeEventListener(window, "touchmove", this.touchmove, { passive: !1 }), ye.removeEventListener(window, "touchend", this.touchend) } } let rs; function Pu(m, t, s, l = !1) { if (l || !s.getCoveringTilesDetailsProvider().allowWorldCopies()) return m == null ? void 0 : m.wrap(); const d = new c.V(m.lng, m.lat); if (m = new c.V(m.lng, m.lat), t) { const g = new c.V(m.lng - 360, m.lat), v = new c.V(m.lng + 360, m.lat), T = s.locationToScreenPoint(m).distSqr(t); s.locationToScreenPoint(g).distSqr(t) < T ? m = g : s.locationToScreenPoint(v).distSqr(t) < T && (m = v) } for (; Math.abs(m.lng - s.center.lng) > 180;) { const g = s.locationToScreenPoint(m); if (g.x >= 0 && g.y >= 0 && g.x <= s.width && g.y <= s.height) break; m.lng > s.center.lng ? m.lng -= 360 : m.lng += 360 } return m.lng !== d.lng && s.isPointOnMapSurface(s.locationToScreenPoint(m)) ? m : d } const dl = { center: "translate(-50%,-50%)", top: "translate(-50%,0)", "top-left": "translate(0,0)", "top-right": "translate(-100%,0)", bottom: "translate(-50%,-100%)", "bottom-left": "translate(0,-100%)", "bottom-right": "translate(-100%,-100%)", left: "translate(0,-50%)", right: "translate(-100%,-50%)" }; function Mu(m, t, s) { const l = m.classList; for (const d in dl) l.remove(`maplibregl-${s}-anchor-${d}`); l.add(`maplibregl-${s}-anchor-${t}`) } class pl extends c.E { constructor(t) { if (super(), this._onKeyPress = s => { const l = s.code, d = s.charCode || s.keyCode; l !== "Space" && l !== "Enter" && d !== 32 && d !== 13 || this.togglePopup() }, this._onMapClick = s => { const l = s.originalEvent.target, d = this._element; this._popup && (l === d || d.contains(l)) && this.togglePopup() }, this._update = s => { if (!this._map) return; const l = this._map.loaded() && !this._map.isMoving(); ((s == null ? void 0 : s.type) === "terrain" || (s == null ? void 0 : s.type) === "render" && !l) && this._map.once("render", this._update), this._lngLat = Pu(this._lngLat, this._flatPos, this._map.transform), this._flatPos = this._pos = this._map.project(this._lngLat)._add(this._offset), this._map.terrain && (this._flatPos = this._map.transform.locationToScreenPoint(this._lngLat)._add(this._offset)); let d = ""; this._rotationAlignment === "viewport" || this._rotationAlignment === "auto" ? d = `rotateZ(${this._rotation}deg)` : this._rotationAlignment === "map" && (d = `rotateZ(${this._rotation - this._map.getBearing()}deg)`); let g = ""; this._pitchAlignment === "viewport" || this._pitchAlignment === "auto" ? g = "rotateX(0deg)" : this._pitchAlignment === "map" && (g = `rotateX(${this._map.getPitch()}deg)`), this._subpixelPositioning || s && s.type !== "moveend" || (this._pos = this._pos.round()), ye.setTransform(this._element, `${dl[this._anchor]} translate(${this._pos.x}px, ${this._pos.y}px) ${g} ${d}`), Ge.frameAsync(new AbortController).then(() => { this._updateOpacity(s && s.type === "moveend") }).catch(() => { }) }, this._onMove = s => { if (!this._isDragging) { const l = this._clickTolerance || this._map._clickTolerance; this._isDragging = s.point.dist(this._pointerdownPos) >= l } this._isDragging && (this._pos = s.point.sub(this._positionDelta), this._lngLat = this._map.unproject(this._pos), this.setLngLat(this._lngLat), this._element.style.pointerEvents = "none", this._state === "pending" && (this._state = "active", this.fire(new c.l("dragstart"))), this.fire(new c.l("drag"))) }, this._onUp = () => { this._element.style.pointerEvents = "auto", this._positionDelta = null, this._pointerdownPos = null, this._isDragging = !1, this._map.off("mousemove", this._onMove), this._map.off("touchmove", this._onMove), this._state === "active" && this.fire(new c.l("dragend")), this._state = "inactive" }, this._addDragHandler = s => { this._element.contains(s.originalEvent.target) && (s.preventDefault(), this._positionDelta = s.point.sub(this._pos).add(this._offset), this._pointerdownPos = s.point, this._state = "pending", this._map.on("mousemove", this._onMove), this._map.on("touchmove", this._onMove), this._map.once("mouseup", this._onUp), this._map.once("touchend", this._onUp)) }, this._anchor = t && t.anchor || "center", this._color = t && t.color || "#3FB1CE", this._scale = t && t.scale || 1, this._draggable = t && t.draggable || !1, this._clickTolerance = t && t.clickTolerance || 0, this._subpixelPositioning = t && t.subpixelPositioning || !1, this._isDragging = !1, this._state = "inactive", this._rotation = t && t.rotation || 0, this._rotationAlignment = t && t.rotationAlignment || "auto", this._pitchAlignment = t && t.pitchAlignment && t.pitchAlignment !== "auto" ? t.pitchAlignment : this._rotationAlignment, this.setOpacity(t == null ? void 0 : t.opacity, t == null ? void 0 : t.opacityWhenCovered), t && t.element) this._element = t.element, this._offset = c.P.convert(t && t.offset || [0, 0]); else { this._defaultMarker = !0, this._element = ye.create("div"); const s = ye.createNS("http://www.w3.org/2000/svg", "svg"), l = 41, d = 27; s.setAttributeNS(null, "display", "block"), s.setAttributeNS(null, "height", `${l}px`), s.setAttributeNS(null, "width", `${d}px`), s.setAttributeNS(null, "viewBox", `0 0 ${d} ${l}`); const g = ye.createNS("http://www.w3.org/2000/svg", "g"); g.setAttributeNS(null, "stroke", "none"), g.setAttributeNS(null, "stroke-width", "1"), g.setAttributeNS(null, "fill", "none"), g.setAttributeNS(null, "fill-rule", "evenodd"); const v = ye.createNS("http://www.w3.org/2000/svg", "g"); v.setAttributeNS(null, "fill-rule", "nonzero"); const T = ye.createNS("http://www.w3.org/2000/svg", "g"); T.setAttributeNS(null, "transform", "translate(3.0, 29.0)"), T.setAttributeNS(null, "fill", "#000000"); const E = [{ rx: "10.5", ry: "5.25002273" }, { rx: "10.5", ry: "5.25002273" }, { rx: "9.5", ry: "4.77275007" }, { rx: "8.5", ry: "4.29549936" }, { rx: "7.5", ry: "3.81822308" }, { rx: "6.5", ry: "3.34094679" }, { rx: "5.5", ry: "2.86367051" }, { rx: "4.5", ry: "2.38636864" }]; for (const Y of E) { const te = ye.createNS("http://www.w3.org/2000/svg", "ellipse"); te.setAttributeNS(null, "opacity", "0.04"), te.setAttributeNS(null, "cx", "10.5"), te.setAttributeNS(null, "cy", "5.80029008"), te.setAttributeNS(null, "rx", Y.rx), te.setAttributeNS(null, "ry", Y.ry), T.appendChild(te) } const I = ye.createNS("http://www.w3.org/2000/svg", "g"); I.setAttributeNS(null, "fill", this._color); const A = ye.createNS("http://www.w3.org/2000/svg", "path"); A.setAttributeNS(null, "d", "M27,13.5 C27,19.074644 20.250001,27.000002 14.75,34.500002 C14.016665,35.500004 12.983335,35.500004 12.25,34.500002 C6.7499993,27.000002 0,19.222562 0,13.5 C0,6.0441559 6.0441559,0 13.5,0 C20.955844,0 27,6.0441559 27,13.5 Z"), I.appendChild(A); const R = ye.createNS("http://www.w3.org/2000/svg", "g"); R.setAttributeNS(null, "opacity", "0.25"), R.setAttributeNS(null, "fill", "#000000"); const z = ye.createNS("http://www.w3.org/2000/svg", "path"); z.setAttributeNS(null, "d", "M13.5,0 C6.0441559,0 0,6.0441559 0,13.5 C0,19.222562 6.7499993,27 12.25,34.5 C13,35.522727 14.016664,35.500004 14.75,34.5 C20.250001,27 27,19.074644 27,13.5 C27,6.0441559 20.955844,0 13.5,0 Z M13.5,1 C20.415404,1 26,6.584596 26,13.5 C26,15.898657 24.495584,19.181431 22.220703,22.738281 C19.945823,26.295132 16.705119,30.142167 13.943359,33.908203 C13.743445,34.180814 13.612715,34.322738 13.5,34.441406 C13.387285,34.322738 13.256555,34.180814 13.056641,33.908203 C10.284481,30.127985 7.4148684,26.314159 5.015625,22.773438 C2.6163816,19.232715 1,15.953538 1,13.5 C1,6.584596 6.584596,1 13.5,1 Z"), R.appendChild(z); const O = ye.createNS("http://www.w3.org/2000/svg", "g"); O.setAttributeNS(null, "transform", "translate(6.0, 7.0)"), O.setAttributeNS(null, "fill", "#FFFFFF"); const U = ye.createNS("http://www.w3.org/2000/svg", "g"); U.setAttributeNS(null, "transform", "translate(8.0, 8.0)"); const X = ye.createNS("http://www.w3.org/2000/svg", "circle"); X.setAttributeNS(null, "fill", "#000000"), X.setAttributeNS(null, "opacity", "0.25"), X.setAttributeNS(null, "cx", "5.5"), X.setAttributeNS(null, "cy", "5.5"), X.setAttributeNS(null, "r", "5.4999962"); const Q = ye.createNS("http://www.w3.org/2000/svg", "circle"); Q.setAttributeNS(null, "fill", "#FFFFFF"), Q.setAttributeNS(null, "cx", "5.5"), Q.setAttributeNS(null, "cy", "5.5"), Q.setAttributeNS(null, "r", "5.4999962"), U.appendChild(X), U.appendChild(Q), v.appendChild(T), v.appendChild(I), v.appendChild(R), v.appendChild(O), v.appendChild(U), s.appendChild(v), s.setAttributeNS(null, "height", l * this._scale + "px"), s.setAttributeNS(null, "width", d * this._scale + "px"), this._element.appendChild(s), this._offset = c.P.convert(t && t.offset || [0, -14]) } if (this._element.classList.add("maplibregl-marker"), this._element.addEventListener("dragstart", s => { s.preventDefault() }), this._element.addEventListener("mousedown", s => { s.preventDefault() }), Mu(this._element, this._anchor, "marker"), t && t.className) for (const s of t.className.split(" ")) this._element.classList.add(s); this._popup = null } addTo(t) { return this.remove(), this._map = t, this._element.hasAttribute("aria-label") || this._element.setAttribute("aria-label", t._getUIString("Marker.Title")), this._element.hasAttribute("role") || this._element.setAttribute("role", "button"), t.getCanvasContainer().appendChild(this._element), t.on("move", this._update), t.on("moveend", this._update), t.on("terrain", this._update), t.on("projectiontransition", this._update), this.setDraggable(this._draggable), this._update(), this._map.on("click", this._onMapClick), this } remove() { return this._opacityTimeout && (clearTimeout(this._opacityTimeout), delete this._opacityTimeout), this._map && (this._map.off("click", this._onMapClick), this._map.off("move", this._update), this._map.off("moveend", this._update), this._map.off("terrain", this._update), this._map.off("projectiontransition", this._update), this._map.off("mousedown", this._addDragHandler), this._map.off("touchstart", this._addDragHandler), this._map.off("mouseup", this._onUp), this._map.off("touchend", this._onUp), this._map.off("mousemove", this._onMove), this._map.off("touchmove", this._onMove), delete this._map), ye.remove(this._element), this._popup && this._popup.remove(), this } getLngLat() { return this._lngLat } setLngLat(t) { return this._lngLat = c.V.convert(t), this._pos = null, this._popup && this._popup.setLngLat(this._lngLat), this._update(), this } getElement() { return this._element } setPopup(t) { if (this._popup && (this._popup.remove(), this._popup = null, this._element.removeEventListener("keypress", this._onKeyPress), this._originalTabIndex || this._element.removeAttribute("tabindex")), t) { if (!("offset" in t.options)) { const d = Math.abs(13.5) / Math.SQRT2; t.options.offset = this._defaultMarker ? { top: [0, 0], "top-left": [0, 0], "top-right": [0, 0], bottom: [0, -38.1], "bottom-left": [d, -1 * (38.1 - 13.5 + d)], "bottom-right": [-d, -1 * (38.1 - 13.5 + d)], left: [13.5, -1 * (38.1 - 13.5)], right: [-13.5, -1 * (38.1 - 13.5)] } : this._offset } this._popup = t, this._originalTabIndex = this._element.getAttribute("tabindex"), this._originalTabIndex || this._element.setAttribute("tabindex", "0"), this._element.addEventListener("keypress", this._onKeyPress) } return this } setSubpixelPositioning(t) { return this._subpixelPositioning = t, this } getPopup() { return this._popup } togglePopup() { const t = this._popup; return this._element.style.opacity === this._opacityWhenCovered ? this : t ? (t.isOpen() ? t.remove() : (t.setLngLat(this._lngLat), t.addTo(this._map)), this) : this } _updateOpacity(t = !1) { var s, l; const d = (s = this._map) === null || s === void 0 ? void 0 : s.terrain, g = this._map.transform.isLocationOccluded(this._lngLat); if (!d || g) { const O = g ? this._opacityWhenCovered : this._opacity; return void (this._element.style.opacity !== O && (this._element.style.opacity = O)) } if (t) this._opacityTimeout = null; else { if (this._opacityTimeout) return; this._opacityTimeout = setTimeout(() => { this._opacityTimeout = null }, 100) } const v = this._map, T = v.terrain.depthAtPoint(this._pos), E = v.terrain.getElevationForLngLat(this._lngLat, v.transform); if (v.transform.lngLatToCameraDepth(this._lngLat, E) - T < .006) return void (this._element.style.opacity = this._opacity); const I = -this._offset.y / v.transform.pixelsPerMeter, A = Math.sin(v.getPitch() * Math.PI / 180) * I, R = v.terrain.depthAtPoint(new c.P(this._pos.x, this._pos.y - this._offset.y)), z = v.transform.lngLatToCameraDepth(this._lngLat, E + A) - R > .006; !((l = this._popup) === null || l === void 0) && l.isOpen() && z && this._popup.remove(), this._element.style.opacity = z ? this._opacityWhenCovered : this._opacity } getOffset() { return this._offset } setOffset(t) { return this._offset = c.P.convert(t), this._update(), this } addClassName(t) { this._element.classList.add(t) } removeClassName(t) { this._element.classList.remove(t) } toggleClassName(t) { return this._element.classList.toggle(t) } setDraggable(t) { return this._draggable = !!t, this._map && (t ? (this._map.on("mousedown", this._addDragHandler), this._map.on("touchstart", this._addDragHandler)) : (this._map.off("mousedown", this._addDragHandler), this._map.off("touchstart", this._addDragHandler))), this } isDraggable() { return this._draggable } setRotation(t) { return this._rotation = t || 0, this._update(), this } getRotation() { return this._rotation } setRotationAlignment(t) { return this._rotationAlignment = t || "auto", this._update(), this } getRotationAlignment() { return this._rotationAlignment } setPitchAlignment(t) { return this._pitchAlignment = t && t !== "auto" ? t : this._rotationAlignment, this._update(), this } getPitchAlignment() { return this._pitchAlignment } setOpacity(t, s) { return (this._opacity === void 0 || t === void 0 && s === void 0) && (this._opacity = "1", this._opacityWhenCovered = "0.2"), t !== void 0 && (this._opacity = t), s !== void 0 && (this._opacityWhenCovered = s), this._map && this._updateOpacity(!0), this } } const gh = { positionOptions: { enableHighAccuracy: !1, maximumAge: 0, timeout: 6e3 }, fitBoundsOptions: { maxZoom: 15 }, trackUserLocation: !1, showAccuracyCircle: !0, showUserLocation: !0 }; let ea = 0, io = !1; const _h = { maxWidth: 100, unit: "metric" }; function fl(m, t, s) { const l = s && s.maxWidth || 100, d = m._container.clientHeight / 2, g = m._container.clientWidth / 2, v = m.unproject([g - l / 2, d]), T = m.unproject([g + l / 2, d]), E = Math.round(m.project(T).x - m.project(v).x), I = Math.min(l, E, m._container.clientWidth), A = v.distanceTo(T); if (s && s.unit === "imperial") { const R = 3.2808 * A; R > 5280 ? so(t, I, R / 5280, m._getUIString("ScaleControl.Miles")) : so(t, I, R, m._getUIString("ScaleControl.Feet")) } else s && s.unit === "nautical" ? so(t, I, A / 1852, m._getUIString("ScaleControl.NauticalMiles")) : A >= 1e3 ? so(t, I, A / 1e3, m._getUIString("ScaleControl.Kilometers")) : so(t, I, A, m._getUIString("ScaleControl.Meters")) } function so(m, t, s, l) { const d = function (g) { const v = Math.pow(10, `${Math.floor(g)}`.length - 1); let T = g / v; return T = T >= 10 ? 10 : T >= 5 ? 5 : T >= 3 ? 3 : T >= 2 ? 2 : T >= 1 ? 1 : function (E) { const I = Math.pow(10, Math.ceil(-Math.log(E) / Math.LN10)); return Math.round(E * I) / I }(T), v * T }(s); m.style.width = t * (d / s) + "px", m.innerHTML = `${d}&nbsp;${l}` } const yh = { closeButton: !0, closeOnClick: !0, focusAfterOpen: !0, className: "", maxWidth: "240px", subpixelPositioning: !1, locationOccludedOpacity: void 0 }, Iu = ["a[href]", "[tabindex]:not([tabindex='-1'])", "[contenteditable]:not([contenteditable='false'])", "button:not([disabled])", "input:not([disabled])", "select:not([disabled])", "textarea:not([disabled])"].join(", "); function Cu(m) { if (m) { if (typeof m == "number") { const t = Math.round(Math.abs(m) / Math.SQRT2); return { center: new c.P(0, 0), top: new c.P(0, m), "top-left": new c.P(t, t), "top-right": new c.P(-t, t), bottom: new c.P(0, -m), "bottom-left": new c.P(t, -t), "bottom-right": new c.P(-t, -t), left: new c.P(m, 0), right: new c.P(-m, 0) } } if (m instanceof c.P || Array.isArray(m)) { const t = c.P.convert(m); return { center: t, top: t, "top-left": t, "top-right": t, bottom: t, "bottom-left": t, "bottom-right": t, left: t, right: t } } return { center: c.P.convert(m.center || [0, 0]), top: c.P.convert(m.top || [0, 0]), "top-left": c.P.convert(m["top-left"] || [0, 0]), "top-right": c.P.convert(m["top-right"] || [0, 0]), bottom: c.P.convert(m.bottom || [0, 0]), "bottom-left": c.P.convert(m["bottom-left"] || [0, 0]), "bottom-right": c.P.convert(m["bottom-right"] || [0, 0]), left: c.P.convert(m.left || [0, 0]), right: c.P.convert(m.right || [0, 0]) } } return Cu(new c.P(0, 0)) } const vh = B; b.AJAXError = c.cI, b.Event = c.l, b.Evented = c.E, b.LngLat = c.V, b.MercatorCoordinate = c.a9, b.Point = c.P, b.addProtocol = c.cJ, b.config = c.c, b.removeProtocol = c.cK, b.AttributionControl = ph, b.BoxZoomHandler = Ko, b.CanvasSource = V, b.CooperativeGesturesHandler = vt, b.DoubleClickZoomHandler = dh, b.DragPanHandler = Lp, b.DragRotateHandler = Pi, b.EdgeInsets = Ro, b.FullscreenControl = class extends c.E { constructor(m = {}) { super(), this._onFullscreenChange = () => { var t; let s = window.document.fullscreenElement || window.document.mozFullScreenElement || window.document.webkitFullscreenElement || window.document.msFullscreenElement; for (; !((t = s == null ? void 0 : s.shadowRoot) === null || t === void 0) && t.fullscreenElement;)s = s.shadowRoot.fullscreenElement; s === this._container !== this._fullscreen && this._handleFullscreenChange() }, this._onClickFullscreen = () => { this._isFullscreen() ? this._exitFullscreen() : this._requestFullscreen() }, this._fullscreen = !1, m && m.container && (m.container instanceof HTMLElement ? this._container = m.container : c.w("Full screen control 'container' must be a DOM element.")), "onfullscreenchange" in document ? this._fullscreenchange = "fullscreenchange" : "onmozfullscreenchange" in document ? this._fullscreenchange = "mozfullscreenchange" : "onwebkitfullscreenchange" in document ? this._fullscreenchange = "webkitfullscreenchange" : "onmsfullscreenchange" in document && (this._fullscreenchange = "MSFullscreenChange") } onAdd(m) { return this._map = m, this._container || (this._container = this._map.getContainer()), this._controlContainer = ye.create("div", "maplibregl-ctrl maplibregl-ctrl-group"), this._setupUI(), this._controlContainer } onRemove() { ye.remove(this._controlContainer), this._map = null, window.document.removeEventListener(this._fullscreenchange, this._onFullscreenChange) } _setupUI() { const m = this._fullscreenButton = ye.create("button", "maplibregl-ctrl-fullscreen", this._controlContainer); ye.create("span", "maplibregl-ctrl-icon", m).setAttribute("aria-hidden", "true"), m.type = "button", this._updateTitle(), this._fullscreenButton.addEventListener("click", this._onClickFullscreen), window.document.addEventListener(this._fullscreenchange, this._onFullscreenChange) } _updateTitle() { const m = this._getTitle(); this._fullscreenButton.setAttribute("aria-label", m), this._fullscreenButton.title = m } _getTitle() { return this._map._getUIString(this._isFullscreen() ? "FullscreenControl.Exit" : "FullscreenControl.Enter") } _isFullscreen() { return this._fullscreen } _handleFullscreenChange() { this._fullscreen = !this._fullscreen, this._fullscreenButton.classList.toggle("maplibregl-ctrl-shrink"), this._fullscreenButton.classList.toggle("maplibregl-ctrl-fullscreen"), this._updateTitle(), this._fullscreen ? (this.fire(new c.l("fullscreenstart")), this._prevCooperativeGesturesEnabled = this._map.cooperativeGestures.isEnabled(), this._map.cooperativeGestures.disable()) : (this.fire(new c.l("fullscreenend")), this._prevCooperativeGesturesEnabled && this._map.cooperativeGestures.enable()) } _exitFullscreen() { window.document.exitFullscreen ? window.document.exitFullscreen() : window.document.mozCancelFullScreen ? window.document.mozCancelFullScreen() : window.document.msExitFullscreen ? window.document.msExitFullscreen() : window.document.webkitCancelFullScreen ? window.document.webkitCancelFullScreen() : this._togglePseudoFullScreen() } _requestFullscreen() { this._container.requestFullscreen ? this._container.requestFullscreen() : this._container.mozRequestFullScreen ? this._container.mozRequestFullScreen() : this._container.msRequestFullscreen ? this._container.msRequestFullscreen() : this._container.webkitRequestFullscreen ? this._container.webkitRequestFullscreen() : this._togglePseudoFullScreen() } _togglePseudoFullScreen() { this._container.classList.toggle("maplibregl-pseudo-fullscreen"), this._handleFullscreenChange(), this._map.resize() } }, b.GeoJSONSource = Io, b.GeolocateControl = class extends c.E { constructor(m) { super(), this._onSuccess = t => { if (this._map) { if (this._isOutOfMapMaxBounds(t)) return this._setErrorState(), this.fire(new c.l("outofmaxbounds", t)), this._updateMarker(), void this._finish(); if (this.options.trackUserLocation) switch (this._lastKnownPosition = t, this._watchState) { case "WAITING_ACTIVE": case "ACTIVE_LOCK": case "ACTIVE_ERROR": this._watchState = "ACTIVE_LOCK", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active-error"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active"); break; case "BACKGROUND": case "BACKGROUND_ERROR": this._watchState = "BACKGROUND", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background-error"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-background"); break; default: throw new Error(`Unexpected watchState ${this._watchState}`) }this.options.showUserLocation && this._watchState !== "OFF" && this._updateMarker(t), this.options.trackUserLocation && this._watchState !== "ACTIVE_LOCK" || this._updateCamera(t), this.options.showUserLocation && this._dotElement.classList.remove("maplibregl-user-location-dot-stale"), this.fire(new c.l("geolocate", t)), this._finish() } }, this._updateCamera = t => { const s = new c.V(t.coords.longitude, t.coords.latitude), l = t.coords.accuracy, d = this._map.getBearing(), g = c.e({ bearing: d }, this.options.fitBoundsOptions), v = Pr.fromLngLat(s, l); this._map.fitBounds(v, g, { geolocateSource: !0 }) }, this._updateMarker = t => { if (t) { const s = new c.V(t.coords.longitude, t.coords.latitude); this._accuracyCircleMarker.setLngLat(s).addTo(this._map), this._userLocationDotMarker.setLngLat(s).addTo(this._map), this._accuracy = t.coords.accuracy, this._updateCircleRadiusIfNeeded() } else this._userLocationDotMarker.remove(), this._accuracyCircleMarker.remove() }, this._onUpdate = () => { this._updateCircleRadiusIfNeeded() }, this._onError = t => { if (this._map) { if (t.code === 1) { this._watchState = "OFF", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active-error"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background-error"), this._geolocateButton.disabled = !0; const s = this._map._getUIString("GeolocateControl.LocationNotAvailable"); this._geolocateButton.title = s, this._geolocateButton.setAttribute("aria-label", s), this._geolocationWatchID !== void 0 && this._clearWatch() } else { if (t.code === 3 && io) return; this._setErrorState() } this._watchState !== "OFF" && this.options.showUserLocation && this._dotElement.classList.add("maplibregl-user-location-dot-stale"), this.fire(new c.l("error", t)), this._finish() } }, this._finish = () => { this._timeoutId && clearTimeout(this._timeoutId), this._timeoutId = void 0 }, this._setupUI = () => { this._map && (this._container.addEventListener("contextmenu", t => t.preventDefault()), this._geolocateButton = ye.create("button", "maplibregl-ctrl-geolocate", this._container), ye.create("span", "maplibregl-ctrl-icon", this._geolocateButton).setAttribute("aria-hidden", "true"), this._geolocateButton.type = "button", this._geolocateButton.disabled = !0) }, this._finishSetupUI = t => { if (this._map) { if (t === !1) { c.w("Geolocation support is not available so the GeolocateControl will be disabled."); const s = this._map._getUIString("GeolocateControl.LocationNotAvailable"); this._geolocateButton.disabled = !0, this._geolocateButton.title = s, this._geolocateButton.setAttribute("aria-label", s) } else { const s = this._map._getUIString("GeolocateControl.FindMyLocation"); this._geolocateButton.disabled = !1, this._geolocateButton.title = s, this._geolocateButton.setAttribute("aria-label", s) } this.options.trackUserLocation && (this._geolocateButton.setAttribute("aria-pressed", "false"), this._watchState = "OFF"), this.options.showUserLocation && (this._dotElement = ye.create("div", "maplibregl-user-location-dot"), this._userLocationDotMarker = new pl({ element: this._dotElement }), this._circleElement = ye.create("div", "maplibregl-user-location-accuracy-circle"), this._accuracyCircleMarker = new pl({ element: this._circleElement, pitchAlignment: "map" }), this.options.trackUserLocation && (this._watchState = "OFF"), this._map.on("zoom", this._onUpdate), this._map.on("move", this._onUpdate), this._map.on("rotate", this._onUpdate), this._map.on("pitch", this._onUpdate)), this._geolocateButton.addEventListener("click", () => this.trigger()), this._setup = !0, this.options.trackUserLocation && this._map.on("movestart", s => { const l = (s == null ? void 0 : s[0]) instanceof ResizeObserverEntry; s.geolocateSource || this._watchState !== "ACTIVE_LOCK" || l || this._map.isZooming() || (this._watchState = "BACKGROUND", this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this.fire(new c.l("trackuserlocationend")), this.fire(new c.l("userlocationlostfocus"))) }) } }, this.options = c.e({}, gh, m) } onAdd(m) { return this._map = m, this._container = ye.create("div", "maplibregl-ctrl maplibregl-ctrl-group"), this._setupUI(), function () { return c._(this, arguments, void 0, function* (t = !1) { if (rs !== void 0 && !t) return rs; if (window.navigator.permissions === void 0) return rs = !!window.navigator.geolocation, rs; try { rs = (yield window.navigator.permissions.query({ name: "geolocation" })).state !== "denied" } catch { rs = !!window.navigator.geolocation } return rs }) }().then(t => this._finishSetupUI(t)), this._container } onRemove() { this._geolocationWatchID !== void 0 && (window.navigator.geolocation.clearWatch(this._geolocationWatchID), this._geolocationWatchID = void 0), this.options.showUserLocation && this._userLocationDotMarker && this._userLocationDotMarker.remove(), this.options.showAccuracyCircle && this._accuracyCircleMarker && this._accuracyCircleMarker.remove(), ye.remove(this._container), this._map.off("zoom", this._onUpdate), this._map.off("move", this._onUpdate), this._map.off("rotate", this._onUpdate), this._map.off("pitch", this._onUpdate), this._map = void 0, ea = 0, io = !1 } _isOutOfMapMaxBounds(m) { const t = this._map.getMaxBounds(), s = m.coords; return t && (s.longitude < t.getWest() || s.longitude > t.getEast() || s.latitude < t.getSouth() || s.latitude > t.getNorth()) } _setErrorState() { switch (this._watchState) { case "WAITING_ACTIVE": this._watchState = "ACTIVE_ERROR", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active-error"); break; case "ACTIVE_LOCK": this._watchState = "ACTIVE_ERROR", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active-error"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-waiting"); break; case "BACKGROUND": this._watchState = "BACKGROUND_ERROR", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-background-error"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-waiting"); break; case "ACTIVE_ERROR": case "BACKGROUND_ERROR": case "OFF": case void 0: break; default: throw new Error(`Unexpected watchState ${this._watchState}`) } } _updateCircleRadiusIfNeeded() { const m = this._userLocationDotMarker.getLngLat(); if (!(this.options.showUserLocation && this.options.showAccuracyCircle && this._accuracy && m)) return; const t = this._map.project(m), s = this._map.unproject([t.x + 100, t.y]), l = m.distanceTo(s) / 100, d = 2 * this._accuracy / l; this._circleElement.style.width = `${d.toFixed(2)}px`, this._circleElement.style.height = `${d.toFixed(2)}px` } trigger() { if (!this._setup) return c.w("Geolocate control triggered before added to a map"), !1; if (this.options.trackUserLocation) { switch (this._watchState) { case "OFF": this._watchState = "WAITING_ACTIVE", this.fire(new c.l("trackuserlocationstart")); break; case "WAITING_ACTIVE": case "ACTIVE_LOCK": case "ACTIVE_ERROR": case "BACKGROUND_ERROR": ea--, io = !1, this._watchState = "OFF", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active-error"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background-error"), this.fire(new c.l("trackuserlocationend")); break; case "BACKGROUND": this._watchState = "ACTIVE_LOCK", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background"), this._lastKnownPosition && this._updateCamera(this._lastKnownPosition), this.fire(new c.l("trackuserlocationstart")), this.fire(new c.l("userlocationfocus")); break; default: throw new Error(`Unexpected watchState ${this._watchState}`) }switch (this._watchState) { case "WAITING_ACTIVE": this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active"); break; case "ACTIVE_LOCK": this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active"); break; case "OFF": break; default: throw new Error(`Unexpected watchState ${this._watchState}`) }if (this._watchState === "OFF" && this._geolocationWatchID !== void 0) this._clearWatch(); else if (this._geolocationWatchID === void 0) { let m; this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.setAttribute("aria-pressed", "true"), ea++, ea > 1 ? (m = { maximumAge: 6e5, timeout: 0 }, io = !0) : (m = this.options.positionOptions, io = !1), this._geolocationWatchID = window.navigator.geolocation.watchPosition(this._onSuccess, this._onError, m) } } else window.navigator.geolocation.getCurrentPosition(this._onSuccess, this._onError, this.options.positionOptions), this._timeoutId = setTimeout(this._finish, 1e4); return !0 } _clearWatch() { window.navigator.geolocation.clearWatch(this._geolocationWatchID), this._geolocationWatchID = void 0, this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.setAttribute("aria-pressed", "false"), this.options.showUserLocation && this._updateMarker(null) } }, b.GlobeControl = class { constructor() { this._toggleProjection = () => { var m; const t = (m = this._map.getProjection()) === null || m === void 0 ? void 0 : m.type; this._map.setProjection(t !== "mercator" && t ? { type: "mercator" } : { type: "globe" }), this._updateGlobeIcon() }, this._updateGlobeIcon = () => { var m; this._globeButton.classList.remove("maplibregl-ctrl-globe"), this._globeButton.classList.remove("maplibregl-ctrl-globe-enabled"), ((m = this._map.getProjection()) === null || m === void 0 ? void 0 : m.type) === "globe" ? (this._globeButton.classList.add("maplibregl-ctrl-globe-enabled"), this._globeButton.title = this._map._getUIString("GlobeControl.Disable")) : (this._globeButton.classList.add("maplibregl-ctrl-globe"), this._globeButton.title = this._map._getUIString("GlobeControl.Enable")) } } onAdd(m) { return this._map = m, this._container = ye.create("div", "maplibregl-ctrl maplibregl-ctrl-group"), this._globeButton = ye.create("button", "maplibregl-ctrl-globe", this._container), ye.create("span", "maplibregl-ctrl-icon", this._globeButton).setAttribute("aria-hidden", "true"), this._globeButton.type = "button", this._globeButton.addEventListener("click", this._toggleProjection), this._updateGlobeIcon(), this._map.on("styledata", this._updateGlobeIcon), this._container } onRemove() { ye.remove(this._container), this._map.off("styledata", this._updateGlobeIcon), this._globeButton.removeEventListener("click", this._toggleProjection), this._map = void 0 } }, b.Hash = sh, b.ImageSource = jn, b.KeyboardHandler = rr, b.LngLatBounds = Pr, b.LogoControl = Fp, b.Map = class extends Ln { constructor(m) { var t, s; c.cG.mark(c.cH.create); const l = Object.assign(Object.assign(Object.assign({}, Eu), m), { canvasContextAttributes: Object.assign(Object.assign({}, Eu.canvasContextAttributes), m.canvasContextAttributes) }); if (l.minZoom != null && l.maxZoom != null && l.minZoom > l.maxZoom) throw new Error("maxZoom must be greater than or equal to minZoom"); if (l.minPitch != null && l.maxPitch != null && l.minPitch > l.maxPitch) throw new Error("maxPitch must be greater than or equal to minPitch"); if (l.minPitch != null && l.minPitch < 0) throw new Error("minPitch must be greater than or equal to 0"); if (l.maxPitch != null && l.maxPitch > 180) throw new Error("maxPitch must be less than or equal to 180"); const d = new Zs, g = new Ws; if (l.minZoom !== void 0 && d.setMinZoom(l.minZoom), l.maxZoom !== void 0 && d.setMaxZoom(l.maxZoom), l.minPitch !== void 0 && d.setMinPitch(l.minPitch), l.maxPitch !== void 0 && d.setMaxPitch(l.maxPitch), l.renderWorldCopies !== void 0 && d.setRenderWorldCopies(l.renderWorldCopies), l.transformConstrain !== null && d.setConstrainOverride(l.transformConstrain), super(d, g, { bearingSnap: l.bearingSnap }), this._idleTriggered = !1, this._crossFadingFactor = 1, this._renderTaskQueue = new sg, this._controls = [], this._mapId = c.af(), this._lostContextStyle = { style: null, images: null }, this._contextLost = T => { T.preventDefault(), this._frameRequest && (this._frameRequest.abort(), this._frameRequest = null), this.painter.destroy(); for (const E of Object.values(this.style._layers)) if (E.type === "custom" && console.warn(`Custom layer with id '${E.id}' cannot be restored after WebGL context loss. You will need to re-add it manually after context restoration.`), E._listeners) for (const [I] of Object.entries(E._listeners)) console.warn(`Custom layer with id '${E.id}' had event listeners for event '${I}' which cannot be restored after WebGL context loss. You will need to re-add them manually after context restoration.`); this._lostContextStyle = this._getStyleAndImages(), this.style.destroy(), this.style = null, this.fire(new c.l("webglcontextlost", { originalEvent: T })) }, this._contextRestored = T => { this._lostContextStyle.style && this.setStyle(this._lostContextStyle.style, { diff: !1 }), this._lostContextStyle.images && (this.style.imageManager.images = this._lostContextStyle.images), this._setupPainter(), this.resize(), this._update(), this.fire(new c.l("webglcontextrestored", { originalEvent: T })) }, this._onMapScroll = T => { if (T.target === this._container) return this._container.scrollTop = 0, this._container.scrollLeft = 0, !1 }, this._onWindowOnline = () => { this._update() }, this._interactive = l.interactive, this._maxTileCacheSize = l.maxTileCacheSize, this._maxTileCacheZoomLevels = l.maxTileCacheZoomLevels, this._canvasContextAttributes = Object.assign({}, l.canvasContextAttributes), this._trackResize = l.trackResize === !0, this._bearingSnap = l.bearingSnap, this._centerClampedToGround = l.centerClampedToGround, this._refreshExpiredTiles = l.refreshExpiredTiles === !0, this._fadeDuration = l.fadeDuration, this._crossSourceCollisions = l.crossSourceCollisions === !0, this._collectResourceTiming = l.collectResourceTiming === !0, this._locale = Object.assign(Object.assign({}, Su), l.locale), this._clickTolerance = l.clickTolerance, this._overridePixelRatio = l.pixelRatio, this._maxCanvasSize = l.maxCanvasSize, this._zoomLevelsToOverscale = l.experimentalZoomLevelsToOverscale, this.transformCameraUpdate = l.transformCameraUpdate, this.transformConstrain = l.transformConstrain, this.cancelPendingTileRequestsWhileZooming = l.cancelPendingTileRequestsWhileZooming === !0, l.reduceMotion !== void 0 && (Ge.prefersReducedMotion = l.reduceMotion), this._imageQueueHandle = ct.addThrottleControl(() => this.isMoving()), this._requestManager = new Z(l.transformRequest), typeof l.container == "string") { if (this._container = document.getElementById(l.container), !this._container) throw new Error(`Container '${l.container}' not found.`) } else { if (!(l.container instanceof HTMLElement)) throw new Error("Invalid type: 'container' must be a String or HTMLElement."); this._container = l.container } if (l.maxBounds && this.setMaxBounds(l.maxBounds), this._setupContainer(), this._setupPainter(), this.on("move", () => this._update(!1)), this.on("moveend", () => this._update(!1)), this.on("zoom", () => this._update(!0)), this.on("terrain", () => { this.painter.terrainFacilitator.dirty = !0, this._update(!0) }), this.once("idle", () => { this._idleTriggered = !0 }), typeof window < "u") { addEventListener("online", this._onWindowOnline, !1); let T = !1; const E = ih(I => { this._trackResize && !this._removed && (this.resize(I), this.redraw()) }, 50); this._resizeObserver = new ResizeObserver(I => { T ? E(I) : T = !0 }), this._resizeObserver.observe(this._container) } this.handlers = new Tu(this, l), this._hash = l.hash && new sh(typeof l.hash == "string" && l.hash || void 0).addTo(this), this._hash && this._hash._onHashChange() || (this.jumpTo({ center: l.center, elevation: l.elevation, zoom: l.zoom, bearing: l.bearing, pitch: l.pitch, roll: l.roll }), l.bounds && (this.resize(), this.fitBounds(l.bounds, c.e({}, l.fitBoundsOptions, { duration: 0 })))); const v = typeof l.style == "string" || ((s = (t = l.style) === null || t === void 0 ? void 0 : t.projection) === null || s === void 0 ? void 0 : s.type) !== "globe"; this.resize(null, v), this._localIdeographFontFamily = l.localIdeographFontFamily, this._validateStyle = l.validateStyle, l.style && this.setStyle(l.style, { localIdeographFontFamily: l.localIdeographFontFamily }), l.attributionControl && this.addControl(new ph(typeof l.attributionControl == "boolean" ? void 0 : l.attributionControl)), l.maplibreLogo && this.addControl(new Fp, l.logoPosition), this.on("style.load", () => { if (v || this._resizeTransform(), this.transform.unmodified) { const T = c.U(this.style.stylesheet, ["center", "zoom", "bearing", "pitch", "roll"]); this.jumpTo(T) } }), this.on("data", T => { this._update(T.dataType === "style"), this.fire(new c.l(`${T.dataType}data`, T)) }), this.on("dataloading", T => { this.fire(new c.l(`${T.dataType}dataloading`, T)) }), this.on("dataabort", T => { this.fire(new c.l("sourcedataabort", T)) }) } _getMapId() { return this._mapId } setGlobalStateProperty(m, t) { return this.style.setGlobalStateProperty(m, t), this._update(!0) } getGlobalState() { return this.style.getGlobalState() } addControl(m, t) { if (t === void 0 && (t = m.getDefaultPosition ? m.getDefaultPosition() : "top-right"), !m || !m.onAdd) return this.fire(new c.k(new Error("Invalid argument to map.addControl(). Argument must be a control with onAdd and onRemove methods."))); const s = m.onAdd(this); this._controls.push(m); const l = this._controlPositions[t]; return t.indexOf("bottom") !== -1 ? l.insertBefore(s, l.firstChild) : l.appendChild(s), this } removeControl(m) { if (!m || !m.onRemove) return this.fire(new c.k(new Error("Invalid argument to map.removeControl(). Argument must be a control with onAdd and onRemove methods."))); const t = this._controls.indexOf(m); return t > -1 && this._controls.splice(t, 1), m.onRemove(this), this } hasControl(m) { return this._controls.indexOf(m) > -1 } coveringTiles(m) { return Mr(this.transform, m) } calculateCameraOptionsFromTo(m, t, s, l) { return l == null && this.terrain && (l = this.terrain.getElevationForLngLat(s, this.transform)), super.calculateCameraOptionsFromTo(m, t, s, l) } resize(m, t = !0) { const [s, l] = this._containerDimensions(), d = this._getClampedPixelRatio(s, l); if (this._resizeCanvas(s, l, d), this.painter.resize(s, l, d), this.painter.overLimit()) { const v = this.painter.context.gl; this._maxCanvasSize = [v.drawingBufferWidth, v.drawingBufferHeight]; const T = this._getClampedPixelRatio(s, l); this._resizeCanvas(s, l, T), this.painter.resize(s, l, T) } this._resizeTransform(t); const g = !this._moving; return g && (this.stop(), this.fire(new c.l("movestart", m)).fire(new c.l("move", m))), this.fire(new c.l("resize", m)), g && this.fire(new c.l("moveend", m)), this } _resizeTransform(m = !0) { var t; const [s, l] = this._containerDimensions(); this.transform.resize(s, l, m), (t = this._requestedCameraState) === null || t === void 0 || t.resize(s, l, m) } _getClampedPixelRatio(m, t) { const { 0: s, 1: l } = this._maxCanvasSize, d = this.getPixelRatio(), g = m * d, v = t * d; return Math.min(g > s ? s / g : 1, v > l ? l / v : 1) * d } getPixelRatio() { var m; return (m = this._overridePixelRatio) !== null && m !== void 0 ? m : devicePixelRatio } setPixelRatio(m) { this._overridePixelRatio = m, this.resize() } getBounds() { return this.transform.getBounds() } getMaxBounds() { return this.transform.getMaxBounds() } setMaxBounds(m) { return this.transform.setMaxBounds(Pr.convert(m)), this._update() } setMinZoom(m) { if ((m = m ?? -2) >= -2 && m <= this.transform.maxZoom) { const t = this._getTransformForUpdate(); return t.setMinZoom(m), this._applyUpdatedTransform(t), this._update(), this } throw new Error("minZoom must be between -2 and the current maxZoom, inclusive") } getMinZoom() { return this.transform.minZoom } setMaxZoom(m) { if ((m = m ?? 22) >= this.transform.minZoom) { const t = this._getTransformForUpdate(); return t.setMaxZoom(m), this._applyUpdatedTransform(t), this._update(), this } throw new Error("maxZoom must be greater than the current minZoom") } getMaxZoom() { return this.transform.maxZoom } setMinPitch(m) { if ((m = m ?? 0) < 0) throw new Error("minPitch must be greater than or equal to 0"); if (m >= 0 && m <= this.transform.maxPitch) return this.transform.setMinPitch(m), this._update(), this.getPitch() < m && this.setPitch(m), this; throw new Error("minPitch must be between 0 and the current maxPitch, inclusive") } getMinPitch() { return this.transform.minPitch } setMaxPitch(m) { if ((m = m ?? 60) > 180) throw new Error("maxPitch must be less than or equal to 180"); if (m >= this.transform.minPitch) return this.transform.setMaxPitch(m), this._update(), this.getPitch() > m && this.setPitch(m), this; throw new Error("maxPitch must be greater than the current minPitch") } getMaxPitch() { return this.transform.maxPitch } getRenderWorldCopies() { return this.transform.renderWorldCopies } setRenderWorldCopies(m) { return this.transform.setRenderWorldCopies(m), this._update() } setTransformConstrain(m) { return this.transform.setConstrainOverride(m), this._update() } project(m) { return this.transform.locationToScreenPoint(c.V.convert(m), this.style && this.terrain) } unproject(m) { return this.transform.screenPointToLocation(c.P.convert(m), this.terrain) } isMoving() { var m; return this._moving || ((m = this.handlers) === null || m === void 0 ? void 0 : m.isMoving()) } isZooming() { var m; return this._zooming || ((m = this.handlers) === null || m === void 0 ? void 0 : m.isZooming()) } isRotating() { var m; return this._rotating || ((m = this.handlers) === null || m === void 0 ? void 0 : m.isRotating()) } _createDelegatedListener(m, t, s) { if (m === "mouseenter" || m === "mouseover") { let l = !1; return { layers: t, listener: s, delegates: { mousemove: g => { const v = t.filter(E => this.getLayer(E)), T = v.length !== 0 ? this.queryRenderedFeatures(g.point, { layers: v }) : []; T.length ? l || (l = !0, s.call(this, new nn(m, this, g.originalEvent, { features: T }))) : l = !1 }, mouseout: () => { l = !1 } } } } if (m === "mouseleave" || m === "mouseout") { let l = !1; return { layers: t, listener: s, delegates: { mousemove: v => { const T = t.filter(E => this.getLayer(E)); (T.length !== 0 ? this.queryRenderedFeatures(v.point, { layers: T }) : []).length ? l = !0 : l && (l = !1, s.call(this, new nn(m, this, v.originalEvent))) }, mouseout: v => { l && (l = !1, s.call(this, new nn(m, this, v.originalEvent))) } } } } { const l = d => { const g = t.filter(T => this.getLayer(T)), v = g.length !== 0 ? this.queryRenderedFeatures(d.point, { layers: g }) : []; v.length && (d.features = v, s.call(this, d), delete d.features) }; return { layers: t, listener: s, delegates: { [m]: l } } } } _saveDelegatedListener(m, t) { this._delegatedListeners = this._delegatedListeners || {}, this._delegatedListeners[m] = this._delegatedListeners[m] || [], this._delegatedListeners[m].push(t) } _removeDelegatedListener(m, t, s) { if (!this._delegatedListeners || !this._delegatedListeners[m]) return; const l = this._delegatedListeners[m]; for (let d = 0; d < l.length; d++) { const g = l[d]; if (g.listener === s && g.layers.length === t.length && g.layers.every(v => t.includes(v))) { for (const v in g.delegates) this.off(v, g.delegates[v]); return void l.splice(d, 1) } } } on(m, t, s) { if (s === void 0) return super.on(m, t); const l = typeof t == "string" ? [t] : t, d = this._createDelegatedListener(m, l, s); this._saveDelegatedListener(m, d); for (const g in d.delegates) this.on(g, d.delegates[g]); return { unsubscribe: () => { this._removeDelegatedListener(m, l, s) } } } once(m, t, s) { if (s === void 0) return super.once(m, t); const l = typeof t == "string" ? [t] : t, d = this._createDelegatedListener(m, l, s); for (const g in d.delegates) { const v = d.delegates[g]; d.delegates[g] = (...T) => { this._removeDelegatedListener(m, l, s), v(...T) } } this._saveDelegatedListener(m, d); for (const g in d.delegates) this.once(g, d.delegates[g]); return this } off(m, t, s) { return s === void 0 ? super.off(m, t) : (this._removeDelegatedListener(m, typeof t == "string" ? [t] : t, s), this) } queryRenderedFeatures(m, t) { if (!this.style) return []; let s; const l = m instanceof c.P || Array.isArray(m), d = l ? m : [[0, 0], [this.transform.width, this.transform.height]]; if (t = t || (l ? {} : m) || {}, d instanceof c.P || typeof d[0] == "number") s = [c.P.convert(d)]; else { const g = c.P.convert(d[0]), v = c.P.convert(d[1]); s = [g, new c.P(v.x, g.y), v, new c.P(g.x, v.y), g] } return this.style.queryRenderedFeatures(s, t, this.transform) } querySourceFeatures(m, t) { return this.style.querySourceFeatures(m, t) } setStyle(m, t) { return (t = c.e({}, { localIdeographFontFamily: this._localIdeographFontFamily, validate: this._validateStyle }, t)).diff !== !1 && t.localIdeographFontFamily === this._localIdeographFontFamily && this.style && m ? (this._diffStyle(m, t), this) : (this._localIdeographFontFamily = t.localIdeographFontFamily, this._updateStyle(m, t)) } setTransformRequest(m) { return this._requestManager.setTransformRequest(m), this } _getUIString(m) { const t = this._locale[m]; if (t == null) throw new Error(`Missing UI string '${m}'`); return t } _updateStyle(m, t) { var s, l; if (t.transformStyle && this.style && !this.style._loaded) return void this.style.once("style.load", () => this._updateStyle(m, t)); const d = this.style && t.transformStyle ? this.style.serialize() : void 0; return this.style && (this.style.setEventedParent(null), this.style._remove(!m)), m ? (this.style = new Xs(this, t || {}), this.style.setEventedParent(this, { style: this.style }), typeof m == "string" ? this.style.loadURL(m, t, d) : this.style.loadJSON(m, t, d), this) : ((l = (s = this.style) === null || s === void 0 ? void 0 : s.projection) === null || l === void 0 || l.destroy(), delete this.style, this) } _lazyInitEmptyStyle() { this.style || (this.style = new Xs(this, {}), this.style.setEventedParent(this, { style: this.style }), this.style.loadEmpty()) } _diffStyle(m, t) { if (typeof m == "string") { const s = this._requestManager.transformRequest(m, "Style"); c.j(s, new AbortController).then(l => { this._updateDiff(l.data, t) }).catch(l => { l && this.fire(new c.k(l)) }) } else typeof m == "object" && this._updateDiff(m, t) } _updateDiff(m, t) { try { this.style.setState(m, t) && this._update(!0) } catch (s) { c.w(`Unable to perform style diff: ${s.message || s.error || s}.  Rebuilding the style from scratch.`), this._updateStyle(m, t) } } getStyle() { if (this.style) return this.style.serialize() } _getStyleAndImages() { return this.style ? { style: this.style.serialize(), images: this.style.imageManager.cloneImages() } : { style: null, images: {} } } isStyleLoaded() { return this.style ? this.style.loaded() : c.w("There is no style added to the map.") } addSource(m, t) { return this._lazyInitEmptyStyle(), this.style.addSource(m, t), this._update(!0) } isSourceLoaded(m) { const t = this.style && this.style.tileManagers[m]; if (t !== void 0) return t.loaded(); this.fire(new c.k(new Error(`There is no tile manager with ID '${m}'`))) } setTerrain(m) { if (this.style._checkLoaded(), this._terrainDataCallback && this.style.off("data", this._terrainDataCallback), m) { const t = this.style.tileManagers[m.source]; if (!t) throw new Error(`cannot load terrain, because there exists no source with ID: ${m.source}`); this.terrain === null && t.reload(); for (const s in this.style._layers) { const l = this.style._layers[s]; l.type === "hillshade" && l.source === m.source && c.w("You are using the same source for a hillshade layer and for 3D terrain. Please consider using two separate sources to improve rendering quality."), l.type === "color-relief" && l.source === m.source && c.w("You are using the same source for a color-relief layer and for 3D terrain. Please consider using two separate sources to improve rendering quality.") } this.terrain = new Tr(this.painter, t, m), this.painter.renderToTexture = new cl(this.painter, this.terrain), this.transform.setMinElevationForCurrentTile(this.terrain.getMinTileElevationForLngLatZoom(this.transform.center, this.transform.tileZoom)), this.transform.setElevation(this.terrain.getElevationForLngLatZoom(this.transform.center, this.transform.tileZoom)), this._terrainDataCallback = s => { var l; s.dataType === "style" ? this.terrain.tileManager.freeRtt() : s.dataType === "source" && s.tile && (s.sourceId !== m.source || this._elevationFreeze || (this.transform.setMinElevationForCurrentTile(this.terrain.getMinTileElevationForLngLatZoom(this.transform.center, this.transform.tileZoom)), this._centerClampedToGround && this.transform.setElevation(this.terrain.getElevationForLngLatZoom(this.transform.center, this.transform.tileZoom))), ((l = s.source) === null || l === void 0 ? void 0 : l.type) === "image" ? this.terrain.tileManager.freeRtt() : this.terrain.tileManager.freeRtt(s.tile.tileID)) }, this.style.on("data", this._terrainDataCallback) } else this.terrain && this.terrain.tileManager.destruct(), this.terrain = null, this.painter.renderToTexture && this.painter.renderToTexture.destruct(), this.painter.renderToTexture = null, this.transform.setMinElevationForCurrentTile(0), this._centerClampedToGround && this.transform.setElevation(0); return this.fire(new c.l("terrain", { terrain: m })), this } getTerrain() { var m, t; return (t = (m = this.terrain) === null || m === void 0 ? void 0 : m.options) !== null && t !== void 0 ? t : null } areTilesLoaded() { const m = this.style && this.style.tileManagers; for (const t of Object.values(m)) if (!t.areTilesLoaded()) return !1; return !0 } removeSource(m) { return this.style.removeSource(m), this._update(!0) } getSource(m) { return this.style.getSource(m) } setSourceTileLodParams(m, t, s) { if (s) { const l = this.getSource(s); if (!l) throw new Error(`There is no source with ID "${s}", cannot set LOD parameters`); l.calculateTileZoom = Jt(Math.max(1, m), Math.max(1, t)) } else for (const l in this.style.tileManagers) this.style.tileManagers[l].getSource().calculateTileZoom = Jt(Math.max(1, m), Math.max(1, t)); return this._update(!0), this } refreshTiles(m, t) { const s = this.style.tileManagers[m]; if (!s) throw new Error(`There is no tile manager with ID "${m}", cannot refresh tile`); t === void 0 ? s.reload(!0) : s.refreshTiles(t.map(l => new c.ac(l.z, l.x, l.y))) } addImage(m, t, s = {}) { const { pixelRatio: l = 1, sdf: d = !1, stretchX: g, stretchY: v, content: T, textFitWidth: E, textFitHeight: I } = s; if (this._lazyInitEmptyStyle(), !(t instanceof HTMLImageElement || c.b(t))) { if (t.width === void 0 || t.height === void 0) return this.fire(new c.k(new Error("Invalid arguments to map.addImage(). The second argument must be an `HTMLImageElement`, `ImageData`, `ImageBitmap`, or object with `width`, `height`, and `data` properties with the same format as `ImageData`"))); { const { width: A, height: R, data: z } = t, O = t; return this.style.addImage(m, { data: new c.R({ width: A, height: R }, new Uint8Array(z)), pixelRatio: l, stretchX: g, stretchY: v, content: T, textFitWidth: E, textFitHeight: I, sdf: d, version: 0, userImage: O }), O.onAdd && O.onAdd(this, m), this } } { const { width: A, height: R, data: z } = Ge.getImageData(t); this.style.addImage(m, { data: new c.R({ width: A, height: R }, z), pixelRatio: l, stretchX: g, stretchY: v, content: T, textFitWidth: E, textFitHeight: I, sdf: d, version: 0 }) } } updateImage(m, t) { const s = this.style.getImage(m); if (!s) return this.fire(new c.k(new Error("The map has no image with that id. If you are adding a new image use `map.addImage(...)` instead."))); const l = t instanceof HTMLImageElement || c.b(t) ? Ge.getImageData(t) : t, { width: d, height: g, data: v } = l; if (d === void 0 || g === void 0) return this.fire(new c.k(new Error("Invalid arguments to map.updateImage(). The second argument must be an `HTMLImageElement`, `ImageData`, `ImageBitmap`, or object with `width`, `height`, and `data` properties with the same format as `ImageData`"))); if (d !== s.data.width || g !== s.data.height) return this.fire(new c.k(new Error("The width and height of the updated image must be that same as the previous version of the image"))); const T = !(t instanceof HTMLImageElement || c.b(t)); return s.data.replace(v, T), this.style.updateImage(m, s), this } getImage(m) { return this.style.getImage(m) } hasImage(m) { return m ? !!this.style.getImage(m) : (this.fire(new c.k(new Error("Missing required image id"))), !1) } removeImage(m) { this.style.removeImage(m) } loadImage(m) { return ct.getImage(this._requestManager.transformRequest(m, "Image"), new AbortController) } listImages() { return this.style.listImages() } addLayer(m, t) { return this._lazyInitEmptyStyle(), this.style.addLayer(m, t), this._update(!0) } moveLayer(m, t) { return this.style.moveLayer(m, t), this._update(!0) } removeLayer(m) { return this.style.removeLayer(m), this._update(!0) } getLayer(m) { return this.style.getLayer(m) } getLayersOrder() { return this.style.getLayersOrder() } setLayerZoomRange(m, t, s) { return this.style.setLayerZoomRange(m, t, s), this._update(!0) } setFilter(m, t, s = {}) { return this.style.setFilter(m, t, s), this._update(!0) } getFilter(m) { return this.style.getFilter(m) } setPaintProperty(m, t, s, l = {}) { return this.style.setPaintProperty(m, t, s, l), this._update(!0) } getPaintProperty(m, t) { return this.style.getPaintProperty(m, t) } setLayoutProperty(m, t, s, l = {}) { return this.style.setLayoutProperty(m, t, s, l), this._update(!0) } getLayoutProperty(m, t) { return this.style.getLayoutProperty(m, t) } setGlyphs(m, t = {}) { return this._lazyInitEmptyStyle(), this.style.setGlyphs(m, t), this._update(!0) } getGlyphs() { return this.style.getGlyphsUrl() } addSprite(m, t, s = {}) { return this._lazyInitEmptyStyle(), this.style.addSprite(m, t, s, l => { l || this._update(!0) }), this } removeSprite(m) { return this._lazyInitEmptyStyle(), this.style.removeSprite(m), this._update(!0) } getSprite() { return this.style.getSprite() } setSprite(m, t = {}) { return this._lazyInitEmptyStyle(), this.style.setSprite(m, t, s => { s || this._update(!0) }), this } setLight(m, t = {}) { return this._lazyInitEmptyStyle(), this.style.setLight(m, t), this._update(!0) } getLight() { return this.style.getLight() } setSky(m, t = {}) { return this._lazyInitEmptyStyle(), this.style.setSky(m, t), this._update(!0) } getSky() { return this.style.getSky() } setFeatureState(m, t) { return this.style.setFeatureState(m, t), this._update() } removeFeatureState(m, t) { return this.style.removeFeatureState(m, t), this._update() } getFeatureState(m) { return this.style.getFeatureState(m) } getContainer() { return this._container } getCanvasContainer() { return this._canvasContainer } getCanvas() { return this._canvas } _containerDimensions() { let m = 0, t = 0; return this._container && (m = this._container.clientWidth || 400, t = this._container.clientHeight || 300), [m, t] } _setupContainer() { const m = this._container; m.classList.add("maplibregl-map"); const t = this._canvasContainer = ye.create("div", "maplibregl-canvas-container", m); this._interactive && t.classList.add("maplibregl-interactive"), this._canvas = ye.create("canvas", "maplibregl-canvas", t), this._canvas.addEventListener("webglcontextlost", this._contextLost, !1), this._canvas.addEventListener("webglcontextrestored", this._contextRestored, !1), this._canvas.setAttribute("tabindex", this._interactive ? "0" : "-1"), this._canvas.setAttribute("aria-label", this._getUIString("Map.Title")), this._canvas.setAttribute("role", "region"); const s = this._containerDimensions(), l = this._getClampedPixelRatio(s[0], s[1]); this._resizeCanvas(s[0], s[1], l); const d = this._controlContainer = ye.create("div", "maplibregl-control-container", m), g = this._controlPositions = {};["top-left", "top-right", "bottom-left", "bottom-right"].forEach(v => { g[v] = ye.create("div", `maplibregl-ctrl-${v} `, d) }), this._container.addEventListener("scroll", this._onMapScroll, !1) } _resizeCanvas(m, t, s) { this._canvas.width = Math.floor(s * m), this._canvas.height = Math.floor(s * t), this._canvas.style.width = `${m}px`, this._canvas.style.height = `${t}px` } _setupPainter() { const m = Object.assign(Object.assign({}, this._canvasContextAttributes), { alpha: !0, depth: !0, stencil: !0, premultipliedAlpha: !0 }); let t = null; this._canvas.addEventListener("webglcontextcreationerror", l => { t = { requestedAttributes: m }, l && (t.statusMessage = l.statusMessage, t.type = l.type) }, { once: !0 }); let s = null; if (s = this._canvasContextAttributes.contextType ? this._canvas.getContext(this._canvasContextAttributes.contextType, m) : this._canvas.getContext("webgl2", m) || this._canvas.getContext("webgl", m), !s) { const l = "Failed to initialize WebGL"; throw t ? (t.message = l, new Error(JSON.stringify(t))) : new Error(l) } this.painter = new Ep(s, this.transform), be.testSupport(s) } migrateProjection(m, t) { super.migrateProjection(m, t), this.painter.transform = m, this.fire(new c.l("projectiontransition", { newProjection: this.style.projection.name })) } loaded() { return !this._styleDirty && !this._sourcesDirty && !!this.style && this.style.loaded() } _update(m) { return this.style && this.style._loaded ? (this._styleDirty = this._styleDirty || m, this._sourcesDirty = !0, this.triggerRepaint(), this) : this } _requestRenderFrame(m) { return this._update(), this._renderTaskQueue.add(m) } _cancelRenderFrame(m) { this._renderTaskQueue.remove(m) } _render(m) { var t, s, l, d, g; const v = this._idleTriggered ? this._fadeDuration : 0, T = ((t = this.style.projection) === null || t === void 0 ? void 0 : t.transitionState) > 0; if (this.painter.context.setDirty(), this.painter.setBaseState(), this._renderTaskQueue.run(m), this._removed) return; let E = !1; if (this.style && this._styleDirty) { this._styleDirty = !1; const R = this.transform.zoom, z = $e(); this.style.zoomHistory.update(R, z); const O = new c.H(R, { now: z, fadeDuration: v, zoomHistory: this.style.zoomHistory, transition: this.style.getTransition() }), U = O.crossFadingFactor(); U === 1 && U === this._crossFadingFactor || (E = !0, this._crossFadingFactor = U), this.style.update(O) } const I = ((s = this.style.projection) === null || s === void 0 ? void 0 : s.transitionState) > 0 !== T; (l = this.style.projection) === null || l === void 0 || l.setErrorQueryLatitudeDegrees(this.transform.center.lat), this.transform.setTransitionState((d = this.style.projection) === null || d === void 0 ? void 0 : d.transitionState, (g = this.style.projection) === null || g === void 0 ? void 0 : g.latitudeErrorCorrectionRadians), this.style && (this._sourcesDirty || I) && (this._sourcesDirty = !1, this.style._updateSources(this.transform)), this.terrain ? (this.terrain.tileManager.update(this.transform, this.terrain), this.transform.setMinElevationForCurrentTile(this.terrain.getMinTileElevationForLngLatZoom(this.transform.center, this.transform.tileZoom)), !this._elevationFreeze && this._centerClampedToGround && this.transform.setElevation(this.terrain.getElevationForLngLatZoom(this.transform.center, this.transform.tileZoom))) : (this.transform.setMinElevationForCurrentTile(0), this._centerClampedToGround && this.transform.setElevation(0)), this._placementDirty = this.style && this.style._updatePlacement(this.transform, this.showCollisionBoxes, v, this._crossSourceCollisions, I), this.painter.render(this.style, { showTileBoundaries: this.showTileBoundaries, showOverdrawInspector: this._showOverdrawInspector, rotating: this.isRotating(), zooming: this.isZooming(), moving: this.isMoving(), fadeDuration: v, showPadding: this.showPadding }), this.fire(new c.l("render")), this.loaded() && !this._loaded && (this._loaded = !0, c.cG.mark(c.cH.load), this.fire(new c.l("load"))), this.style && (this.style.hasTransitions() || E) && (this._styleDirty = !0), this.style && !this._placementDirty && this.style._releaseSymbolFadeTiles(); const A = this._sourcesDirty || this._styleDirty || this._placementDirty; return A || this._repaint ? this.triggerRepaint() : !this.isMoving() && this.loaded() && this.fire(new c.l("idle")), !this._loaded || this._fullyLoaded || A || (this._fullyLoaded = !0, c.cG.mark(c.cH.fullLoad)), this } redraw() { return this.style && (this._frameRequest && (this._frameRequest.abort(), this._frameRequest = null), this._render(0)), this } remove() { var m; this._hash && this._hash.remove(); for (const s of this._controls) s.onRemove(this); this._controls = [], this._frameRequest && (this._frameRequest.abort(), this._frameRequest = null), this._renderTaskQueue.clear(), this.painter.destroy(), this.handlers.destroy(), delete this.handlers, this.setStyle(null), typeof window < "u" && removeEventListener("online", this._onWindowOnline, !1), ct.removeThrottleControl(this._imageQueueHandle), (m = this._resizeObserver) === null || m === void 0 || m.disconnect(); const t = this.painter.context.gl.getExtension("WEBGL_lose_context"); t != null && t.loseContext && t.loseContext(), this._canvas.removeEventListener("webglcontextrestored", this._contextRestored, !1), this._canvas.removeEventListener("webglcontextlost", this._contextLost, !1), ye.remove(this._canvasContainer), ye.remove(this._controlContainer), this._container.removeEventListener("scroll", this._onMapScroll, !1), this._container.classList.remove("maplibregl-map"), c.cG.clearMetrics(), this._removed = !0, this.fire(new c.l("remove")) } triggerRepaint() { this.style && !this._frameRequest && (this._frameRequest = new AbortController, Ge.frame(this._frameRequest, m => { c.cG.frame(m), this._frameRequest = null; try { this._render(m) } catch (t) { if (!c.Z(t) && !function (s) { return s.message === Qc }(t)) throw t } }, () => { })) } get showTileBoundaries() { return !!this._showTileBoundaries } set showTileBoundaries(m) { this._showTileBoundaries !== m && (this._showTileBoundaries = m, this._update()) } get showPadding() { return !!this._showPadding } set showPadding(m) { this._showPadding !== m && (this._showPadding = m, this._update()) } get showCollisionBoxes() { return !!this._showCollisionBoxes } set showCollisionBoxes(m) { this._showCollisionBoxes !== m && (this._showCollisionBoxes = m, m ? this.style._generateCollisionBoxes() : this._update()) } get showOverdrawInspector() { return !!this._showOverdrawInspector } set showOverdrawInspector(m) { this._showOverdrawInspector !== m && (this._showOverdrawInspector = m, this._update()) } get repaint() { return !!this._repaint } set repaint(m) { this._repaint !== m && (this._repaint = m, this.triggerRepaint()) } get vertices() { return !!this._vertices } set vertices(m) { this._vertices = m, this._update() } get version() { return fh } getCameraTargetElevation() { return this.transform.elevation } getProjection() { return this.style.getProjection() } setProjection(m) { return this._lazyInitEmptyStyle(), this.style.setProjection(m), this._update(!0) } }, b.MapMouseEvent = nn, b.MapTouchEvent = rl, b.MapWheelEvent = Ip, b.Marker = pl, b.NavigationControl = class { constructor(m) { this._updateZoomButtons = () => { const t = this._map.getZoom(), s = t === this._map.getMaxZoom(), l = t === this._map.getMinZoom(); this._zoomInButton.disabled = s, this._zoomOutButton.disabled = l, this._zoomInButton.setAttribute("aria-disabled", s.toString()), this._zoomOutButton.setAttribute("aria-disabled", l.toString()) }, this._rotateCompassArrow = () => { this._compassIcon.style.transform = this.options.visualizePitch && this.options.visualizeRoll ? `scale(${1 / Math.pow(Math.cos(this._map.transform.pitchInRadians), .5)}) rotateZ(${-this._map.transform.roll}deg) rotateX(${this._map.transform.pitch}deg) rotateZ(${-this._map.transform.bearing}deg)` : this.options.visualizePitch ? `scale(${1 / Math.pow(Math.cos(this._map.transform.pitchInRadians), .5)}) rotateX(${this._map.transform.pitch}deg) rotateZ(${-this._map.transform.bearing}deg)` : this.options.visualizeRoll ? `rotate(${-this._map.transform.bearing - this._map.transform.roll}deg)` : `rotate(${-this._map.transform.bearing}deg)` }, this._setButtonTitle = (t, s) => { const l = this._map._getUIString(`NavigationControl.${s}`); t.title = l, t.setAttribute("aria-label", l) }, this.options = c.e({}, mh, m), this._container = ye.create("div", "maplibregl-ctrl maplibregl-ctrl-group"), this._container.addEventListener("contextmenu", t => t.preventDefault()), this.options.showZoom && (this._zoomInButton = this._createButton("maplibregl-ctrl-zoom-in", t => this._map.zoomIn({}, { originalEvent: t })), ye.create("span", "maplibregl-ctrl-icon", this._zoomInButton).setAttribute("aria-hidden", "true"), this._zoomOutButton = this._createButton("maplibregl-ctrl-zoom-out", t => this._map.zoomOut({}, { originalEvent: t })), ye.create("span", "maplibregl-ctrl-icon", this._zoomOutButton).setAttribute("aria-hidden", "true")), this.options.showCompass && (this._compass = this._createButton("maplibregl-ctrl-compass", t => { this.options.visualizePitch ? this._map.resetNorthPitch({}, { originalEvent: t }) : this._map.resetNorth({}, { originalEvent: t }) }), this._compassIcon = ye.create("span", "maplibregl-ctrl-icon", this._compass), this._compassIcon.setAttribute("aria-hidden", "true")) } onAdd(m) { return this._map = m, this.options.showZoom && (this._setButtonTitle(this._zoomInButton, "ZoomIn"), this._setButtonTitle(this._zoomOutButton, "ZoomOut"), this._map.on("zoom", this._updateZoomButtons), this._updateZoomButtons()), this.options.showCompass && (this._setButtonTitle(this._compass, "ResetBearing"), this.options.visualizePitch && this._map.on("pitch", this._rotateCompassArrow), this.options.visualizeRoll && this._map.on("roll", this._rotateCompassArrow), this._map.on("rotate", this._rotateCompassArrow), this._rotateCompassArrow(), this._handler = new hl(this._map, this._compass, this.options.visualizePitch)), this._container } onRemove() { ye.remove(this._container), this.options.showZoom && this._map.off("zoom", this._updateZoomButtons), this.options.showCompass && (this.options.visualizePitch && this._map.off("pitch", this._rotateCompassArrow), this.options.visualizeRoll && this._map.off("roll", this._rotateCompassArrow), this._map.off("rotate", this._rotateCompassArrow), this._handler.off(), delete this._handler), delete this._map } _createButton(m, t) { const s = ye.create("button", m, this._container); return s.type = "button", s.addEventListener("click", t), s } }, b.Popup = class extends c.E { constructor(m) { super(), this._updateOpacity = () => { this.options.locationOccludedOpacity !== void 0 && (this._container.style.opacity = this._map.transform.isLocationOccluded(this.getLngLat()) ? `${this.options.locationOccludedOpacity}` : "") }, this.remove = () => (this._content && ye.remove(this._content), this._container && (ye.remove(this._container), delete this._container), this._map && (this._map.off("move", this._update), this._map.off("move", this._onClose), this._map.off("click", this._onClose), this._map.off("remove", this.remove), this._map.off("mousemove", this._onMouseMove), this._map.off("mouseup", this._onMouseUp), this._map.off("drag", this._onDrag), this._map._canvasContainer.classList.remove("maplibregl-track-pointer"), delete this._map, this.fire(new c.l("close"))), this), this._onMouseUp = t => { this._update(t.point) }, this._onMouseMove = t => { this._update(t.point) }, this._onDrag = t => { this._update(t.point) }, this._update = t => { if (!this._map || !this._lngLat && !this._trackPointer || !this._content) return; if (!this._container) { if (this._container = ye.create("div", "maplibregl-popup", this._map.getContainer()), this._tip = ye.create("div", "maplibregl-popup-tip", this._container), this._container.appendChild(this._content), this.options.className) for (const v of this.options.className.split(" ")) this._container.classList.add(v); this._closeButton && this._closeButton.setAttribute("aria-label", this._map._getUIString("Popup.Close")), this._trackPointer && this._container.classList.add("maplibregl-popup-track-pointer") } if (this.options.maxWidth && this._container.style.maxWidth !== this.options.maxWidth && (this._container.style.maxWidth = this.options.maxWidth), this._lngLat = Pu(this._lngLat, this._flatPos, this._map.transform, this._trackPointer), this._trackPointer && !t) return; const s = this._flatPos = this._pos = this._trackPointer && t ? t : this._map.project(this._lngLat); this._map.terrain && (this._flatPos = this._trackPointer && t ? t : this._map.transform.locationToScreenPoint(this._lngLat)); let l = this.options.anchor; const d = Cu(this.options.offset); if (!l) { const v = this._container.offsetWidth, T = this._container.offsetHeight; let E; E = s.y + d.bottom.y < T ? ["top"] : s.y > this._map.transform.height - T ? ["bottom"] : [], s.x < v / 2 ? E.push("left") : s.x > this._map.transform.width - v / 2 && E.push("right"), l = E.length === 0 ? "bottom" : E.join("-") } let g = s.add(d[l]); this.options.subpixelPositioning || (g = g.round()), ye.setTransform(this._container, `${dl[l]} translate(${g.x}px,${g.y}px)`), Mu(this._container, l, "popup"), this._updateOpacity() }, this._onClose = () => { this.remove() }, this.options = c.e(Object.create(yh), m) } addTo(m) { return this._map && this.remove(), this._map = m, this.options.closeOnClick && this._map.on("click", this._onClose), this.options.closeOnMove && this._map.on("move", this._onClose), this._map.on("remove", this.remove), this._update(), this._focusFirstElement(), this._trackPointer ? (this._map.on("mousemove", this._onMouseMove), this._map.on("mouseup", this._onMouseUp), this._container && this._container.classList.add("maplibregl-popup-track-pointer"), this._map._canvasContainer.classList.add("maplibregl-track-pointer")) : this._map.on("move", this._update), this.fire(new c.l("open")), this } isOpen() { return !!this._map } getLngLat() { return this._lngLat } setLngLat(m) { return this._lngLat = c.V.convert(m), this._pos = null, this._flatPos = null, this._trackPointer = !1, this._update(), this._map && (this._map.on("move", this._update), this._map.off("mousemove", this._onMouseMove), this._container && this._container.classList.remove("maplibregl-popup-track-pointer"), this._map._canvasContainer.classList.remove("maplibregl-track-pointer")), this } trackPointer() { return this._trackPointer = !0, this._pos = null, this._flatPos = null, this._update(), this._map && (this._map.off("move", this._update), this._map.on("mousemove", this._onMouseMove), this._map.on("drag", this._onDrag), this._container && this._container.classList.add("maplibregl-popup-track-pointer"), this._map._canvasContainer.classList.add("maplibregl-track-pointer")), this } getElement() { return this._container } setText(m) { return this.setDOMContent(document.createTextNode(m)) } setHTML(m) { const t = document.createDocumentFragment(), s = document.createElement("body"); let l; for (s.innerHTML = m; l = s.firstChild, l;)t.appendChild(l); return this.setDOMContent(t) } getMaxWidth() { var m; return (m = this._container) === null || m === void 0 ? void 0 : m.style.maxWidth } setMaxWidth(m) { return this.options.maxWidth = m, this._update(), this } setDOMContent(m) { if (this._content) for (; this._content.hasChildNodes();)this._content.firstChild && this._content.removeChild(this._content.firstChild); else this._content = ye.create("div", "maplibregl-popup-content", this._container); return this._content.appendChild(m), this._createCloseButton(), this._update(), this._focusFirstElement(), this } addClassName(m) { return this._container && this._container.classList.add(m), this } removeClassName(m) { return this._container && this._container.classList.remove(m), this } setOffset(m) { return this.options.offset = m, this._update(), this } toggleClassName(m) { if (this._container) return this._container.classList.toggle(m) } setSubpixelPositioning(m) { this.options.subpixelPositioning = m } _createCloseButton() { this.options.closeButton && (this._closeButton = ye.create("button", "maplibregl-popup-close-button", this._content), this._closeButton.type = "button", this._closeButton.innerHTML = "&#215;", this._closeButton.addEventListener("click", this._onClose)) } _focusFirstElement() { if (!this.options.focusAfterOpen || !this._container) return; const m = this._container.querySelector(Iu); m && m.focus() } }, b.RasterDEMTileSource = vs, b.RasterTileSource = Po, b.ScaleControl = class { constructor(m) { this._onMove = () => { fl(this._map, this._container, this.options) }, this.setUnit = t => { this.options.unit = t, fl(this._map, this._container, this.options) }, this.options = Object.assign(Object.assign({}, _h), m) } getDefaultPosition() { return "bottom-left" } onAdd(m) { return this._map = m, this._container = ye.create("div", "maplibregl-ctrl maplibregl-ctrl-scale", m.getContainer()), this._map.on("move", this._onMove), this._onMove(), this._container } onRemove() { ye.remove(this._container), this._map.off("move", this._onMove), this._map = void 0 } }, b.ScrollZoomHandler = wu, b.Style = Xs, b.TerrainControl = class { constructor(m) { this._toggleTerrain = () => { this._map.getTerrain() ? this._map.setTerrain(null) : this._map.setTerrain(this.options), this._updateTerrainIcon() }, this._updateTerrainIcon = () => { this._terrainButton.classList.remove("maplibregl-ctrl-terrain"), this._terrainButton.classList.remove("maplibregl-ctrl-terrain-enabled"), this._map.terrain ? (this._terrainButton.classList.add("maplibregl-ctrl-terrain-enabled"), this._terrainButton.title = this._map._getUIString("TerrainControl.Disable")) : (this._terrainButton.classList.add("maplibregl-ctrl-terrain"), this._terrainButton.title = this._map._getUIString("TerrainControl.Enable")) }, this.options = m } onAdd(m) { return this._map = m, this._container = ye.create("div", "maplibregl-ctrl maplibregl-ctrl-group"), this._terrainButton = ye.create("button", "maplibregl-ctrl-terrain", this._container), ye.create("span", "maplibregl-ctrl-icon", this._terrainButton).setAttribute("aria-hidden", "true"), this._terrainButton.type = "button", this._terrainButton.addEventListener("click", this._toggleTerrain), this._updateTerrainIcon(), this._map.on("terrain", this._updateTerrainIcon), this._container } onRemove() { ye.remove(this._container), this._map.off("terrain", this._updateTerrainIcon), this._map = void 0 } }, b.TwoFingersTouchPitchHandler = Dp, b.TwoFingersTouchRotateHandler = ch, b.TwoFingersTouchZoomHandler = uh, b.TwoFingersTouchZoomRotateHandler = al, b.VectorTileSource = Us, b.VideoSource = Pe, b.addSourceType = (m, t) => c._(void 0, void 0, void 0, function* () { if (W(m)) throw new Error(`A source type called "${m}" already exists.`); ((s, l) => { j[s] = l })(m, t) }), b.clearPrewarmedResources = function () { const m = Yt; m && (m.isPreloaded() && m.numActive() === 1 ? (m.release(Ut), Yt = null) : console.warn("Could not clear WebWorkers since there are active Map instances that still reference it. The pre-warmed WebWorker pool can only be cleared when all map instances have been removed with map.remove()")) }, b.createTileMesh = qd, b.getMaxParallelImageRequests = function () { return c.c.MAX_PARALLEL_IMAGE_REQUESTS }, b.getRTLTextPluginStatus = function () { return Ee().getRTLTextPluginStatus() }, b.getVersion = function () { return vh }, b.getWorkerCount = function () { return St.workerCount }, b.getWorkerUrl = function () { return c.c.WORKER_URL }, b.importScriptInWorkers = function (m) { return vn().broadcast("IS", m) }, b.isTimeFrozen = function () { return Ye.isFrozen() }, b.now = $e, b.prewarm = function () { vi().acquire(Ut) }, b.restoreNow = function () { Ye.restoreNow() }, b.setMaxParallelImageRequests = function (m) { c.c.MAX_PARALLEL_IMAGE_REQUESTS = m }, b.setNow = function (m) { Ye.setNow(m) }, b.setRTLTextPlugin = function (m, t) { return Ee().setRTLTextPlugin(m, t) }, b.setWorkerCount = function (m) { St.workerCount = m }, b.setWorkerUrl = function (m) { c.c.WORKER_URL = m }
        }); var P = h; return P
    })
})(N2); var tI = N2.exports; const D_ = Pw(tI), ow = i => { let o; const h = new Set, y = ($, me) => { const ge = typeof $ == "function" ? $(o) : $; if (!Object.is(ge, o)) { const we = o; o = me ?? (typeof ge != "object" || ge === null) ? ge : Object.assign({}, o, ge), h.forEach(Ge => Ge(o, we)) } }, w = () => o, c = { setState: y, getState: w, getInitialState: () => B, subscribe: $ => (h.add($), () => h.delete($)) }, B = o = i(y, w, c); return c }, rI = i => i ? ow(i) : ow, nI = i => i; function iI(i, o = nI) { const h = Kh.useSyncExternalStore(i.subscribe, Kh.useCallback(() => o(i.getState()), [i, o]), Kh.useCallback(() => o(i.getInitialState()), [i, o])); return Kh.useDebugValue(h), h } const aw = i => { const o = rI(i), h = y => iI(o, y); return Object.assign(h, o), h }, sI = i => i ? aw(i) : aw, Vs = sI(i => ({ userPosition: null, setUserPosition: o => i({ userPosition: o }), status: "IDLE", gameMode: null, extractionPoint: null, shadowPosition: null, shadowDistance: null, exploredPolygon: null, setStatus: o => i({ status: o }), setGameMode: o => i({ gameMode: o }), setExtractionPoint: o => i({ extractionPoint: o }), setShadowPosition: o => i({ shadowPosition: o }), setShadowDistance: o => i({ shadowDistance: o }), setExploredPolygon: o => i({ exploredPolygon: o }), resetGame: () => i({ status: "IDLE", gameMode: null, extractionPoint: null, shadowPosition: null, shadowDistance: null, exploredPolygon: null }) })); var Di = 63710088e-1, V2 = { centimeters: Di * 100, centimetres: Di * 100, degrees: 360 / (2 * Math.PI), feet: Di * 3.28084, inches: Di * 39.37, kilometers: Di / 1e3, kilometres: Di / 1e3, meters: Di, metres: Di, miles: Di / 1609.344, millimeters: Di * 1e3, millimetres: Di * 1e3, nauticalmiles: Di / 1852, radians: 1, yards: Di * 1.0936 }; function F0(i, o, h = {}) { const y = { type: "Feature" }; return (h.id === 0 || h.id) && (y.id = h.id), h.bbox && (y.bbox = h.bbox), y.properties = o || {}, y.geometry = i, y } function Al(i, o, h = {}) { if (!i) throw new Error("coordinates is required"); if (!Array.isArray(i)) throw new Error("coordinates must be an Array"); if (i.length < 2) throw new Error("coordinates must be at least 2 numbers long"); if (!lw(i[0]) || !lw(i[1])) throw new Error("coordinates must contain numbers"); return F0({ type: "Point", coordinates: i }, o, h) } function B0(i, o, h = {}) { for (const w of i) { if (w.length < 4) throw new Error("Each LinearRing of a Polygon must have 4 or more Positions."); if (w[w.length - 1].length !== w[0].length) throw new Error("First and last Position are not equivalent."); for (let P = 0; P < w[w.length - 1].length; P++)if (w[w.length - 1][P] !== w[0][P]) throw new Error("First and last Position are not equivalent.") } return F0({ type: "Polygon", coordinates: i }, o, h) } function oI(i, o = {}) { const h = { type: "FeatureCollection" }; return o.id && (h.id = o.id), o.bbox && (h.bbox = o.bbox), h.features = i, h } function U2(i, o, h = {}) { return F0({ type: "MultiPolygon", coordinates: i }, o, h) } function aI(i, o = "kilometers") { const h = V2[o]; if (!h) throw new Error(o + " units is invalid"); return i * h } function lI(i, o = "kilometers") { const h = V2[o]; if (!h) throw new Error(o + " units is invalid"); return i / h } function ky(i) { return i % (2 * Math.PI) * 180 / Math.PI } function fs(i) { return i % 360 * Math.PI / 180 } function lw(i) { return !isNaN(i) && i !== null && !Array.isArray(i) } function kd(i) { if (!i) throw new Error("coord is required"); if (!Array.isArray(i)) { if (i.type === "Feature" && i.geometry !== null && i.geometry.type === "Point") return [...i.geometry.coordinates]; if (i.type === "Point") return [...i.coordinates] } if (Array.isArray(i) && i.length >= 2 && !Array.isArray(i[0]) && !Array.isArray(i[1])) return [...i]; throw new Error("coord must be GeoJSON Point or an Array of numbers") } function G2(i, o, h = {}) { if (h.final === !0) return uI(i, o); const y = kd(i), w = kd(o), P = fs(y[0]), b = fs(w[0]), c = fs(y[1]), B = fs(w[1]), $ = Math.sin(b - P) * Math.cos(B), me = Math.cos(c) * Math.sin(B) - Math.sin(c) * Math.cos(B) * Math.cos(b - P); return ky(Math.atan2($, me)) } function uI(i, o) { let h = G2(o, i); return h = (h + 180) % 360, h } function rd(i, o, h, y = {}) { const w = kd(i), P = fs(w[0]), b = fs(w[1]), c = fs(h), B = lI(o, y.units), $ = Math.asin(Math.sin(b) * Math.cos(B) + Math.cos(b) * Math.sin(B) * Math.cos(c)), me = P + Math.atan2(Math.sin(c) * Math.sin(B) * Math.cos(b), Math.cos(B) - Math.sin(b) * Math.sin($)), ge = ky(me), we = ky($); return w[2] !== void 0 ? Al([ge, we, w[2]], y.properties) : Al([ge, we], y.properties) } function uw(i, o, h = {}) { var y = kd(i), w = kd(o), P = fs(w[1] - y[1]), b = fs(w[0] - y[0]), c = fs(y[1]), B = fs(w[1]), $ = Math.pow(Math.sin(P / 2), 2) + Math.pow(Math.sin(b / 2), 2) * Math.cos(c) * Math.cos(B); return aI(2 * Math.atan2(Math.sqrt($), Math.sqrt(1 - $)), h.units) } function cI(i, o) { var h, y, w, P, b, c, B, $, me, ge, we = 0, Ge = i.type === "FeatureCollection", Ye = i.type === "Feature", $e = Ge ? i.features.length : 1; for (h = 0; h < $e; h++) { for (c = Ge ? i.features[h].geometry : Ye ? i.geometry : i, $ = Ge ? i.features[h].properties : Ye ? i.properties : {}, me = Ge ? i.features[h].bbox : Ye ? i.bbox : void 0, ge = Ge ? i.features[h].id : Ye ? i.id : void 0, B = c ? c.type === "GeometryCollection" : !1, b = B ? c.geometries.length : 1, w = 0; w < b; w++) { if (P = B ? c.geometries[w] : c, P === null) { if (o(null, we, $, me, ge) === !1) return !1; continue } switch (P.type) { case "Point": case "LineString": case "MultiPoint": case "Polygon": case "MultiLineString": case "MultiPolygon": { if (o(P, we, $, me, ge) === !1) return !1; break } case "GeometryCollection": { for (y = 0; y < P.geometries.length; y++)if (o(P.geometries[y], we, $, me, ge) === !1) return !1; break } default: throw new Error("Unknown Geometry Type") } } we++ } } function hI(i, o, h = {}) { const y = h.steps || 64, w = h.properties ? h.properties : !Array.isArray(i) && i.type === "Feature" && i.properties ? i.properties : {}, P = []; for (let b = 0; b < y; b++)P.push(rd(i, o, b * -360 / y, h).geometry.coordinates); return P.push(P[0]), B0([P], w) } function dI(i) { if (!i) throw new Error("geojson is required"); switch (i.type) { case "Feature": return $2(i); case "FeatureCollection": return pI(i); case "Point": case "LineString": case "Polygon": case "MultiPoint": case "MultiLineString": case "MultiPolygon": case "GeometryCollection": return O0(i); default: throw new Error("unknown GeoJSON type") } } function $2(i) { const o = { type: "Feature" }; return Object.keys(i).forEach(h => { switch (h) { case "type": case "properties": case "geometry": return; default: o[h] = i[h] } }), o.properties = q2(i.properties), i.geometry == null ? o.geometry = null : o.geometry = O0(i.geometry), o } function q2(i) { const o = {}; return i && Object.keys(i).forEach(h => { const y = i[h]; typeof y == "object" ? y === null ? o[h] = null : Array.isArray(y) ? o[h] = y.map(w => w) : o[h] = q2(y) : o[h] = y }), o } function pI(i) { const o = { type: "FeatureCollection" }; return Object.keys(i).forEach(h => { switch (h) { case "type": case "features": return; default: o[h] = i[h] } }), o.features = i.features.map(h => $2(h)), o } function O0(i) { const o = { type: i.type }; return i.bbox && (o.bbox = i.bbox), i.type === "GeometryCollection" ? (o.geometries = i.geometries.map(h => O0(h)), o) : (o.coordinates = Z2(i.coordinates), o) } function Z2(i) { const o = i; return typeof o[0] != "object" ? o.slice() : o.map(h => Z2(h)) } var fI = /^-?(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?$/i, z_ = Math.ceil, Zi = Math.floor, pi = "[BigNumber Error] ", cw = pi + "Number primitive has more than 15 significant digits: ", cs = 1e14, Bt = 14, R_ = 9007199254740991, L_ = [1, 10, 100, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8, 1e9, 1e10, 1e11, 1e12, 1e13], la = 1e7, En = 1e9; function W2(i) { var o, h, y, w = K.prototype = { constructor: K, toString: null, valueOf: null }, P = new K(1), b = 20, c = 4, B = -7, $ = 21, me = -1e7, ge = 1e7, we = !1, Ge = 1, Ye = 0, $e = { prefix: "", groupSize: 3, secondaryGroupSize: 0, groupSeparator: ",", decimalSeparator: ".", fractionGroupSize: 0, fractionGroupSeparator: "", suffix: "" }, ye = "0123456789abcdefghijklmnopqrstuvwxyz", be = !0; function K(Z, re) { var ie, Ce, xe, Te, Ne, _e, Me, Le, de = this; if (!(de instanceof K)) return new K(Z, re); if (re == null) { if (Z && Z._isBigNumber === !0) { de.s = Z.s, !Z.c || Z.e > ge ? de.c = de.e = null : Z.e < me ? de.c = [de.e = 0] : (de.e = Z.e, de.c = Z.c.slice()); return } if ((_e = typeof Z == "number") && Z * 0 == 0) { if (de.s = 1 / Z < 0 ? (Z = -Z, -1) : 1, Z === ~~Z) { for (Te = 0, Ne = Z; Ne >= 10; Ne /= 10, Te++); Te > ge ? de.c = de.e = null : (de.e = Te, de.c = [Z]); return } Le = String(Z) } else { if (!fI.test(Le = String(Z))) return y(de, Le, _e); de.s = Le.charCodeAt(0) == 45 ? (Le = Le.slice(1), -1) : 1 } (Te = Le.indexOf(".")) > -1 && (Le = Le.replace(".", "")), (Ne = Le.search(/e/i)) > 0 ? (Te < 0 && (Te = Ne), Te += +Le.slice(Ne + 1), Le = Le.substring(0, Ne)) : Te < 0 && (Te = Le.length) } else { if (Gr(re, 2, ye.length, "Base"), re == 10 && be) return de = new K(Z), mt(de, b + de.e + 1, c); if (Le = String(Z), _e = typeof Z == "number") { if (Z * 0 != 0) return y(de, Le, _e, re); if (de.s = 1 / Z < 0 ? (Le = Le.slice(1), -1) : 1, K.DEBUG && Le.replace(/^0\.0*|\./, "").length > 15) throw Error(cw + Z) } else de.s = Le.charCodeAt(0) === 45 ? (Le = Le.slice(1), -1) : 1; for (ie = ye.slice(0, re), Te = Ne = 0, Me = Le.length; Ne < Me; Ne++)if (ie.indexOf(Ce = Le.charAt(Ne)) < 0) { if (Ce == ".") { if (Ne > Te) { Te = Me; continue } } else if (!xe && (Le == Le.toUpperCase() && (Le = Le.toLowerCase()) || Le == Le.toLowerCase() && (Le = Le.toUpperCase()))) { xe = !0, Ne = -1, Te = 0; continue } return y(de, String(Z), _e, re) } _e = !1, Le = h(Le, re, 10, de.s), (Te = Le.indexOf(".")) > -1 ? Le = Le.replace(".", "") : Te = Le.length } for (Ne = 0; Le.charCodeAt(Ne) === 48; Ne++); for (Me = Le.length; Le.charCodeAt(--Me) === 48;); if (Le = Le.slice(Ne, ++Me)) { if (Me -= Ne, _e && K.DEBUG && Me > 15 && (Z > R_ || Z !== Zi(Z))) throw Error(cw + de.s * Z); if ((Te = Te - Ne - 1) > ge) de.c = de.e = null; else if (Te < me) de.c = [de.e = 0]; else { if (de.e = Te, de.c = [], Ne = (Te + 1) % Bt, Te < 0 && (Ne += Bt), Ne < Me) { for (Ne && de.c.push(+Le.slice(0, Ne)), Me -= Bt; Ne < Me;)de.c.push(+Le.slice(Ne, Ne += Bt)); Ne = Bt - (Le = Le.slice(Ne)).length } else Ne -= Me; for (; Ne--; Le += "0"); de.c.push(+Le) } } else de.c = [de.e = 0] } K.clone = W2, K.ROUND_UP = 0, K.ROUND_DOWN = 1, K.ROUND_CEIL = 2, K.ROUND_FLOOR = 3, K.ROUND_HALF_UP = 4, K.ROUND_HALF_DOWN = 5, K.ROUND_HALF_EVEN = 6, K.ROUND_HALF_CEIL = 7, K.ROUND_HALF_FLOOR = 8, K.EUCLID = 9, K.config = K.set = function (Z) { var re, ie; if (Z != null) if (typeof Z == "object") { if (Z.hasOwnProperty(re = "DECIMAL_PLACES") && (ie = Z[re], Gr(ie, 0, En, re), b = ie), Z.hasOwnProperty(re = "ROUNDING_MODE") && (ie = Z[re], Gr(ie, 0, 8, re), c = ie), Z.hasOwnProperty(re = "EXPONENTIAL_AT") && (ie = Z[re], ie && ie.pop ? (Gr(ie[0], -En, 0, re), Gr(ie[1], 0, En, re), B = ie[0], $ = ie[1]) : (Gr(ie, -En, En, re), B = -($ = ie < 0 ? -ie : ie))), Z.hasOwnProperty(re = "RANGE")) if (ie = Z[re], ie && ie.pop) Gr(ie[0], -En, -1, re), Gr(ie[1], 1, En, re), me = ie[0], ge = ie[1]; else if (Gr(ie, -En, En, re), ie) me = -(ge = ie < 0 ? -ie : ie); else throw Error(pi + re + " cannot be zero: " + ie); if (Z.hasOwnProperty(re = "CRYPTO")) if (ie = Z[re], ie === !!ie) if (ie) if (typeof crypto < "u" && crypto && (crypto.getRandomValues || crypto.randomBytes)) we = ie; else throw we = !ie, Error(pi + "crypto unavailable"); else we = ie; else throw Error(pi + re + " not true or false: " + ie); if (Z.hasOwnProperty(re = "MODULO_MODE") && (ie = Z[re], Gr(ie, 0, 9, re), Ge = ie), Z.hasOwnProperty(re = "POW_PRECISION") && (ie = Z[re], Gr(ie, 0, En, re), Ye = ie), Z.hasOwnProperty(re = "FORMAT")) if (ie = Z[re], typeof ie == "object") $e = ie; else throw Error(pi + re + " not an object: " + ie); if (Z.hasOwnProperty(re = "ALPHABET")) if (ie = Z[re], typeof ie == "string" && !/^.?$|[+\-.\s]|(.).*\1/.test(ie)) be = ie.slice(0, 10) == "0123456789", ye = ie; else throw Error(pi + re + " invalid: " + ie) } else throw Error(pi + "Object expected: " + Z); return { DECIMAL_PLACES: b, ROUNDING_MODE: c, EXPONENTIAL_AT: [B, $], RANGE: [me, ge], CRYPTO: we, MODULO_MODE: Ge, POW_PRECISION: Ye, FORMAT: $e, ALPHABET: ye } }, K.isBigNumber = function (Z) { if (!Z || Z._isBigNumber !== !0) return !1; if (!K.DEBUG) return !0; var re, ie, Ce = Z.c, xe = Z.e, Te = Z.s; e: if ({}.toString.call(Ce) == "[object Array]") { if ((Te === 1 || Te === -1) && xe >= -En && xe <= En && xe === Zi(xe)) { if (Ce[0] === 0) { if (xe === 0 && Ce.length === 1) return !0; break e } if (re = (xe + 1) % Bt, re < 1 && (re += Bt), String(Ce[0]).length == re) { for (re = 0; re < Ce.length; re++)if (ie = Ce[re], ie < 0 || ie >= cs || ie !== Zi(ie)) break e; if (ie !== 0) return !0 } } } else if (Ce === null && xe === null && (Te === null || Te === 1 || Te === -1)) return !0; throw Error(pi + "Invalid BigNumber: " + Z) }, K.maximum = K.max = function () { return Ke(arguments, -1) }, K.minimum = K.min = function () { return Ke(arguments, 1) }, K.random = function () { var Z = 9007199254740992, re = Math.random() * Z & 2097151 ? function () { return Zi(Math.random() * Z) } : function () { return (Math.random() * 1073741824 | 0) * 8388608 + (Math.random() * 8388608 | 0) }; return function (ie) { var Ce, xe, Te, Ne, _e, Me = 0, Le = [], de = new K(P); if (ie == null ? ie = b : Gr(ie, 0, En), Ne = z_(ie / Bt), we) if (crypto.getRandomValues) { for (Ce = crypto.getRandomValues(new Uint32Array(Ne *= 2)); Me < Ne;)_e = Ce[Me] * 131072 + (Ce[Me + 1] >>> 11), _e >= 9e15 ? (xe = crypto.getRandomValues(new Uint32Array(2)), Ce[Me] = xe[0], Ce[Me + 1] = xe[1]) : (Le.push(_e % 1e14), Me += 2); Me = Ne / 2 } else if (crypto.randomBytes) { for (Ce = crypto.randomBytes(Ne *= 7); Me < Ne;)_e = (Ce[Me] & 31) * 281474976710656 + Ce[Me + 1] * 1099511627776 + Ce[Me + 2] * 4294967296 + Ce[Me + 3] * 16777216 + (Ce[Me + 4] << 16) + (Ce[Me + 5] << 8) + Ce[Me + 6], _e >= 9e15 ? crypto.randomBytes(7).copy(Ce, Me) : (Le.push(_e % 1e14), Me += 7); Me = Ne / 7 } else throw we = !1, Error(pi + "crypto unavailable"); if (!we) for (; Me < Ne;)_e = re(), _e < 9e15 && (Le[Me++] = _e % 1e14); for (Ne = Le[--Me], ie %= Bt, Ne && ie && (_e = L_[Bt - ie], Le[Me] = Zi(Ne / _e) * _e); Le[Me] === 0; Le.pop(), Me--); if (Me < 0) Le = [Te = 0]; else { for (Te = -1; Le[0] === 0; Le.splice(0, 1), Te -= Bt); for (Me = 1, _e = Le[0]; _e >= 10; _e /= 10, Me++); Me < Bt && (Te -= Bt - Me) } return de.e = Te, de.c = Le, de } }(), K.sum = function () { for (var Z = 1, re = arguments, ie = new K(re[0]); Z < re.length;)ie = ie.plus(re[Z++]); return ie }, h = function () { var Z = "0123456789"; function re(ie, Ce, xe, Te) { for (var Ne, _e = [0], Me, Le = 0, de = ie.length; Le < de;) { for (Me = _e.length; Me--; _e[Me] *= Ce); for (_e[0] += Te.indexOf(ie.charAt(Le++)), Ne = 0; Ne < _e.length; Ne++)_e[Ne] > xe - 1 && (_e[Ne + 1] == null && (_e[Ne + 1] = 0), _e[Ne + 1] += _e[Ne] / xe | 0, _e[Ne] %= xe) } return _e.reverse() } return function (ie, Ce, xe, Te, Ne) { var _e, Me, Le, de, Se, et, lt, Tt, Zt = ie.indexOf("."), Ut = b, St = c; for (Zt >= 0 && (de = Ye, Ye = 0, ie = ie.replace(".", ""), Tt = new K(Ce), et = Tt.pow(ie.length - Zt), Ye = de, Tt.c = re(fo(qi(et.c), et.e, "0"), 10, xe, Z), Tt.e = Tt.c.length), lt = re(ie, Ce, xe, Ne ? (_e = ye, Z) : (_e = Z, ye)), Le = de = lt.length; lt[--de] == 0; lt.pop()); if (!lt[0]) return _e.charAt(0); if (Zt < 0 ? --Le : (et.c = lt, et.e = Le, et.s = Te, et = o(et, Tt, Ut, St, xe), lt = et.c, Se = et.r, Le = et.e), Me = Le + Ut + 1, Zt = lt[Me], de = xe / 2, Se = Se || Me < 0 || lt[Me + 1] != null, Se = St < 4 ? (Zt != null || Se) && (St == 0 || St == (et.s < 0 ? 3 : 2)) : Zt > de || Zt == de && (St == 4 || Se || St == 6 && lt[Me - 1] & 1 || St == (et.s < 0 ? 8 : 7)), Me < 1 || !lt[0]) ie = Se ? fo(_e.charAt(1), -Ut, _e.charAt(0)) : _e.charAt(0); else { if (lt.length = Me, Se) for (--xe; ++lt[--Me] > xe;)lt[Me] = 0, Me || (++Le, lt = [1].concat(lt)); for (de = lt.length; !lt[--de];); for (Zt = 0, ie = ""; Zt <= de; ie += _e.charAt(lt[Zt++])); ie = fo(ie, Le, _e.charAt(0)) } return ie } }(), o = function () { function Z(Ce, xe, Te) { var Ne, _e, Me, Le, de = 0, Se = Ce.length, et = xe % la, lt = xe / la | 0; for (Ce = Ce.slice(); Se--;)Me = Ce[Se] % la, Le = Ce[Se] / la | 0, Ne = lt * Me + Le * et, _e = et * Me + Ne % la * la + de, de = (_e / Te | 0) + (Ne / la | 0) + lt * Le, Ce[Se] = _e % Te; return de && (Ce = [de].concat(Ce)), Ce } function re(Ce, xe, Te, Ne) { var _e, Me; if (Te != Ne) Me = Te > Ne ? 1 : -1; else for (_e = Me = 0; _e < Te; _e++)if (Ce[_e] != xe[_e]) { Me = Ce[_e] > xe[_e] ? 1 : -1; break } return Me } function ie(Ce, xe, Te, Ne) { for (var _e = 0; Te--;)Ce[Te] -= _e, _e = Ce[Te] < xe[Te] ? 1 : 0, Ce[Te] = _e * Ne + Ce[Te] - xe[Te]; for (; !Ce[0] && Ce.length > 1; Ce.splice(0, 1)); } return function (Ce, xe, Te, Ne, _e) { var Me, Le, de, Se, et, lt, Tt, Zt, Ut, St, Ct, Yt, Wr, vi, In, vn, dn, rn = Ce.s == xe.s ? 1 : -1, qt = Ce.c, Gt = xe.c; if (!qt || !qt[0] || !Gt || !Gt[0]) return new K(!Ce.s || !xe.s || (qt ? Gt && qt[0] == Gt[0] : !Gt) ? NaN : qt && qt[0] == 0 || !Gt ? rn * 0 : rn / 0); for (Zt = new K(rn), Ut = Zt.c = [], Le = Ce.e - xe.e, rn = Te + Le + 1, _e || (_e = cs, Le = Wi(Ce.e / Bt) - Wi(xe.e / Bt), rn = rn / Bt | 0), de = 0; Gt[de] == (qt[de] || 0); de++); if (Gt[de] > (qt[de] || 0) && Le--, rn < 0) Ut.push(1), Se = !0; else { for (vi = qt.length, vn = Gt.length, de = 0, rn += 2, et = Zi(_e / (Gt[0] + 1)), et > 1 && (Gt = Z(Gt, et, _e), qt = Z(qt, et, _e), vn = Gt.length, vi = qt.length), Wr = vn, St = qt.slice(0, vn), Ct = St.length; Ct < vn; St[Ct++] = 0); dn = Gt.slice(), dn = [0].concat(dn), In = Gt[0], Gt[1] >= _e / 2 && In++; do { if (et = 0, Me = re(Gt, St, vn, Ct), Me < 0) { if (Yt = St[0], vn != Ct && (Yt = Yt * _e + (St[1] || 0)), et = Zi(Yt / In), et > 1) for (et >= _e && (et = _e - 1), lt = Z(Gt, et, _e), Tt = lt.length, Ct = St.length; re(lt, St, Tt, Ct) == 1;)et--, ie(lt, vn < Tt ? dn : Gt, Tt, _e), Tt = lt.length, Me = 1; else et == 0 && (Me = et = 1), lt = Gt.slice(), Tt = lt.length; if (Tt < Ct && (lt = [0].concat(lt)), ie(St, lt, Ct, _e), Ct = St.length, Me == -1) for (; re(Gt, St, vn, Ct) < 1;)et++, ie(St, vn < Ct ? dn : Gt, Ct, _e), Ct = St.length } else Me === 0 && (et++, St = [0]); Ut[de++] = et, St[0] ? St[Ct++] = qt[Wr] || 0 : (St = [qt[Wr]], Ct = 1) } while ((Wr++ < vi || St[0] != null) && rn--); Se = St[0] != null, Ut[0] || Ut.splice(0, 1) } if (_e == cs) { for (de = 1, rn = Ut[0]; rn >= 10; rn /= 10, de++); mt(Zt, Te + (Zt.e = de + Le * Bt - 1) + 1, Ne, Se) } else Zt.e = Le, Zt.r = +Se; return Zt } }(); function ve(Z, re, ie, Ce) { var xe, Te, Ne, _e, Me; if (ie == null ? ie = c : Gr(ie, 0, 8), !Z.c) return Z.toString(); if (xe = Z.c[0], Ne = Z.e, re == null) Me = qi(Z.c), Me = Ce == 1 || Ce == 2 && (Ne <= B || Ne >= $) ? kf(Me, Ne) : fo(Me, Ne, "0"); else if (Z = mt(new K(Z), re, ie), Te = Z.e, Me = qi(Z.c), _e = Me.length, Ce == 1 || Ce == 2 && (re <= Te || Te <= B)) { for (; _e < re; Me += "0", _e++); Me = kf(Me, Te) } else if (re -= Ne + (Ce === 2 && Te > Ne), Me = fo(Me, Te, "0"), Te + 1 > _e) { if (--re > 0) for (Me += "."; re--; Me += "0"); } else if (re += Te - _e, re > 0) for (Te + 1 == _e && (Me += "."); re--; Me += "0"); return Z.s < 0 && xe ? "-" + Me : Me } function Ke(Z, re) { for (var ie, Ce, xe = 1, Te = new K(Z[0]); xe < Z.length; xe++)Ce = new K(Z[xe]), (!Ce.s || (ie = Sl(Te, Ce)) === re || ie === 0 && Te.s === re) && (Te = Ce); return Te } function ft(Z, re, ie) { for (var Ce = 1, xe = re.length; !re[--xe]; re.pop()); for (xe = re[0]; xe >= 10; xe /= 10, Ce++); return (ie = Ce + ie * Bt - 1) > ge ? Z.c = Z.e = null : ie < me ? Z.c = [Z.e = 0] : (Z.e = ie, Z.c = re), Z } y = function () { var Z = /^(-?)0([xbo])(?=\w[\w.]*$)/i, re = /^([^.]+)\.$/, ie = /^\.([^.]+)$/, Ce = /^-?(Infinity|NaN)$/, xe = /^\s*\+(?=[\w.])|^\s+|\s+$/g; return function (Te, Ne, _e, Me) { var Le, de = _e ? Ne : Ne.replace(xe, ""); if (Ce.test(de)) Te.s = isNaN(de) ? null : de < 0 ? -1 : 1; else { if (!_e && (de = de.replace(Z, function (Se, et, lt) { return Le = (lt = lt.toLowerCase()) == "x" ? 16 : lt == "b" ? 2 : 8, !Me || Me == Le ? et : Se }), Me && (Le = Me, de = de.replace(re, "$1").replace(ie, "0.$1")), Ne != de)) return new K(de, Le); if (K.DEBUG) throw Error(pi + "Not a" + (Me ? " base " + Me : "") + " number: " + Ne); Te.s = null } Te.c = Te.e = null } }(); function mt(Z, re, ie, Ce) { var xe, Te, Ne, _e, Me, Le, de, Se = Z.c, et = L_; if (Se) { e: { for (xe = 1, _e = Se[0]; _e >= 10; _e /= 10, xe++); if (Te = re - xe, Te < 0) Te += Bt, Ne = re, Me = Se[Le = 0], de = Zi(Me / et[xe - Ne - 1] % 10); else if (Le = z_((Te + 1) / Bt), Le >= Se.length) if (Ce) { for (; Se.length <= Le; Se.push(0)); Me = de = 0, xe = 1, Te %= Bt, Ne = Te - Bt + 1 } else break e; else { for (Me = _e = Se[Le], xe = 1; _e >= 10; _e /= 10, xe++); Te %= Bt, Ne = Te - Bt + xe, de = Ne < 0 ? 0 : Zi(Me / et[xe - Ne - 1] % 10) } if (Ce = Ce || re < 0 || Se[Le + 1] != null || (Ne < 0 ? Me : Me % et[xe - Ne - 1]), Ce = ie < 4 ? (de || Ce) && (ie == 0 || ie == (Z.s < 0 ? 3 : 2)) : de > 5 || de == 5 && (ie == 4 || Ce || ie == 6 && (Te > 0 ? Ne > 0 ? Me / et[xe - Ne] : 0 : Se[Le - 1]) % 10 & 1 || ie == (Z.s < 0 ? 8 : 7)), re < 1 || !Se[0]) return Se.length = 0, Ce ? (re -= Z.e + 1, Se[0] = et[(Bt - re % Bt) % Bt], Z.e = -re || 0) : Se[0] = Z.e = 0, Z; if (Te == 0 ? (Se.length = Le, _e = 1, Le--) : (Se.length = Le + 1, _e = et[Bt - Te], Se[Le] = Ne > 0 ? Zi(Me / et[xe - Ne] % et[Ne]) * _e : 0), Ce) for (; ;)if (Le == 0) { for (Te = 1, Ne = Se[0]; Ne >= 10; Ne /= 10, Te++); for (Ne = Se[0] += _e, _e = 1; Ne >= 10; Ne /= 10, _e++); Te != _e && (Z.e++, Se[0] == cs && (Se[0] = 1)); break } else { if (Se[Le] += _e, Se[Le] != cs) break; Se[Le--] = 0, _e = 1 } for (Te = Se.length; Se[--Te] === 0; Se.pop()); } Z.e > ge ? Z.c = Z.e = null : Z.e < me && (Z.c = [Z.e = 0]) } return Z } function ct(Z) { var re, ie = Z.e; return ie === null ? Z.toString() : (re = qi(Z.c), re = ie <= B || ie >= $ ? kf(re, ie) : fo(re, ie, "0"), Z.s < 0 ? "-" + re : re) } return w.absoluteValue = w.abs = function () { var Z = new K(this); return Z.s < 0 && (Z.s = 1), Z }, w.comparedTo = function (Z, re) { return Sl(this, new K(Z, re)) }, w.decimalPlaces = w.dp = function (Z, re) { var ie, Ce, xe, Te = this; if (Z != null) return Gr(Z, 0, En), re == null ? re = c : Gr(re, 0, 8), mt(new K(Te), Z + Te.e + 1, re); if (!(ie = Te.c)) return null; if (Ce = ((xe = ie.length - 1) - Wi(this.e / Bt)) * Bt, xe = ie[xe]) for (; xe % 10 == 0; xe /= 10, Ce--); return Ce < 0 && (Ce = 0), Ce }, w.dividedBy = w.div = function (Z, re) { return o(this, new K(Z, re), b, c) }, w.dividedToIntegerBy = w.idiv = function (Z, re) { return o(this, new K(Z, re), 0, 1) }, w.exponentiatedBy = w.pow = function (Z, re) { var ie, Ce, xe, Te, Ne, _e, Me, Le, de, Se = this; if (Z = new K(Z), Z.c && !Z.isInteger()) throw Error(pi + "Exponent not an integer: " + ct(Z)); if (re != null && (re = new K(re)), _e = Z.e > 14, !Se.c || !Se.c[0] || Se.c[0] == 1 && !Se.e && Se.c.length == 1 || !Z.c || !Z.c[0]) return de = new K(Math.pow(+ct(Se), _e ? Z.s * (2 - Af(Z)) : +ct(Z))), re ? de.mod(re) : de; if (Me = Z.s < 0, re) { if (re.c ? !re.c[0] : !re.s) return new K(NaN); Ce = !Me && Se.isInteger() && re.isInteger(), Ce && (Se = Se.mod(re)) } else { if (Z.e > 9 && (Se.e > 0 || Se.e < -1 || (Se.e == 0 ? Se.c[0] > 1 || _e && Se.c[1] >= 24e7 : Se.c[0] < 8e13 || _e && Se.c[0] <= 9999975e7))) return Te = Se.s < 0 && Af(Z) ? -0 : 0, Se.e > -1 && (Te = 1 / Te), new K(Me ? 1 / Te : Te); Ye && (Te = z_(Ye / Bt + 2)) } for (_e ? (ie = new K(.5), Me && (Z.s = 1), Le = Af(Z)) : (xe = Math.abs(+ct(Z)), Le = xe % 2), de = new K(P); ;) { if (Le) { if (de = de.times(Se), !de.c) break; Te ? de.c.length > Te && (de.c.length = Te) : Ce && (de = de.mod(re)) } if (xe) { if (xe = Zi(xe / 2), xe === 0) break; Le = xe % 2 } else if (Z = Z.times(ie), mt(Z, Z.e + 1, 1), Z.e > 14) Le = Af(Z); else { if (xe = +ct(Z), xe === 0) break; Le = xe % 2 } Se = Se.times(Se), Te ? Se.c && Se.c.length > Te && (Se.c.length = Te) : Ce && (Se = Se.mod(re)) } return Ce ? de : (Me && (de = P.div(de)), re ? de.mod(re) : Te ? mt(de, Ye, c, Ne) : de) }, w.integerValue = function (Z) { var re = new K(this); return Z == null ? Z = c : Gr(Z, 0, 8), mt(re, re.e + 1, Z) }, w.isEqualTo = w.eq = function (Z, re) { return Sl(this, new K(Z, re)) === 0 }, w.isFinite = function () { return !!this.c }, w.isGreaterThan = w.gt = function (Z, re) { return Sl(this, new K(Z, re)) > 0 }, w.isGreaterThanOrEqualTo = w.gte = function (Z, re) { return (re = Sl(this, new K(Z, re))) === 1 || re === 0 }, w.isInteger = function () { return !!this.c && Wi(this.e / Bt) > this.c.length - 2 }, w.isLessThan = w.lt = function (Z, re) { return Sl(this, new K(Z, re)) < 0 }, w.isLessThanOrEqualTo = w.lte = function (Z, re) { return (re = Sl(this, new K(Z, re))) === -1 || re === 0 }, w.isNaN = function () { return !this.s }, w.isNegative = function () { return this.s < 0 }, w.isPositive = function () { return this.s > 0 }, w.isZero = function () { return !!this.c && this.c[0] == 0 }, w.minus = function (Z, re) { var ie, Ce, xe, Te, Ne = this, _e = Ne.s; if (Z = new K(Z, re), re = Z.s, !_e || !re) return new K(NaN); if (_e != re) return Z.s = -re, Ne.plus(Z); var Me = Ne.e / Bt, Le = Z.e / Bt, de = Ne.c, Se = Z.c; if (!Me || !Le) { if (!de || !Se) return de ? (Z.s = -re, Z) : new K(Se ? Ne : NaN); if (!de[0] || !Se[0]) return Se[0] ? (Z.s = -re, Z) : new K(de[0] ? Ne : c == 3 ? -0 : 0) } if (Me = Wi(Me), Le = Wi(Le), de = de.slice(), _e = Me - Le) { for ((Te = _e < 0) ? (_e = -_e, xe = de) : (Le = Me, xe = Se), xe.reverse(), re = _e; re--; xe.push(0)); xe.reverse() } else for (Ce = (Te = (_e = de.length) < (re = Se.length)) ? _e : re, _e = re = 0; re < Ce; re++)if (de[re] != Se[re]) { Te = de[re] < Se[re]; break } if (Te && (xe = de, de = Se, Se = xe, Z.s = -Z.s), re = (Ce = Se.length) - (ie = de.length), re > 0) for (; re--; de[ie++] = 0); for (re = cs - 1; Ce > _e;) { if (de[--Ce] < Se[Ce]) { for (ie = Ce; ie && !de[--ie]; de[ie] = re); --de[ie], de[Ce] += cs } de[Ce] -= Se[Ce] } for (; de[0] == 0; de.splice(0, 1), --Le); return de[0] ? ft(Z, de, Le) : (Z.s = c == 3 ? -1 : 1, Z.c = [Z.e = 0], Z) }, w.modulo = w.mod = function (Z, re) { var ie, Ce, xe = this; return Z = new K(Z, re), !xe.c || !Z.s || Z.c && !Z.c[0] ? new K(NaN) : !Z.c || xe.c && !xe.c[0] ? new K(xe) : (Ge == 9 ? (Ce = Z.s, Z.s = 1, ie = o(xe, Z, 0, 3), Z.s = Ce, ie.s *= Ce) : ie = o(xe, Z, 0, Ge), Z = xe.minus(ie.times(Z)), !Z.c[0] && Ge == 1 && (Z.s = xe.s), Z) }, w.multipliedBy = w.times = function (Z, re) { var ie, Ce, xe, Te, Ne, _e, Me, Le, de, Se, et, lt, Tt, Zt, Ut, St = this, Ct = St.c, Yt = (Z = new K(Z, re)).c; if (!Ct || !Yt || !Ct[0] || !Yt[0]) return !St.s || !Z.s || Ct && !Ct[0] && !Yt || Yt && !Yt[0] && !Ct ? Z.c = Z.e = Z.s = null : (Z.s *= St.s, !Ct || !Yt ? Z.c = Z.e = null : (Z.c = [0], Z.e = 0)), Z; for (Ce = Wi(St.e / Bt) + Wi(Z.e / Bt), Z.s *= St.s, Me = Ct.length, Se = Yt.length, Me < Se && (Tt = Ct, Ct = Yt, Yt = Tt, xe = Me, Me = Se, Se = xe), xe = Me + Se, Tt = []; xe--; Tt.push(0)); for (Zt = cs, Ut = la, xe = Se; --xe >= 0;) { for (ie = 0, et = Yt[xe] % Ut, lt = Yt[xe] / Ut | 0, Ne = Me, Te = xe + Ne; Te > xe;)Le = Ct[--Ne] % Ut, de = Ct[Ne] / Ut | 0, _e = lt * Le + de * et, Le = et * Le + _e % Ut * Ut + Tt[Te] + ie, ie = (Le / Zt | 0) + (_e / Ut | 0) + lt * de, Tt[Te--] = Le % Zt; Tt[Te] = ie } return ie ? ++Ce : Tt.splice(0, 1), ft(Z, Tt, Ce) }, w.negated = function () { var Z = new K(this); return Z.s = -Z.s || null, Z }, w.plus = function (Z, re) { var ie, Ce = this, xe = Ce.s; if (Z = new K(Z, re), re = Z.s, !xe || !re) return new K(NaN); if (xe != re) return Z.s = -re, Ce.minus(Z); var Te = Ce.e / Bt, Ne = Z.e / Bt, _e = Ce.c, Me = Z.c; if (!Te || !Ne) { if (!_e || !Me) return new K(xe / 0); if (!_e[0] || !Me[0]) return Me[0] ? Z : new K(_e[0] ? Ce : xe * 0) } if (Te = Wi(Te), Ne = Wi(Ne), _e = _e.slice(), xe = Te - Ne) { for (xe > 0 ? (Ne = Te, ie = Me) : (xe = -xe, ie = _e), ie.reverse(); xe--; ie.push(0)); ie.reverse() } for (xe = _e.length, re = Me.length, xe - re < 0 && (ie = Me, Me = _e, _e = ie, re = xe), xe = 0; re;)xe = (_e[--re] = _e[re] + Me[re] + xe) / cs | 0, _e[re] = cs === _e[re] ? 0 : _e[re] % cs; return xe && (_e = [xe].concat(_e), ++Ne), ft(Z, _e, Ne) }, w.precision = w.sd = function (Z, re) { var ie, Ce, xe, Te = this; if (Z != null && Z !== !!Z) return Gr(Z, 1, En), re == null ? re = c : Gr(re, 0, 8), mt(new K(Te), Z, re); if (!(ie = Te.c)) return null; if (xe = ie.length - 1, Ce = xe * Bt + 1, xe = ie[xe]) { for (; xe % 10 == 0; xe /= 10, Ce--); for (xe = ie[0]; xe >= 10; xe /= 10, Ce++); } return Z && Te.e + 1 > Ce && (Ce = Te.e + 1), Ce }, w.shiftedBy = function (Z) { return Gr(Z, -R_, R_), this.times("1e" + Z) }, w.squareRoot = w.sqrt = function () { var Z, re, ie, Ce, xe, Te = this, Ne = Te.c, _e = Te.s, Me = Te.e, Le = b + 4, de = new K("0.5"); if (_e !== 1 || !Ne || !Ne[0]) return new K(!_e || _e < 0 && (!Ne || Ne[0]) ? NaN : Ne ? Te : 1 / 0); if (_e = Math.sqrt(+ct(Te)), _e == 0 || _e == 1 / 0 ? (re = qi(Ne), (re.length + Me) % 2 == 0 && (re += "0"), _e = Math.sqrt(+re), Me = Wi((Me + 1) / 2) - (Me < 0 || Me % 2), _e == 1 / 0 ? re = "5e" + Me : (re = _e.toExponential(), re = re.slice(0, re.indexOf("e") + 1) + Me), ie = new K(re)) : ie = new K(_e + ""), ie.c[0]) { for (Me = ie.e, _e = Me + Le, _e < 3 && (_e = 0); ;)if (xe = ie, ie = de.times(xe.plus(o(Te, xe, Le, 1))), qi(xe.c).slice(0, _e) === (re = qi(ie.c)).slice(0, _e)) if (ie.e < Me && --_e, re = re.slice(_e - 3, _e + 1), re == "9999" || !Ce && re == "4999") { if (!Ce && (mt(xe, xe.e + b + 2, 0), xe.times(xe).eq(Te))) { ie = xe; break } Le += 4, _e += 4, Ce = 1 } else { (!+re || !+re.slice(1) && re.charAt(0) == "5") && (mt(ie, ie.e + b + 2, 1), Z = !ie.times(ie).eq(Te)); break } } return mt(ie, ie.e + b + 1, c, Z) }, w.toExponential = function (Z, re) { return Z != null && (Gr(Z, 0, En), Z++), ve(this, Z, re, 1) }, w.toFixed = function (Z, re) { return Z != null && (Gr(Z, 0, En), Z = Z + this.e + 1), ve(this, Z, re) }, w.toFormat = function (Z, re, ie) { var Ce, xe = this; if (ie == null) Z != null && re && typeof re == "object" ? (ie = re, re = null) : Z && typeof Z == "object" ? (ie = Z, Z = re = null) : ie = $e; else if (typeof ie != "object") throw Error(pi + "Argument not an object: " + ie); if (Ce = xe.toFixed(Z, re), xe.c) { var Te, Ne = Ce.split("."), _e = +ie.groupSize, Me = +ie.secondaryGroupSize, Le = ie.groupSeparator || "", de = Ne[0], Se = Ne[1], et = xe.s < 0, lt = et ? de.slice(1) : de, Tt = lt.length; if (Me && (Te = _e, _e = Me, Me = Te, Tt -= Te), _e > 0 && Tt > 0) { for (Te = Tt % _e || _e, de = lt.substr(0, Te); Te < Tt; Te += _e)de += Le + lt.substr(Te, _e); Me > 0 && (de += Le + lt.slice(Te)), et && (de = "-" + de) } Ce = Se ? de + (ie.decimalSeparator || "") + ((Me = +ie.fractionGroupSize) ? Se.replace(new RegExp("\\d{" + Me + "}\\B", "g"), "$&" + (ie.fractionGroupSeparator || "")) : Se) : de } return (ie.prefix || "") + Ce + (ie.suffix || "") }, w.toFraction = function (Z) { var re, ie, Ce, xe, Te, Ne, _e, Me, Le, de, Se, et, lt = this, Tt = lt.c; if (Z != null && (_e = new K(Z), !_e.isInteger() && (_e.c || _e.s !== 1) || _e.lt(P))) throw Error(pi + "Argument " + (_e.isInteger() ? "out of range: " : "not an integer: ") + ct(_e)); if (!Tt) return new K(lt); for (re = new K(P), Le = ie = new K(P), Ce = Me = new K(P), et = qi(Tt), Te = re.e = et.length - lt.e - 1, re.c[0] = L_[(Ne = Te % Bt) < 0 ? Bt + Ne : Ne], Z = !Z || _e.comparedTo(re) > 0 ? Te > 0 ? re : Le : _e, Ne = ge, ge = 1 / 0, _e = new K(et), Me.c[0] = 0; de = o(_e, re, 0, 1), xe = ie.plus(de.times(Ce)), xe.comparedTo(Z) != 1;)ie = Ce, Ce = xe, Le = Me.plus(de.times(xe = Le)), Me = xe, re = _e.minus(de.times(xe = re)), _e = xe; return xe = o(Z.minus(ie), Ce, 0, 1), Me = Me.plus(xe.times(Le)), ie = ie.plus(xe.times(Ce)), Me.s = Le.s = lt.s, Te = Te * 2, Se = o(Le, Ce, Te, c).minus(lt).abs().comparedTo(o(Me, ie, Te, c).minus(lt).abs()) < 1 ? [Le, Ce] : [Me, ie], ge = Ne, Se }, w.toNumber = function () { return +ct(this) }, w.toPrecision = function (Z, re) { return Z != null && Gr(Z, 1, En), ve(this, Z, re, 2) }, w.toString = function (Z) { var re, ie = this, Ce = ie.s, xe = ie.e; return xe === null ? Ce ? (re = "Infinity", Ce < 0 && (re = "-" + re)) : re = "NaN" : (Z == null ? re = xe <= B || xe >= $ ? kf(qi(ie.c), xe) : fo(qi(ie.c), xe, "0") : Z === 10 && be ? (ie = mt(new K(ie), b + xe + 1, c), re = fo(qi(ie.c), ie.e, "0")) : (Gr(Z, 2, ye.length, "Base"), re = h(fo(qi(ie.c), xe, "0"), 10, Z, Ce, !0)), Ce < 0 && ie.c[0] && (re = "-" + re)), re }, w.valueOf = w.toJSON = function () { return ct(this) }, w._isBigNumber = !0, w[Symbol.toStringTag] = "BigNumber", w[Symbol.for("nodejs.util.inspect.custom")] = w.valueOf, i != null && K.set(i), K } function Wi(i) { var o = i | 0; return i > 0 || i === o ? o : o - 1 } function qi(i) { for (var o, h, y = 1, w = i.length, P = i[0] + ""; y < w;) { for (o = i[y++] + "", h = Bt - o.length; h--; o = "0" + o); P += o } for (w = P.length; P.charCodeAt(--w) === 48;); return P.slice(0, w + 1 || 1) } function Sl(i, o) { var h, y, w = i.c, P = o.c, b = i.s, c = o.s, B = i.e, $ = o.e; if (!b || !c) return null; if (h = w && !w[0], y = P && !P[0], h || y) return h ? y ? 0 : -c : b; if (b != c) return b; if (h = b < 0, y = B == $, !w || !P) return y ? 0 : !w ^ h ? 1 : -1; if (!y) return B > $ ^ h ? 1 : -1; for (c = (B = w.length) < ($ = P.length) ? B : $, b = 0; b < c; b++)if (w[b] != P[b]) return w[b] > P[b] ^ h ? 1 : -1; return B == $ ? 0 : B > $ ^ h ? 1 : -1 } function Gr(i, o, h, y) { if (i < o || i > h || i !== Zi(i)) throw Error(pi + (y || "Argument") + (typeof i == "number" ? i < o || i > h ? " out of range: " : " not an integer: " : " not a primitive number: ") + String(i)) } function Af(i) { var o = i.c.length - 1; return Wi(i.e / Bt) == o && i.c[o] % 2 != 0 } function kf(i, o) { return (i.length > 1 ? i.charAt(0) + "." + i.slice(1) : i) + (o < 0 ? "e" : "e+") + o } function fo(i, o, h) { var y, w; if (o < 0) { for (w = h + "."; ++o; w += h); i = w + i } else if (y = i.length, ++o > y) { for (w = h, o -= y; --o; w += h); i += w } else o < y && (i = i.slice(0, o) + "." + i.slice(o)); return i } var Os = W2(), mI = class { constructor(i) { rt(this, "key"); rt(this, "left", null); rt(this, "right", null); this.key = i } }, Xh = class extends mI { constructor(i) { super(i) } }, gI = class { constructor() { rt(this, "size", 0); rt(this, "modificationCount", 0); rt(this, "splayCount", 0) } splay(i) { const o = this.root; if (o == null) return this.compare(i, i), -1; let h = null, y = null, w = null, P = null, b = o; const c = this.compare; let B; for (; ;)if (B = c(b.key, i), B > 0) { let $ = b.left; if ($ == null || (B = c($.key, i), B > 0 && (b.left = $.right, $.right = b, b = $, $ = b.left, $ == null))) break; h == null ? y = b : h.left = b, h = b, b = $ } else if (B < 0) { let $ = b.right; if ($ == null || (B = c($.key, i), B < 0 && (b.right = $.left, $.left = b, b = $, $ = b.right, $ == null))) break; w == null ? P = b : w.right = b, w = b, b = $ } else break; return w != null && (w.right = b.left, b.left = P), h != null && (h.left = b.right, b.right = y), this.root !== b && (this.root = b, this.splayCount++), B } splayMin(i) { let o = i, h = o.left; for (; h != null;) { const y = h; o.left = y.right, y.right = o, o = y, h = o.left } return o } splayMax(i) { let o = i, h = o.right; for (; h != null;) { const y = h; o.right = y.left, y.left = o, o = y, h = o.right } return o } _delete(i) { if (this.root == null || this.splay(i) != 0) return null; let h = this.root; const y = h, w = h.left; if (this.size--, w == null) this.root = h.right; else { const P = h.right; h = this.splayMax(w), h.right = P, this.root = h } return this.modificationCount++, y } addNewRoot(i, o) { this.size++, this.modificationCount++; const h = this.root; if (h == null) { this.root = i; return } o < 0 ? (i.left = h, i.right = h.right, h.right = null) : (i.right = h, i.left = h.left, h.left = null), this.root = i } _first() { const i = this.root; return i == null ? null : (this.root = this.splayMin(i), this.root) } _last() { const i = this.root; return i == null ? null : (this.root = this.splayMax(i), this.root) } clear() { this.root = null, this.size = 0, this.modificationCount++ } has(i) { return this.validKey(i) && this.splay(i) == 0 } defaultCompare() { return (i, o) => i < o ? -1 : i > o ? 1 : 0 } wrap() { return { getRoot: () => this.root, setRoot: i => { this.root = i }, getSize: () => this.size, getModificationCount: () => this.modificationCount, getSplayCount: () => this.splayCount, setSplayCount: i => { this.splayCount = i }, splay: i => this.splay(i), has: i => this.has(i) } } }, Sw, Ew, gm = class nd extends gI { constructor(h, y) { super(); rt(this, "root", null); rt(this, "compare"); rt(this, "validKey"); rt(this, Sw, "[object Set]"); this.compare = h ?? this.defaultCompare(), this.validKey = y ?? (w => w != null && w != null) } delete(h) { return this.validKey(h) ? this._delete(h) != null : !1 } deleteAll(h) { for (const y of h) this.delete(y) } forEach(h) { const y = this[Symbol.iterator](); let w; for (; w = y.next(), !w.done;)h(w.value, w.value, this) } add(h) { const y = this.splay(h); return y != 0 && this.addNewRoot(new Xh(h), y), this } addAndReturn(h) { const y = this.splay(h); return y != 0 && this.addNewRoot(new Xh(h), y), this.root.key } addAll(h) { for (const y of h) this.add(y) } isEmpty() { return this.root == null } isNotEmpty() { return this.root != null } single() { if (this.size == 0) throw "Bad state: No element"; if (this.size > 1) throw "Bad state: Too many element"; return this.root.key } first() { if (this.size == 0) throw "Bad state: No element"; return this._first().key } last() { if (this.size == 0) throw "Bad state: No element"; return this._last().key } lastBefore(h) { if (h == null) throw "Invalid arguments(s)"; if (this.root == null) return null; if (this.splay(h) < 0) return this.root.key; let w = this.root.left; if (w == null) return null; let P = w.right; for (; P != null;)w = P, P = w.right; return w.key } firstAfter(h) { if (h == null) throw "Invalid arguments(s)"; if (this.root == null) return null; if (this.splay(h) > 0) return this.root.key; let w = this.root.right; if (w == null) return null; let P = w.left; for (; P != null;)w = P, P = w.left; return w.key } retainAll(h) { const y = new nd(this.compare, this.validKey), w = this.modificationCount; for (const P of h) { if (w != this.modificationCount) throw "Concurrent modification during iteration."; this.validKey(P) && this.splay(P) == 0 && y.add(this.root.key) } y.size != this.size && (this.root = y.root, this.size = y.size, this.modificationCount++) } lookup(h) { return !this.validKey(h) || this.splay(h) != 0 ? null : this.root.key } intersection(h) { const y = new nd(this.compare, this.validKey); for (const w of this) h.has(w) && y.add(w); return y } difference(h) { const y = new nd(this.compare, this.validKey); for (const w of this) h.has(w) || y.add(w); return y } union(h) { const y = this.clone(); return y.addAll(h), y } clone() { const h = new nd(this.compare, this.validKey); return h.size = this.size, h.root = this.copyNode(this.root), h } copyNode(h) { if (h == null) return null; function y(P, b) { let c, B; do { if (c = P.left, B = P.right, c != null) { const $ = new Xh(c.key); b.left = $, y(c, $) } if (B != null) { const $ = new Xh(B.key); b.right = $, P = B, b = $ } } while (B != null) } const w = new Xh(h.key); return y(h, w), w } toSet() { return this.clone() } entries() { return new yI(this.wrap()) } keys() { return this[Symbol.iterator]() } values() { return this[Symbol.iterator]() } [(Ew = Symbol.iterator, Sw = Symbol.toStringTag, Ew)]() { return new _I(this.wrap()) } }, H2 = class { constructor(i) { rt(this, "tree"); rt(this, "path", new Array); rt(this, "modificationCount", null); rt(this, "splayCount"); this.tree = i, this.splayCount = i.getSplayCount() } [Symbol.iterator]() { return this } next() { return this.moveNext() ? { done: !1, value: this.current() } : { done: !0, value: null } } current() { if (!this.path.length) return null; const i = this.path[this.path.length - 1]; return this.getValue(i) } rebuildPath(i) { this.path.splice(0, this.path.length), this.tree.splay(i), this.path.push(this.tree.getRoot()), this.splayCount = this.tree.getSplayCount() } findLeftMostDescendent(i) { for (; i != null;)this.path.push(i), i = i.left } moveNext() { if (this.modificationCount != this.tree.getModificationCount()) { if (this.modificationCount == null) { this.modificationCount = this.tree.getModificationCount(); let h = this.tree.getRoot(); for (; h != null;)this.path.push(h), h = h.left; return this.path.length > 0 } throw "Concurrent modification during iteration." } if (!this.path.length) return !1; this.splayCount != this.tree.getSplayCount() && this.rebuildPath(this.path[this.path.length - 1].key); let i = this.path[this.path.length - 1], o = i.right; if (o != null) { for (; o != null;)this.path.push(o), o = o.left; return !0 } for (this.path.pop(); this.path.length && this.path[this.path.length - 1].right === i;)i = this.path.pop(); return this.path.length > 0 } }, _I = class extends H2 { getValue(i) { return i.key } }, yI = class extends H2 { getValue(i) { return [i.key, i.key] } }, X2 = i => () => i, Dy = i => { const o = i ? (h, y) => y.minus(h).abs().isLessThanOrEqualTo(i) : X2(!1); return (h, y) => o(h, y) ? 0 : h.comparedTo(y) }; function vI(i) { const o = i ? (h, y, w, P, b) => h.exponentiatedBy(2).isLessThanOrEqualTo(P.minus(y).exponentiatedBy(2).plus(b.minus(w).exponentiatedBy(2)).times(i)) : X2(!1); return (h, y, w) => { const P = h.x, b = h.y, c = w.x, B = w.y, $ = b.minus(B).times(y.x.minus(c)).minus(P.minus(c).times(y.y.minus(B))); return o($, P, b, c, B) ? 0 : $.comparedTo(0) } } var xI = i => i, wI = i => { if (i) { const o = new gm(Dy(i)), h = new gm(Dy(i)), y = (P, b) => b.addAndReturn(P), w = P => ({ x: y(P.x, o), y: y(P.y, h) }); return w({ x: new Os(0), y: new Os(0) }), w } return xI }, zy = i => ({ set: o => { So = zy(o) }, reset: () => zy(i), compare: Dy(i), snap: wI(i), orient: vI(i) }), So = zy(), Yh = (i, o) => i.ll.x.isLessThanOrEqualTo(o.x) && o.x.isLessThanOrEqualTo(i.ur.x) && i.ll.y.isLessThanOrEqualTo(o.y) && o.y.isLessThanOrEqualTo(i.ur.y), Ry = (i, o) => { if (o.ur.x.isLessThan(i.ll.x) || i.ur.x.isLessThan(o.ll.x) || o.ur.y.isLessThan(i.ll.y) || i.ur.y.isLessThan(o.ll.y)) return null; const h = i.ll.x.isLessThan(o.ll.x) ? o.ll.x : i.ll.x, y = i.ur.x.isLessThan(o.ur.x) ? i.ur.x : o.ur.x, w = i.ll.y.isLessThan(o.ll.y) ? o.ll.y : i.ll.y, P = i.ur.y.isLessThan(o.ur.y) ? i.ur.y : o.ur.y; return { ll: { x: h, y: w }, ur: { x: y, y: P } } }, $f = (i, o) => i.x.times(o.y).minus(i.y.times(o.x)), Y2 = (i, o) => i.x.times(o.x).plus(i.y.times(o.y)), _m = i => Y2(i, i).sqrt(), bI = (i, o, h) => { const y = { x: o.x.minus(i.x), y: o.y.minus(i.y) }, w = { x: h.x.minus(i.x), y: h.y.minus(i.y) }; return $f(w, y).div(_m(w)).div(_m(y)) }, TI = (i, o, h) => { const y = { x: o.x.minus(i.x), y: o.y.minus(i.y) }, w = { x: h.x.minus(i.x), y: h.y.minus(i.y) }; return Y2(w, y).div(_m(w)).div(_m(y)) }, hw = (i, o, h) => o.y.isZero() ? null : { x: i.x.plus(o.x.div(o.y).times(h.minus(i.y))), y: h }, dw = (i, o, h) => o.x.isZero() ? null : { x: h, y: i.y.plus(o.y.div(o.x).times(h.minus(i.x))) }, SI = (i, o, h, y) => { if (o.x.isZero()) return dw(h, y, i.x); if (y.x.isZero()) return dw(i, o, h.x); if (o.y.isZero()) return hw(h, y, i.y); if (y.y.isZero()) return hw(i, o, h.y); const w = $f(o, y); if (w.isZero()) return null; const P = { x: h.x.minus(i.x), y: h.y.minus(i.y) }, b = $f(P, o).div(w), c = $f(P, y).div(w), B = i.x.plus(c.times(o.x)), $ = h.x.plus(b.times(y.x)), me = i.y.plus(c.times(o.y)), ge = h.y.plus(b.times(y.y)), we = B.plus($).div(2), Ge = me.plus(ge).div(2); return { x: we, y: Ge } }, Fs = class K2 { constructor(o, h) { rt(this, "point"); rt(this, "isLeft"); rt(this, "segment"); rt(this, "otherSE"); rt(this, "consumedBy"); o.events === void 0 ? o.events = [this] : o.events.push(this), this.point = o, this.isLeft = h } static compare(o, h) { const y = K2.comparePoints(o.point, h.point); return y !== 0 ? y : (o.point !== h.point && o.link(h), o.isLeft !== h.isLeft ? o.isLeft ? 1 : -1 : ym.compare(o.segment, h.segment)) } static comparePoints(o, h) { return o.x.isLessThan(h.x) ? -1 : o.x.isGreaterThan(h.x) ? 1 : o.y.isLessThan(h.y) ? -1 : o.y.isGreaterThan(h.y) ? 1 : 0 } link(o) { if (o.point === this.point) throw new Error("Tried to link already linked events"); const h = o.point.events; for (let y = 0, w = h.length; y < w; y++) { const P = h[y]; this.point.events.push(P), P.point = this.point } this.checkForConsuming() } checkForConsuming() { const o = this.point.events.length; for (let h = 0; h < o; h++) { const y = this.point.events[h]; if (y.segment.consumedBy === void 0) for (let w = h + 1; w < o; w++) { const P = this.point.events[w]; P.consumedBy === void 0 && y.otherSE.point.events === P.otherSE.point.events && y.segment.consume(P.segment) } } } getAvailableLinkedEvents() { const o = []; for (let h = 0, y = this.point.events.length; h < y; h++) { const w = this.point.events[h]; w !== this && !w.segment.ringOut && w.segment.isInResult() && o.push(w) } return o } getLeftmostComparator(o) { const h = new Map, y = w => { const P = w.otherSE; h.set(w, { sine: bI(this.point, o.point, P.point), cosine: TI(this.point, o.point, P.point) }) }; return (w, P) => { h.has(w) || y(w), h.has(P) || y(P); const { sine: b, cosine: c } = h.get(w), { sine: B, cosine: $ } = h.get(P); return b.isGreaterThanOrEqualTo(0) && B.isGreaterThanOrEqualTo(0) ? c.isLessThan($) ? 1 : c.isGreaterThan($) ? -1 : 0 : b.isLessThan(0) && B.isLessThan(0) ? c.isLessThan($) ? -1 : c.isGreaterThan($) ? 1 : 0 : B.isLessThan(b) ? -1 : B.isGreaterThan(b) ? 1 : 0 } } }, EI = class Ly { constructor(o) { rt(this, "events"); rt(this, "poly"); rt(this, "_isExteriorRing"); rt(this, "_enclosingRing"); this.events = o; for (let h = 0, y = o.length; h < y; h++)o[h].segment.ringOut = this; this.poly = null } static factory(o) { const h = []; for (let y = 0, w = o.length; y < w; y++) { const P = o[y]; if (!P.isInResult() || P.ringOut) continue; let b = null, c = P.leftSE, B = P.rightSE; const $ = [c], me = c.point, ge = []; for (; b = c, c = B, $.push(c), c.point !== me;)for (; ;) { const we = c.getAvailableLinkedEvents(); if (we.length === 0) { const $e = $[0].point, ye = $[$.length - 1].point; throw new Error(`Unable to complete output ring starting at [${$e.x}, ${$e.y}]. Last matching segment found ends at [${ye.x}, ${ye.y}].`) } if (we.length === 1) { B = we[0].otherSE; break } let Ge = null; for (let $e = 0, ye = ge.length; $e < ye; $e++)if (ge[$e].point === c.point) { Ge = $e; break } if (Ge !== null) { const $e = ge.splice(Ge)[0], ye = $.splice($e.index); ye.unshift(ye[0].otherSE), h.push(new Ly(ye.reverse())); continue } ge.push({ index: $.length, point: c.point }); const Ye = c.getLeftmostComparator(b); B = we.sort(Ye)[0].otherSE; break } h.push(new Ly($)) } return h } getGeom() { let o = this.events[0].point; const h = [o]; for (let $ = 1, me = this.events.length - 1; $ < me; $++) { const ge = this.events[$].point, we = this.events[$ + 1].point; So.orient(ge, o, we) !== 0 && (h.push(ge), o = ge) } if (h.length === 1) return null; const y = h[0], w = h[1]; So.orient(y, o, w) === 0 && h.shift(), h.push(h[0]); const P = this.isExteriorRing() ? 1 : -1, b = this.isExteriorRing() ? 0 : h.length - 1, c = this.isExteriorRing() ? h.length : -1, B = []; for (let $ = b; $ != c; $ += P)B.push([h[$].x.toNumber(), h[$].y.toNumber()]); return B } isExteriorRing() { if (this._isExteriorRing === void 0) { const o = this.enclosingRing(); this._isExteriorRing = o ? !o.isExteriorRing() : !0 } return this._isExteriorRing } enclosingRing() { return this._enclosingRing === void 0 && (this._enclosingRing = this._calcEnclosingRing()), this._enclosingRing } _calcEnclosingRing() { var w, P; let o = this.events[0]; for (let b = 1, c = this.events.length; b < c; b++) { const B = this.events[b]; Fs.compare(o, B) > 0 && (o = B) } let h = o.segment.prevInResult(), y = h ? h.prevInResult() : null; for (; ;) { if (!h) return null; if (!y) return h.ringOut; if (y.ringOut !== h.ringOut) return ((w = y.ringOut) == null ? void 0 : w.enclosingRing()) !== h.ringOut ? h.ringOut : (P = h.ringOut) == null ? void 0 : P.enclosingRing(); h = y.prevInResult(), y = h ? h.prevInResult() : null } } }, pw = class { constructor(i) { rt(this, "exteriorRing"); rt(this, "interiorRings"); this.exteriorRing = i, i.poly = this, this.interiorRings = [] } addInterior(i) { this.interiorRings.push(i), i.poly = this } getGeom() { const i = this.exteriorRing.getGeom(); if (i === null) return null; const o = [i]; for (let h = 0, y = this.interiorRings.length; h < y; h++) { const w = this.interiorRings[h].getGeom(); w !== null && o.push(w) } return o } }, PI = class { constructor(i) { rt(this, "rings"); rt(this, "polys"); this.rings = i, this.polys = this._composePolys(i) } getGeom() { const i = []; for (let o = 0, h = this.polys.length; o < h; o++) { const y = this.polys[o].getGeom(); y !== null && i.push(y) } return i } _composePolys(i) { var h; const o = []; for (let y = 0, w = i.length; y < w; y++) { const P = i[y]; if (!P.poly) if (P.isExteriorRing()) o.push(new pw(P)); else { const b = P.enclosingRing(); b != null && b.poly || o.push(new pw(b)), (h = b == null ? void 0 : b.poly) == null || h.addInterior(P) } } return o } }, MI = class { constructor(i, o = ym.compare) { rt(this, "queue"); rt(this, "tree"); rt(this, "segments"); this.queue = i, this.tree = new gm(o), this.segments = [] } process(i) { const o = i.segment, h = []; if (i.consumedBy) return i.isLeft ? this.queue.delete(i.otherSE) : this.tree.delete(o), h; i.isLeft && this.tree.add(o); let y = o, w = o; do y = this.tree.lastBefore(y); while (y != null && y.consumedBy != null); do w = this.tree.firstAfter(w); while (w != null && w.consumedBy != null); if (i.isLeft) { let P = null; if (y) { const c = y.getIntersection(o); if (c !== null && (o.isAnEndpoint(c) || (P = c), !y.isAnEndpoint(c))) { const B = this._splitSafely(y, c); for (let $ = 0, me = B.length; $ < me; $++)h.push(B[$]) } } let b = null; if (w) { const c = w.getIntersection(o); if (c !== null && (o.isAnEndpoint(c) || (b = c), !w.isAnEndpoint(c))) { const B = this._splitSafely(w, c); for (let $ = 0, me = B.length; $ < me; $++)h.push(B[$]) } } if (P !== null || b !== null) { let c = null; P === null ? c = b : b === null ? c = P : c = Fs.comparePoints(P, b) <= 0 ? P : b, this.queue.delete(o.rightSE), h.push(o.rightSE); const B = o.split(c); for (let $ = 0, me = B.length; $ < me; $++)h.push(B[$]) } h.length > 0 ? (this.tree.delete(o), h.push(i)) : (this.segments.push(o), o.prev = y) } else { if (y && w) { const P = y.getIntersection(w); if (P !== null) { if (!y.isAnEndpoint(P)) { const b = this._splitSafely(y, P); for (let c = 0, B = b.length; c < B; c++)h.push(b[c]) } if (!w.isAnEndpoint(P)) { const b = this._splitSafely(w, P); for (let c = 0, B = b.length; c < B; c++)h.push(b[c]) } } } this.tree.delete(o) } return h } _splitSafely(i, o) { this.tree.delete(i); const h = i.rightSE; this.queue.delete(h); const y = i.split(o); return y.push(h), i.consumedBy === void 0 && this.tree.add(i), y } }, II = class { constructor() { rt(this, "type"); rt(this, "numMultiPolys") } run(i, o, h) { id.type = i; const y = [new mw(o, !0)]; for (let $ = 0, me = h.length; $ < me; $++)y.push(new mw(h[$], !1)); if (id.numMultiPolys = y.length, id.type === "difference") { const $ = y[0]; let me = 1; for (; me < y.length;)Ry(y[me].bbox, $.bbox) !== null ? me++ : y.splice(me, 1) } if (id.type === "intersection") for (let $ = 0, me = y.length; $ < me; $++) { const ge = y[$]; for (let we = $ + 1, Ge = y.length; we < Ge; we++)if (Ry(ge.bbox, y[we].bbox) === null) return [] } const w = new gm(Fs.compare); for (let $ = 0, me = y.length; $ < me; $++) { const ge = y[$].getSweepEvents(); for (let we = 0, Ge = ge.length; we < Ge; we++)w.add(ge[we]) } const P = new MI(w); let b = null; for (w.size != 0 && (b = w.first(), w.delete(b)); b;) { const $ = P.process(b); for (let me = 0, ge = $.length; me < ge; me++) { const we = $[me]; we.consumedBy === void 0 && w.add(we) } w.size != 0 ? (b = w.first(), w.delete(b)) : b = null } So.reset(); const c = EI.factory(P.segments); return new PI(c).getGeom() } }, id = new II, wc = id, CI = 0, ym = class qf { constructor(o, h, y, w) { rt(this, "id"); rt(this, "leftSE"); rt(this, "rightSE"); rt(this, "rings"); rt(this, "windings"); rt(this, "ringOut"); rt(this, "consumedBy"); rt(this, "prev"); rt(this, "_prevInResult"); rt(this, "_beforeState"); rt(this, "_afterState"); rt(this, "_isInResult"); this.id = ++CI, this.leftSE = o, o.segment = this, o.otherSE = h, this.rightSE = h, h.segment = this, h.otherSE = o, this.rings = y, this.windings = w } static compare(o, h) { const y = o.leftSE.point.x, w = h.leftSE.point.x, P = o.rightSE.point.x, b = h.rightSE.point.x; if (b.isLessThan(y)) return 1; if (P.isLessThan(w)) return -1; const c = o.leftSE.point.y, B = h.leftSE.point.y, $ = o.rightSE.point.y, me = h.rightSE.point.y; if (y.isLessThan(w)) { if (B.isLessThan(c) && B.isLessThan($)) return 1; if (B.isGreaterThan(c) && B.isGreaterThan($)) return -1; const ge = o.comparePoint(h.leftSE.point); if (ge < 0) return 1; if (ge > 0) return -1; const we = h.comparePoint(o.rightSE.point); return we !== 0 ? we : -1 } if (y.isGreaterThan(w)) { if (c.isLessThan(B) && c.isLessThan(me)) return -1; if (c.isGreaterThan(B) && c.isGreaterThan(me)) return 1; const ge = h.comparePoint(o.leftSE.point); if (ge !== 0) return ge; const we = o.comparePoint(h.rightSE.point); return we < 0 ? 1 : we > 0 ? -1 : 1 } if (c.isLessThan(B)) return -1; if (c.isGreaterThan(B)) return 1; if (P.isLessThan(b)) { const ge = h.comparePoint(o.rightSE.point); if (ge !== 0) return ge } if (P.isGreaterThan(b)) { const ge = o.comparePoint(h.rightSE.point); if (ge < 0) return 1; if (ge > 0) return -1 } if (!P.eq(b)) { const ge = $.minus(c), we = P.minus(y), Ge = me.minus(B), Ye = b.minus(w); if (ge.isGreaterThan(we) && Ge.isLessThan(Ye)) return 1; if (ge.isLessThan(we) && Ge.isGreaterThan(Ye)) return -1 } return P.isGreaterThan(b) ? 1 : P.isLessThan(b) || $.isLessThan(me) ? -1 : $.isGreaterThan(me) ? 1 : o.id < h.id ? -1 : o.id > h.id ? 1 : 0 } static fromRing(o, h, y) { let w, P, b; const c = Fs.comparePoints(o, h); if (c < 0) w = o, P = h, b = 1; else if (c > 0) w = h, P = o, b = -1; else throw new Error(`Tried to create degenerate segment at [${o.x}, ${o.y}]`); const B = new Fs(w, !0), $ = new Fs(P, !1); return new qf(B, $, [y], [b]) } replaceRightSE(o) { this.rightSE = o, this.rightSE.segment = this, this.rightSE.otherSE = this.leftSE, this.leftSE.otherSE = this.rightSE } bbox() { const o = this.leftSE.point.y, h = this.rightSE.point.y; return { ll: { x: this.leftSE.point.x, y: o.isLessThan(h) ? o : h }, ur: { x: this.rightSE.point.x, y: o.isGreaterThan(h) ? o : h } } } vector() { return { x: this.rightSE.point.x.minus(this.leftSE.point.x), y: this.rightSE.point.y.minus(this.leftSE.point.y) } } isAnEndpoint(o) { return o.x.eq(this.leftSE.point.x) && o.y.eq(this.leftSE.point.y) || o.x.eq(this.rightSE.point.x) && o.y.eq(this.rightSE.point.y) } comparePoint(o) { return So.orient(this.leftSE.point, o, this.rightSE.point) } getIntersection(o) { const h = this.bbox(), y = o.bbox(), w = Ry(h, y); if (w === null) return null; const P = this.leftSE.point, b = this.rightSE.point, c = o.leftSE.point, B = o.rightSE.point, $ = Yh(h, c) && this.comparePoint(c) === 0, me = Yh(y, P) && o.comparePoint(P) === 0, ge = Yh(h, B) && this.comparePoint(B) === 0, we = Yh(y, b) && o.comparePoint(b) === 0; if (me && $) return we && !ge ? b : !we && ge ? B : null; if (me) return ge && P.x.eq(B.x) && P.y.eq(B.y) ? null : P; if ($) return we && b.x.eq(c.x) && b.y.eq(c.y) ? null : c; if (we && ge) return null; if (we) return b; if (ge) return B; const Ge = SI(P, this.vector(), c, o.vector()); return Ge === null || !Yh(w, Ge) ? null : So.snap(Ge) } split(o) { const h = [], y = o.events !== void 0, w = new Fs(o, !0), P = new Fs(o, !1), b = this.rightSE; this.replaceRightSE(P), h.push(P), h.push(w); const c = new qf(w, b, this.rings.slice(), this.windings.slice()); return Fs.comparePoints(c.leftSE.point, c.rightSE.point) > 0 && c.swapEvents(), Fs.comparePoints(this.leftSE.point, this.rightSE.point) > 0 && this.swapEvents(), y && (w.checkForConsuming(), P.checkForConsuming()), h } swapEvents() { const o = this.rightSE; this.rightSE = this.leftSE, this.leftSE = o, this.leftSE.isLeft = !0, this.rightSE.isLeft = !1; for (let h = 0, y = this.windings.length; h < y; h++)this.windings[h] *= -1 } consume(o) { let h = this, y = o; for (; h.consumedBy;)h = h.consumedBy; for (; y.consumedBy;)y = y.consumedBy; const w = qf.compare(h, y); if (w !== 0) { if (w > 0) { const P = h; h = y, y = P } if (h.prev === y) { const P = h; h = y, y = P } for (let P = 0, b = y.rings.length; P < b; P++) { const c = y.rings[P], B = y.windings[P], $ = h.rings.indexOf(c); $ === -1 ? (h.rings.push(c), h.windings.push(B)) : h.windings[$] += B } y.rings = null, y.windings = null, y.consumedBy = h, y.leftSE.consumedBy = h.leftSE, y.rightSE.consumedBy = h.rightSE } } prevInResult() { return this._prevInResult !== void 0 ? this._prevInResult : (this.prev ? this.prev.isInResult() ? this._prevInResult = this.prev : this._prevInResult = this.prev.prevInResult() : this._prevInResult = null, this._prevInResult) } beforeState() { if (this._beforeState !== void 0) return this._beforeState; if (!this.prev) this._beforeState = { rings: [], windings: [], multiPolys: [] }; else { const o = this.prev.consumedBy || this.prev; this._beforeState = o.afterState() } return this._beforeState } afterState() { if (this._afterState !== void 0) return this._afterState; const o = this.beforeState(); this._afterState = { rings: o.rings.slice(0), windings: o.windings.slice(0), multiPolys: [] }; const h = this._afterState.rings, y = this._afterState.windings, w = this._afterState.multiPolys; for (let c = 0, B = this.rings.length; c < B; c++) { const $ = this.rings[c], me = this.windings[c], ge = h.indexOf($); ge === -1 ? (h.push($), y.push(me)) : y[ge] += me } const P = [], b = []; for (let c = 0, B = h.length; c < B; c++) { if (y[c] === 0) continue; const $ = h[c], me = $.poly; if (b.indexOf(me) === -1) if ($.isExterior) P.push(me); else { b.indexOf(me) === -1 && b.push(me); const ge = P.indexOf($.poly); ge !== -1 && P.splice(ge, 1) } } for (let c = 0, B = P.length; c < B; c++) { const $ = P[c].multiPoly; w.indexOf($) === -1 && w.push($) } return this._afterState } isInResult() { if (this.consumedBy) return !1; if (this._isInResult !== void 0) return this._isInResult; const o = this.beforeState().multiPolys, h = this.afterState().multiPolys; switch (wc.type) { case "union": { const y = o.length === 0, w = h.length === 0; this._isInResult = y !== w; break } case "intersection": { let y, w; o.length < h.length ? (y = o.length, w = h.length) : (y = h.length, w = o.length), this._isInResult = w === wc.numMultiPolys && y < w; break } case "xor": { const y = Math.abs(o.length - h.length); this._isInResult = y % 2 === 1; break } case "difference": { const y = w => w.length === 1 && w[0].isSubject; this._isInResult = y(o) !== y(h); break } }return this._isInResult } }, fw = class { constructor(i, o, h) { rt(this, "poly"); rt(this, "isExterior"); rt(this, "segments"); rt(this, "bbox"); if (!Array.isArray(i) || i.length === 0) throw new Error("Input geometry is not a valid Polygon or MultiPolygon"); if (this.poly = o, this.isExterior = h, this.segments = [], typeof i[0][0] != "number" || typeof i[0][1] != "number") throw new Error("Input geometry is not a valid Polygon or MultiPolygon"); const y = So.snap({ x: new Os(i[0][0]), y: new Os(i[0][1]) }); this.bbox = { ll: { x: y.x, y: y.y }, ur: { x: y.x, y: y.y } }; let w = y; for (let P = 1, b = i.length; P < b; P++) { if (typeof i[P][0] != "number" || typeof i[P][1] != "number") throw new Error("Input geometry is not a valid Polygon or MultiPolygon"); const c = So.snap({ x: new Os(i[P][0]), y: new Os(i[P][1]) }); c.x.eq(w.x) && c.y.eq(w.y) || (this.segments.push(ym.fromRing(w, c, this)), c.x.isLessThan(this.bbox.ll.x) && (this.bbox.ll.x = c.x), c.y.isLessThan(this.bbox.ll.y) && (this.bbox.ll.y = c.y), c.x.isGreaterThan(this.bbox.ur.x) && (this.bbox.ur.x = c.x), c.y.isGreaterThan(this.bbox.ur.y) && (this.bbox.ur.y = c.y), w = c) } (!y.x.eq(w.x) || !y.y.eq(w.y)) && this.segments.push(ym.fromRing(w, y, this)) } getSweepEvents() { const i = []; for (let o = 0, h = this.segments.length; o < h; o++) { const y = this.segments[o]; i.push(y.leftSE), i.push(y.rightSE) } return i } }, AI = class { constructor(i, o) { rt(this, "multiPoly"); rt(this, "exteriorRing"); rt(this, "interiorRings"); rt(this, "bbox"); if (!Array.isArray(i)) throw new Error("Input geometry is not a valid Polygon or MultiPolygon"); this.exteriorRing = new fw(i[0], this, !0), this.bbox = { ll: { x: this.exteriorRing.bbox.ll.x, y: this.exteriorRing.bbox.ll.y }, ur: { x: this.exteriorRing.bbox.ur.x, y: this.exteriorRing.bbox.ur.y } }, this.interiorRings = []; for (let h = 1, y = i.length; h < y; h++) { const w = new fw(i[h], this, !1); w.bbox.ll.x.isLessThan(this.bbox.ll.x) && (this.bbox.ll.x = w.bbox.ll.x), w.bbox.ll.y.isLessThan(this.bbox.ll.y) && (this.bbox.ll.y = w.bbox.ll.y), w.bbox.ur.x.isGreaterThan(this.bbox.ur.x) && (this.bbox.ur.x = w.bbox.ur.x), w.bbox.ur.y.isGreaterThan(this.bbox.ur.y) && (this.bbox.ur.y = w.bbox.ur.y), this.interiorRings.push(w) } this.multiPoly = o } getSweepEvents() { const i = this.exteriorRing.getSweepEvents(); for (let o = 0, h = this.interiorRings.length; o < h; o++) { const y = this.interiorRings[o].getSweepEvents(); for (let w = 0, P = y.length; w < P; w++)i.push(y[w]) } return i } }, mw = class { constructor(i, o) { rt(this, "isSubject"); rt(this, "polys"); rt(this, "bbox"); if (!Array.isArray(i)) throw new Error("Input geometry is not a valid Polygon or MultiPolygon"); try { typeof i[0][0][0] == "number" && (i = [i]) } catch { } this.polys = [], this.bbox = { ll: { x: new Os(Number.POSITIVE_INFINITY), y: new Os(Number.POSITIVE_INFINITY) }, ur: { x: new Os(Number.NEGATIVE_INFINITY), y: new Os(Number.NEGATIVE_INFINITY) } }; for (let h = 0, y = i.length; h < y; h++) { const w = new AI(i[h], this); w.bbox.ll.x.isLessThan(this.bbox.ll.x) && (this.bbox.ll.x = w.bbox.ll.x), w.bbox.ll.y.isLessThan(this.bbox.ll.y) && (this.bbox.ll.y = w.bbox.ll.y), w.bbox.ur.x.isGreaterThan(this.bbox.ur.x) && (this.bbox.ur.x = w.bbox.ur.x), w.bbox.ur.y.isGreaterThan(this.bbox.ur.y) && (this.bbox.ur.y = w.bbox.ur.y), this.polys.push(w) } this.isSubject = o } getSweepEvents() { const i = []; for (let o = 0, h = this.polys.length; o < h; o++) { const y = this.polys[o].getSweepEvents(); for (let w = 0, P = y.length; w < P; w++)i.push(y[w]) } return i } }, bc = (i, ...o) => wc.run("union", i, o), kI = (i, ...o) => wc.run("intersection", i, o), DI = (i, ...o) => wc.run("xor", i, o), zI = (i, ...o) => wc.run("difference", i, o), RI = So.set; const LI = Object.freeze(Object.defineProperty({ __proto__: null, difference: zI, intersection: kI, setPrecision: RI, union: bc, xor: DI }, Symbol.toStringTag, { value: "Module" })); function FI(i, o, h) { var y; const w = (y = h == null ? void 0 : h.mutate) != null ? y : !1; let P = o; o && w === !1 && (P = dI(o)); const b = OI(P); let c = null; return i.type === "FeatureCollection" ? c = BI(i) : i.type === "Feature" ? c = Fy(bc(i.geometry.coordinates)) : c = Fy(bc(i.coordinates)), c.geometry.coordinates.forEach(function (B) { b.geometry.coordinates.push(B[0]) }), b } function BI(i) { const o = i.features.length === 2 ? bc(i.features[0].geometry.coordinates, i.features[1].geometry.coordinates) : bc.apply(LI, i.features.map(function (h) { return h.geometry.coordinates })); return Fy(o) } function Fy(i) { return U2(i) } function OI(i) { let h = [[[180, 90], [-180, 90], [-180, -90], [180, -90], [180, 90]]]; return i && (i.type === "Feature" ? h = i.geometry.coordinates : h = i.coordinates), B0(h) } function NI(i, o = {}) { const h = []; if (cI(i, w => { h.push(w.coordinates) }), h.length < 2) throw new Error("Must have at least 2 geometries"); const y = bc(h[0], ...h.slice(1)); return y.length === 0 ? null : y.length === 1 ? B0(y[0], o.properties) : U2(y, o.properties) } const jI = () => { const i = gr.useRef(null), o = gr.useRef(null), { userPosition: h, extractionPoint: y, shadowPosition: w, status: P, exploredPolygon: b } = Vs(); gr.useEffect(() => { if (!o.current) { if (i.current) try { console.log("Initializing GameMap..."), o.current = new D_.Map({ container: i.current, style: "https://basemaps.cartocdn.com/gl/dark-matter-gl-style/style.json", center: [2.3522, 48.8566], zoom: 14, attributionControl: !1 }), o.current.addControl(new D_.NavigationControl, "top-right"), o.current.addControl(new D_.GeolocateControl({ positionOptions: { enableHighAccuracy: !0 }, trackUserLocation: !0, showUserHeading: !0 }), "bottom-right"), o.current.on("error", $ => { console.error("MapLibre Error:", $) }), o.current.on("load", () => { console.log("Map style loaded"), o.current && (o.current.addSource("fog", { type: "geojson", data: { type: "FeatureCollection", features: [] } }), o.current.addLayer({ id: "fog-fill", type: "fill", source: "fog", paint: { "fill-color": "#000000", "fill-opacity": .95 } }), o.current.addSource("extraction", { type: "geojson", data: { type: "FeatureCollection", features: [] } }), o.current.addLayer({ id: "extraction-glow", type: "circle", source: "extraction", paint: { "circle-radius": 40, "circle-color": "#10b981", "circle-opacity": .3, "circle-blur": .5 } }), o.current.addLayer({ id: "extraction-core", type: "circle", source: "extraction", paint: { "circle-radius": 10, "circle-color": "#34d399", "circle-stroke-width": 2, "circle-stroke-color": "#ffffff" } }), o.current.addSource("shadow", { type: "geojson", data: { type: "FeatureCollection", features: [] } }), o.current.addLayer({ id: "shadow-glow", type: "circle", source: "shadow", paint: { "circle-radius": 50, "circle-color": "#ef4444", "circle-opacity": .2, "circle-blur": .4 } }), o.current.addLayer({ id: "shadow-core", type: "circle", source: "shadow", paint: { "circle-radius": 8, "circle-color": "#dc2626", "circle-stroke-width": 2, "circle-stroke-color": "#7f1d1d" } }), o.current.addSource("player", { type: "geojson", data: { type: "FeatureCollection", features: [] } }), o.current.addLayer({ id: "player-radius", type: "circle", source: "player", paint: { "circle-radius": 50, "circle-color": "#3b82f6", "circle-opacity": .1, "circle-stroke-width": 1, "circle-stroke-color": "#60a5fa", "circle-stroke-opacity": .5 } }), o.current.addLayer({ id: "player-marker", type: "circle", source: "player", paint: { "circle-radius": 6, "circle-color": "#3b82f6", "circle-stroke-width": 2, "circle-stroke-color": "#ffffff" } })) }) } catch ($) { console.error("Failed to initialize map:", $) } return () => { o.current && (o.current.remove(), o.current = null) } } }, []), gr.useEffect(() => { if (!o.current || !o.current.isStyleLoaded()) return; const $ = o.current.getSource("fog"); if ($) if (b) try { const me = FI(b); $.setData(me) } catch (me) { console.error("Error generating fog mask:", me) } else $.setData({ type: "FeatureCollection", features: [] }) }, [b]), gr.useEffect(() => { if (!o.current || !o.current.isStyleLoaded()) return; const $ = o.current.getSource("extraction"); $ && (y ? $.setData({ type: "Feature", geometry: { type: "Point", coordinates: [y.longitude, y.latitude] }, properties: {} }) : $.setData({ type: "FeatureCollection", features: [] })) }, [y]), gr.useEffect(() => { if (!o.current || !o.current.isStyleLoaded()) return; const $ = o.current.getSource("shadow"); $ && (w ? $.setData({ type: "Feature", geometry: { type: "Point", coordinates: [w.longitude, w.latitude] }, properties: {} }) : $.setData({ type: "FeatureCollection", features: [] })) }, [w]), gr.useEffect(() => { if (!o.current || !o.current.isStyleLoaded()) return; const $ = o.current.getSource("player"); $ && (h ? $.setData({ type: "Feature", geometry: { type: "Point", coordinates: [h.longitude, h.latitude] }, properties: {} }) : $.setData({ type: "FeatureCollection", features: [] })) }, [h]); const c = $ => { if (!$ && $ !== 0) return 0; if (P === "CAUGHT") return .8; const me = 500, ge = 20; if ($ > me) return 0; const we = (me - Math.max($, ge)) / (me - ge); return Math.min(Math.max(we, 0), .8) }, B = Vs($ => c($.shadowDistance)); return _t.jsxs("div", { className: "relative w-full h-screen overflow-hidden bg-slate-950", children: [_t.jsx("div", { ref: i, className: "absolute inset-0", style: { width: "100%", height: "100%" } }), _t.jsxs("div", { className: "absolute top-4 left-4 z-10 pointer-events-none", children: [_t.jsxs("h1", { className: "text-2xl font-black text-white tracking-tighter uppercase drop-shadow-[0_2px_2px_rgba(0,0,0,0.8)]", children: ["Shadow ", _t.jsx("span", { className: "text-red-600", children: "Runner" })] }), P !== "IDLE" && _t.jsxs("div", { className: `text-xs font-mono font-bold mt-1 ${P === "ACTIVE" ? "text-emerald-400" : P === "CAUGHT" ? "text-red-500" : P === "EXTRACTED" ? "text-blue-400" : "text-slate-500"}`, children: ["STATUS: ", P] })] }), (P === "ACTIVE" || P === "CAUGHT") && _t.jsx("div", { className: "absolute inset-0 pointer-events-none transition-opacity duration-500 ease-in-out", style: { boxShadow: `inset 0 0 100px 50px rgba(220, 38, 38, ${B})`, zIndex: 5 } }), P === "CAUGHT" && _t.jsx("div", { className: "absolute inset-0 border-[20px] border-red-600/50 pointer-events-none animate-pulse z-10" }), P === "EXTRACTED" && _t.jsx("div", { className: "absolute inset-0 border-[20px] border-emerald-600/50 pointer-events-none z-10" })] }) };/**
 * @license lucide-react v0.562.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const VI = i => i.replace(/([a-z0-9])([A-Z])/g, "$1-$2").toLowerCase(), UI = i => i.replace(/^([A-Z])|[\s-_]+(\w)/g, (o, h, y) => y ? y.toUpperCase() : h.toLowerCase()), gw = i => { const o = UI(i); return o.charAt(0).toUpperCase() + o.slice(1) }, Q2 = (...i) => i.filter((o, h, y) => !!o && o.trim() !== "" && y.indexOf(o) === h).join(" ").trim(), GI = i => { for (const o in i) if (o.startsWith("aria-") || o === "role" || o === "title") return !0 };/**
 * @license lucide-react v0.562.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */var $I = { xmlns: "http://www.w3.org/2000/svg", width: 24, height: 24, viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: 2, strokeLinecap: "round", strokeLinejoin: "round" };/**
 * @license lucide-react v0.562.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const qI = gr.forwardRef(({ color: i = "currentColor", size: o = 24, strokeWidth: h = 2, absoluteStrokeWidth: y, className: w = "", children: P, iconNode: b, ...c }, B) => gr.createElement("svg", { ref: B, ...$I, width: o, height: o, stroke: i, strokeWidth: y ? Number(h) * 24 / Number(o) : h, className: Q2("lucide", w), ...!P && !GI(c) && { "aria-hidden": "true" }, ...c }, [...b.map(([$, me]) => gr.createElement($, me)), ...Array.isArray(P) ? P : [P]]));/**
 * @license lucide-react v0.562.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const Vl = (i, o) => { const h = gr.forwardRef(({ className: y, ...w }, P) => gr.createElement(qI, { ref: P, iconNode: o, className: Q2(`lucide-${VI(gw(i))}`, `lucide-${i}`, y), ...w })); return h.displayName = gw(i), h };/**
 * @license lucide-react v0.562.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const ZI = [["path", { d: "M22 12h-2.48a2 2 0 0 0-1.93 1.46l-2.35 8.36a.25.25 0 0 1-.48 0L9.24 2.18a.25.25 0 0 0-.48 0l-2.35 8.36A2 2 0 0 1 4.49 12H2", key: "169zse" }]], WI = Vl("activity", ZI);/**
 * @license lucide-react v0.562.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const HI = [["line", { x1: "2", x2: "5", y1: "12", y2: "12", key: "bvdh0s" }], ["line", { x1: "19", x2: "22", y1: "12", y2: "12", key: "1tbv5k" }], ["line", { x1: "12", x2: "12", y1: "2", y2: "5", key: "11lu5j" }], ["line", { x1: "12", x2: "12", y1: "19", y2: "22", key: "x3vr5v" }], ["circle", { cx: "12", cy: "12", r: "7", key: "fim9np" }]], XI = Vl("locate", HI);/**
 * @license lucide-react v0.562.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const YI = [["path", { d: "M14.106 5.553a2 2 0 0 0 1.788 0l3.659-1.83A1 1 0 0 1 21 4.619v12.764a1 1 0 0 1-.553.894l-4.553 2.277a2 2 0 0 1-1.788 0l-4.212-2.106a2 2 0 0 0-1.788 0l-3.659 1.83A1 1 0 0 1 3 19.381V6.618a1 1 0 0 1 .553-.894l4.553-2.277a2 2 0 0 1 1.788 0z", key: "169xi5" }], ["path", { d: "M15 5.764v15", key: "1pn4in" }], ["path", { d: "M9 3.236v15", key: "1uimfh" }]], KI = Vl("map", YI);/**
 * @license lucide-react v0.562.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const QI = [["polygon", { points: "3 11 22 2 13 21 11 13 3 11", key: "1ltx0t" }]], JI = Vl("navigation", QI);/**
 * @license lucide-react v0.562.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const eC = [["path", { d: "M5 5a2 2 0 0 1 3.008-1.728l11.997 6.998a2 2 0 0 1 .003 3.458l-12 7A2 2 0 0 1 5 19z", key: "10ikf1" }]], _w = Vl("play", eC);/**
 * @license lucide-react v0.562.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const tC = [["path", { d: "M20 13c0 5-3.5 7.5-7.66 8.95a1 1 0 0 1-.67-.01C7.5 20.5 4 18 4 13V6a1 1 0 0 1 1-1c2 0 4.5-1.2 6.24-2.72a1.17 1.17 0 0 1 1.52 0C14.51 3.81 17 5 19 5a1 1 0 0 1 1 1z", key: "oel41y" }], ["path", { d: "M12 8v4", key: "1got3b" }], ["path", { d: "M12 16h.01", key: "1drbdi" }]], yw = Vl("shield-alert", tC);/**
 * @license lucide-react v0.562.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const rC = [["circle", { cx: "12", cy: "12", r: "10", key: "1mglay" }], ["circle", { cx: "12", cy: "12", r: "6", key: "1vlfrh" }], ["circle", { cx: "12", cy: "12", r: "2", key: "1c9p78" }]], nC = Vl("target", rC), iC = () => { var y, w; const i = Vs(P => P.userPosition), o = P => P === null ? "--" : (P * 3.6).toFixed(1), h = P => P === null ? "--" : Math.round(P); return _t.jsxs("div", { className: "absolute inset-0 pointer-events-none p-4 pb-[calc(2rem+env(safe-area-inset-bottom))] flex flex-col justify-end", children: [_t.jsxs("div", { className: "absolute top-4 right-4 flex flex-col items-end gap-2", children: [_t.jsxs("div", { className: "flex items-center gap-2 bg-slate-900/80 text-emerald-400 px-3 py-1 rounded border border-emerald-500/30 backdrop-blur-sm", children: [_t.jsx(XI, { size: 18, className: i ? "animate-pulse" : "opacity-50" }), _t.jsxs("span", { className: "font-mono text-sm font-bold", children: ["GPS: ", i ? "LOCKED" : "SEARCHING"] })] }), _t.jsxs("div", { className: "flex items-center gap-2 bg-slate-900/80 text-sky-400 px-3 py-1 rounded border border-sky-500/30 backdrop-blur-sm", children: [_t.jsx("span", { className: "font-mono text-xs", children: "ACCURACY" }), _t.jsxs("span", { className: "font-mono text-lg font-bold", children: ["", h((i == null ? void 0 : i.accuracy) || null), "m"] })] })] }), _t.jsxs("div", { className: "w-full flex justify-center gap-4", children: [_t.jsxs("div", { className: "flex flex-col items-center bg-slate-900/90 p-3 rounded-lg border border-slate-700 backdrop-blur-md min-w-[100px]", children: [_t.jsxs("div", { className: "flex items-center gap-2 text-slate-400 mb-1", children: [_t.jsx(WI, { size: 16 }), _t.jsx("span", { className: "text-xs font-bold tracking-wider", children: "SPEED" })] }), _t.jsxs("div", { className: "flex items-baseline gap-1", children: [_t.jsx("span", { className: "text-3xl font-black text-white font-mono", children: o((i == null ? void 0 : i.speed) || 0) }), _t.jsx("span", { className: "text-xs text-slate-500 font-bold", children: "KM/H" })] })] }), _t.jsxs("div", { className: "flex flex-col items-center bg-slate-900/90 p-3 rounded-lg border border-slate-700 backdrop-blur-md min-w-[100px]", children: [_t.jsxs("div", { className: "flex items-center gap-2 text-slate-400 mb-1", children: [_t.jsx(JI, { size: 16 }), _t.jsx("span", { className: "text-xs font-bold tracking-wider", children: "HEADING" })] }), _t.jsxs("div", { className: "flex items-baseline gap-1", children: [_t.jsx("span", { className: "text-3xl font-black text-white font-mono", children: i != null && i.heading ? Math.round(i.heading) : "--" }), _t.jsx("span", { className: "text-xs text-slate-500 font-bold", children: "" })] })] })] }), _t.jsxs("div", { className: "absolute top-20 right-4 text-xs font-mono text-slate-500 bg-black/50 p-2 rounded", children: [_t.jsxs("div", { children: ["LAT: ", ((y = i == null ? void 0 : i.latitude) == null ? void 0 : y.toFixed(5)) || "--"] }), _t.jsxs("div", { children: ["LNG: ", ((w = i == null ? void 0 : i.longitude) == null ? void 0 : w.toFixed(5)) || "--"] })] })] }) }, sC = () => { const { setGameMode: i, setStatus: o } = Vs(), h = y => { i(y), o("ACTIVE") }; return _t.jsx("div", { className: "fixed inset-0 z-[100] flex items-center justify-center bg-slate-950/90 backdrop-blur-md overflow-y-auto", children: _t.jsxs("div", { className: "max-w-4xl w-full px-6 flex flex-col items-center", children: [_t.jsxs("div", { className: "mb-12 text-center", children: [_t.jsxs("h1", { className: "text-6xl font-black text-white tracking-tighter uppercase mb-2 drop-shadow-[0_0_15px_rgba(220,38,38,0.5)]", children: ["Shadow ", _t.jsx("span", { className: "text-red-600", children: "Runner" })] }), _t.jsx("p", { className: "text-slate-400 font-mono text-sm tracking-widest uppercase italic", children: "// Outrun The Shadow" })] }), _t.jsxs("div", { className: "grid grid-cols-1 md:grid-cols-2 gap-6 w-full mb-12", children: [_t.jsxs("button", { onClick: () => h("EXTRACTION"), className: "group relative flex flex-col items-start p-8 bg-slate-900 border border-slate-700 rounded-xl overflow-hidden transition-all hover:border-emerald-500/50 hover:bg-slate-800/80 text-left", children: [_t.jsx("div", { className: "absolute top-0 right-0 p-4 opacity-10 group-hover:scale-110 transition-transform", children: _t.jsx(nC, { size: 120 }) }), _t.jsx("div", { className: "mb-4 p-3 bg-emerald-500/10 rounded-lg text-emerald-400 group-hover:bg-emerald-500/20 transition-colors", children: _t.jsx(KI, { size: 32 }) }), _t.jsx("h2", { className: "text-2xl font-bold text-white mb-2 group-hover:text-emerald-300 transition-colors uppercase", children: "Extraction" }), _t.jsx("p", { className: "text-slate-400 text-sm font-medium pr-12", children: "Reach the extraction site 2km away. Avoid detection and outrun the shadow pursuing you." }), _t.jsxs("div", { className: "mt-8 flex items-center gap-2 text-emerald-500 font-mono text-xs font-bold tracking-widest uppercase opacity-0 group-hover:opacity-100 transition-opacity", children: [_t.jsx(_w, { size: 12, fill: "currentColor" }), " Initialize Protocol"] }), _t.jsx("div", { className: "absolute inset-x-0 bottom-0 h-1 bg-emerald-500 scale-x-0 group-hover:scale-x-100 transition-transform origin-left" })] }), _t.jsxs("button", { onClick: () => h("SURVIVAL"), className: "group relative flex flex-col items-start p-8 bg-slate-900 border border-slate-700 rounded-xl overflow-hidden transition-all hover:border-red-500/50 hover:bg-slate-800/80 text-left", children: [_t.jsx("div", { className: "absolute top-0 right-0 p-4 opacity-10 group-hover:scale-110 transition-transform", children: _t.jsx(yw, { size: 120 }) }), _t.jsx("div", { className: "mb-4 p-3 bg-red-500/10 rounded-lg text-red-400 group-hover:bg-red-500/20 transition-colors", children: _t.jsx(yw, { size: 32 }) }), _t.jsx("h2", { className: "text-2xl font-bold text-white mb-2 group-hover:text-red-300 transition-colors uppercase", children: "Survival" }), _t.jsx("p", { className: "text-slate-400 text-sm font-medium pr-12", children: "No destination. No exit. Survival is the only objective. The shadow grows faster over time." }), _t.jsxs("div", { className: "mt-8 flex items-center gap-2 text-red-500 font-mono text-xs font-bold tracking-widest uppercase opacity-0 group-hover:opacity-100 transition-opacity", children: [_t.jsx(_w, { size: 12, fill: "currentColor" }), " Initiate Chaos"] }), _t.jsx("div", { className: "absolute inset-x-0 bottom-0 h-1 bg-red-500 scale-x-0 group-hover:scale-x-100 transition-transform origin-left" })] })] }), _t.jsxs("div", { className: "flex flex-col items-center gap-4 text-slate-500 font-mono text-xs", children: [_t.jsxs("div", { className: "flex items-center gap-8 px-6 py-2 border-x border-slate-800", children: [_t.jsxs("span", { className: "flex items-center gap-2", children: [_t.jsx("div", { className: "w-1.5 h-1.5 rounded-full bg-emerald-500 animate-pulse" }), "SYSTEM_GO"] }), _t.jsx("span", { className: "flex items-center gap-2 uppercase tracking-tighter", children: "GPS_LAT: SEARCHING..." })] }), _t.jsx("p", { className: "opacity-50", children: "SHADOW_RUNNER v1.0.4 CORE_PROTOCOL" })] })] }) }) }, oC = () => { const i = gr.useRef(null); gr.useEffect(() => { const o = async () => { try { "wakeLock" in navigator && navigator.wakeLock && (i.current = await navigator.wakeLock.request("screen"), console.log("Wake Lock is active")) } catch (y) { console.warn("Wake Lock request failed:", y) } }; o(); const h = async () => { i.current !== null && document.visibilityState === "visible" && await o() }; return document.addEventListener("visibilitychange", h), () => { document.removeEventListener("visibilitychange", h), i.current && i.current.release().then(() => { i.current = null, console.log("Wake Lock released") }) } }, []) }, aC = (i = { enableHighAccuracy: !0 }) => { const o = Vs(w => w.setUserPosition), [h, y] = gr.useState(null); return gr.useEffect(() => { if (!("geolocation" in navigator)) { y({ code: 0, message: "Geolocation not supported", PERMISSION_DENIED: 1, POSITION_UNAVAILABLE: 2, TIMEOUT: 3 }); return } const w = navigator.geolocation.watchPosition(P => { o({ latitude: P.coords.latitude, longitude: P.coords.longitude, accuracy: P.coords.accuracy, heading: P.coords.heading, speed: P.coords.speed, timestamp: P.timestamp }), y(null) }, P => { y(P) }, i); return () => { navigator.geolocation.clearWatch(w) } }, [o, i.enableHighAccuracy, i.timeout, i.maximumAge]), { error: h } }, lC = 2, uC = 50, cC = 20, hC = 15, dC = i => i / 3.6, pC = () => { const { userPosition: i, status: o, gameMode: h, extractionPoint: y, shadowPosition: w, setStatus: P, setExtractionPoint: b, setShadowPosition: c, setShadowDistance: B } = Vs(), $ = gr.useRef(Date.now()), me = gr.useRef(); gr.useEffect(() => { if (o === "ACTIVE" && i && !w) { const ge = Al([i.longitude, i.latitude]); if (h === "EXTRACTION") { const we = Math.random() * 360, Ge = rd(ge, lC, we), [Ye, $e] = Ge.geometry.coordinates; b({ latitude: $e, longitude: Ye }); const ye = rd(ge, .5, (we + 180) % 360), [be, K] = ye.geometry.coordinates; c({ latitude: K, longitude: be }) } else { const we = Math.random() * 360, Ge = rd(ge, .8, we), [Ye, $e] = Ge.geometry.coordinates; c({ latitude: $e, longitude: Ye }), b(null) } } }, [i, o, h, w, P, b, c]), gr.useEffect(() => { if (o !== "ACTIVE" || !i || !w || !y) { cancelAnimationFrame(me.current); return } const ge = () => { const we = Date.now(), Ge = (we - $.current) / 1e3; $.current = we; const Ye = Al([w.longitude, w.latitude]), $e = Al([i.longitude, i.latitude]), ye = G2(Ye, $e), be = dC(hC) * Ge / 1e3, K = rd(Ye, be, ye), [ve, Ke] = K.geometry.coordinates; if (c({ latitude: Ke, longitude: ve }), h === "EXTRACTION" && y) { const mt = Al([y.longitude, y.latitude]); if (uw($e, mt, { units: "meters" }) < uC) { P("EXTRACTED"); return } } const ft = uw($e, Ye, { units: "meters" }); if (B(ft), ft < cC) { P("CAUGHT"); return } me.current = requestAnimationFrame(ge) }; return me.current = requestAnimationFrame(ge), () => { me.current && cancelAnimationFrame(me.current) } }, [o, i, w, y, P, c, B]) }, By = (i, o) => o.some(h => i instanceof h); let vw, xw; function fC() { return vw || (vw = [IDBDatabase, IDBObjectStore, IDBIndex, IDBCursor, IDBTransaction]) } function mC() { return xw || (xw = [IDBCursor.prototype.advance, IDBCursor.prototype.continue, IDBCursor.prototype.continuePrimaryKey]) } const Oy = new WeakMap, F_ = new WeakMap, Lm = new WeakMap; function gC(i) { const o = new Promise((h, y) => { const w = () => { i.removeEventListener("success", P), i.removeEventListener("error", b) }, P = () => { h(zl(i.result)), w() }, b = () => { y(i.error), w() }; i.addEventListener("success", P), i.addEventListener("error", b) }); return Lm.set(o, i), o } function _C(i) { if (Oy.has(i)) return; const o = new Promise((h, y) => { const w = () => { i.removeEventListener("complete", P), i.removeEventListener("error", b), i.removeEventListener("abort", b) }, P = () => { h(), w() }, b = () => { y(i.error || new DOMException("AbortError", "AbortError")), w() }; i.addEventListener("complete", P), i.addEventListener("error", b), i.addEventListener("abort", b) }); Oy.set(i, o) } let Ny = { get(i, o, h) { if (i instanceof IDBTransaction) { if (o === "done") return Oy.get(i); if (o === "store") return h.objectStoreNames[1] ? void 0 : h.objectStore(h.objectStoreNames[0]) } return zl(i[o]) }, set(i, o, h) { return i[o] = h, !0 }, has(i, o) { return i instanceof IDBTransaction && (o === "done" || o === "store") ? !0 : o in i } }; function J2(i) { Ny = i(Ny) } function yC(i) { return mC().includes(i) ? function (...o) { return i.apply(jy(this), o), zl(this.request) } : function (...o) { return zl(i.apply(jy(this), o)) } } function vC(i) { return typeof i == "function" ? yC(i) : (i instanceof IDBTransaction && _C(i), By(i, fC()) ? new Proxy(i, Ny) : i) } function zl(i) { if (i instanceof IDBRequest) return gC(i); if (F_.has(i)) return F_.get(i); const o = vC(i); return o !== i && (F_.set(i, o), Lm.set(o, i)), o } const jy = i => Lm.get(i); function xC(i, o, { blocked: h, upgrade: y, blocking: w, terminated: P } = {}) { const b = indexedDB.open(i, o), c = zl(b); return y && b.addEventListener("upgradeneeded", B => { y(zl(b.result), B.oldVersion, B.newVersion, zl(b.transaction), B) }), h && b.addEventListener("blocked", B => h(B.oldVersion, B.newVersion, B)), c.then(B => { P && B.addEventListener("close", () => P()), w && B.addEventListener("versionchange", $ => w($.oldVersion, $.newVersion, $)) }).catch(() => { }), c } const wC = ["get", "getKey", "getAll", "getAllKeys", "count"], bC = ["put", "add", "delete", "clear"], B_ = new Map; function ww(i, o) { if (!(i instanceof IDBDatabase && !(o in i) && typeof o == "string")) return; if (B_.get(o)) return B_.get(o); const h = o.replace(/FromIndex$/, ""), y = o !== h, w = bC.includes(h); if (!(h in (y ? IDBIndex : IDBObjectStore).prototype) || !(w || wC.includes(h))) return; const P = async function (b, ...c) { const B = this.transaction(b, w ? "readwrite" : "readonly"); let $ = B.store; return y && ($ = $.index(c.shift())), (await Promise.all([$[h](...c), w && B.done]))[0] }; return B_.set(o, P), P } J2(i => ({ ...i, get: (o, h, y) => ww(o, h) || i.get(o, h, y), has: (o, h) => !!ww(o, h) || i.has(o, h) })); const TC = ["continue", "continuePrimaryKey", "advance"], bw = {}, Vy = new WeakMap, eT = new WeakMap, SC = { get(i, o) { if (!TC.includes(o)) return i[o]; let h = bw[o]; return h || (h = bw[o] = function (...y) { Vy.set(this, eT.get(this)[o](...y)) }), h } }; async function* EC(...i) { let o = this; if (o instanceof IDBCursor || (o = await o.openCursor(...i)), !o) return; o = o; const h = new Proxy(o, SC); for (eT.set(h, o), Lm.set(h, jy(o)); o;)yield h, o = await (Vy.get(h) || o.continue()), Vy.delete(h) } function Tw(i, o) { return o === Symbol.asyncIterator && By(i, [IDBIndex, IDBObjectStore, IDBCursor]) || o === "iterate" && By(i, [IDBIndex, IDBObjectStore]) } J2(i => ({ ...i, get(o, h, y) { return Tw(o, h) ? EC : i.get(o, h, y) }, has(o, h) { return Tw(o, h) || i.has(o, h) } })); const PC = "shadow-runner-db", N0 = "game-state", tT = async () => xC(PC, 1, { upgrade(i) { i.createObjectStore(N0) } }), MC = async i => { await (await tT()).put(N0, i, "explored-polygon") }, IC = async () => await (await tT()).get(N0, "explored-polygon") || void 0, CC = 50, AC = 2e3, kC = () => { const i = Vs(P => P.userPosition), o = Vs(P => P.exploredPolygon), h = Vs(P => P.setExploredPolygon), y = gr.useRef(null), w = gr.useRef(null); gr.useEffect(() => { w.current = o }, [o]), gr.useEffect(() => { (async () => { try { const b = await IC(); b && h(b) } catch (b) { console.error("Failed to load explored polygon:", b) } })() }, [h]), gr.useEffect(() => { if (!i) return; const P = w.current, b = Al([i.longitude, i.latitude]), c = hI(b, CC, { units: "meters", steps: 32 }); let B; if (!P) B = c; else try { const $ = NI(oI([P, c])); $ ? B = $ : B = P } catch ($) { console.error("Error unioning polygons:", $); return } h(B), y.current && clearTimeout(y.current), y.current = setTimeout(() => { MC(B) }, AC) }, [i, h]) }; function DC() { const i = Vs(o => o.status); return oC(), aC(), pC(), kC(), _t.jsxs("main", { className: "w-full h-screen relative bg-slate-950", children: [i === "IDLE" && _t.jsx(sC, {}), _t.jsx(jI, {}), _t.jsx(iC, {})] }) } O_.createRoot(document.getElementById("root")).render(_t.jsx(Kh.StrictMode, { children: _t.jsx(DC, {}) }));
